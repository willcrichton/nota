(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // ../../node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "../../node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // ../../node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "../../node_modules/react/cjs/react.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var _assign = require_object_assign();
          var ReactVersion = "17.0.2";
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          exports.Fragment = 60107;
          exports.StrictMode = 60108;
          exports.Profiler = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          exports.Suspense = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            exports.Fragment = symbolFor("react.fragment");
            exports.StrictMode = symbolFor("react.strict_mode");
            exports.Profiler = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            exports.Suspense = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: 0
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var IsSomeRendererActing = {
            current: false
          };
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner,
            IsSomeRendererActing,
            assign: _assign
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          }
          function warn(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
              {
                throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
              }
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent2.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent2;
          _assign(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case exports.Fragment:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case exports.Profiler:
                return "Profiler";
              case exports.StrictMode:
                return "StrictMode";
              case exports.Suspense:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentName(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty2.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty2.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentName(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement2(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                key = "" + config.key;
              }
              self2 = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config, children) {
            if (!!(element === null || element === void 0)) {
              {
                throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
              }
            }
            var propName;
            var props = _assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                key = "" + config.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object2) {
            return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              return escape("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (Array.isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
                }
                array2.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (Array.isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = "" + children;
                {
                  {
                    throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                  }
                }
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              {
                throw Error("React.Children.only expected to receive a single React element child.");
              }
            }
            return children;
          }
          function createContext(defaultValue, calculateChangedBits) {
            if (calculateChangedBits === void 0) {
              calculateChangedBits = null;
            } else {
              {
                if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                  error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
                }
              }
            }
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _calculateChangedBits: calculateChangedBits,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context,
                _calculateChangedBits: context._calculateChangedBits
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
              thenable.then(function(moduleObject) {
                if (payload._status === Pending) {
                  var defaultExport = moduleObject.default;
                  {
                    if (defaultExport === void 0) {
                      error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                    }
                  }
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = defaultExport;
                }
              }, function(error2) {
                if (payload._status === Pending) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
            }
            if (payload._status === Resolved) {
              return payload._result;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              _status: -1,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef3(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name2) {
                  ownName = name2;
                  if (render.displayName == null) {
                    render.displayName = name2;
                  }
                }
              });
            }
            return elementType;
          }
          var enableScopeAPI = false;
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }
            return false;
          }
          function memo3(type, compare2) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare2 === void 0 ? null : compare2
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name2) {
                  ownName = name2;
                  if (type.displayName == null) {
                    type.displayName = name2;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            if (!(dispatcher !== null)) {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext2(Context, unstable_observedBits) {
            var dispatcher = resolveDispatcher();
            {
              if (unstable_observedBits !== void 0) {
                error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
              }
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context, unstable_observedBits);
          }
          function useState6(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef3(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect2(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case exports.Suspense:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values2, location, componentName, element) {
            {
              var has3 = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has3(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name2 = getComponentName(ReactCurrentOwner.current.type);
              if (name2) {
                return "\n\nCheck the render method of `" + name2 + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (Array.isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name2 = getComponentName(type);
                checkPropTypes(propTypes, element.props, "prop", name2, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentName(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys2 = Object.keys(fragment.props);
              for (var i = 0; i < keys2.length; i++) {
                var key = keys2[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (Array.isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement2.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === exports.Fragment) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          {
            try {
              var frozenObject = Object.freeze({});
              new Map([[frozenObject, null]]);
              new Set([frozenObject]);
            } catch (e) {
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children;
          exports.Component = Component2;
          exports.PureComponent = PureComponent2;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef3;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy;
          exports.memo = memo3;
          exports.useCallback = useCallback;
          exports.useContext = useContext2;
          exports.useDebugValue = useDebugValue;
          exports.useEffect = useEffect2;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useLayoutEffect = useLayoutEffect;
          exports.useMemo = useMemo;
          exports.useReducer = useReducer;
          exports.useRef = useRef3;
          exports.useState = useState6;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // ../../node_modules/react/index.js
  var require_react = __commonJS({
    "../../node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // ../../node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "../../node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var requestHostCallback;
          var requestHostTimeout;
          var cancelHostTimeout;
          var requestPaint;
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          if (typeof window === "undefined" || typeof MessageChannel !== "function") {
            var _callback = null;
            var _timeoutID = null;
            var _flushCallback = function() {
              if (_callback !== null) {
                try {
                  var currentTime = exports.unstable_now();
                  var hasRemainingTime = true;
                  _callback(hasRemainingTime, currentTime);
                  _callback = null;
                } catch (e) {
                  setTimeout(_flushCallback, 0);
                  throw e;
                }
              }
            };
            requestHostCallback = function(cb) {
              if (_callback !== null) {
                setTimeout(requestHostCallback, 0, cb);
              } else {
                _callback = cb;
                setTimeout(_flushCallback, 0);
              }
            };
            requestHostTimeout = function(cb, ms) {
              _timeoutID = setTimeout(cb, ms);
            };
            cancelHostTimeout = function() {
              clearTimeout(_timeoutID);
            };
            exports.unstable_shouldYield = function() {
              return false;
            };
            requestPaint = exports.unstable_forceFrameRate = function() {
            };
          } else {
            var _setTimeout = window.setTimeout;
            var _clearTimeout = window.clearTimeout;
            if (typeof console !== "undefined") {
              var requestAnimationFrame2 = window.requestAnimationFrame;
              var cancelAnimationFrame2 = window.cancelAnimationFrame;
              if (typeof requestAnimationFrame2 !== "function") {
                console["error"]("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
              if (typeof cancelAnimationFrame2 !== "function") {
                console["error"]("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
            }
            var isMessageLoopRunning = false;
            var scheduledHostCallback = null;
            var taskTimeoutID = -1;
            var yieldInterval = 5;
            var deadline = 0;
            {
              exports.unstable_shouldYield = function() {
                return exports.unstable_now() >= deadline;
              };
              requestPaint = function() {
              };
            }
            exports.unstable_forceFrameRate = function(fps) {
              if (fps < 0 || fps > 125) {
                console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
                return;
              }
              if (fps > 0) {
                yieldInterval = Math.floor(1e3 / fps);
              } else {
                yieldInterval = 5;
              }
            };
            var performWorkUntilDeadline = function() {
              if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now();
                deadline = currentTime + yieldInterval;
                var hasTimeRemaining = true;
                try {
                  var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                  if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                  } else {
                    port.postMessage(null);
                  }
                } catch (error) {
                  port.postMessage(null);
                  throw error;
                }
              } else {
                isMessageLoopRunning = false;
              }
            };
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            requestHostCallback = function(callback) {
              scheduledHostCallback = callback;
              if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
              }
            };
            requestHostTimeout = function(callback, ms) {
              taskTimeoutID = _setTimeout(function() {
                callback(exports.unstable_now());
              }, ms);
            };
            cancelHostTimeout = function() {
              _clearTimeout(taskTimeoutID);
              taskTimeoutID = -1;
            };
          }
          function push2(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
          }
          function peek(heap) {
            var first = heap[0];
            return first === void 0 ? null : first;
          }
          function pop2(heap) {
            var first = heap[0];
            if (first !== void 0) {
              var last = heap.pop();
              if (last !== first) {
                heap[0] = last;
                siftDown(heap, last, 0);
              }
              return first;
            } else {
              return null;
            }
          }
          function siftUp(heap, node, i) {
            var index = i;
            while (true) {
              var parentIndex = index - 1 >>> 1;
              var parent = heap[parentIndex];
              if (parent !== void 0 && compare2(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            while (index < length) {
              var leftIndex = (index + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (left !== void 0 && compare2(left, node) < 0) {
                if (right !== void 0 && compare2(right, left) < 0) {
                  heap[index] = right;
                  heap[rightIndex] = node;
                  index = rightIndex;
                } else {
                  heap[index] = left;
                  heap[leftIndex] = node;
                  index = leftIndex;
                }
              } else if (right !== void 0 && compare2(right, node) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare2(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop2(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop2(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push2(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop2(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop2(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports.unstable_now();
            var startTime;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime = currentTime + delay;
              } else {
                startTime = currentTime;
              }
            } else {
              startTime = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime,
              expirationTime,
              sortIndex: -1
            };
            if (startTime > currentTime) {
              newTask.sortIndex = startTime;
              push2(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push2(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_wrapCallback = unstable_wrapCallback;
        })();
      }
    }
  });

  // ../../node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../../node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // ../../node_modules/scheduler/cjs/scheduler-tracing.development.js
  var require_scheduler_tracing_development = __commonJS({
    "../../node_modules/scheduler/cjs/scheduler-tracing.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var DEFAULT_THREAD_ID = 0;
          var interactionIDCounter = 0;
          var threadIDCounter = 0;
          exports.__interactionsRef = null;
          exports.__subscriberRef = null;
          {
            exports.__interactionsRef = {
              current: new Set()
            };
            exports.__subscriberRef = {
              current: null
            };
          }
          function unstable_clear(callback) {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = new Set();
            try {
              return callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;
            }
          }
          function unstable_getCurrent() {
            {
              return exports.__interactionsRef.current;
            }
          }
          function unstable_getThreadID() {
            return ++threadIDCounter;
          }
          function unstable_trace(name2, timestamp, callback) {
            var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_THREAD_ID;
            var interaction = {
              __count: 1,
              id: interactionIDCounter++,
              name: name2,
              timestamp
            };
            var prevInteractions = exports.__interactionsRef.current;
            var interactions = new Set(prevInteractions);
            interactions.add(interaction);
            exports.__interactionsRef.current = interactions;
            var subscriber = exports.__subscriberRef.current;
            var returnValue;
            try {
              if (subscriber !== null) {
                subscriber.onInteractionTraced(interaction);
              }
            } finally {
              try {
                if (subscriber !== null) {
                  subscriber.onWorkStarted(interactions, threadID);
                }
              } finally {
                try {
                  returnValue = callback();
                } finally {
                  exports.__interactionsRef.current = prevInteractions;
                  try {
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(interactions, threadID);
                    }
                  } finally {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  }
                }
              }
            }
            return returnValue;
          }
          function unstable_wrap(callback) {
            var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_THREAD_ID;
            var wrappedInteractions = exports.__interactionsRef.current;
            var subscriber = exports.__subscriberRef.current;
            if (subscriber !== null) {
              subscriber.onWorkScheduled(wrappedInteractions, threadID);
            }
            wrappedInteractions.forEach(function(interaction) {
              interaction.__count++;
            });
            var hasRun = false;
            function wrapped() {
              var prevInteractions = exports.__interactionsRef.current;
              exports.__interactionsRef.current = wrappedInteractions;
              subscriber = exports.__subscriberRef.current;
              try {
                var returnValue;
                try {
                  if (subscriber !== null) {
                    subscriber.onWorkStarted(wrappedInteractions, threadID);
                  }
                } finally {
                  try {
                    returnValue = callback.apply(void 0, arguments);
                  } finally {
                    exports.__interactionsRef.current = prevInteractions;
                    if (subscriber !== null) {
                      subscriber.onWorkStopped(wrappedInteractions, threadID);
                    }
                  }
                }
                return returnValue;
              } finally {
                if (!hasRun) {
                  hasRun = true;
                  wrappedInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    }
                  });
                }
              }
            }
            wrapped.cancel = function cancel() {
              subscriber = exports.__subscriberRef.current;
              try {
                if (subscriber !== null) {
                  subscriber.onWorkCanceled(wrappedInteractions, threadID);
                }
              } finally {
                wrappedInteractions.forEach(function(interaction) {
                  interaction.__count--;
                  if (subscriber && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                });
              }
            };
            return wrapped;
          }
          var subscribers = null;
          {
            subscribers = new Set();
          }
          function unstable_subscribe(subscriber) {
            {
              subscribers.add(subscriber);
              if (subscribers.size === 1) {
                exports.__subscriberRef.current = {
                  onInteractionScheduledWorkCompleted,
                  onInteractionTraced,
                  onWorkCanceled,
                  onWorkScheduled,
                  onWorkStarted,
                  onWorkStopped
                };
              }
            }
          }
          function unstable_unsubscribe(subscriber) {
            {
              subscribers.delete(subscriber);
              if (subscribers.size === 0) {
                exports.__subscriberRef.current = null;
              }
            }
          }
          function onInteractionTraced(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionTraced(interaction);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onInteractionScheduledWorkCompleted(interaction) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkScheduled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkScheduled(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStarted(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkStopped(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkStopped(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          function onWorkCanceled(interactions, threadID) {
            var didCatchError = false;
            var caughtError = null;
            subscribers.forEach(function(subscriber) {
              try {
                subscriber.onWorkCanceled(interactions, threadID);
              } catch (error) {
                if (!didCatchError) {
                  didCatchError = true;
                  caughtError = error;
                }
              }
            });
            if (didCatchError) {
              throw caughtError;
            }
          }
          exports.unstable_clear = unstable_clear;
          exports.unstable_getCurrent = unstable_getCurrent;
          exports.unstable_getThreadID = unstable_getThreadID;
          exports.unstable_subscribe = unstable_subscribe;
          exports.unstable_trace = unstable_trace;
          exports.unstable_unsubscribe = unstable_unsubscribe;
          exports.unstable_wrap = unstable_wrap;
        })();
      }
    }
  });

  // ../../node_modules/scheduler/tracing.js
  var require_tracing = __commonJS({
    "../../node_modules/scheduler/tracing.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_tracing_development();
      }
    }
  });

  // ../../node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "../../node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React6 = require_react();
          var _assign = require_object_assign();
          var Scheduler = require_scheduler();
          var tracing = require_tracing();
          var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn(format) {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
          function error(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          if (!React6) {
            {
              throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var FundamentalComponent = 20;
          var ScopeComponent = 21;
          var Block = 22;
          var OffscreenComponent = 23;
          var LegacyHiddenComponent = 24;
          var enableProfilerTimer = true;
          var enableFundamentalAPI = false;
          var enableNewReconciler = false;
          var warnAboutStringRefs = false;
          var allNativeEvents = new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i = 0; i < dependencies.length; i++) {
              allNativeEvents.add(dependencies[i]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var ROOT_ATTRIBUTE_NAME = "data-reactroot";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name2.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name2) {
            return properties.hasOwnProperty(name2) ? properties[name2] : null;
          }
          function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name2;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, RESERVED, false, name2, null, false, false);
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name2 = _ref[0], attributeName = _ref[1];
            properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2.toLowerCase(), null, false, false);
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2, null, false, false);
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, false, name2.toLowerCase(), null, false, false);
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, true, name2, null, false, false);
          });
          [
            "capture",
            "download"
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, OVERLOADED_BOOLEAN, false, name2, null, false, false);
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, POSITIVE_NUMERIC, false, name2, null, false, false);
          });
          ["rowSpan", "start"].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(name2, NUMERIC, false, name2.toLowerCase(), null, false, false);
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name2 = attributeName.replace(CAMELIZE, capitalize);
            properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name2 = attributeName.replace(CAMELIZE, capitalize);
            properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name2 = attributeName.replace(CAMELIZE, capitalize);
            properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name2, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName2 = propertyInfo.propertyName;
                return node[propertyName2];
              } else {
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name2, expected) {
            {
              if (!isAttributeNameSafe(name2)) {
                return;
              }
              if (isOpaqueHydratingObject(expected)) {
                return expected;
              }
              if (!node.hasAttribute(name2)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name2);
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name2, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name2);
            if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name2)) {
                var _attributeName = name2;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName2 = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName2] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName2] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          var REACT_FRAGMENT_TYPE = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case Block:
                return describeFunctionComponentFrame(fiber.type._render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentName(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentName(owner.type);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function getIsRendering() {
            {
              return isRendering;
            }
          }
          function toString2(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "object":
              case "string":
              case "undefined":
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get5 = descriptor.get, set6 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get5.call(this);
              },
              set: function(value) {
                currentValue = "" + value;
                set6.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc2) {
            doc2 = doc2 || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc2 === "undefined") {
              return null;
            }
            try {
              return doc2.activeElement || doc2.body;
            } catch (e) {
              return doc2.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = _assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || node.value != value) {
                  node.value = toString2(value);
                }
              } else if (node.value !== toString2(value)) {
                node.value = toString2(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString2(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name2 = node.name;
            if (name2 !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name2 !== "") {
              node.name = name2;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name2 = props.name;
            if (props.type === "radio" && name2 != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
              for (var i = 0; i < group.length; i++) {
                var otherNode = group[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  {
                    throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                  }
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (type !== "number" || getActiveElement(node.ownerDocument) !== node) {
              if (value == null) {
                node.defaultValue = toString2(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString2(value)) {
                node.defaultValue = toString2(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          function flattenChildren(children) {
            var content2 = "";
            React6.Children.forEach(children, function(child) {
              if (child == null) {
                return;
              }
              content2 += child;
            });
            return content2;
          }
          function validateProps(element, props) {
            {
              if (typeof props.children === "object" && props.children !== null) {
                React6.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (typeof child.type !== "string") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error("Only strings and numbers are supported as <option> children.");
                  }
                });
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString2(getToStringValue(props.value)));
            }
          }
          function getHostProps$1(element, props) {
            var hostProps = _assign({
              children: void 0
            }, props);
            var content2 = flattenChildren(props.children);
            if (content2) {
              hostProps.children = content2;
            }
            return hostProps;
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var isArray2 = Array.isArray(props[propName]);
                if (props.multiple && !isArray2) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && isArray2) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options2 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i2].value);
                if (options2[_i2].selected !== selected) {
                  options2[_i2].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString2(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i22 = 0; _i22 < options2.length; _i22++) {
                if (options2[_i22].value === _selectedValue) {
                  options2[_i22].selected = true;
                  if (setDefaultSelected) {
                    options2[_i22].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i22].disabled) {
                  defaultSelected = options2[_i22];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$2(element, props) {
            return _assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$3(element, props) {
            var node = element;
            if (!(props.dangerouslySetInnerHTML == null)) {
              {
                throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              }
            }
            var hostProps = _assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString2(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(children)) {
                    if (!(children.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString2(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString2(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var Namespaces = {
            html: HTML_NAMESPACE,
            mathml: MATH_NAMESPACE,
            svg: SVG_NAMESPACE
          };
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === Namespaces.svg) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name2, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
              return value + "px";
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name2) {
            return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string2) {
              return string2.replace(hyphenPattern, function(_14, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name2) {
              if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
                return;
              }
              warnedStyleNames[name2] = true;
              error("Unsupported style property %s. Did you mean %s?", name2, camelize(name2.replace(msPattern$1, "ms-")));
            };
            var warnBadVendoredStyleName = function(name2) {
              if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
                return;
              }
              warnedStyleNames[name2] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name2, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name2, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name2);
            };
            var warnStyleValueIsInfinity = function(name2, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name2);
            };
            warnValidStyle = function(name2, value) {
              if (name2.indexOf("-") > -1) {
                warnHyphenatedStyleName(name2);
              } else if (badVendoredStyleNamePattern.test(name2)) {
                warnBadVendoredStyleName(name2);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name2, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name2, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name2, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var voidElementTags = _assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
                {
                  throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                }
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (!(props.children == null)) {
                {
                  throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
                }
              }
              if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
                {
                  throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
                }
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (!(props.style == null || typeof props.style === "object")) {
              {
                throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
          function validateProperty(tagName, name2) {
            {
              if (hasOwnProperty$1.call(warnedProperties, name2) && warnedProperties[name2]) {
                return true;
              }
              if (rARIACamel.test(name2)) {
                var ariaName = "aria-" + name2.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                  warnedProperties[name2] = true;
                  return true;
                }
                if (name2 !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                  warnedProperties[name2] = true;
                  return true;
                }
              }
              if (rARIA.test(name2)) {
                var lowerCasedName = name2.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name2] = true;
                  return false;
                }
                if (name2 !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                  warnedProperties[name2] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var _hasOwnProperty = Object.prototype.hasOwnProperty;
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name2, value, eventRegistry) {
              if (_hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
                return true;
              }
              var lowerCasedName = name2.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name2] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name2)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                  warnedProperties$1[name2] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name2)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name2);
                  warnedProperties$1[name2] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name2)) {
                if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
                }
                warnedProperties$1[name2] = true;
                return true;
              }
              if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name2] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name2] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name2);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name2) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                  warnedProperties$1[name2] = true;
                  return true;
                }
              } else if (!isReserved && name2 !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
                }
                warnedProperties$1[name2] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
                warnedProperties$1[name2] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
                warnedProperties$1[name2] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var IS_REPLAYED = 1 << 4;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (!(typeof restoreImpl === "function")) {
              {
                throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn, bookkeeping) {
            return fn(bookkeeping);
          };
          var discreteUpdatesImpl = function(fn, a, b, c, d) {
            return fn(a, b, c, d);
          };
          var flushDiscreteUpdatesImpl = function() {
          };
          var batchedEventUpdatesImpl = batchedUpdatesImpl;
          var isInsideEventHandler = false;
          var isBatchingEventUpdates = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushDiscreteUpdatesImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn, bookkeeping) {
            if (isInsideEventHandler) {
              return fn(bookkeeping);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn, bookkeeping);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function batchedEventUpdates(fn, a, b) {
            if (isBatchingEventUpdates) {
              return fn(a, b);
            }
            isBatchingEventUpdates = true;
            try {
              return batchedEventUpdatesImpl(fn, a, b);
            } finally {
              isBatchingEventUpdates = false;
              finishEventHandler();
            }
          }
          function discreteUpdates(fn, a, b, c, d) {
            var prevIsInsideEventHandler = isInsideEventHandler;
            isInsideEventHandler = true;
            try {
              return discreteUpdatesImpl(fn, a, b, c, d);
            } finally {
              isInsideEventHandler = prevIsInsideEventHandler;
              if (!isInsideEventHandler) {
                finishEventHandler();
              }
            }
          }
          function flushDiscreteUpdatesIfNeeded(timeStamp) {
            {
              if (!isInsideEventHandler) {
                flushDiscreteUpdatesImpl();
              }
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            discreteUpdatesImpl = _discreteUpdatesImpl;
            flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
            batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name2, type, props) {
            switch (name2) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (!(!listener || typeof listener === "function")) {
              {
                throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
              }
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name2, func, context, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a, b, c, d, e, f) {
                if (!(typeof document !== "undefined")) {
                  {
                    throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                  }
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name2, func, context, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              {
                {
                  throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          function get4(key) {
            return key._reactInternals;
          }
          function has3(key) {
            return key._reactInternals !== void 0;
          }
          function set5(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var PlacementAndUpdate = 6;
          var Deletion = 8;
          var ContentReset = 16;
          var Callback = 32;
          var DidCapture = 64;
          var Ref = 128;
          var Snapshot = 256;
          var Passive = 512;
          var PassiveUnmountPendingDev = 8192;
          var Hydrating = 1024;
          var HydratingAndUpdate = 1028;
          var LifecycleEffectMask = 932;
          var HostEffectMask = 2047;
          var Incomplete = 2048;
          var ShouldCapture = 4096;
          var ForceUpdateForLegacySuspense = 16384;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get4(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (!(getNearestMountedFiber(fiber) === fiber)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (!(nearestMounted !== null)) {
                {
                  throw Error("Unable to find node on an unmounted component.");
                }
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                {
                  {
                    throw Error("Unable to find node on an unmounted component.");
                  }
                }
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    {
                      throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                    }
                  }
                }
              }
              if (!(a.alternate === b)) {
                {
                  throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (!(a.tag === HostRoot)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText) {
                return node;
              } else if (node.child) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            if (!currentParent) {
              return null;
            }
            var node = currentParent;
            while (true) {
              if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {
                return node;
              } else if (node.child && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === currentParent) {
                return null;
              }
              while (!node.sibling) {
                if (!node.return || node.return === currentParent) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          function doesFiberContain(parentFiber, childFiber) {
            var node = childFiber;
            var parentFiberAlternate = parentFiber.alternate;
            while (node !== null) {
              if (node === parentFiber || node === parentFiberAlternate) {
                return true;
              }
              node = node.return;
            }
            return false;
          }
          var attemptUserBlockingHydration;
          function setAttemptUserBlockingHydration(fn) {
            attemptUserBlockingHydration = fn;
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn) {
            attemptHydrationAtPriority = fn;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = new Map();
          var queuedPointerCaptures = new Map();
          var queuedExplicitHydrationTargets = [];
          function hasQueuedDiscreteEvents() {
            return queuedDiscreteEvents.length > 0;
          }
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isReplayableDiscreteEvent(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags: eventSystemFlags | IS_REPLAYED,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            queuedDiscreteEvents.push(queuedEvent);
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.lanePriority, function() {
                      Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                        attemptHydrationAtCurrentPriority(nearestMounted);
                      });
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (root2.hydrate) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn !== null) {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map2.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            while (queuedDiscreteEvents.length > 0) {
              var nextDiscreteEvent = queuedDiscreteEvents[0];
              if (nextDiscreteEvent.blockedOn !== null) {
                var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);
                if (_fiber4 !== null) {
                  attemptUserBlockingHydration(_fiber4);
                }
                break;
              }
              var targetContainers = nextDiscreteEvent.targetContainers;
              while (targetContainers.length > 0) {
                var targetContainer = targetContainers[0];
                var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);
                if (nextBlockedOn !== null) {
                  nextDiscreteEvent.blockedOn = nextBlockedOn;
                  break;
                }
                targetContainers.shift();
              }
              if (nextDiscreteEvent.blockedOn === null) {
                queuedDiscreteEvents.shift();
              }
            }
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i2 = 0; _i2 < queuedExplicitHydrationTargets.length; _i2++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i2];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var DiscreteEvent = 0;
          var UserBlockingEvent = 1;
          var ContinuousEvent = 2;
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = new Map();
          var eventPriorities = new Map();
          var discreteEventPairsForSimpleEventPlugin = [
            "cancel",
            "cancel",
            "click",
            "click",
            "close",
            "close",
            "contextmenu",
            "contextMenu",
            "copy",
            "copy",
            "cut",
            "cut",
            "auxclick",
            "auxClick",
            "dblclick",
            "doubleClick",
            "dragend",
            "dragEnd",
            "dragstart",
            "dragStart",
            "drop",
            "drop",
            "focusin",
            "focus",
            "focusout",
            "blur",
            "input",
            "input",
            "invalid",
            "invalid",
            "keydown",
            "keyDown",
            "keypress",
            "keyPress",
            "keyup",
            "keyUp",
            "mousedown",
            "mouseDown",
            "mouseup",
            "mouseUp",
            "paste",
            "paste",
            "pause",
            "pause",
            "play",
            "play",
            "pointercancel",
            "pointerCancel",
            "pointerdown",
            "pointerDown",
            "pointerup",
            "pointerUp",
            "ratechange",
            "rateChange",
            "reset",
            "reset",
            "seeked",
            "seeked",
            "submit",
            "submit",
            "touchcancel",
            "touchCancel",
            "touchend",
            "touchEnd",
            "touchstart",
            "touchStart",
            "volumechange",
            "volumeChange"
          ];
          var otherDiscreteEvents = ["change", "selectionchange", "textInput", "compositionstart", "compositionend", "compositionupdate"];
          var userBlockingPairsForSimpleEventPlugin = ["drag", "drag", "dragenter", "dragEnter", "dragexit", "dragExit", "dragleave", "dragLeave", "dragover", "dragOver", "mousemove", "mouseMove", "mouseout", "mouseOut", "mouseover", "mouseOver", "pointermove", "pointerMove", "pointerout", "pointerOut", "pointerover", "pointerOver", "scroll", "scroll", "toggle", "toggle", "touchmove", "touchMove", "wheel", "wheel"];
          var continuousPairsForSimpleEventPlugin = ["abort", "abort", ANIMATION_END, "animationEnd", ANIMATION_ITERATION, "animationIteration", ANIMATION_START, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", TRANSITION_END, "transitionEnd", "waiting", "waiting"];
          function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
            for (var i = 0; i < eventTypes.length; i += 2) {
              var topEvent = eventTypes[i];
              var event = eventTypes[i + 1];
              var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
              var reactName = "on" + capitalizedEvent;
              eventPriorities.set(topEvent, priority);
              topLevelEventsToReactNames.set(topEvent, reactName);
              registerTwoPhaseEvent(reactName, [topEvent]);
            }
          }
          function setEventPriorities(eventTypes, priority) {
            for (var i = 0; i < eventTypes.length; i++) {
              eventPriorities.set(eventTypes[i], priority);
            }
          }
          function getEventPriorityForPluginSystem(domEventName) {
            var priority = eventPriorities.get(domEventName);
            return priority === void 0 ? ContinuousEvent : priority;
          }
          function registerSimpleEvents() {
            registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
            registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
            registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
            setEventPriorities(otherDiscreteEvents, DiscreteEvent);
          }
          var Scheduler_now = Scheduler.unstable_now;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
              }
            }
          }
          var ImmediatePriority = 99;
          var UserBlockingPriority = 98;
          var NormalPriority = 97;
          var LowPriority = 96;
          var IdlePriority = 95;
          var NoPriority = 90;
          var initialTimeMs = Scheduler_now();
          var SyncLanePriority = 15;
          var SyncBatchedLanePriority = 14;
          var InputDiscreteHydrationLanePriority = 13;
          var InputDiscreteLanePriority = 12;
          var InputContinuousHydrationLanePriority = 11;
          var InputContinuousLanePriority = 10;
          var DefaultHydrationLanePriority = 9;
          var DefaultLanePriority = 8;
          var TransitionHydrationPriority = 7;
          var TransitionPriority = 6;
          var RetryLanePriority = 5;
          var SelectiveHydrationLanePriority = 4;
          var IdleHydrationLanePriority = 3;
          var IdleLanePriority = 2;
          var OffscreenLanePriority = 1;
          var NoLanePriority = 0;
          var TotalLanes = 31;
          var NoLanes = 0;
          var NoLane = 0;
          var SyncLane = 1;
          var SyncBatchedLane = 2;
          var InputDiscreteHydrationLane = 4;
          var InputDiscreteLanes = 24;
          var InputContinuousHydrationLane = 32;
          var InputContinuousLanes = 192;
          var DefaultHydrationLane = 256;
          var DefaultLanes = 3584;
          var TransitionHydrationLane = 4096;
          var TransitionLanes = 4186112;
          var RetryLanes = 62914560;
          var SomeRetryLane = 33554432;
          var SelectiveHydrationLane = 67108864;
          var NonIdleLanes = 134217727;
          var IdleHydrationLane = 134217728;
          var IdleLanes = 805306368;
          var OffscreenLane = 1073741824;
          var NoTimestamp = -1;
          function setCurrentUpdateLanePriority(newLanePriority) {
          }
          var return_highestLanePriority = DefaultLanePriority;
          function getHighestPriorityLanes(lanes) {
            if ((SyncLane & lanes) !== NoLanes) {
              return_highestLanePriority = SyncLanePriority;
              return SyncLane;
            }
            if ((SyncBatchedLane & lanes) !== NoLanes) {
              return_highestLanePriority = SyncBatchedLanePriority;
              return SyncBatchedLane;
            }
            if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
              return_highestLanePriority = InputDiscreteHydrationLanePriority;
              return InputDiscreteHydrationLane;
            }
            var inputDiscreteLanes = InputDiscreteLanes & lanes;
            if (inputDiscreteLanes !== NoLanes) {
              return_highestLanePriority = InputDiscreteLanePriority;
              return inputDiscreteLanes;
            }
            if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
              return_highestLanePriority = InputContinuousHydrationLanePriority;
              return InputContinuousHydrationLane;
            }
            var inputContinuousLanes = InputContinuousLanes & lanes;
            if (inputContinuousLanes !== NoLanes) {
              return_highestLanePriority = InputContinuousLanePriority;
              return inputContinuousLanes;
            }
            if ((lanes & DefaultHydrationLane) !== NoLanes) {
              return_highestLanePriority = DefaultHydrationLanePriority;
              return DefaultHydrationLane;
            }
            var defaultLanes = DefaultLanes & lanes;
            if (defaultLanes !== NoLanes) {
              return_highestLanePriority = DefaultLanePriority;
              return defaultLanes;
            }
            if ((lanes & TransitionHydrationLane) !== NoLanes) {
              return_highestLanePriority = TransitionHydrationPriority;
              return TransitionHydrationLane;
            }
            var transitionLanes = TransitionLanes & lanes;
            if (transitionLanes !== NoLanes) {
              return_highestLanePriority = TransitionPriority;
              return transitionLanes;
            }
            var retryLanes = RetryLanes & lanes;
            if (retryLanes !== NoLanes) {
              return_highestLanePriority = RetryLanePriority;
              return retryLanes;
            }
            if (lanes & SelectiveHydrationLane) {
              return_highestLanePriority = SelectiveHydrationLanePriority;
              return SelectiveHydrationLane;
            }
            if ((lanes & IdleHydrationLane) !== NoLanes) {
              return_highestLanePriority = IdleHydrationLanePriority;
              return IdleHydrationLane;
            }
            var idleLanes = IdleLanes & lanes;
            if (idleLanes !== NoLanes) {
              return_highestLanePriority = IdleLanePriority;
              return idleLanes;
            }
            if ((OffscreenLane & lanes) !== NoLanes) {
              return_highestLanePriority = OffscreenLanePriority;
              return OffscreenLane;
            }
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return_highestLanePriority = DefaultLanePriority;
            return lanes;
          }
          function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
            switch (schedulerPriorityLevel) {
              case ImmediatePriority:
                return SyncLanePriority;
              case UserBlockingPriority:
                return InputContinuousLanePriority;
              case NormalPriority:
              case LowPriority:
                return DefaultLanePriority;
              case IdlePriority:
                return IdleLanePriority;
              default:
                return NoLanePriority;
            }
          }
          function lanePriorityToSchedulerPriority(lanePriority) {
            switch (lanePriority) {
              case SyncLanePriority:
              case SyncBatchedLanePriority:
                return ImmediatePriority;
              case InputDiscreteHydrationLanePriority:
              case InputDiscreteLanePriority:
              case InputContinuousHydrationLanePriority:
              case InputContinuousLanePriority:
                return UserBlockingPriority;
              case DefaultHydrationLanePriority:
              case DefaultLanePriority:
              case TransitionHydrationPriority:
              case TransitionPriority:
              case SelectiveHydrationLanePriority:
              case RetryLanePriority:
                return NormalPriority;
              case IdleHydrationLanePriority:
              case IdleLanePriority:
              case OffscreenLanePriority:
                return IdlePriority;
              case NoLanePriority:
                return NoPriority;
              default: {
                {
                  throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
                }
              }
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return_highestLanePriority = NoLanePriority;
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var nextLanePriority = NoLanePriority;
            var expiredLanes = root2.expiredLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            if (expiredLanes !== NoLanes) {
              nextLanes = expiredLanes;
              nextLanePriority = return_highestLanePriority = SyncLanePriority;
            } else {
              var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
              if (nonIdlePendingLanes !== NoLanes) {
                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
                if (nonIdleUnblockedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                  nextLanePriority = return_highestLanePriority;
                } else {
                  var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                  if (nonIdlePingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                    nextLanePriority = return_highestLanePriority;
                  }
                }
              } else {
                var unblockedLanes = pendingLanes & ~suspendedLanes;
                if (unblockedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(unblockedLanes);
                  nextLanePriority = return_highestLanePriority;
                } else {
                  if (pingedLanes !== NoLanes) {
                    nextLanes = getHighestPriorityLanes(pingedLanes);
                    nextLanePriority = return_highestLanePriority;
                  }
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes);
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
              getHighestPriorityLanes(wipLanes);
              var wipLanePriority = return_highestLanePriority;
              if (nextLanePriority <= wipLanePriority) {
                return wipLanes;
              } else {
                return_highestLanePriority = nextLanePriority;
              }
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index2 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index2;
                nextLanes |= entanglements[index2];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var eventTime = eventTimes[index2];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            getHighestPriorityLanes(lane);
            var priority = return_highestLanePriority;
            if (priority >= InputContinuousLanePriority) {
              return currentTime + 250;
            } else if (priority >= TransitionPriority) {
              return currentTime + 5e3;
            } else {
              return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var expirationTime = expirationTimes[index2];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function returnNextLanesPriority() {
            return return_highestLanePriority;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function findUpdateLane(lanePriority, wipLanes) {
            switch (lanePriority) {
              case NoLanePriority:
                break;
              case SyncLanePriority:
                return SyncLane;
              case SyncBatchedLanePriority:
                return SyncBatchedLane;
              case InputDiscreteLanePriority: {
                var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
                if (_lane === NoLane) {
                  return findUpdateLane(InputContinuousLanePriority, wipLanes);
                }
                return _lane;
              }
              case InputContinuousLanePriority: {
                var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
                if (_lane2 === NoLane) {
                  return findUpdateLane(DefaultLanePriority, wipLanes);
                }
                return _lane2;
              }
              case DefaultLanePriority: {
                var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
                if (_lane3 === NoLane) {
                  _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
                  if (_lane3 === NoLane) {
                    _lane3 = pickArbitraryLane(DefaultLanes);
                  }
                }
                return _lane3;
              }
              case TransitionPriority:
              case RetryLanePriority:
                break;
              case IdleLanePriority:
                var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
                if (lane === NoLane) {
                  lane = pickArbitraryLane(IdleLanes);
                }
                return lane;
            }
            {
              {
                throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
              }
            }
          }
          function findTransitionLane(wipLanes, pendingLanes) {
            var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
              if (lane === NoLane) {
                lane = pickArbitraryLane(TransitionLanes);
              }
            }
            return lane;
          }
          function findRetryLane(wipLanes) {
            var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(RetryLanes);
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function getLowestPriorityLane(lanes) {
            var index2 = 31 - clz32(lanes);
            return index2 < 0 ? NoLanes : 1 << index2;
          }
          function getEqualOrHigherPriorityLanes(lanes) {
            return (getLowestPriorityLane(lanes) << 1) - 1;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
          }
          function isSubsetOfLanes(set6, subset) {
            return (set6 & subset) === subset;
          }
          function mergeLanes(a, b) {
            return a | b;
          }
          function removeLanes(set6, subset) {
            return set6 & ~subset;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            var higherPriorityLanes = updateLane - 1;
            root2.suspendedLanes &= higherPriorityLanes;
            root2.pingedLanes &= higherPriorityLanes;
            var eventTimes = root2.eventTimes;
            var index2 = laneToIndex(updateLane);
            eventTimes[index2] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markDiscreteUpdatesExpired(root2) {
            root2.expiredLanes |= InputDiscreteLanes & root2.pendingLanes;
          }
          function hasDiscreteLanes(lanes) {
            return (lanes & InputDiscreteLanes) !== NoLanes;
          }
          function markRootMutableRead(root2, updateLane) {
            root2.mutableReadLanes |= updateLane & root2.pendingLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = 0;
            root2.pingedLanes = 0;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] = NoLanes;
              eventTimes[index2] = NoTimestamp;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = entangledLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] |= entangledLanes;
              lanes &= ~lane;
            }
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(lanes) {
            if (lanes === 0) {
              return 32;
            }
            return 31 - (log(lanes) / LN2 | 0) | 0;
          }
          var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriorityForPluginSystem(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEvent:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case UserBlockingEvent:
                listenerWrapper = dispatchUserBlockingUpdate;
                break;
              case ContinuousEvent:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            {
              flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
            }
            discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
          }
          function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
            {
              runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            var allowReplay = true;
            {
              allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
            }
            if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
              queueDiscreteEvent(null, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              return;
            }
            var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              if (allowReplay) {
                clearIfContinuousEvent(domEventName, nativeEvent);
              }
              return;
            }
            if (allowReplay) {
              if (isReplayableDiscreteEvent(domEventName)) {
                queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
                return;
              }
              if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
                return;
              }
              clearIfContinuousEvent(domEventName, nativeEvent);
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (root2.hydrate) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
            return null;
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              passive
            });
            return listener;
          }
          var root = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start2;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start2 = 0; start2 < startLength; start2++) {
              if (startValue[start2] !== endValue[start2]) {
                break;
              }
            }
            var minEnd = startLength - start2;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start2, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root) {
              return root.value;
            }
            return root.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize = Interface[_propName];
                if (normalize) {
                  this[_propName] = normalize(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            _assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              persist: function() {
              },
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = _assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = _assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = _assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = _assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = _assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = _assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = _assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = _assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = _assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = _assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = _assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = _assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc2 = nativeEventTarget.ownerDocument;
              if (doc2) {
                win = doc2.defaultView || doc2.parentWindow;
              } else {
                win = window;
              }
            }
            var from;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from = null;
              to = targetInst;
            }
            if (from === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
          }
          function is3(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is3;
          var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
          function shallowEqual2(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root2, offset) {
            var node = getLeafNode(root2);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                  return {
                    node,
                    offset: offset - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start2 = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start2 = length + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start2 = length;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start2 === -1 || end === -1) {
              return null;
            }
            return {
              start: start2,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc2 = node.ownerDocument || document;
            var win = doc2 && doc2.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start2 = Math.min(offsets.start, length);
            var end = offsets.end === void 0 ? start2 : Math.min(offsets.end, length);
            if (!selection.extend && start2 > end) {
              var temp = end;
              end = start2;
              start2 = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start2);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc2.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start2 > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection2(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection2(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start2 = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start2;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start2;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc2 = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc2)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual2(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i2 = 0; _i2 < dispatchListeners.length; _i2++) {
                var _dispatchListeners$_i = dispatchListeners[_i2], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
              var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            {
              if (rootContainerElement[listeningMarker]) {
                return;
              }
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement, null);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement, null);
              });
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
            var eventSystemFlags = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
            var target = rootContainerElement;
            if (domEventName === "selectionchange" && rootContainerElement.nodeType !== DOCUMENT_NODE) {
              target = rootContainerElement.ownerDocument;
            }
            if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
              if (domEventName !== "scroll") {
                return;
              }
              eventSystemFlags |= IS_NON_DELEGATED;
              target = targetElement;
            }
            var listenerSet = getEventListenerSet(target);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              if (isCapturePhaseListener) {
                eventSystemFlags |= IS_CAPTURE_PHASE;
              }
              addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container !== null) {
                        var parentNode = getClosestInstanceFromNode(container);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container = container.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedEventUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            if (from !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var HTML_NAMESPACE$1 = Namespaces.html;
          var warnedUnknownTags;
          var suppressHydrationWarning;
          var validatePropertiesInDevelopment;
          var warnForTextDifference;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeMarkupForTextOrAttribute;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              dialog: true,
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
            var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
            normalizeMarkupForTextOrAttribute = function(markup) {
              var markupString = typeof markup === "string" ? markup : "" + markup;
              return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
            };
            warnForTextDifference = function(serverText, clientText) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
              var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
              if (normalizedServerText === normalizedClientText) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            };
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name2) {
                names.push(name2);
              });
              error("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop3() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop3;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement2(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE$1) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE$1) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE$1) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$3(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "option":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$3(domElement, lastRawProps);
                nextProps = getHostProps$3(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else if (typeof nextProp === "object" && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
                nextProp.toString();
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = new Set();
              var attributes = domElement.attributes;
              for (var _i2 = 0; _i2 < attributes.length; _i2++) {
                var name2 = attributes[_i2].name.toLowerCase();
                switch (name2) {
                  case "data-reactroot":
                    break;
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i2].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (!suppressHydrationWarning) {
                      warnForTextDifference(domElement.textContent, nextProp);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (!suppressHydrationWarning) {
                      warnForTextDifference(domElement.textContent, nextProp);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = getPropertyInfo(propKey);
                if (suppressHydrationWarning)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE$1) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE$1) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForUnmatchedText(textNode, text) {
            {
              warnForTextDifference(textNode.nodeValue, text);
            }
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1;
          {
            SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          }
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function shouldAutoFocusHostComponent(type, props) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
            }
            return false;
          }
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root2 = rootContainerInstance.documentElement;
                namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string2 = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement2(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            return shouldAutoFocusHostComponent(type, props);
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string2 = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "option" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            if (shouldAutoFocusHostComponent(type, newProps)) {
              domElement.focus();
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateFiberProps(domElement, newProps);
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
              container.textContent = "";
            } else if (container.nodeType === DOCUMENT_NODE) {
              var body = container.body;
              if (body != null) {
                body.textContent = "";
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            return diffHydratedProperties(instance, type, props, parentNamespace);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            return diffHydratedText(textInstance, text);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
            {
              warnForUnmatchedText(textInstance, text);
            }
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForUnmatchedText(textInstance, text);
            }
          }
          function didNotHydrateContainerInstance(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
          function didNotFindHydratableContainerInstance(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableContainerTextInstance(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type);
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text);
            }
          }
          function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true)
              ;
          }
          var clientId = 0;
          function makeClientIdInDEV(warnOnAccessInDEV) {
            var id = "r:" + (clientId++).toString(36);
            return {
              toString: function() {
                warnOnAccessInDEV();
                return id;
              },
              valueOf: function() {
                warnOnAccessInDEV();
                return id;
              }
            };
          }
          function isOpaqueHydratingObject(value) {
            return value !== null && typeof value === "object" && value.$$typeof === REACT_OPAQUE_ID_TYPE;
          }
          function makeOpaqueHydratingObject(attemptToReadValue) {
            return {
              $$typeof: REACT_OPAQUE_ID_TYPE,
              toString: attemptToReadValue,
              valueOf: attemptToReadValue
            };
          }
          function preparePortalMount(portalInstance) {
            {
              listenToAllSupportedEvents(portalInstance);
            }
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            {
              {
                throw Error("getNodeFromInstance: Invalid argument.");
              }
            }
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values2, location, componentName, element) {
            {
              var has4 = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has4(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop2(cursor, fiber) {
            if (index < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
              fiberStack[index] = null;
            }
            index--;
          }
          function push2(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
              fiberStack[index] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name2 = getComponentName(type) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name2);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop2(didPerformWorkStackCursor, fiber);
              pop2(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop2(didPerformWorkStackCursor, fiber);
              pop2(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (!(contextStackCursor.current === emptyContextObject)) {
                {
                  throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              push2(contextStackCursor, context, fiber);
              push2(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentName(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  {
                    throw Error((getComponentName(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                  }
                }
              }
              {
                var name2 = getComponentName(type) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name2);
              }
              return _assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push2(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push2(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                {
                  throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop2(didPerformWorkStackCursor, workInProgress2);
                pop2(contextStackCursor, workInProgress2);
                push2(contextStackCursor, mergedContext, workInProgress2);
                push2(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop2(didPerformWorkStackCursor, workInProgress2);
                push2(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
                {
                  throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component2 = node.type;
                    if (isContextProvider(Component2)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              {
                {
                  throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
          }
          var LegacyRoot = 0;
          var BlockingRoot = 1;
          var ConcurrentRoot = 2;
          var rendererID = null;
          var injectedHook = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            return true;
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, priorityLevel) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  injectedHook.onCommitFiberRoot(rendererID, root2, priorityLevel, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
          {
            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
              {
                throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
              }
            }
          }
          var fakeCallbackNode = {};
          var ImmediatePriority$1 = 99;
          var UserBlockingPriority$2 = 98;
          var NormalPriority$1 = 97;
          var LowPriority$1 = 96;
          var IdlePriority$1 = 95;
          var NoPriority$1 = 90;
          var shouldYield = Scheduler_shouldYield;
          var requestPaint = Scheduler_requestPaint !== void 0 ? Scheduler_requestPaint : function() {
          };
          var syncQueue = null;
          var immediateQueueCallbackNode = null;
          var isFlushingSyncQueue = false;
          var initialTimeMs$1 = Scheduler_now$1();
          var now = initialTimeMs$1 < 1e4 ? Scheduler_now$1 : function() {
            return Scheduler_now$1() - initialTimeMs$1;
          };
          function getCurrentPriorityLevel() {
            switch (Scheduler_getCurrentPriorityLevel()) {
              case Scheduler_ImmediatePriority:
                return ImmediatePriority$1;
              case Scheduler_UserBlockingPriority:
                return UserBlockingPriority$2;
              case Scheduler_NormalPriority:
                return NormalPriority$1;
              case Scheduler_LowPriority:
                return LowPriority$1;
              case Scheduler_IdlePriority:
                return IdlePriority$1;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function reactPriorityToSchedulerPriority(reactPriorityLevel) {
            switch (reactPriorityLevel) {
              case ImmediatePriority$1:
                return Scheduler_ImmediatePriority;
              case UserBlockingPriority$2:
                return Scheduler_UserBlockingPriority;
              case NormalPriority$1:
                return Scheduler_NormalPriority;
              case LowPriority$1:
                return Scheduler_LowPriority;
              case IdlePriority$1:
                return Scheduler_IdlePriority;
              default: {
                {
                  throw Error("Unknown priority level.");
                }
              }
            }
          }
          function runWithPriority$1(reactPriorityLevel, fn) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_runWithPriority(priorityLevel, fn);
          }
          function scheduleCallback(reactPriorityLevel, callback, options2) {
            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
            return Scheduler_scheduleCallback(priorityLevel, callback, options2);
          }
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
              immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
            } else {
              syncQueue.push(callback);
            }
            return fakeCallbackNode;
          }
          function cancelCallback(callbackNode) {
            if (callbackNode !== fakeCallbackNode) {
              Scheduler_cancelCallback(callbackNode);
            }
          }
          function flushSyncCallbackQueue() {
            if (immediateQueueCallbackNode !== null) {
              var node = immediateQueueCallbackNode;
              immediateQueueCallbackNode = null;
              Scheduler_cancelCallback(node);
            }
            flushSyncCallbackQueueImpl();
          }
          function flushSyncCallbackQueueImpl() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              {
                try {
                  var _isSync2 = true;
                  var _queue = syncQueue;
                  runWithPriority$1(ImmediatePriority$1, function() {
                    for (; i < _queue.length; i++) {
                      var callback = _queue[i];
                      do {
                        callback = callback(_isSync2);
                      } while (callback !== null);
                    }
                  });
                  syncQueue = null;
                } catch (error2) {
                  if (syncQueue !== null) {
                    syncQueue = syncQueue.slice(i + 1);
                  }
                  Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                  throw error2;
                } finally {
                  isFlushingSyncQueue = false;
                }
              }
            }
          }
          var ReactVersion = "17.0.2";
          var NoMode = 0;
          var StrictMode = 1;
          var BlockingMode = 2;
          var ConcurrentMode = 4;
          var ProfileMode = 8;
          var DebugTracingMode = 16;
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = 0;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set6) {
              var array2 = [];
              set6.forEach(function(value) {
                array2.push(value);
              });
              return array2.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = new Map();
            var didWarnAboutLegacyContext = new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentName(fiber.type) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = new Map();
            };
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = _assign({}, baseProps);
              var defaultProps = Component2.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var MAX_SIGNED_31_BIT_INT = 1073741823;
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastContextWithAllBitsObserved = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, nextValue) {
            var context = providerFiber.type._context;
            {
              push2(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(providerFiber) {
            var currentValue = valueCursor.current;
            pop2(valueCursor, providerFiber);
            var context = providerFiber.type._context;
            {
              context._currentValue = currentValue;
            }
          }
          function calculateChangedBits(context, newValue, oldValue) {
            if (objectIs(oldValue, newValue)) {
              return 0;
            } else {
              var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
              {
                if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
                  error("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
                }
              }
              return changedBits | 0;
            }
          }
          function scheduleWorkOnParentPath(parent, renderLanes2) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              } else {
                break;
              }
              node = node.return;
            }
          }
          function propagateContextChange(workInProgress2, context, changedBits, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                    if (fiber.tag === ClassComponent) {
                      var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes2));
                      update.tag = ForceUpdate;
                      enqueueUpdate(fiber, update);
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleWorkOnParentPath(fiber.return, renderLanes2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastContextWithAllBitsObserved = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
          function readContext(context, observedBits) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            if (lastContextWithAllBitsObserved === context)
              ;
            else if (observedBits === false || observedBits === 0)
              ;
            else {
              var resolvedObservedBits;
              if (typeof observedBits !== "number" || observedBits === MAX_SIGNED_31_BIT_INT) {
                lastContextWithAllBitsObserved = context;
                resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
              } else {
                resolvedObservedBits = observedBits;
              }
              var contextItem = {
                context,
                observedBits: resolvedObservedBits,
                next: null
              };
              if (lastContextDependency === null) {
                if (!(currentlyRenderingFiber !== null)) {
                  {
                    throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                  }
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem,
                  responders: null
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return context._currentValue;
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            var pending = sharedQueue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            sharedQueue.pending = update;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone;
                    } else {
                      newLast.next = clone;
                      newLast = clone;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictMode) {
                      disableLogs();
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        reenableLogs();
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictMode) {
                      disableLogs();
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        reenableLogs();
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return _assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (!(typeof callback === "function")) {
              {
                throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
              }
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect = effects[i];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var isArray = Array.isArray;
          var emptyRefsObject = new React6.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = new Set();
            didWarnAboutUninitializedState = new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
            didWarnAboutDirectlyAssigningPropsToState = new Set();
            didWarnAboutUndefinedDerivedState = new Set();
            didWarnAboutContextTypeAndContextTypes = new Set();
            didWarnAboutInvalidateContextType = new Set();
            var didWarnOnInvalidCallback = new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentName(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                {
                  {
                    throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                  }
                }
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            {
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  reenableLogs();
                }
              }
            }
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : _assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get4(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get4(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get4(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              enqueueUpdate(fiber, update);
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              {
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    reenableLogs();
                  }
                }
              }
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual2(oldProps, newProps) || !shallowEqual2(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name2 = getComponentName(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error("%s.state: must be set to an object or null", name2);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set5(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            {
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  new ctor(props, context);
                } finally {
                  reenableLogs();
                }
              }
            }
            var instance = new ctor(props, context);
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentName(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress2.type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentName(workInProgress2.type) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentName(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              workInProgress2.flags |= Update;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                workInProgress2.flags |= Update;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (!(typeof child._store === "object")) {
                {
                  throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              child._store.validated = true;
              var componentName = getComponentName(returnFiber.type) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          var isArray$1 = Array.isArray;
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentName(returnFiber.type) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (!(ownerFiber.tag === ClassComponent)) {
                    {
                      throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                    }
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  {
                    throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = inst.refs;
                  if (refs === emptyRefsObject) {
                    refs = inst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (!(typeof mixedRef === "string")) {
                  {
                    throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                  }
                }
                if (!element._owner) {
                  {
                    throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                  }
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            if (returnFiber.type !== "textarea") {
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentName(returnFiber.type) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = childToDelete;
                returnFiber.lastEffect = childToDelete;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
              }
              childToDelete.nextEffect = null;
              childToDelete.flags = Deletion;
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone = createWorkInProgress(fiber, pendingProps);
              clone.index = 0;
              clone.sibling = null;
              return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags = Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags = Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags = Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              if (current2 !== null) {
                if (current2.elementType === element.type || isCompatibleFamilyForHotReloading(current2, element)) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      if (newChild.type === REACT_FRAGMENT_TYPE) {
                        return updateFragment2(returnFiber, oldFiber, newChild.props.children, lanes, key);
                      }
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment2(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
                    }
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                }
                if (isArray$1(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (!(typeof iteratorFn === "function")) {
                {
                  throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (!(newChildren != null)) {
                {
                  throw Error("An iterable object provided no iterator.");
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  switch (child.tag) {
                    case Fragment: {
                      if (element.type === REACT_FRAGMENT_TYPE) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var existing = useFiber(child, element.props.children);
                        existing.return = returnFiber;
                        {
                          existing._debugSource = element._source;
                          existing._debugOwner = element._owner;
                        }
                        return existing;
                      }
                      break;
                    }
                    case Block:
                    default: {
                      if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                        deleteRemainingChildren(returnFiber, child.sibling);
                        var _existing3 = useFiber(child, element.props);
                        _existing3.ref = coerceRef(returnFiber, child, element);
                        _existing3.return = returnFiber;
                        {
                          _existing3._debugSource = element._source;
                          _existing3._debugOwner = element._owner;
                        }
                        return _existing3;
                      }
                      break;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              var isObject2 = typeof newChild === "object" && newChild !== null;
              if (isObject2) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                }
              }
              if (typeof newChild === "string" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              if (isArray$1(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (isObject2) {
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
                switch (returnFiber.tag) {
                  case ClassComponent: {
                    {
                      var instance = returnFiber.stateNode;
                      if (instance.render._isMockFunction) {
                        break;
                      }
                    }
                  }
                  case Block:
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    {
                      {
                        throw Error((getComponentName(returnFiber.type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
                      }
                    }
                  }
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (!(current2 === null || workInProgress2.child === current2.child)) {
              {
                throw Error("Resuming work not yet implemented.");
              }
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (!(c !== NO_CONTEXT)) {
              {
                throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push2(rootInstanceStackCursor, nextRootInstance, fiber);
            push2(contextFiberStackCursor, fiber, fiber);
            push2(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop2(contextStackCursor$1, fiber);
            push2(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop2(contextStackCursor$1, fiber);
            pop2(contextFiberStackCursor, fiber);
            pop2(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push2(contextFiberStackCursor, fiber, fiber);
            push2(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop2(contextStackCursor$1, fiber);
            pop2(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push2(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop2(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            if (props.fallback === void 0) {
              return false;
            }
            if (props.unstable_avoidThisFallback !== true) {
              return true;
            }
            if (hasInvisibleParent) {
              return false;
            }
            return true;
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = 0;
          var HasEffect = 1;
          var Layout = 2;
          var Passive$1 = 4;
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChild(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            return true;
          }
          function deleteHydratableInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot:
                  didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                  break;
                case HostComponent:
                  didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                  break;
              }
            }
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            childToDelete.flags = Deletion;
            if (returnFiber.lastEffect !== null) {
              returnFiber.lastEffect.nextEffect = childToDelete;
              returnFiber.lastEffect = childToDelete;
            } else {
              returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableContainerInstance(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableContainerTextInstance(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                      break;
                    case HostText:
                      var _text = fiber.pendingProps;
                      didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                      break;
                    case SuspenseComponent:
                      didNotFindHydratableSuspenseInstance(parentType, parentProps);
                      break;
                  }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                return false;
              }
              default:
                return false;
            }
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
            }
            hydrationParentFiber = fiber;
            nextHydratableInstance = getFirstHydratableChild(nextInstance);
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            {
              if (shouldUpdate) {
                var returnFiber = hydrationParentFiber;
                if (returnFiber !== null) {
                  switch (returnFiber.tag) {
                    case HostRoot: {
                      var parentContainer = returnFiber.stateNode.containerInfo;
                      didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                      break;
                    }
                    case HostComponent: {
                      var parentType = returnFiber.type;
                      var parentProps = returnFiber.memoizedProps;
                      var parentInstance = returnFiber.stateNode;
                      didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                      break;
                    }
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              {
                throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            var type = fiber.type;
            if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
              var nextInstance = nextHydratableInstance;
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
          }
          function getIsHydrating() {
            return isHydrating;
          }
          var workInProgressSources = [];
          var rendererSigil$1;
          {
            rendererSigil$1 = {};
          }
          function markSourceAsDirty(mutableSource) {
            workInProgressSources.push(mutableSource);
          }
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function getWorkInProgressVersion(mutableSource) {
            {
              return mutableSource._workInProgressVersionPrimary;
            }
          }
          function setWorkInProgressVersion(mutableSource, version) {
            {
              mutableSource._workInProgressVersionPrimary = version;
            }
            workInProgressSources.push(mutableSource);
          }
          function warnAboutMultipleRenderersDEV(mutableSource) {
            {
              {
                if (mutableSource._currentPrimaryRenderer == null) {
                  mutableSource._currentPrimaryRenderer = rendererSigil$1;
                } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
                  error("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
                }
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnAboutUseOpaqueIdentifier;
          {
            didWarnAboutUseOpaqueIdentifier = {};
            didWarnAboutMismatchedHooksForComponent = new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !Array.isArray(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentName(currentlyRenderingFiber$1.type);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            {
              {
                throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component2(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
                  {
                    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                  }
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component2(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
            }
            didScheduleRenderPhaseUpdate = false;
            if (!!didRenderTooFewHooks) {
              {
                throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
              }
            }
            return children;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.flags &= ~(Passive | Update);
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (!(nextCurrentHook !== null)) {
                {
                  throw Error("Rendered more hooks than during the previous render.");
                }
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null
            };
          }
          function basicStateReducer(state, action2) {
            return typeof action2 === "function" ? action2(state) : action2;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== void 0) {
              initialState = init(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (!(queue !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone = {
                    lane: updateLane,
                    action: update.action,
                    eagerReducer: update.eagerReducer,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      lane: NoLane,
                      action: update.action,
                      eagerReducer: update.eagerReducer,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.eagerReducer === reducer) {
                    newState = update.eagerState;
                  } else {
                    var action2 = update.action;
                    newState = reducer(newState, action2);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (!(queue !== null)) {
              {
                throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
              }
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action2 = update.action;
                newState = reducer(newState, action2);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function readFromUnsubcribedMutableSource(root2, source, getSnapshot) {
            {
              warnAboutMultipleRenderersDEV(source);
            }
            var getVersion = source._getVersion;
            var version = getVersion(source._source);
            var isSafeToReadFromSource = false;
            var currentRenderVersion = getWorkInProgressVersion(source);
            if (currentRenderVersion !== null) {
              isSafeToReadFromSource = currentRenderVersion === version;
            } else {
              isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root2.mutableReadLanes);
              if (isSafeToReadFromSource) {
                setWorkInProgressVersion(source, version);
              }
            }
            if (isSafeToReadFromSource) {
              var snapshot = getSnapshot(source._source);
              {
                if (typeof snapshot === "function") {
                  error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                }
              }
              return snapshot;
            } else {
              markSourceAsDirty(source);
              {
                {
                  throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
                }
              }
            }
          }
          function useMutableSource(hook, source, getSnapshot, subscribe) {
            var root2 = getWorkInProgressRoot();
            if (!(root2 !== null)) {
              {
                throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
            }
            var getVersion = source._getVersion;
            var version = getVersion(source._source);
            var dispatcher = ReactCurrentDispatcher$1.current;
            var _dispatcher$useState = dispatcher.useState(function() {
              return readFromUnsubcribedMutableSource(root2, source, getSnapshot);
            }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];
            var snapshot = currentSnapshot;
            var stateHook = workInProgressHook;
            var memoizedState = hook.memoizedState;
            var refs = memoizedState.refs;
            var prevGetSnapshot = refs.getSnapshot;
            var prevSource = memoizedState.source;
            var prevSubscribe = memoizedState.subscribe;
            var fiber = currentlyRenderingFiber$1;
            hook.memoizedState = {
              refs,
              source,
              subscribe
            };
            dispatcher.useEffect(function() {
              refs.getSnapshot = getSnapshot;
              refs.setSnapshot = setSnapshot;
              var maybeNewVersion = getVersion(source._source);
              if (!objectIs(version, maybeNewVersion)) {
                var maybeNewSnapshot = getSnapshot(source._source);
                {
                  if (typeof maybeNewSnapshot === "function") {
                    error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                  }
                }
                if (!objectIs(snapshot, maybeNewSnapshot)) {
                  setSnapshot(maybeNewSnapshot);
                  var lane = requestUpdateLane(fiber);
                  markRootMutableRead(root2, lane);
                }
                markRootEntangled(root2, root2.mutableReadLanes);
              }
            }, [getSnapshot, source, subscribe]);
            dispatcher.useEffect(function() {
              var handleChange = function() {
                var latestGetSnapshot = refs.getSnapshot;
                var latestSetSnapshot = refs.setSnapshot;
                try {
                  latestSetSnapshot(latestGetSnapshot(source._source));
                  var lane = requestUpdateLane(fiber);
                  markRootMutableRead(root2, lane);
                } catch (error2) {
                  latestSetSnapshot(function() {
                    throw error2;
                  });
                }
              };
              var unsubscribe = subscribe(source._source, handleChange);
              {
                if (typeof unsubscribe !== "function") {
                  error("Mutable source subscribe function must return an unsubscribe function.");
                }
              }
              return unsubscribe;
            }, [source, subscribe]);
            if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
              var newQueue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: snapshot
              };
              newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
              stateHook.queue = newQueue;
              stateHook.baseQueue = null;
              snapshot = readFromUnsubcribedMutableSource(root2, source, getSnapshot);
              stateHook.memoizedState = stateHook.baseState = snapshot;
            }
            return snapshot;
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = {
              refs: {
                getSnapshot,
                setSnapshot: null
              },
              source,
              subscribe
            };
            return useMutableSource(hook, source, getSnapshot, subscribe);
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            var hook = updateWorkInProgressHook();
            return useMutableSource(hook, source, getSnapshot, subscribe);
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = hook.queue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect = {
              tag,
              create,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            hook.memoizedState = ref;
            return ref;
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  pushEffect(hookFlags, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            {
              if (typeof jest !== "undefined") {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return mountEffectImpl(Update | Passive, Passive$1, create, deps);
          }
          function updateEffect(create, deps) {
            {
              if (typeof jest !== "undefined") {
                warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
              }
            }
            return updateEffectImpl(Update | Passive, Passive$1, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            return mountEffectImpl(Update, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
            mountEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function updateDeferredValue(value) {
            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
            updateEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function rerenderDeferredValue(value) {
            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
            updateEffect(function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setValue(value);
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            }, [value]);
            return prevValue;
          }
          function startTransition(setPending, callback) {
            var priorityLevel = getCurrentPriorityLevel();
            {
              runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function() {
                setPending(true);
              });
              runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
                var prevTransition = ReactCurrentBatchConfig$1.transition;
                ReactCurrentBatchConfig$1.transition = 1;
                try {
                  setPending(false);
                  callback();
                } finally {
                  ReactCurrentBatchConfig$1.transition = prevTransition;
                }
              });
            }
          }
          function mountTransition() {
            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1];
            var start2 = startTransition.bind(null, setPending);
            mountRef(start2);
            return [start2, isPending];
          }
          function updateTransition() {
            var _updateState2 = updateState(), isPending = _updateState2[0];
            var startRef = updateRef();
            var start2 = startRef.current;
            return [start2, isPending];
          }
          function rerenderTransition() {
            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
            var startRef = updateRef();
            var start2 = startRef.current;
            return [start2, isPending];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function warnOnOpaqueIdentifierAccessInDEV(fiber) {
            {
              var name2 = getComponentName(fiber.type) || "Unknown";
              if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name2]) {
                error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                didWarnAboutUseOpaqueIdentifier[name2] = true;
              }
            }
          }
          function mountOpaqueIdentifier() {
            var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
            if (getIsHydrating()) {
              var didUpgrade = false;
              var fiber = currentlyRenderingFiber$1;
              var readValue = function() {
                if (!didUpgrade) {
                  didUpgrade = true;
                  {
                    isUpdatingOpaqueValueInRenderPhase = true;
                    setId(makeId());
                    isUpdatingOpaqueValueInRenderPhase = false;
                    warnOnOpaqueIdentifierAccessInDEV(fiber);
                  }
                }
                {
                  {
                    throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                  }
                }
              };
              var id = makeOpaqueHydratingObject(readValue);
              var setId = mountState(id)[1];
              if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
                currentlyRenderingFiber$1.flags |= Update | Passive;
                pushEffect(HasEffect | Passive$1, function() {
                  setId(makeId());
                }, void 0, null);
              }
              return id;
            } else {
              var _id = makeId();
              mountState(_id);
              return _id;
            }
          }
          function updateOpaqueIdentifier() {
            var id = updateState()[0];
            return id;
          }
          function rerenderOpaqueIdentifier() {
            var id = rerenderState()[0];
            return id;
          }
          function dispatchAction(fiber, queue, action2) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action: action2,
              eagerReducer: null,
              eagerState: null,
              next: null
            };
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
            var alternate = fiber.alternate;
            if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
              didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            } else {
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action2);
                    update.eagerReducer = lastRenderedReducer;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              {
                if (typeof jest !== "undefined") {
                  warnIfNotScopedWithMatchingAct(fiber);
                  warnIfNotCurrentlyActingUpdatesInDev(fiber);
                }
              }
              scheduleUpdateOnFiber(fiber, lane, eventTime);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useOpaqueIdentifier: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                mountHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return updateOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context, observedBits) {
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                updateHookTypesDev();
                return rerenderOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context, observedBits) {
                warnInvalidContextAccess();
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context, observedBits) {
                warnInvalidContextAccess();
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context, observedBits) {
                warnInvalidContextAccess();
                return readContext(context, observedBits);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context, observedBits) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context, observedBits);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource(source, getSnapshot, subscribe);
              },
              useOpaqueIdentifier: function() {
                currentHookNameInDev = "useOpaqueIdentifier";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderOpaqueIdentifier();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var profilerStartTime = -1;
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component2));
                }
              }
            }
            var render2 = Component2.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component2, nextProps, updateLanes, renderLanes2) {
            if (current2 === null) {
              var type = Component2.type;
              if (isSimpleFunctionComponent(type) && Component2.compare === null && Component2.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, updateLanes, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(type));
                }
              }
              var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component2.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentName(_type));
              }
            }
            var currentChild = current2.child;
            if (!includesSomeLane(updateLanes, renderLanes2)) {
              var prevProps = currentChild.memoizedProps;
              var compare2 = Component2.compare;
              compare2 = compare2 !== null ? compare2 : shallowEqual2;
              if (compare2(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, updateLanes, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    outerMemoType = init(payload);
                  } catch (x) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, nextProps, "prop", getComponentName(outerMemoType));
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual2(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                if (!includesSomeLane(renderLanes2, updateLanes)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || nextProps.mode === "unstable-defer-without-hiding") {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                {
                  markSpawnedWork(OffscreenLane);
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes
                };
                workInProgress2.memoizedState = _nextState;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          var updateLegacyHiddenComponent = updateOffscreenComponent;
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component2));
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component2));
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
              constructClassInstance(workInProgress2, Component2, nextProps);
              mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component2, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress2.type) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component2, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    instance.render();
                  } finally {
                    reenableLogs();
                  }
                }
                setIsRendering(false);
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            var updateQueue = workInProgress2.updateQueue;
            if (!(current2 !== null && updateQueue !== null)) {
              {
                throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState !== null ? prevState.element : null;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var nextChildren = nextState.element;
            if (nextChildren === prevChildren) {
              resetHydrationState();
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var root2 = workInProgress2.stateNode;
            if (root2.hydrate && enterHydrationState(workInProgress2)) {
              {
                var mutableSourceEagerHydrationData = root2.mutableSourceEagerHydrationData;
                if (mutableSourceEagerHydrationData != null) {
                  for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
                    var mutableSource = mutableSourceEagerHydrationData[i];
                    var version = mutableSourceEagerHydrationData[i + 1];
                    setWorkInProgressVersion(mutableSource, version);
                  }
                }
              }
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
              resetHydrationState();
            }
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, updateLanes, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component2 = init(payload);
            workInProgress2.type = Component2;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
            var resolvedProps = resolveDefaultProps(Component2, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component2);
                  workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
                }
                child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
                }
                child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
                }
                child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentName(Component2));
                    }
                  }
                }
                child = updateMemoComponent(null, workInProgress2, Component2, resolveDefaultProps(Component2.type, resolvedProps), updateLanes, renderLanes2);
                return child;
              }
            }
            var hint = "";
            {
              if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            {
              {
                throw Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". Lazy element type must resolve to a class or function." + hint);
              }
            }
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
            if (_current !== null) {
              _current.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
              setIsRendering(false);
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component2)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              var getDerivedStateFromProps = Component2.getDerivedStateFromProps;
              if (typeof getDerivedStateFromProps === "function") {
                applyDerivedStateFromProps(workInProgress2, Component2, getDerivedStateFromProps, props);
              }
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component2, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
                  } finally {
                    reenableLogs();
                  }
                }
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || workInProgress2._debugID || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentName(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2)
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                if (nextProps.fallback !== void 0 && nextProps.unstable_avoidThisFallback !== true) {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              if (nextProps.fallback !== void 0) {
                tryToClaimNextHydratableInstance(workInProgress2);
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else if (typeof nextProps.unstable_expectedLoadTime === "number") {
                var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment = workInProgress2.child;
                _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                workInProgress2.lanes = SomeRetryLane;
                {
                  markSpawnedWork(SomeRetryLane);
                }
                return _fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren, renderLanes2);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                if (showFallback) {
                  var _nextFallbackChildren2 = nextProps.fallback;
                  var _nextPrimaryChildren2 = nextProps.children;
                  var _fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes2);
                  var _primaryChildFragment3 = workInProgress2.child;
                  var prevOffscreenState = current2.child.memoizedState;
                  _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                  _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  return _fallbackChildFragment;
                } else {
                  var _nextPrimaryChildren3 = nextProps.children;
                  var _primaryChildFragment4 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren3, renderLanes2);
                  workInProgress2.memoizedState = null;
                  return _primaryChildFragment4;
                }
              } else {
                if (showFallback) {
                  var _nextFallbackChildren3 = nextProps.fallback;
                  var _nextPrimaryChildren4 = nextProps.children;
                  var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes2);
                  var _primaryChildFragment5 = workInProgress2.child;
                  var _prevOffscreenState = current2.child.memoizedState;
                  _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes2);
                  _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                  workInProgress2.memoizedState = SUSPENDED_MARKER;
                  return _fallbackChildFragment2;
                } else {
                  var _nextPrimaryChildren5 = nextProps.children;
                  var _primaryChildFragment6 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren5, renderLanes2);
                  workInProgress2.memoizedState = null;
                  return _primaryChildFragment6;
                }
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes2, null);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function createWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              currentFallbackChildFragment.nextEffect = null;
              currentFallbackChildFragment.flags = Deletion;
              workInProgress2.firstEffect = workInProgress2.lastEffect = currentFallbackChildFragment;
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & BlockingMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              var progressedLastEffect = primaryChildFragment.lastEffect;
              if (progressedLastEffect !== null) {
                workInProgress2.firstEffect = primaryChildFragment.firstEffect;
                workInProgress2.lastEffect = progressedLastEffect;
                progressedLastEffect.nextEffect = null;
              } else {
                workInProgress2.firstEffect = workInProgress2.lastEffect = null;
              }
            } else {
              primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function scheduleWorkOnFiber(fiber, renderLanes2) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleWorkOnParentPath(fiber.return, renderLanes2);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleWorkOnFiber(node, renderLanes2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleWorkOnFiber(node, renderLanes2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index2) {
            {
              var isArray2 = Array.isArray(childSlot);
              var isIterable = !isArray2 && typeof getIteratorFn(childSlot) === "function";
              if (isArray2 || isIterable) {
                var type = isArray2 ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i2 = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i2)) {
                          return;
                        }
                        _i2++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode,
                lastEffect: lastEffectBeforeRendering
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
              renderState.lastEffect = lastEffectBeforeRendering;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & BlockingMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(workInProgress2, false, tail, lastContentRow, tailMode, workInProgress2.lastEffect);
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(workInProgress2, true, _tail, null, tailMode, workInProgress2.lastEffect);
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(workInProgress2, false, null, null, void 0, workInProgress2.lastEffect);
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, newValue);
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              var changedBits = calculateChangedBits(context, newValue, oldValue);
              if (changedBits === 0) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context, changedBits, renderLanes2);
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context, newProps.unstable_observedBits);
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              return null;
            } else {
              cloneChildFibers(current2, workInProgress2);
              return workInProgress2.child;
            }
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var last = returnFiber.lastEffect;
              if (last !== null) {
                last.nextEffect = current2;
                returnFiber.lastEffect = current2;
              } else {
                returnFiber.firstEffect = returnFiber.lastEffect = current2;
              }
              current2.nextEffect = null;
              current2.flags = Deletion;
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            var updateLanes = workInProgress2.lanes;
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else if (!includesSomeLane(renderLanes2, updateLanes)) {
                didReceiveUpdate = false;
                switch (workInProgress2.tag) {
                  case HostRoot:
                    pushHostRootContext(workInProgress2);
                    resetHydrationState();
                    break;
                  case HostComponent:
                    pushHostContext(workInProgress2);
                    break;
                  case ClassComponent: {
                    var Component2 = workInProgress2.type;
                    if (isContextProvider(Component2)) {
                      pushContextProvider(workInProgress2);
                    }
                    break;
                  }
                  case HostPortal:
                    pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                    break;
                  case ContextProvider: {
                    var newValue = workInProgress2.memoizedProps.value;
                    pushProvider(workInProgress2, newValue);
                    break;
                  }
                  case Profiler:
                    {
                      var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                      if (hasChildWork) {
                        workInProgress2.flags |= Update;
                      }
                      var stateNode = workInProgress2.stateNode;
                      stateNode.effectDuration = 0;
                      stateNode.passiveEffectDuration = 0;
                    }
                    break;
                  case SuspenseComponent: {
                    var state = workInProgress2.memoizedState;
                    if (state !== null) {
                      var primaryChildFragment = workInProgress2.child;
                      var primaryChildLanes = primaryChildFragment.childLanes;
                      if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                        return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                      } else {
                        pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                        var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                        if (child !== null) {
                          return child.sibling;
                        } else {
                          return null;
                        }
                      }
                    } else {
                      pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    }
                    break;
                  }
                  case SuspenseListComponent: {
                    var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                    var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                    if (didSuspendBefore) {
                      if (_hasChildWork) {
                        return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                      }
                      workInProgress2.flags |= DidCapture;
                    }
                    var renderState = workInProgress2.memoizedState;
                    if (renderState !== null) {
                      renderState.rendering = null;
                      renderState.tail = null;
                      renderState.lastEffect = null;
                    }
                    pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                    if (_hasChildWork) {
                      break;
                    } else {
                      return null;
                    }
                  }
                  case OffscreenComponent:
                  case LegacyHiddenComponent: {
                    workInProgress2.lanes = NoLanes;
                    return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
                  }
                }
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else {
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, updateLanes, renderLanes2);
              }
              case FunctionComponent: {
                var _Component = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, _Component, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component2, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentName(_type2));
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, updateLanes, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, updateLanes, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component3 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component3, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case Block: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
              case LegacyHiddenComponent: {
                return updateLegacyHiddenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                return null;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var fiberRoot = workInProgress2.stateNode;
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else if (!fiberRoot.hydrate) {
                    workInProgress2.flags |= Snapshot;
                  }
                }
                updateHostContainer(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (!(workInProgress2.stateNode !== null)) {
                      {
                        throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = false;
                if (current2 === null) {
                  if (workInProgress2.memoizedProps.fallback !== void 0) {
                    popHydrationState(workInProgress2);
                  }
                } else {
                  var prevState = current2.memoizedState;
                  prevDidTimeout = prevState !== null;
                }
                if (nextDidTimeout && !prevDidTimeout) {
                  if ((workInProgress2.mode & BlockingMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && workInProgress2.memoizedProps.unstable_avoidThisFallback !== true;
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
                {
                  if (nextDidTimeout || prevDidTimeout) {
                    workInProgress2.flags |= Update;
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThennables = suspended.updateQueue;
                          if (newThennables !== null) {
                            workInProgress2.updateQueue = newThennables;
                            workInProgress2.flags |= Update;
                          }
                          if (renderState.lastEffect === null) {
                            workInProgress2.firstEffect = null;
                          }
                          workInProgress2.lastEffect = renderState.lastEffect;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                      {
                        markSpawnedWork(SomeRetryLane);
                      }
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThennables = _suspended.updateQueue;
                      if (_newThennables !== null) {
                        workInProgress2.updateQueue = _newThennables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        var lastEffect = workInProgress2.lastEffect = renderState.lastEffect;
                        if (lastEffect !== null) {
                          lastEffect.nextEffect = null;
                        }
                        return null;
                      }
                    } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                      {
                        markSpawnedWork(SomeRetryLane);
                      }
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.lastEffect = workInProgress2.lastEffect;
                  renderState.renderingStartTime = now();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                return null;
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case Block:
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                if (current2 !== null) {
                  var _nextState = workInProgress2.memoizedState;
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  var nextIsHidden = _nextState !== null;
                  if (prevIsHidden !== nextIsHidden && newProps.mode !== "unstable-defer-without-hiding") {
                    workInProgress2.flags |= Update;
                  }
                }
                return null;
              }
            }
            {
              {
                throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function unwindWork(workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if (!((_flags & DidCapture) === NoFlags)) {
                  {
                    throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                  }
                }
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                popProvider(workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(interruptedWork) {
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                popProvider(interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          function createCapturedValue(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error2 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error2 != null && error2._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error2);
                }
                var componentName = source ? getComponentName(source.type) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                var errorBoundaryName = getComponentName(boundary.type);
                if (errorBoundaryName) {
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                } else {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error2);
              }
            } catch (e) {
              setTimeout(function() {
                throw e;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error2);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                logCapturedError(fiber, errorInfo);
                return getDerivedStateFromError(error$1);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                  logCapturedError(fiber, errorInfo);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown");
                    }
                  }
                }
              };
            } else {
              update.callback = function() {
                markFailedErrorBoundaryForHotReloading(fiber);
              };
            }
            return update;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              wakeable.then(ping, ping);
            }
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            sourceFiber.firstEffect = sourceFiber.lastEffect = null;
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              if ((sourceFiber.mode & BlockingMode) === NoMode) {
                var currentSource = sourceFiber.alternate;
                if (currentSource) {
                  sourceFiber.updateQueue = currentSource.updateQueue;
                  sourceFiber.memoizedState = currentSource.memoizedState;
                  sourceFiber.lanes = currentSource.lanes;
                } else {
                  sourceFiber.updateQueue = null;
                  sourceFiber.memoizedState = null;
                }
              }
              var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);
              var _workInProgress = returnFiber;
              do {
                if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                  var wakeables = _workInProgress.updateQueue;
                  if (wakeables === null) {
                    var updateQueue = new Set();
                    updateQueue.add(wakeable);
                    _workInProgress.updateQueue = updateQueue;
                  } else {
                    wakeables.add(wakeable);
                  }
                  if ((_workInProgress.mode & BlockingMode) === NoMode) {
                    _workInProgress.flags |= DidCapture;
                    sourceFiber.flags |= ForceUpdateForLegacySuspense;
                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                    if (sourceFiber.tag === ClassComponent) {
                      var currentSourceFiber = sourceFiber.alternate;
                      if (currentSourceFiber === null) {
                        sourceFiber.tag = IncompleteClassComponent;
                      } else {
                        var update = createUpdate(NoTimestamp, SyncLane);
                        update.tag = ForceUpdate;
                        enqueueUpdate(sourceFiber, update);
                      }
                    }
                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                    return;
                  }
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  _workInProgress.flags |= ShouldCapture;
                  _workInProgress.lanes = rootRenderLanes;
                  return;
                }
                _workInProgress = _workInProgress.return;
              } while (_workInProgress !== null);
              value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            renderDidError();
            value = createCapturedValue(value, sourceFiber);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var _update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update2 = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update2);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
          }
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            {
              instance.componentWillUnmount();
            }
          };
          function safelyCallComponentWillUnmount(current2, instance) {
            {
              invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current2, instance);
              if (hasCaughtError()) {
                var unmountError = clearCaughtError();
                captureCommitPhaseError(current2, unmountError);
              }
            }
          }
          function safelyDetachRef(current2) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                {
                  invokeGuardedCallback(null, ref, null, null);
                  if (hasCaughtError()) {
                    var refError = clearCaughtError();
                    captureCommitPhaseError(current2, refError);
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, destroy) {
            {
              invokeGuardedCallback(null, destroy, null);
              if (hasCaughtError()) {
                var error2 = clearCaughtError();
                captureCommitPhaseError(current2, error2);
              }
            }
          }
          function commitBeforeMutationLifeCycles(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent:
              case Block: {
                return;
              }
              case ClassComponent: {
                if (finishedWork.flags & Snapshot) {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                }
                return;
              }
              case HostRoot: {
                {
                  if (finishedWork.flags & Snapshot) {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                }
                return;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitHookEffectListUnmount(tag, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    destroy();
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(tag, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & tag) === tag) {
                  var create = effect.create;
                  effect.destroy = create();
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function schedulePassiveEffects(finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                var _effect = effect, next = _effect.next, tag = _effect.tag;
                if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
                  enqueuePendingPassiveHookEffectMount(finishedWork, effect);
                }
                effect = next;
              } while (effect !== firstEffect);
            }
          }
          function commitLifeCycles(finishedRoot, current2, finishedWork, committedLanes) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent:
              case Block: {
                {
                  commitHookEffectListMount(Layout | HasEffect, finishedWork);
                }
                schedulePassiveEffects(finishedWork);
                return;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (current2 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    {
                      instance.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                        }
                      }
                    }
                    {
                      instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                return;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                return;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type, props);
                }
                return;
              }
              case HostText: {
                return;
              }
              case HostPortal: {
                return;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  if (typeof onRender === "function") {
                    {
                      onRender(finishedWork.memoizedProps.id, current2 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2, finishedRoot.memoizedInteractions);
                    }
                  }
                }
                return;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                return;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case FundamentalComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
                return;
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  var instance = node.stateNode;
                  if (isHidden) {
                    hideInstance(instance);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } else if (node.tag === HostText) {
                  var _instance3 = node.stateNode;
                  if (isHidden) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                ref(instanceToUse);
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function commitDetachRef(current2) {
            var currentRef = current2.ref;
            if (currentRef !== null) {
              if (typeof currentRef === "function") {
                currentRef(null);
              } else {
                currentRef.current = null;
              }
            }
          }
          function commitUnmount(finishedRoot, current2, renderPriorityLevel) {
            onCommitUnmount(current2);
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block: {
                var updateQueue = current2.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                      if (destroy !== void 0) {
                        if ((tag & Passive$1) !== NoFlags$1) {
                          enqueuePendingPassiveHookEffectUnmount(current2, effect);
                        } else {
                          {
                            safelyCallDestroy(current2, destroy);
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
                return;
              }
              case ClassComponent: {
                safelyDetachRef(current2);
                var instance = current2.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(current2, instance);
                }
                return;
              }
              case HostComponent: {
                safelyDetachRef(current2);
                return;
              }
              case HostPortal: {
                {
                  unmountHostComponents(finishedRoot, current2);
                }
                return;
              }
              case FundamentalComponent: {
                return;
              }
              case DehydratedFragment: {
                return;
              }
              case ScopeComponent: {
                return;
              }
            }
          }
          function commitNestedUnmounts(finishedRoot, root2, renderPriorityLevel) {
            var node = root2;
            while (true) {
              commitUnmount(finishedRoot, node);
              if (node.child !== null && node.tag !== HostPortal) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === root2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === root2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function detachFiberMutation(fiber) {
            fiber.alternate = null;
            fiber.child = null;
            fiber.dependencies = null;
            fiber.firstEffect = null;
            fiber.lastEffect = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.return = null;
            fiber.updateQueue = null;
            {
              fiber._debugOwner = null;
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            {
              {
                throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            var parent;
            var isContainer;
            var parentStateNode = parentFiber.stateNode;
            switch (parentFiber.tag) {
              case HostComponent:
                parent = parentStateNode;
                isContainer = false;
                break;
              case HostRoot:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case HostPortal:
                parent = parentStateNode.containerInfo;
                isContainer = true;
                break;
              case FundamentalComponent:
              default: {
                {
                  throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            if (isContainer) {
              insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
            } else {
              insertOrAppendPlacementNode(finishedWork, before, parent);
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost || enableFundamentalAPI) {
              var stateNode = isHost ? node.stateNode : node.stateNode.instance;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function unmountHostComponents(finishedRoot, current2, renderPriorityLevel) {
            var node = current2;
            var currentParentIsValid = false;
            var currentParent;
            var currentParentIsContainer;
            while (true) {
              if (!currentParentIsValid) {
                var parent = node.return;
                findParent:
                  while (true) {
                    if (!(parent !== null)) {
                      {
                        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                      }
                    }
                    var parentStateNode = parent.stateNode;
                    switch (parent.tag) {
                      case HostComponent:
                        currentParent = parentStateNode;
                        currentParentIsContainer = false;
                        break findParent;
                      case HostRoot:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                      case HostPortal:
                        currentParent = parentStateNode.containerInfo;
                        currentParentIsContainer = true;
                        break findParent;
                    }
                    parent = parent.return;
                  }
                currentParentIsValid = true;
              }
              if (node.tag === HostComponent || node.tag === HostText) {
                commitNestedUnmounts(finishedRoot, node);
                if (currentParentIsContainer) {
                  removeChildFromContainer(currentParent, node.stateNode);
                } else {
                  removeChild(currentParent, node.stateNode);
                }
              } else if (node.tag === HostPortal) {
                if (node.child !== null) {
                  currentParent = node.stateNode.containerInfo;
                  currentParentIsContainer = true;
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              } else {
                commitUnmount(finishedRoot, node);
                if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              }
              if (node === current2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === current2) {
                  return;
                }
                node = node.return;
                if (node.tag === HostPortal) {
                  currentParentIsValid = false;
                }
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function commitDeletion(finishedRoot, current2, renderPriorityLevel) {
            {
              unmountHostComponents(finishedRoot, current2);
            }
            var alternate = current2.alternate;
            detachFiberMutation(current2);
            if (alternate !== null) {
              detachFiberMutation(alternate);
            }
          }
          function commitWork(current2, finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent:
              case Block: {
                {
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
                }
                return;
              }
              case ClassComponent: {
                return;
              }
              case HostComponent: {
                var instance = finishedWork.stateNode;
                if (instance != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    commitUpdate(instance, updatePayload, type, oldProps, newProps);
                  }
                }
                return;
              }
              case HostText: {
                if (!(finishedWork.stateNode !== null)) {
                  {
                    throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                commitTextUpdate(textInstance, oldText, newText);
                return;
              }
              case HostRoot: {
                {
                  var _root = finishedWork.stateNode;
                  if (_root.hydrate) {
                    _root.hydrate = false;
                    commitHydratedContainer(_root.containerInfo);
                  }
                }
                return;
              }
              case Profiler: {
                return;
              }
              case SuspenseComponent: {
                commitSuspenseComponent(finishedWork);
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case SuspenseListComponent: {
                attachSuspenseRetryListeners(finishedWork);
                return;
              }
              case IncompleteClassComponent: {
                return;
              }
              case FundamentalComponent: {
                break;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                var newState = finishedWork.memoizedState;
                var isHidden = newState !== null;
                hideOrUnhideAllChildren(finishedWork, isHidden);
                return;
              }
            }
            {
              {
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function commitSuspenseComponent(finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState !== null) {
              markCommitTimeOfFallback();
              {
                var primaryChildParent = finishedWork.child;
                hideOrUnhideAllChildren(primaryChildParent, true);
              }
            }
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  {
                    if (wakeable.__reactDoNotTraceInteractions !== true) {
                      retry = tracing.unstable_wrap(retry);
                    }
                  }
                  retryCache.add(wakeable);
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function isSuspenseBoundaryBeingHidden(current2, finishedWork) {
            if (current2 !== null) {
              var oldState = current2.memoizedState;
              if (oldState === null || oldState.dehydrated !== null) {
                var newState = finishedWork.memoizedState;
                return newState !== null && newState.dehydrated === null;
              }
            }
            return false;
          }
          function commitResetTextContent(current2) {
            resetTextContent(current2.stateNode);
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor$1 = Symbol.for;
            COMPONENT_TYPE = symbolFor$1("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor$1("selector.role");
            TEST_NAME_TYPE = symbolFor$1("selector.test_id");
            TEXT_TYPE = symbolFor$1("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
          var NoContext = 0;
          var BatchedContext = 1;
          var EventContext = 2;
          var DiscreteEventContext = 4;
          var LegacyUnbatchedContext = 8;
          var RenderContext = 16;
          var CommitContext = 32;
          var RetryAfterError = 64;
          var RootIncomplete = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootIncomplete;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var mostRecentlyUpdatedRoot = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var nextEffect = null;
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsRenderPriority = NoPriority$1;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveHookEffectsMount = [];
          var pendingPassiveHookEffectsUnmount = [];
          var rootsWithPendingDiscreteUpdates = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var spawnedWorkDuringRender = null;
          var currentEventTime = NoTimestamp;
          var currentEventWipLanes = NoLanes;
          var currentEventPendingLanes = NoLanes;
          var isFlushingPassiveEffects = false;
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return SyncLane;
            } else if ((mode & ConcurrentMode) === NoMode) {
              return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
            }
            if (currentEventWipLanes === NoLanes) {
              currentEventWipLanes = workInProgressRootIncludedLanes;
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (currentEventPendingLanes !== NoLanes) {
                currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
              }
              return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
            }
            var schedulerPriority = getCurrentPriorityLevel();
            var lane;
            if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
              lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
            } else {
              var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
              lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
            }
            return lane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & BlockingMode) === NoMode) {
              return SyncLane;
            } else if ((mode & ConcurrentMode) === NoMode) {
              return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
            }
            if (currentEventWipLanes === NoLanes) {
              currentEventWipLanes = workInProgressRootIncludedLanes;
            }
            return findRetryLane(currentEventWipLanes);
          }
          function scheduleUpdateOnFiber(fiber, lane, eventTime) {
            checkForNestedUpdates();
            warnAboutRenderPhaseUpdatesInDEV(fiber);
            var root2 = markUpdateLaneFromFiberToRoot(fiber, lane);
            if (root2 === null) {
              warnAboutUpdateOnUnmountedFiberInDEV(fiber);
              return null;
            }
            markRootUpdated(root2, lane, eventTime);
            if (root2 === workInProgressRoot) {
              {
                workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            var priorityLevel = getCurrentPriorityLevel();
            if (lane === SyncLane) {
              if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
                schedulePendingInteractions(root2, lane);
                performSyncWorkOnRoot(root2);
              } else {
                ensureRootIsScheduled(root2, eventTime);
                schedulePendingInteractions(root2, lane);
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            } else {
              if ((executionContext & DiscreteEventContext) !== NoContext && (priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
                if (rootsWithPendingDiscreteUpdates === null) {
                  rootsWithPendingDiscreteUpdates = new Set([root2]);
                } else {
                  rootsWithPendingDiscreteUpdates.add(root2);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, lane);
            }
            mostRecentlyUpdatedRoot = root2;
          }
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root2 = node.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          function ensureRootIsScheduled(root2, currentTime) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            var newCallbackPriority = returnNextLanesPriority();
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback(existingCallbackNode);
                root2.callbackNode = null;
                root2.callbackPriority = NoLanePriority;
              }
              return;
            }
            if (existingCallbackNode !== null) {
              var existingCallbackPriority = root2.callbackPriority;
              if (existingCallbackPriority === newCallbackPriority) {
                return;
              }
              cancelCallback(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLanePriority) {
              newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else if (newCallbackPriority === SyncBatchedLanePriority) {
              newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root2));
            } else {
              var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
              newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2) {
            currentEventTime = NoTimestamp;
            currentEventWipLanes = NoLanes;
            currentEventPendingLanes = NoLanes;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var exitStatus = renderRootConcurrent(root2, lanes);
            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
              prepareFreshStack(root2, NoLanes);
            } else if (exitStatus !== RootIncomplete) {
              if (exitStatus === RootErrored) {
                executionContext |= RetryAfterError;
                if (root2.hydrate) {
                  root2.hydrate = false;
                  clearContainer(root2.containerInfo);
                }
                lanes = getLanesToRetrySynchronouslyOnError(root2);
                if (lanes !== NoLanes) {
                  exitStatus = renderRootSync(root2, lanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now());
                throw fatalError;
              }
              var finishedWork = root2.current.alternate;
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
            ensureRootIsScheduled(root2, now());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootIncomplete:
              case RootFatalErrored: {
                {
                  {
                    throw Error("Root did not complete. This is a bug in React.");
                  }
                }
              }
              case RootErrored: {
                commitRoot(root2);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2);
                break;
              }
              case RootCompleted: {
                commitRoot(root2);
                break;
              }
              default: {
                {
                  {
                    throw Error("Unknown root exit status.");
                  }
                }
              }
            }
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            flushPassiveEffects();
            var lanes;
            var exitStatus;
            if (root2 === workInProgressRoot && includesSomeLane(root2.expiredLanes, workInProgressRootRenderLanes)) {
              lanes = workInProgressRootRenderLanes;
              exitStatus = renderRootSync(root2, lanes);
              if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
                lanes = getNextLanes(root2, lanes);
                exitStatus = renderRootSync(root2, lanes);
              }
            } else {
              lanes = getNextLanes(root2, NoLanes);
              exitStatus = renderRootSync(root2, lanes);
            }
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              executionContext |= RetryAfterError;
              if (root2.hydrate) {
                root2.hydrate = false;
                clearContainer(root2.containerInfo);
              }
              lanes = getLanesToRetrySynchronouslyOnError(root2);
              if (lanes !== NoLanes) {
                exitStatus = renderRootSync(root2, lanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2);
            ensureRootIsScheduled(root2, now());
            return null;
          }
          function flushDiscreteUpdates() {
            if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
              {
                if ((executionContext & RenderContext) !== NoContext) {
                  error("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
                }
              }
              return;
            }
            flushPendingDiscreteUpdates();
            flushPassiveEffects();
          }
          function flushPendingDiscreteUpdates() {
            if (rootsWithPendingDiscreteUpdates !== null) {
              var roots = rootsWithPendingDiscreteUpdates;
              rootsWithPendingDiscreteUpdates = null;
              roots.forEach(function(root2) {
                markDiscreteUpdatesExpired(root2);
                ensureRootIsScheduled(root2, now());
              });
            }
            flushSyncCallbackQueue();
          }
          function batchedUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function batchedEventUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= EventContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function discreteUpdates$1(fn, a, b, c, d) {
            var prevExecutionContext = executionContext;
            executionContext |= DiscreteEventContext;
            {
              try {
                return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
              } finally {
                executionContext = prevExecutionContext;
                if (executionContext === NoContext) {
                  resetRenderTimer();
                  flushSyncCallbackQueue();
                }
              }
            }
          }
          function unbatchedUpdates(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext &= ~BatchedContext;
            executionContext |= LegacyUnbatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
          function flushSync(fn, a) {
            var prevExecutionContext = executionContext;
            if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
              {
                error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
              return fn(a);
            }
            executionContext |= BatchedContext;
            {
              try {
                if (fn) {
                  return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
                } else {
                  return void 0;
                }
              } finally {
                executionContext = prevExecutionContext;
                flushSyncCallbackQueue();
              }
            }
          }
          function pushRenderLanes(fiber, lanes) {
            push2(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop2(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                unwindInterruptedWork(interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            workInProgress = createWorkInProgress(root2.current, null);
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootIncomplete;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            {
              spawnedWorkDuringRender = null;
            }
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function pushInteractions(root2) {
            {
              var prevInteractions = tracing.__interactionsRef.current;
              tracing.__interactionsRef.current = root2.memoizedInteractions;
              return prevInteractions;
            }
          }
          function popInteractions(prevInteractions) {
            {
              tracing.__interactionsRef.current = prevInteractions;
            }
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError() {
            if (workInProgressRootExitStatus !== RootCompleted) {
              workInProgressRootExitStatus = RootErrored;
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootIncomplete;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              prepareFreshStack(root2, lanes);
              startWorkOnPendingInteractions(root2, lanes);
            }
            var prevInteractions = pushInteractions(root2);
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            {
              popInteractions(prevInteractions);
            }
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              {
                {
                  throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
              startWorkOnPendingInteractions(root2, lanes);
            }
            var prevInteractions = pushInteractions(root2);
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            {
              popInteractions(prevInteractions);
            }
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              return RootIncomplete;
            } else {
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
                resetChildLanes(completedWork);
                if (returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
                  if (returnFiber.firstEffect === null) {
                    returnFiber.firstEffect = completedWork.firstEffect;
                  }
                  if (completedWork.lastEffect !== null) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
                    }
                    returnFiber.lastEffect = completedWork.lastEffect;
                  }
                  var flags = completedWork.flags;
                  if (flags > PerformedWork) {
                    if (returnFiber.lastEffect !== null) {
                      returnFiber.lastEffect.nextEffect = completedWork;
                    } else {
                      returnFiber.firstEffect = completedWork;
                    }
                    returnFiber.lastEffect = completedWork;
                  }
                }
              } else {
                var _next = unwindWork(completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.firstEffect = returnFiber.lastEffect = null;
                  returnFiber.flags |= Incomplete;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootIncomplete) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function resetChildLanes(completedWork) {
            if ((completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
              return;
            }
            var newChildLanes = NoLanes;
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                if (shouldBubbleActualDurations) {
                  actualDuration += child.actualDuration;
                }
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
              if (isTimedOutSuspense) {
                var primaryChildFragment = completedWork.child;
                if (primaryChildFragment !== null) {
                  treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                }
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                _child = _child.sibling;
              }
            }
            completedWork.childLanes = newChildLanes;
          }
          function commitRoot(root2) {
            var renderPriorityLevel = getCurrentPriorityLevel();
            runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root2, renderPriorityLevel));
            return null;
          }
          function commitRootImpl(root2, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Should not already be working.");
              }
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            if (finishedWork === null) {
              return null;
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (!(finishedWork !== root2.current)) {
              {
                throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            root2.callbackNode = null;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (rootsWithPendingDiscreteUpdates !== null) {
              if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root2)) {
                rootsWithPendingDiscreteUpdates.delete(root2);
              }
            }
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            var firstEffect;
            if (finishedWork.flags > PerformedWork) {
              if (finishedWork.lastEffect !== null) {
                finishedWork.lastEffect.nextEffect = finishedWork;
                firstEffect = finishedWork.firstEffect;
              } else {
                firstEffect = finishedWork;
              }
            } else {
              firstEffect = finishedWork.firstEffect;
            }
            if (firstEffect !== null) {
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              var prevInteractions = pushInteractions(root2);
              ReactCurrentOwner$2.current = null;
              focusedInstanceHandle = prepareForCommit(root2.containerInfo);
              shouldFireAfterActiveInstanceBlur = false;
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, error2);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              focusedInstanceHandle = null;
              {
                recordCommitTime();
              }
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitMutationEffects, null, root2, renderPriorityLevel);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              nextEffect = firstEffect;
              do {
                {
                  invokeGuardedCallback(null, commitLayoutEffects, null, root2, lanes);
                  if (hasCaughtError()) {
                    if (!(nextEffect !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var _error2 = clearCaughtError();
                    captureCommitPhaseError(nextEffect, _error2);
                    nextEffect = nextEffect.nextEffect;
                  }
                }
              } while (nextEffect !== null);
              nextEffect = null;
              requestPaint();
              {
                popInteractions(prevInteractions);
              }
              executionContext = prevExecutionContext;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
              pendingPassiveEffectsRenderPriority = renderPriorityLevel;
            } else {
              nextEffect = firstEffect;
              while (nextEffect !== null) {
                var nextNextEffect = nextEffect.nextEffect;
                nextEffect.nextEffect = null;
                if (nextEffect.flags & Deletion) {
                  detachFiberAfterEffects(nextEffect);
                }
                nextEffect = nextNextEffect;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes !== NoLanes) {
              {
                if (spawnedWorkDuringRender !== null) {
                  var expirationTimes = spawnedWorkDuringRender;
                  spawnedWorkDuringRender = null;
                  for (var i = 0; i < expirationTimes.length; i++) {
                    scheduleInteractions(root2, expirationTimes[i], root2.memoizedInteractions);
                  }
                }
                schedulePendingInteractions(root2, remainingLanes);
              }
            } else {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                finishPendingInteractions(root2, lanes);
              }
            }
            if (remainingLanes === SyncLane) {
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now());
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var _error3 = firstUncaughtError;
              firstUncaughtError = null;
              throw _error3;
            }
            if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
              return null;
            }
            flushSyncCallbackQueue();
            return null;
          }
          function commitBeforeMutationEffects() {
            while (nextEffect !== null) {
              var current2 = nextEffect.alternate;
              if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
                if ((nextEffect.flags & Deletion) !== NoFlags) {
                  if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
                    shouldFireAfterActiveInstanceBlur = true;
                  }
                } else {
                  if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current2, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
                    shouldFireAfterActiveInstanceBlur = true;
                  }
                }
              }
              var flags = nextEffect.flags;
              if ((flags & Snapshot) !== NoFlags) {
                setCurrentFiber(nextEffect);
                commitBeforeMutationLifeCycles(current2, nextEffect);
                resetCurrentFiber();
              }
              if ((flags & Passive) !== NoFlags) {
                if (!rootDoesHavePassiveEffects) {
                  rootDoesHavePassiveEffects = true;
                  scheduleCallback(NormalPriority$1, function() {
                    flushPassiveEffects();
                    return null;
                  });
                }
              }
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitMutationEffects(root2, renderPriorityLevel) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var flags = nextEffect.flags;
              if (flags & ContentReset) {
                commitResetTextContent(nextEffect);
              }
              if (flags & Ref) {
                var current2 = nextEffect.alternate;
                if (current2 !== null) {
                  commitDetachRef(current2);
                }
              }
              var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
              switch (primaryFlags) {
                case Placement: {
                  commitPlacement(nextEffect);
                  nextEffect.flags &= ~Placement;
                  break;
                }
                case PlacementAndUpdate: {
                  commitPlacement(nextEffect);
                  nextEffect.flags &= ~Placement;
                  var _current = nextEffect.alternate;
                  commitWork(_current, nextEffect);
                  break;
                }
                case Hydrating: {
                  nextEffect.flags &= ~Hydrating;
                  break;
                }
                case HydratingAndUpdate: {
                  nextEffect.flags &= ~Hydrating;
                  var _current2 = nextEffect.alternate;
                  commitWork(_current2, nextEffect);
                  break;
                }
                case Update: {
                  var _current3 = nextEffect.alternate;
                  commitWork(_current3, nextEffect);
                  break;
                }
                case Deletion: {
                  commitDeletion(root2, nextEffect);
                  break;
                }
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function commitLayoutEffects(root2, committedLanes) {
            while (nextEffect !== null) {
              setCurrentFiber(nextEffect);
              var flags = nextEffect.flags;
              if (flags & (Update | Callback)) {
                var current2 = nextEffect.alternate;
                commitLifeCycles(root2, current2, nextEffect);
              }
              {
                if (flags & Ref) {
                  commitAttachRef(nextEffect);
                }
              }
              resetCurrentFiber();
              nextEffect = nextEffect.nextEffect;
            }
          }
          function flushPassiveEffects() {
            if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
              var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
              pendingPassiveEffectsRenderPriority = NoPriority$1;
              {
                return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
              }
            }
            return false;
          }
          function enqueuePendingPassiveHookEffectMount(fiber, effect) {
            pendingPassiveHookEffectsMount.push(effect, fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
            pendingPassiveHookEffectsUnmount.push(effect, fiber);
            {
              fiber.flags |= PassiveUnmountPendingDev;
              var alternate = fiber.alternate;
              if (alternate !== null) {
                alternate.flags |= PassiveUnmountPendingDev;
              }
            }
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback(NormalPriority$1, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          function invokePassiveEffectCreate(effect) {
            var create = effect.create;
            effect.destroy = create();
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
              {
                throw Error("Cannot flush passive effects while already rendering.");
              }
            }
            {
              isFlushingPassiveEffects = true;
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root2);
            var unmountEffects = pendingPassiveHookEffectsUnmount;
            pendingPassiveHookEffectsUnmount = [];
            for (var i = 0; i < unmountEffects.length; i += 2) {
              var _effect = unmountEffects[i];
              var fiber = unmountEffects[i + 1];
              var destroy = _effect.destroy;
              _effect.destroy = void 0;
              {
                fiber.flags &= ~PassiveUnmountPendingDev;
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.flags &= ~PassiveUnmountPendingDev;
                }
              }
              if (typeof destroy === "function") {
                {
                  setCurrentFiber(fiber);
                  {
                    invokeGuardedCallback(null, destroy, null);
                  }
                  if (hasCaughtError()) {
                    if (!(fiber !== null)) {
                      {
                        throw Error("Should be working on an effect.");
                      }
                    }
                    var error2 = clearCaughtError();
                    captureCommitPhaseError(fiber, error2);
                  }
                  resetCurrentFiber();
                }
              }
            }
            var mountEffects = pendingPassiveHookEffectsMount;
            pendingPassiveHookEffectsMount = [];
            for (var _i2 = 0; _i2 < mountEffects.length; _i2 += 2) {
              var _effect2 = mountEffects[_i2];
              var _fiber = mountEffects[_i2 + 1];
              {
                setCurrentFiber(_fiber);
                {
                  invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
                }
                if (hasCaughtError()) {
                  if (!(_fiber !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var _error4 = clearCaughtError();
                  captureCommitPhaseError(_fiber, _error4);
                }
                resetCurrentFiber();
              }
            }
            var effect = root2.current.firstEffect;
            while (effect !== null) {
              var nextNextEffect = effect.nextEffect;
              effect.nextEffect = null;
              if (effect.flags & Deletion) {
                detachFiberAfterEffects(effect);
              }
              effect = nextNextEffect;
            }
            {
              popInteractions(prevInteractions);
              finishPendingInteractions(root2, lanes);
            }
            {
              isFlushingPassiveEffects = false;
            }
            executionContext = prevExecutionContext;
            flushSyncCallbackQueue();
            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValue(error2, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            enqueueUpdate(rootFiber, update);
            var eventTime = requestEventTime();
            var root2 = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, SyncLane);
            }
          }
          function captureCommitPhaseError(sourceFiber, error2) {
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
              return;
            }
            var fiber = sourceFiber.return;
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error2);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValue(error2, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  enqueueUpdate(fiber, update);
                  var eventTime = requestEventTime();
                  var root2 = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                    schedulePendingInteractions(root2, SyncLane);
                  } else {
                    if (typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                      try {
                        instance.componentDidCatch(error2, errorInfo);
                      } catch (errorToIgnore) {
                      }
                    }
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, pingedLanes);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, retryLane);
            }
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            {
              retryCache = boundaryFiber.stateNode;
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              {
                {
                  throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
                }
              }
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var didWarnStateUpdateForUnmountedComponent = null;
          function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
            {
              var tag = fiber.tag;
              if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
                return;
              }
              if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
                return;
              }
              var componentName = getComponentName(fiber.type) || "ReactComponent";
              if (didWarnStateUpdateForUnmountedComponent !== null) {
                if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForUnmountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
              }
              if (isFlushingPassiveEffects)
                ;
              else {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? "the componentWillUnmount method" : "a useEffect cleanup function");
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  throw replayError;
                } else {
                  throw originalError;
                }
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentName(fiber.type) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          var IsThisRendererActing = {
            current: false
          };
          function warnIfNotScopedWithMatchingAct(fiber) {
            {
              if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
            {
              if ((fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                error("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
              }
            }
          }
          function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
            {
              if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;
          var didWarnAboutUnmockedScheduler = false;
          function warnIfUnmockedScheduler(fiber) {
            {
              if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === void 0) {
                if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                  didWarnAboutUnmockedScheduler = true;
                  error(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest:
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://reactjs.org/link/mock-scheduler`);
                }
              }
            }
          }
          function computeThreadID(root2, lane) {
            return lane * 1e3 + root2.interactionThreadID;
          }
          function markSpawnedWork(lane) {
            if (spawnedWorkDuringRender === null) {
              spawnedWorkDuringRender = [lane];
            } else {
              spawnedWorkDuringRender.push(lane);
            }
          }
          function scheduleInteractions(root2, lane, interactions) {
            if (interactions.size > 0) {
              var pendingInteractionMap = root2.pendingInteractionMap;
              var pendingInteractions = pendingInteractionMap.get(lane);
              if (pendingInteractions != null) {
                interactions.forEach(function(interaction) {
                  if (!pendingInteractions.has(interaction)) {
                    interaction.__count++;
                  }
                  pendingInteractions.add(interaction);
                });
              } else {
                pendingInteractionMap.set(lane, new Set(interactions));
                interactions.forEach(function(interaction) {
                  interaction.__count++;
                });
              }
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root2, lane);
                subscriber.onWorkScheduled(interactions, threadID);
              }
            }
          }
          function schedulePendingInteractions(root2, lane) {
            scheduleInteractions(root2, lane, tracing.__interactionsRef.current);
          }
          function startWorkOnPendingInteractions(root2, lanes) {
            var interactions = new Set();
            root2.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
              if (includesSomeLane(lanes, scheduledLane)) {
                scheduledInteractions.forEach(function(interaction) {
                  return interactions.add(interaction);
                });
              }
            });
            root2.memoizedInteractions = interactions;
            if (interactions.size > 0) {
              var subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null) {
                var threadID = computeThreadID(root2, lanes);
                try {
                  subscriber.onWorkStarted(interactions, threadID);
                } catch (error2) {
                  scheduleCallback(ImmediatePriority$1, function() {
                    throw error2;
                  });
                }
              }
            }
          }
          function finishPendingInteractions(root2, committedLanes) {
            var remainingLanesAfterCommit = root2.pendingLanes;
            var subscriber;
            try {
              subscriber = tracing.__subscriberRef.current;
              if (subscriber !== null && root2.memoizedInteractions.size > 0) {
                var threadID = computeThreadID(root2, committedLanes);
                subscriber.onWorkStopped(root2.memoizedInteractions, threadID);
              }
            } catch (error2) {
              scheduleCallback(ImmediatePriority$1, function() {
                throw error2;
              });
            } finally {
              var pendingInteractionMap = root2.pendingInteractionMap;
              pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
                if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
                  pendingInteractionMap.delete(lane);
                  scheduledInteractions.forEach(function(interaction) {
                    interaction.__count--;
                    if (subscriber !== null && interaction.__count === 0) {
                      try {
                        subscriber.onInteractionScheduledWorkCompleted(interaction);
                      } catch (error2) {
                        scheduleCallback(ImmediatePriority$1, function() {
                          throw error2;
                        });
                      }
                    }
                  });
                }
              });
            }
          }
          function shouldForceFlushFallbacksInDEV() {
            return actingUpdatesScopeDepth > 0;
          }
          var actingUpdatesScopeDepth = 0;
          function detachFiberAfterEffects(fiber) {
            fiber.sibling = null;
            fiber.stateNode = null;
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = new Set();
              var types2 = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types2.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              new Map([[nonExtensibleObject, null]]);
              new Set([nonExtensibleObject]);
            } catch (e) {
              hasBadMapPolyfill = true;
            }
          }
          var debugCounter = 1;
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.nextEffect = null;
            this.firstEffect = null;
            this.lastEffect = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugID = debugCounter++;
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component2) {
            if (typeof Component2 === "function") {
              return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
            } else if (Component2 !== void 0 && Component2 !== null) {
              var $$typeof = Component2.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugID = current2._debugID;
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.nextEffect = null;
              workInProgress2.firstEffect = null;
              workInProgress2.lastEffect = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= Placement;
            workInProgress2.nextEffect = null;
            workInProgress2.firstEffect = null;
            workInProgress2.lastEffect = null;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode | BlockingMode | StrictMode;
            } else if (tag === BlockingRoot) {
              mode = BlockingMode | StrictMode;
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= DebugTracingMode;
                    break;
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictMode;
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                    return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
                  case REACT_SCOPE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                        case REACT_BLOCK_TYPE:
                          fiberTag = Block;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentName(owner.type) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    {
                      {
                        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
                      }
                    }
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error('Profiler must specify an "id" as a prop');
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.type = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.type = REACT_SUSPENSE_TYPE;
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_SUSPENSE_LIST_TYPE;
            }
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_OFFSCREEN_TYPE;
            }
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
            var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode);
            {
              fiber.type = REACT_LEGACY_HIDDEN_TYPE;
            }
            fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromText(content2, mode, lanes) {
            var fiber = createFiber(HostText, content2, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            fiber.type = "DELETED";
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.nextEffect = source.nextEffect;
            target.firstEffect = source.firstEffect;
            target.lastEffect = source.lastEffect;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugID = source._debugID;
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.hydrate = hydrate2;
            this.callbackNode = null;
            this.callbackPriority = NoLanePriority;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.interactionThreadID = tracing.unstable_getThreadID();
              this.memoizedInteractions = new Set();
              this.pendingInteractionMap = new Map();
            }
            {
              switch (tag) {
                case BlockingRoot:
                  this._debugRootType = "createBlockingRoot()";
                  break;
                case ConcurrentRoot:
                  this._debugRootType = "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = "createLegacyRoot()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, hydrationCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate2);
            var uninitializedFiber = createHostRootFiber(tag);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version = getVersion(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
          }
          function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get4(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component2 = fiber.type;
              if (isContextProvider(Component2)) {
                return processChildContext(fiber, Component2, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get4(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  {
                    {
                      throw Error("Unable to find node on an unmounted component.");
                    }
                  }
                } else {
                  {
                    {
                      throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
                    }
                  }
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictMode) {
                var componentName = getComponentName(fiber.type) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictMode) {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrate2, hydrationCallbacks) {
            return createFiberRoot(containerInfo, tag, hydrate2);
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            {
              if (typeof jest !== "undefined") {
                warnIfUnmockedScheduler(current$1);
                warnIfNotScopedWithMatchingAct(current$1);
              }
            }
            var lane = requestUpdateLane(current$1);
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context;
            } else {
              container.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current.type) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            enqueueUpdate(current$1, update);
            scheduleUpdateOnFiber(current$1, lane, eventTime);
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptUserBlockingHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = InputDiscreteHydrationLane;
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = SelectiveHydrationLane;
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function runWithPriority$2(priority, fn) {
            try {
              setCurrentUpdateLanePriority(priority);
              return fn();
            } finally {
            }
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.tag === FundamentalComponent) {
              return hostFiber.stateNode.instance;
            }
            return hostFiber.stateNode;
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index2) {
              var key = path[index2];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              if (index2 + 1 === path.length) {
                if (Array.isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
              var oldKey = oldPath[index2];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              if (index2 + 1 === oldPath.length) {
                var newKey = newPath[index2];
                updated[newKey] = updated[oldKey];
                if (Array.isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index2 + 1);
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index2, value) {
              if (index2 >= path.length) {
                return value;
              }
              var key = path[index2];
              var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id, path, value) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideHookStateDeletePath = function(fiber, id, path) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = _assign({}, fiber.memoizedProps);
                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            scheduleUpdate = function(fiber) {
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: getCurrentFiberForDevTools
            });
          }
          function ReactDOMRoot(container, options2) {
            this._internalRoot = createRootImpl(container, ConcurrentRoot, options2);
          }
          function ReactDOMBlockingRoot(container, tag, options2) {
            this._internalRoot = createRootImpl(container, tag, options2);
          }
          ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
              var container = root2.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root2.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root2, null, null);
          };
          ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root2 = this._internalRoot;
            var container = root2.containerInfo;
            updateContainer(null, root2, null, function() {
              unmarkContainerAsRoot(container);
            });
          };
          function createRootImpl(container, tag, options2) {
            var hydrate2 = options2 != null && options2.hydrate === true;
            var hydrationCallbacks = options2 != null && options2.hydrationOptions || null;
            var mutableSources = options2 != null && options2.hydrationOptions != null && options2.hydrationOptions.mutableSources || null;
            var root2 = createContainer(container, tag, hydrate2);
            markContainerAsRoot(root2.current, container);
            var containerNodeType = container.nodeType;
            {
              var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(rootContainerElement);
            }
            if (mutableSources) {
              for (var i = 0; i < mutableSources.length; i++) {
                var mutableSource = mutableSources[i];
                registerMutableSourceForHydration(root2, mutableSource);
              }
            }
            return root2;
          }
          function createLegacyRoot(container, options2) {
            return new ReactDOMBlockingRoot(container, LegacyRoot, options2);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          var warnedAboutHydrateAPI = false;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function shouldHydrateDueToLegacyHeuristic(container) {
            var rootElement = getReactRootElementInContainer(container);
            return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
          }
          function legacyCreateRootFromDOMContainer(container, forceHydrate) {
            var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
            if (!shouldHydrate) {
              var warned = false;
              var rootSibling;
              while (rootSibling = container.lastChild) {
                {
                  if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                    warned = true;
                    error("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
                  }
                }
                container.removeChild(rootSibling);
              }
            }
            {
              if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
                warnedAboutHydrateAPI = true;
                warn("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.");
              }
            }
            return createLegacyRoot(container, shouldHydrate ? {
              hydrate: true
            } : void 0);
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var root2 = container._reactRootContainer;
            var fiberRoot;
            if (!root2) {
              root2 = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
              fiberRoot = root2._internalRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(fiberRoot);
                  originalCallback.call(instance);
                };
              }
              unbatchedUpdates(function() {
                updateContainer(children, fiberRoot, parentComponent, callback);
              });
            } else {
              fiberRoot = root2._internalRoot;
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(fiberRoot);
                  _originalCallback.call(instance);
                };
              }
              updateContainer(children, fiberRoot, parentComponent, callback);
            }
            return getPublicRootInstance(fiberRoot);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container, callback) {
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render(element, container, callback) {
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            if (!isValidContainer(containerNode)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            if (!(parentComponent != null && has3(parentComponent))) {
              {
                throw Error("parentComponent must be a valid React Component");
              }
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container) {
            if (!isValidContainer(container)) {
              {
                throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
              }
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              unbatchedUpdates(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setAttemptHydrationAtPriority(runWithPriority$2);
          var didWarnAboutUnstableCreatePortal = false;
          {
            if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
          function createPortal$1(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              {
                throw Error("Target container is not a DOM element.");
              }
            }
            return createPortal(children, container, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          function unstable_createPortal(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            {
              if (!didWarnAboutUnstableCreatePortal) {
                didWarnAboutUnstableCreatePortal = true;
                warn('The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.');
              }
            }
            return createPortal$1(children, container, key);
          }
          var Internals = {
            Events: [
              getInstanceFromNode,
              getNodeFromInstance,
              getFiberCurrentPropsFromNode,
              enqueueStateRestore,
              restoreStateIfNeeded,
              flushPassiveEffects,
              IsThisRendererActing
            ]
          };
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync;
          exports.hydrate = hydrate;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_createPortal = unstable_createPortal;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // ../../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../../node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // ../../node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "../../node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React6 = require_react();
          var _assign = require_object_assign();
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          exports.Fragment = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            exports.Fragment = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format) {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return "" + item;
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentName(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case exports.Fragment:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  return getComponentName(type.type);
                case REACT_BLOCK_TYPE:
                  return getComponentName(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentName(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: _assign({}, props, {
                    value: prevLog
                  }),
                  info: _assign({}, props, {
                    value: prevInfo
                  }),
                  warn: _assign({}, props, {
                    value: prevWarn
                  }),
                  error: _assign({}, props, {
                    value: prevError
                  }),
                  group: _assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: _assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: _assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_BLOCK_TYPE:
                  return describeFunctionComponentFrame(type._render);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values2, location, componentName, element) {
            {
              var has3 = Function.call.bind(Object.prototype.hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has3(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty2.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty2.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config, self2) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentName(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                key = "" + maybeKey;
              }
              if (hasValidKey(config)) {
                key = "" + config.key;
              }
              if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config, self2);
              }
              for (propName in config) {
                if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement(object2) {
            {
              return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name2 = getComponentName(ReactCurrentOwner$1.current.type);
                if (name2) {
                  return "\n\nCheck the render method of `" + name2 + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (Array.isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                  var child = node[i];
                  if (isValidElement(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name2 = getComponentName(type);
                checkPropTypes(propTypes, element.props, "prop", name2, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentName(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys2 = Object.keys(fragment.props);
              for (var i = 0; i < keys2.length; i++) {
                var key = keys2[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (Array.isArray(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (Array.isArray(children)) {
                      for (var i = 0; i < children.length; i++) {
                        validateChildKeys(children[i], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              if (type === exports.Fragment) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx = jsxWithValidationDynamic;
          var jsxs = jsxWithValidationStatic;
          exports.jsx = jsx;
          exports.jsxs = jsxs;
        })();
      }
    }
  });

  // ../../node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "../../node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // ../../node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "../../node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol2 = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol2 ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol2 ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol2 ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol2 ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol2 ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol2 ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol2 ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol2 ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol2 ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol2 ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol2 ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol2 ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol2 ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol2 ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol2 ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol2 ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol2 ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object2) {
            if (typeof object2 === "object" && object2 !== null) {
              var $$typeof = object2.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object2.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object2) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object2) {
            return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object2) {
            return typeOf(object2) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object2) {
            return typeOf(object2) === REACT_PROVIDER_TYPE;
          }
          function isElement(object2) {
            return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object2) {
            return typeOf(object2) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object2) {
            return typeOf(object2) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object2) {
            return typeOf(object2) === REACT_LAZY_TYPE;
          }
          function isMemo(object2) {
            return typeOf(object2) === REACT_MEMO_TYPE;
          }
          function isPortal(object2) {
            return typeOf(object2) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object2) {
            return typeOf(object2) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object2) {
            return typeOf(object2) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object2) {
            return typeOf(object2) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // ../../node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "../../node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // ../../node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "../../node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // ../../node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "../../node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has3 = Function.call.bind(Object.prototype.hasOwnProperty);
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has3;
      function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has3(typeSpecs, typeSpecName)) {
              var error;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // ../../node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "../../node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign2 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var checkPropTypes = require_checkPropTypes();
      var has3 = Function.call.bind(Object.prototype.hasOwnProperty);
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is3(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message) {
          this.message = message;
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker2(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                  printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType2(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType2(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker2(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType2(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
              var propType = getPropType2(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType2(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is3(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType2(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker2(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType2(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has3(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location, propFullName) {
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              if (checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                return null;
              }
            }
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
          }
          return createChainableTypeChecker2(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType2(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (!checker) {
                continue;
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType2(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign2({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (!checker) {
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker2(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol2(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType2(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol2(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType2(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType2(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType2(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // ../../node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "../../node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // ../../node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "../../node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        function classNames() {
          var classes = [];
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString === Object.prototype.toString) {
                for (var key in arg) {
                  if (hasOwn.call(arg, key) && arg[key]) {
                    classes.push(key);
                  }
                }
              } else {
                classes.push(arg.toString());
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames.default = classNames;
          module.exports = classNames;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames;
          });
        } else {
          window.classNames = classNames;
        }
      })();
    }
  });

  // ../../node_modules/lodash.debounce/index.js
  var require_lodash2 = __commonJS({
    "../../node_modules/lodash.debounce/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now = function() {
        return root.Date.now();
      };
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function isObject2(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = debounce;
    }
  });

  // ../../node_modules/lodash.isequal/index.js
  var require_lodash3 = __commonJS({
    "../../node_modules/lodash.isequal/index.js"(exports, module) {
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var asyncTag = "[object AsyncFunction]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var nullTag = "[object Null]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var proxyTag = "[object Proxy]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var undefinedTag = "[object Undefined]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayPush(array2, values2) {
        var index = -1, length = values2.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values2[index];
        }
        return array2;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function setToArray(set5) {
        var index = -1, result = Array(set5.size);
        set5.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var Symbol2 = root.Symbol;
      var Uint8Array2 = root.Uint8Array;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var splice2 = arrayProto.splice;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var nativeKeys = overArg(Object.keys, Object);
      var DataView = getNative(root, "DataView");
      var Map2 = getNative(root, "Map");
      var Promise2 = getNative(root, "Promise");
      var Set2 = getNative(root, "Set");
      var WeakMap2 = getNative(root, "WeakMap");
      var nativeCreate = getNative(Object, "create");
      var dataViewCtorString = toSource(DataView);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function Hash2(entries2) {
        var index = -1, length = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index < length) {
          var entry = entries2[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash2.prototype.clear = hashClear;
      Hash2.prototype["delete"] = hashDelete;
      Hash2.prototype.get = hashGet;
      Hash2.prototype.has = hashHas;
      Hash2.prototype.set = hashSet;
      function ListCache(entries2) {
        var index = -1, length = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index < length) {
          var entry = entries2[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries2) {
        var index = -1, length = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index < length) {
          var entry = entries2[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries2) {
        var data = this.__data__ = new ListCache(entries2);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq2(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction4(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty2.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array2);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq2(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var stacked = stack.get(object2);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys2, getSymbols);
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction4(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isFunction4(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function keys2(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      module.exports = isEqual;
    }
  });

  // ../../node_modules/create-react-class/factory.js
  var require_factory = __commonJS({
    "../../node_modules/create-react-class/factory.js"(exports, module) {
      "use strict";
      var _assign = require_object_assign();
      var emptyObject = {};
      if (true) {
        Object.freeze(emptyObject);
      }
      var validateFormat = function validateFormat2(format) {
      };
      if (true) {
        validateFormat = function validateFormat2(format) {
          if (format === void 0) {
            throw new Error("invariant requires an error message argument");
          }
        };
      }
      function _invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);
        if (!condition) {
          var error;
          if (format === void 0) {
            error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
              return args[argIndex++];
            }));
            error.name = "Invariant Violation";
          }
          error.framesToPop = 1;
          throw error;
        }
      }
      var warning = function() {
      };
      if (true) {
        printWarning = function printWarning2(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var argIndex = 0;
          var message = "Warning: " + format.replace(/%s/g, function() {
            return args[argIndex++];
          });
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
        warning = function warning2(condition, format) {
          if (format === void 0) {
            throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
          }
          if (format.indexOf("Failed Composite propType: ") === 0) {
            return;
          }
          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }
            printWarning.apply(void 0, [format].concat(args));
          }
        };
      }
      var printWarning;
      var MIXINS_KEY = "mixins";
      function identity(fn) {
        return fn;
      }
      var ReactPropTypeLocationNames;
      if (true) {
        ReactPropTypeLocationNames = {
          prop: "prop",
          context: "context",
          childContext: "child context"
        };
      } else {
        ReactPropTypeLocationNames = {};
      }
      function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
        var injectedMixins = [];
        var ReactClassInterface = {
          mixins: "DEFINE_MANY",
          statics: "DEFINE_MANY",
          propTypes: "DEFINE_MANY",
          contextTypes: "DEFINE_MANY",
          childContextTypes: "DEFINE_MANY",
          getDefaultProps: "DEFINE_MANY_MERGED",
          getInitialState: "DEFINE_MANY_MERGED",
          getChildContext: "DEFINE_MANY_MERGED",
          render: "DEFINE_ONCE",
          componentWillMount: "DEFINE_MANY",
          componentDidMount: "DEFINE_MANY",
          componentWillReceiveProps: "DEFINE_MANY",
          shouldComponentUpdate: "DEFINE_ONCE",
          componentWillUpdate: "DEFINE_MANY",
          componentDidUpdate: "DEFINE_MANY",
          componentWillUnmount: "DEFINE_MANY",
          UNSAFE_componentWillMount: "DEFINE_MANY",
          UNSAFE_componentWillReceiveProps: "DEFINE_MANY",
          UNSAFE_componentWillUpdate: "DEFINE_MANY",
          updateComponent: "OVERRIDE_BASE"
        };
        var ReactClassStaticInterface = {
          getDerivedStateFromProps: "DEFINE_MANY_MERGED"
        };
        var RESERVED_SPEC_KEYS = {
          displayName: function(Constructor, displayName) {
            Constructor.displayName = displayName;
          },
          mixins: function(Constructor, mixins) {
            if (mixins) {
              for (var i = 0; i < mixins.length; i++) {
                mixSpecIntoComponent(Constructor, mixins[i]);
              }
            }
          },
          childContextTypes: function(Constructor, childContextTypes) {
            if (true) {
              validateTypeDef(Constructor, childContextTypes, "childContext");
            }
            Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
          },
          contextTypes: function(Constructor, contextTypes) {
            if (true) {
              validateTypeDef(Constructor, contextTypes, "context");
            }
            Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
          },
          getDefaultProps: function(Constructor, getDefaultProps) {
            if (Constructor.getDefaultProps) {
              Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
            } else {
              Constructor.getDefaultProps = getDefaultProps;
            }
          },
          propTypes: function(Constructor, propTypes) {
            if (true) {
              validateTypeDef(Constructor, propTypes, "prop");
            }
            Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
          },
          statics: function(Constructor, statics) {
            mixStaticSpecIntoComponent(Constructor, statics);
          },
          autobind: function() {
          }
        };
        function validateTypeDef(Constructor, typeDef, location) {
          for (var propName in typeDef) {
            if (typeDef.hasOwnProperty(propName)) {
              if (true) {
                warning(typeof typeDef[propName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName);
              }
            }
          }
        }
        function validateMethodOverride(isAlreadyDefined, name2) {
          var specPolicy = ReactClassInterface.hasOwnProperty(name2) ? ReactClassInterface[name2] : null;
          if (ReactClassMixin.hasOwnProperty(name2)) {
            _invariant(specPolicy === "OVERRIDE_BASE", "ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.", name2);
          }
          if (isAlreadyDefined) {
            _invariant(specPolicy === "DEFINE_MANY" || specPolicy === "DEFINE_MANY_MERGED", "ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name2);
          }
        }
        function mixSpecIntoComponent(Constructor, spec) {
          if (!spec) {
            if (true) {
              var typeofSpec = typeof spec;
              var isMixinValid = typeofSpec === "object" && spec !== null;
              if (true) {
                warning(isMixinValid, "%s: You're attempting to include a mixin that is either null or not an object. Check the mixins included by the component, as well as any mixins they include themselves. Expected object but got %s.", Constructor.displayName || "ReactClass", spec === null ? null : typeofSpec);
              }
            }
            return;
          }
          _invariant(typeof spec !== "function", "ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object.");
          _invariant(!isValidElement(spec), "ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object.");
          var proto = Constructor.prototype;
          var autoBindPairs = proto.__reactAutoBindPairs;
          if (spec.hasOwnProperty(MIXINS_KEY)) {
            RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
          }
          for (var name2 in spec) {
            if (!spec.hasOwnProperty(name2)) {
              continue;
            }
            if (name2 === MIXINS_KEY) {
              continue;
            }
            var property = spec[name2];
            var isAlreadyDefined = proto.hasOwnProperty(name2);
            validateMethodOverride(isAlreadyDefined, name2);
            if (RESERVED_SPEC_KEYS.hasOwnProperty(name2)) {
              RESERVED_SPEC_KEYS[name2](Constructor, property);
            } else {
              var isReactClassMethod = ReactClassInterface.hasOwnProperty(name2);
              var isFunction4 = typeof property === "function";
              var shouldAutoBind = isFunction4 && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
              if (shouldAutoBind) {
                autoBindPairs.push(name2, property);
                proto[name2] = property;
              } else {
                if (isAlreadyDefined) {
                  var specPolicy = ReactClassInterface[name2];
                  _invariant(isReactClassMethod && (specPolicy === "DEFINE_MANY_MERGED" || specPolicy === "DEFINE_MANY"), "ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.", specPolicy, name2);
                  if (specPolicy === "DEFINE_MANY_MERGED") {
                    proto[name2] = createMergedResultFunction(proto[name2], property);
                  } else if (specPolicy === "DEFINE_MANY") {
                    proto[name2] = createChainedFunction(proto[name2], property);
                  }
                } else {
                  proto[name2] = property;
                  if (true) {
                    if (typeof property === "function" && spec.displayName) {
                      proto[name2].displayName = spec.displayName + "_" + name2;
                    }
                  }
                }
              }
            }
          }
        }
        function mixStaticSpecIntoComponent(Constructor, statics) {
          if (!statics) {
            return;
          }
          for (var name2 in statics) {
            var property = statics[name2];
            if (!statics.hasOwnProperty(name2)) {
              continue;
            }
            var isReserved = name2 in RESERVED_SPEC_KEYS;
            _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name2);
            var isAlreadyDefined = name2 in Constructor;
            if (isAlreadyDefined) {
              var specPolicy = ReactClassStaticInterface.hasOwnProperty(name2) ? ReactClassStaticInterface[name2] : null;
              _invariant(specPolicy === "DEFINE_MANY_MERGED", "ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name2);
              Constructor[name2] = createMergedResultFunction(Constructor[name2], property);
              return;
            }
            Constructor[name2] = property;
          }
        }
        function mergeIntoWithNoDuplicateKeys(one, two) {
          _invariant(one && two && typeof one === "object" && typeof two === "object", "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");
          for (var key in two) {
            if (two.hasOwnProperty(key)) {
              _invariant(one[key] === void 0, "mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.", key);
              one[key] = two[key];
            }
          }
          return one;
        }
        function createMergedResultFunction(one, two) {
          return function mergedResult() {
            var a = one.apply(this, arguments);
            var b = two.apply(this, arguments);
            if (a == null) {
              return b;
            } else if (b == null) {
              return a;
            }
            var c = {};
            mergeIntoWithNoDuplicateKeys(c, a);
            mergeIntoWithNoDuplicateKeys(c, b);
            return c;
          };
        }
        function createChainedFunction(one, two) {
          return function chainedFunction() {
            one.apply(this, arguments);
            two.apply(this, arguments);
          };
        }
        function bindAutoBindMethod(component, method) {
          var boundMethod = method.bind(component);
          if (true) {
            boundMethod.__reactBoundContext = component;
            boundMethod.__reactBoundMethod = method;
            boundMethod.__reactBoundArguments = null;
            var componentName = component.constructor.displayName;
            var _bind = boundMethod.bind;
            boundMethod.bind = function(newThis) {
              for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (newThis !== component && newThis !== null) {
                if (true) {
                  warning(false, "bind(): React component methods may only be bound to the component instance. See %s", componentName);
                }
              } else if (!args.length) {
                if (true) {
                  warning(false, "bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s", componentName);
                }
                return boundMethod;
              }
              var reboundMethod = _bind.apply(boundMethod, arguments);
              reboundMethod.__reactBoundContext = component;
              reboundMethod.__reactBoundMethod = method;
              reboundMethod.__reactBoundArguments = args;
              return reboundMethod;
            };
          }
          return boundMethod;
        }
        function bindAutoBindMethods(component) {
          var pairs = component.__reactAutoBindPairs;
          for (var i = 0; i < pairs.length; i += 2) {
            var autoBindKey = pairs[i];
            var method = pairs[i + 1];
            component[autoBindKey] = bindAutoBindMethod(component, method);
          }
        }
        var IsMountedPreMixin = {
          componentDidMount: function() {
            this.__isMounted = true;
          }
        };
        var IsMountedPostMixin = {
          componentWillUnmount: function() {
            this.__isMounted = false;
          }
        };
        var ReactClassMixin = {
          replaceState: function(newState, callback) {
            this.updater.enqueueReplaceState(this, newState, callback);
          },
          isMounted: function() {
            if (true) {
              warning(this.__didWarnIsMounted, "%s: isMounted is deprecated. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.", this.constructor && this.constructor.displayName || this.name || "Component");
              this.__didWarnIsMounted = true;
            }
            return !!this.__isMounted;
          }
        };
        var ReactClassComponent = function() {
        };
        _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
        function createClass(spec) {
          var Constructor = identity(function(props, context, updater) {
            if (true) {
              warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or JSX instead. See: https://fb.me/react-legacyfactory");
            }
            if (this.__reactAutoBindPairs.length) {
              bindAutoBindMethods(this);
            }
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
            this.state = null;
            var initialState = this.getInitialState ? this.getInitialState() : null;
            if (true) {
              if (initialState === void 0 && this.getInitialState._isMockFunction) {
                initialState = null;
              }
            }
            _invariant(typeof initialState === "object" && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent");
            this.state = initialState;
          });
          Constructor.prototype = new ReactClassComponent();
          Constructor.prototype.constructor = Constructor;
          Constructor.prototype.__reactAutoBindPairs = [];
          injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
          mixSpecIntoComponent(Constructor, IsMountedPreMixin);
          mixSpecIntoComponent(Constructor, spec);
          mixSpecIntoComponent(Constructor, IsMountedPostMixin);
          if (Constructor.getDefaultProps) {
            Constructor.defaultProps = Constructor.getDefaultProps();
          }
          if (true) {
            if (Constructor.getDefaultProps) {
              Constructor.getDefaultProps.isReactClassApproved = {};
            }
            if (Constructor.prototype.getInitialState) {
              Constructor.prototype.getInitialState.isReactClassApproved = {};
            }
          }
          _invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method.");
          if (true) {
            warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", spec.displayName || "A component");
            warning(!Constructor.prototype.componentWillRecieveProps, "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", spec.displayName || "A component");
            warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", spec.displayName || "A component");
          }
          for (var methodName in ReactClassInterface) {
            if (!Constructor.prototype[methodName]) {
              Constructor.prototype[methodName] = null;
            }
          }
          return Constructor;
        }
        return createClass;
      }
      module.exports = factory;
    }
  });

  // ../../node_modules/create-react-class/index.js
  var require_create_react_class = __commonJS({
    "../../node_modules/create-react-class/index.js"(exports, module) {
      "use strict";
      var React6 = require_react();
      var factory = require_factory();
      if (typeof React6 === "undefined") {
        throw Error("create-react-class could not find the React object. If you are using script tags, make sure that React is being loaded before create-react-class.");
      }
      var ReactNoopUpdateQueue = new React6.Component().updater;
      module.exports = factory(React6.Component, React6.isValidElement, ReactNoopUpdateQueue);
    }
  });

  // ../../node_modules/codemirror/lib/codemirror.js
  var require_codemirror = __commonJS({
    "../../node_modules/codemirror/lib/codemirror.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
      })(exports, function() {
        "use strict";
        var userAgent = navigator.userAgent;
        var platform = navigator.platform;
        var gecko3 = /gecko\/\d/i.test(userAgent);
        var ie_upto102 = /MSIE \d/.test(userAgent);
        var ie_11up2 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
        var edge = /Edge\/(\d+)/.exec(userAgent);
        var ie3 = ie_upto102 || ie_11up2 || edge;
        var ie_version = ie3 && (ie_upto102 ? document.documentMode || 6 : +(edge || ie_11up2)[1]);
        var webkit2 = !edge && /WebKit\//.test(userAgent);
        var qtwebkit = webkit2 && /Qt\/\d+\.\d+/.test(userAgent);
        var chrome3 = !edge && /Chrome\//.test(userAgent);
        var presto = /Opera\//.test(userAgent);
        var safari3 = /Apple Computer/.test(navigator.vendor);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
        var phantom = /PhantomJS/.test(userAgent);
        var ios = safari3 && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
        var android = /Android/.test(userAgent);
        var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
        var mac2 = ios || /Mac/.test(platform);
        var chromeOS = /\bCrOS\b/.test(userAgent);
        var windows = /win/i.test(platform);
        var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
        if (presto_version) {
          presto_version = Number(presto_version[1]);
        }
        if (presto_version && presto_version >= 15) {
          presto = false;
          webkit2 = true;
        }
        var flipCtrlCmd = mac2 && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
        var captureRightClick = gecko3 || ie3 && ie_version >= 9;
        function classTest(cls) {
          return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
        }
        var rmClass = function(node, cls) {
          var current = node.className;
          var match = classTest(cls).exec(current);
          if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
          }
        };
        function removeChildren(e) {
          for (var count = e.childNodes.length; count > 0; --count) {
            e.removeChild(e.firstChild);
          }
          return e;
        }
        function removeChildrenAndAdd(parent, e) {
          return removeChildren(parent).appendChild(e);
        }
        function elt(tag, content2, className, style) {
          var e = document.createElement(tag);
          if (className) {
            e.className = className;
          }
          if (style) {
            e.style.cssText = style;
          }
          if (typeof content2 == "string") {
            e.appendChild(document.createTextNode(content2));
          } else if (content2) {
            for (var i2 = 0; i2 < content2.length; ++i2) {
              e.appendChild(content2[i2]);
            }
          }
          return e;
        }
        function eltP(tag, content2, className, style) {
          var e = elt(tag, content2, className, style);
          e.setAttribute("role", "presentation");
          return e;
        }
        var range;
        if (document.createRange) {
          range = function(node, start2, end, endNode) {
            var r6 = document.createRange();
            r6.setEnd(endNode || node, end);
            r6.setStart(node, start2);
            return r6;
          };
        } else {
          range = function(node, start2, end) {
            var r6 = document.body.createTextRange();
            try {
              r6.moveToElementText(node.parentNode);
            } catch (e) {
              return r6;
            }
            r6.collapse(true);
            r6.moveEnd("character", end);
            r6.moveStart("character", start2);
            return r6;
          };
        }
        function contains2(parent, child) {
          if (child.nodeType == 3) {
            child = child.parentNode;
          }
          if (parent.contains) {
            return parent.contains(child);
          }
          do {
            if (child.nodeType == 11) {
              child = child.host;
            }
            if (child == parent) {
              return true;
            }
          } while (child = child.parentNode);
        }
        function activeElt() {
          var activeElement;
          try {
            activeElement = document.activeElement;
          } catch (e) {
            activeElement = document.body || null;
          }
          while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          return activeElement;
        }
        function addClass(node, cls) {
          var current = node.className;
          if (!classTest(cls).test(current)) {
            node.className += (current ? " " : "") + cls;
          }
        }
        function joinClasses(a, b) {
          var as = a.split(" ");
          for (var i2 = 0; i2 < as.length; i2++) {
            if (as[i2] && !classTest(as[i2]).test(b)) {
              b += " " + as[i2];
            }
          }
          return b;
        }
        var selectInput = function(node) {
          node.select();
        };
        if (ios) {
          selectInput = function(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie3) {
          selectInput = function(node) {
            try {
              node.select();
            } catch (_e2) {
            }
          };
        }
        function bind(f) {
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f.apply(null, args);
          };
        }
        function copyObj(obj, target, overwrite) {
          if (!target) {
            target = {};
          }
          for (var prop2 in obj) {
            if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
              target[prop2] = obj[prop2];
            }
          }
          return target;
        }
        function countColumn2(string2, end, tabSize, startIndex, startValue) {
          if (end == null) {
            end = string2.search(/[^\s\u00a0]/);
            if (end == -1) {
              end = string2.length;
            }
          }
          for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
            var nextTab = string2.indexOf("	", i2);
            if (nextTab < 0 || nextTab >= end) {
              return n + (end - i2);
            }
            n += nextTab - i2;
            n += tabSize - n % tabSize;
            i2 = nextTab + 1;
          }
        }
        var Delayed = function() {
          this.id = null;
          this.f = null;
          this.time = 0;
          this.handler = bind(this.onTimeout, this);
        };
        Delayed.prototype.onTimeout = function(self2) {
          self2.id = 0;
          if (self2.time <= +new Date()) {
            self2.f();
          } else {
            setTimeout(self2.handler, self2.time - +new Date());
          }
        };
        Delayed.prototype.set = function(ms, f) {
          this.f = f;
          var time = +new Date() + ms;
          if (!this.id || time < this.time) {
            clearTimeout(this.id);
            this.id = setTimeout(this.handler, ms);
            this.time = time;
          }
        };
        function indexOf(array2, elt2) {
          for (var i2 = 0; i2 < array2.length; ++i2) {
            if (array2[i2] == elt2) {
              return i2;
            }
          }
          return -1;
        }
        var scrollerGap = 50;
        var Pass = { toString: function() {
          return "CodeMirror.Pass";
        } };
        var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
        function findColumn2(string2, goal, tabSize) {
          for (var pos = 0, col = 0; ; ) {
            var nextTab = string2.indexOf("	", pos);
            if (nextTab == -1) {
              nextTab = string2.length;
            }
            var skipped = nextTab - pos;
            if (nextTab == string2.length || col + skipped >= goal) {
              return pos + Math.min(skipped, goal - col);
            }
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal) {
              return pos;
            }
          }
        }
        var spaceStrs = [""];
        function spaceStr(n) {
          while (spaceStrs.length <= n) {
            spaceStrs.push(lst(spaceStrs) + " ");
          }
          return spaceStrs[n];
        }
        function lst(arr) {
          return arr[arr.length - 1];
        }
        function map2(array2, f) {
          var out = [];
          for (var i2 = 0; i2 < array2.length; i2++) {
            out[i2] = f(array2[i2], i2);
          }
          return out;
        }
        function insertSorted(array2, value, score) {
          var pos = 0, priority = score(value);
          while (pos < array2.length && score(array2[pos]) <= priority) {
            pos++;
          }
          array2.splice(pos, 0, value);
        }
        function nothing() {
        }
        function createObj(base2, props) {
          var inst;
          if (Object.create) {
            inst = Object.create(base2);
          } else {
            nothing.prototype = base2;
            inst = new nothing();
          }
          if (props) {
            copyObj(props, inst);
          }
          return inst;
        }
        var nonASCIISingleCaseWordChar2 = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordCharBasic(ch2) {
          return /\w/.test(ch2) || ch2 > "\x80" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar2.test(ch2));
        }
        function isWordChar(ch2, helper) {
          if (!helper) {
            return isWordCharBasic(ch2);
          }
          if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch2)) {
            return true;
          }
          return helper.test(ch2);
        }
        function isEmpty(obj) {
          for (var n in obj) {
            if (obj.hasOwnProperty(n) && obj[n]) {
              return false;
            }
          }
          return true;
        }
        var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
        function isExtendingChar2(ch2) {
          return ch2.charCodeAt(0) >= 768 && extendingChars.test(ch2);
        }
        function skipExtendingChars(str, pos, dir) {
          while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar2(str.charAt(pos))) {
            pos += dir;
          }
          return pos;
        }
        function findFirst(pred, from, to) {
          var dir = from > to ? -1 : 1;
          for (; ; ) {
            if (from == to) {
              return from;
            }
            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from) {
              return pred(mid) ? from : to;
            }
            if (pred(mid)) {
              to = mid;
            } else {
              from = mid + dir;
            }
          }
        }
        function iterateBidiSections(order, from, to, f) {
          if (!order) {
            return f(from, to, "ltr", 0);
          }
          var found = false;
          for (var i2 = 0; i2 < order.length; ++i2) {
            var part = order[i2];
            if (part.from < to && part.to > from || from == to && part.to == from) {
              f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
              found = true;
            }
          }
          if (!found) {
            f(from, to, "ltr");
          }
        }
        var bidiOther = null;
        function getBidiPartAt(order, ch2, sticky) {
          var found;
          bidiOther = null;
          for (var i2 = 0; i2 < order.length; ++i2) {
            var cur = order[i2];
            if (cur.from < ch2 && cur.to > ch2) {
              return i2;
            }
            if (cur.to == ch2) {
              if (cur.from != cur.to && sticky == "before") {
                found = i2;
              } else {
                bidiOther = i2;
              }
            }
            if (cur.from == ch2) {
              if (cur.from != cur.to && sticky != "before") {
                found = i2;
              } else {
                bidiOther = i2;
              }
            }
          }
          return found != null ? found : bidiOther;
        }
        var bidiOrdering = function() {
          var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
          var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
          function charType2(code) {
            if (code <= 247) {
              return lowTypes.charAt(code);
            } else if (1424 <= code && code <= 1524) {
              return "R";
            } else if (1536 <= code && code <= 1785) {
              return arabicTypes.charAt(code - 1536);
            } else if (1774 <= code && code <= 2220) {
              return "r";
            } else if (8192 <= code && code <= 8203) {
              return "w";
            } else if (code == 8204) {
              return "b";
            } else {
              return "L";
            }
          }
          var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
          var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
          function BidiSpan2(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
          }
          return function(str, direction) {
            var outerType = direction == "ltr" ? "L" : "R";
            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
              return false;
            }
            var len = str.length, types2 = [];
            for (var i2 = 0; i2 < len; ++i2) {
              types2.push(charType2(str.charCodeAt(i2)));
            }
            for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
              var type = types2[i$12];
              if (type == "m") {
                types2[i$12] = prev;
              } else {
                prev = type;
              }
            }
            for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
              var type$1 = types2[i$22];
              if (type$1 == "1" && cur == "r") {
                types2[i$22] = "n";
              } else if (isStrong.test(type$1)) {
                cur = type$1;
                if (type$1 == "r") {
                  types2[i$22] = "R";
                }
              }
            }
            for (var i$3 = 1, prev$1 = types2[0]; i$3 < len - 1; ++i$3) {
              var type$2 = types2[i$3];
              if (type$2 == "+" && prev$1 == "1" && types2[i$3 + 1] == "1") {
                types2[i$3] = "1";
              } else if (type$2 == "," && prev$1 == types2[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
                types2[i$3] = prev$1;
              }
              prev$1 = type$2;
            }
            for (var i$4 = 0; i$4 < len; ++i$4) {
              var type$3 = types2[i$4];
              if (type$3 == ",") {
                types2[i$4] = "N";
              } else if (type$3 == "%") {
                var end = void 0;
                for (end = i$4 + 1; end < len && types2[end] == "%"; ++end) {
                }
                var replace2 = i$4 && types2[i$4 - 1] == "!" || end < len && types2[end] == "1" ? "1" : "N";
                for (var j = i$4; j < end; ++j) {
                  types2[j] = replace2;
                }
                i$4 = end - 1;
              }
            }
            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
              var type$4 = types2[i$5];
              if (cur$1 == "L" && type$4 == "1") {
                types2[i$5] = "L";
              } else if (isStrong.test(type$4)) {
                cur$1 = type$4;
              }
            }
            for (var i$6 = 0; i$6 < len; ++i$6) {
              if (isNeutral.test(types2[i$6])) {
                var end$1 = void 0;
                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types2[end$1]); ++end$1) {
                }
                var before = (i$6 ? types2[i$6 - 1] : outerType) == "L";
                var after = (end$1 < len ? types2[end$1] : outerType) == "L";
                var replace$1 = before == after ? before ? "L" : "R" : outerType;
                for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                  types2[j$1] = replace$1;
                }
                i$6 = end$1 - 1;
              }
            }
            var order = [], m;
            for (var i$7 = 0; i$7 < len; ) {
              if (countsAsLeft.test(types2[i$7])) {
                var start2 = i$7;
                for (++i$7; i$7 < len && countsAsLeft.test(types2[i$7]); ++i$7) {
                }
                order.push(new BidiSpan2(0, start2, i$7));
              } else {
                var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
                for (++i$7; i$7 < len && types2[i$7] != "L"; ++i$7) {
                }
                for (var j$2 = pos; j$2 < i$7; ) {
                  if (countsAsNum.test(types2[j$2])) {
                    if (pos < j$2) {
                      order.splice(at, 0, new BidiSpan2(1, pos, j$2));
                      at += isRTL;
                    }
                    var nstart = j$2;
                    for (++j$2; j$2 < i$7 && countsAsNum.test(types2[j$2]); ++j$2) {
                    }
                    order.splice(at, 0, new BidiSpan2(2, nstart, j$2));
                    at += isRTL;
                    pos = j$2;
                  } else {
                    ++j$2;
                  }
                }
                if (pos < i$7) {
                  order.splice(at, 0, new BidiSpan2(1, pos, i$7));
                }
              }
            }
            if (direction == "ltr") {
              if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                order[0].from = m[0].length;
                order.unshift(new BidiSpan2(0, 0, m[0].length));
              }
              if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                lst(order).to -= m[0].length;
                order.push(new BidiSpan2(0, len - m[0].length, len));
              }
            }
            return direction == "rtl" ? order.reverse() : order;
          };
        }();
        function getOrder(line, direction) {
          var order = line.order;
          if (order == null) {
            order = line.order = bidiOrdering(line.text, direction);
          }
          return order;
        }
        var noHandlers = [];
        var on = function(emitter, type, f) {
          if (emitter.addEventListener) {
            emitter.addEventListener(type, f, false);
          } else if (emitter.attachEvent) {
            emitter.attachEvent("on" + type, f);
          } else {
            var map3 = emitter._handlers || (emitter._handlers = {});
            map3[type] = (map3[type] || noHandlers).concat(f);
          }
        };
        function getHandlers(emitter, type) {
          return emitter._handlers && emitter._handlers[type] || noHandlers;
        }
        function off(emitter, type, f) {
          if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f, false);
          } else if (emitter.detachEvent) {
            emitter.detachEvent("on" + type, f);
          } else {
            var map3 = emitter._handlers, arr = map3 && map3[type];
            if (arr) {
              var index = indexOf(arr, f);
              if (index > -1) {
                map3[type] = arr.slice(0, index).concat(arr.slice(index + 1));
              }
            }
          }
        }
        function signal(emitter, type) {
          var handlers2 = getHandlers(emitter, type);
          if (!handlers2.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2);
          for (var i2 = 0; i2 < handlers2.length; ++i2) {
            handlers2[i2].apply(null, args);
          }
        }
        function signalDOMEvent(cm, e, override2) {
          if (typeof e == "string") {
            e = { type: e, preventDefault: function() {
              this.defaultPrevented = true;
            } };
          }
          signal(cm, override2 || e.type, cm, e);
          return e_defaultPrevented(e) || e.codemirrorIgnore;
        }
        function signalCursorActivity(cm) {
          var arr = cm._handlers && cm._handlers.cursorActivity;
          if (!arr) {
            return;
          }
          var set5 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
          for (var i2 = 0; i2 < arr.length; ++i2) {
            if (indexOf(set5, arr[i2]) == -1) {
              set5.push(arr[i2]);
            }
          }
        }
        function hasHandler(emitter, type) {
          return getHandlers(emitter, type).length > 0;
        }
        function eventMixin(ctor) {
          ctor.prototype.on = function(type, f) {
            on(this, type, f);
          };
          ctor.prototype.off = function(type, f) {
            off(this, type, f);
          };
        }
        function e_preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }
        function e_stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
          } else {
            e.cancelBubble = true;
          }
        }
        function e_defaultPrevented(e) {
          return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
        }
        function e_stop(e) {
          e_preventDefault(e);
          e_stopPropagation(e);
        }
        function e_target(e) {
          return e.target || e.srcElement;
        }
        function e_button(e) {
          var b = e.which;
          if (b == null) {
            if (e.button & 1) {
              b = 1;
            } else if (e.button & 2) {
              b = 3;
            } else if (e.button & 4) {
              b = 2;
            }
          }
          if (mac2 && e.ctrlKey && b == 1) {
            b = 3;
          }
          return b;
        }
        var dragAndDrop = function() {
          if (ie3 && ie_version < 9) {
            return false;
          }
          var div = elt("div");
          return "draggable" in div || "dragDrop" in div;
        }();
        var zwspSupported;
        function zeroWidthElement(measure) {
          if (zwspSupported == null) {
            var test = elt("span", "\u200B");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
            if (measure.firstChild.offsetHeight != 0) {
              zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie3 && ie_version < 8);
            }
          }
          var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
          node.setAttribute("cm-text", "");
          return node;
        }
        var badBidiRects;
        function hasBadBidiRects(measure) {
          if (badBidiRects != null) {
            return badBidiRects;
          }
          var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
          var r0 = range(txt, 0, 1).getBoundingClientRect();
          var r1 = range(txt, 1, 2).getBoundingClientRect();
          removeChildren(measure);
          if (!r0 || r0.left == r0.right) {
            return false;
          }
          return badBidiRects = r1.right - r0.right < 3;
        }
        var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string2) {
          var pos = 0, result = [], l = string2.length;
          while (pos <= l) {
            var nl = string2.indexOf("\n", pos);
            if (nl == -1) {
              nl = string2.length;
            }
            var line = string2.slice(pos, string2.charAt(nl - 1) == "\r" ? nl - 1 : nl);
            var rt = line.indexOf("\r");
            if (rt != -1) {
              result.push(line.slice(0, rt));
              pos += rt + 1;
            } else {
              result.push(line);
              pos = nl + 1;
            }
          }
          return result;
        } : function(string2) {
          return string2.split(/\r\n?|\n/);
        };
        var hasSelection2 = window.getSelection ? function(te) {
          try {
            return te.selectionStart != te.selectionEnd;
          } catch (e) {
            return false;
          }
        } : function(te) {
          var range2;
          try {
            range2 = te.ownerDocument.selection.createRange();
          } catch (e) {
          }
          if (!range2 || range2.parentElement() != te) {
            return false;
          }
          return range2.compareEndPoints("StartToEnd", range2) != 0;
        };
        var hasCopyEvent = function() {
          var e = elt("div");
          if ("oncopy" in e) {
            return true;
          }
          e.setAttribute("oncopy", "return;");
          return typeof e.oncopy == "function";
        }();
        var badZoomedRects = null;
        function hasBadZoomedRects(measure) {
          if (badZoomedRects != null) {
            return badZoomedRects;
          }
          var node = removeChildrenAndAdd(measure, elt("span", "x"));
          var normal = node.getBoundingClientRect();
          var fromRange = range(node, 0, 1).getBoundingClientRect();
          return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
        }
        var modes = {}, mimeModes = {};
        function defineMode(name2, mode) {
          if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
          }
          modes[name2] = mode;
        }
        function defineMIME(mime, spec) {
          mimeModes[mime] = spec;
        }
        function resolveMode(spec) {
          if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
          } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == "string") {
              found = { name: found };
            }
            spec = createObj(found, spec);
            spec.name = found.name;
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode("application/xml");
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode("application/json");
          }
          if (typeof spec == "string") {
            return { name: spec };
          } else {
            return spec || { name: "null" };
          }
        }
        function getMode(options, spec) {
          spec = resolveMode(spec);
          var mfactory = modes[spec.name];
          if (!mfactory) {
            return getMode(options, "text/plain");
          }
          var modeObj = mfactory(options, spec);
          if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop2 in exts) {
              if (!exts.hasOwnProperty(prop2)) {
                continue;
              }
              if (modeObj.hasOwnProperty(prop2)) {
                modeObj["_" + prop2] = modeObj[prop2];
              }
              modeObj[prop2] = exts[prop2];
            }
          }
          modeObj.name = spec.name;
          if (spec.helperType) {
            modeObj.helperType = spec.helperType;
          }
          if (spec.modeProps) {
            for (var prop$1 in spec.modeProps) {
              modeObj[prop$1] = spec.modeProps[prop$1];
            }
          }
          return modeObj;
        }
        var modeExtensions = {};
        function extendMode(mode, properties) {
          var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
          copyObj(properties, exts);
        }
        function copyState(mode, state) {
          if (state === true) {
            return state;
          }
          if (mode.copyState) {
            return mode.copyState(state);
          }
          var nstate = {};
          for (var n in state) {
            var val = state[n];
            if (val instanceof Array) {
              val = val.concat([]);
            }
            nstate[n] = val;
          }
          return nstate;
        }
        function innerMode(mode, state) {
          var info;
          while (mode.innerMode) {
            info = mode.innerMode(state);
            if (!info || info.mode == mode) {
              break;
            }
            state = info.state;
            mode = info.mode;
          }
          return info || { mode, state };
        }
        function startState(mode, a1, a2) {
          return mode.startState ? mode.startState(a1, a2) : true;
        }
        var StringStream = function(string2, tabSize, lineOracle) {
          this.pos = this.start = 0;
          this.string = string2;
          this.tabSize = tabSize || 8;
          this.lastColumnPos = this.lastColumnValue = 0;
          this.lineStart = 0;
          this.lineOracle = lineOracle;
        };
        StringStream.prototype.eol = function() {
          return this.pos >= this.string.length;
        };
        StringStream.prototype.sol = function() {
          return this.pos == this.lineStart;
        };
        StringStream.prototype.peek = function() {
          return this.string.charAt(this.pos) || void 0;
        };
        StringStream.prototype.next = function() {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
          }
        };
        StringStream.prototype.eat = function(match) {
          var ch2 = this.string.charAt(this.pos);
          var ok;
          if (typeof match == "string") {
            ok = ch2 == match;
          } else {
            ok = ch2 && (match.test ? match.test(ch2) : match(ch2));
          }
          if (ok) {
            ++this.pos;
            return ch2;
          }
        };
        StringStream.prototype.eatWhile = function(match) {
          var start2 = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start2;
        };
        StringStream.prototype.eatSpace = function() {
          var start2 = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this.pos;
          }
          return this.pos > start2;
        };
        StringStream.prototype.skipToEnd = function() {
          this.pos = this.string.length;
        };
        StringStream.prototype.skipTo = function(ch2) {
          var found = this.string.indexOf(ch2, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        };
        StringStream.prototype.backUp = function(n) {
          this.pos -= n;
        };
        StringStream.prototype.column = function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn2(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn2(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.indentation = function() {
          return countColumn2(this.string, null, this.tabSize) - (this.lineStart ? countColumn2(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length;
              }
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
              return null;
            }
            if (match && consume !== false) {
              this.pos += match[0].length;
            }
            return match;
          }
        };
        StringStream.prototype.current = function() {
          return this.string.slice(this.start, this.pos);
        };
        StringStream.prototype.hideFirstChars = function(n, inner) {
          this.lineStart += n;
          try {
            return inner();
          } finally {
            this.lineStart -= n;
          }
        };
        StringStream.prototype.lookAhead = function(n) {
          var oracle = this.lineOracle;
          return oracle && oracle.lookAhead(n);
        };
        StringStream.prototype.baseToken = function() {
          var oracle = this.lineOracle;
          return oracle && oracle.baseToken(this.pos);
        };
        function getLine(doc2, n) {
          n -= doc2.first;
          if (n < 0 || n >= doc2.size) {
            throw new Error("There is no line " + (n + doc2.first) + " in the document.");
          }
          var chunk = doc2;
          while (!chunk.lines) {
            for (var i2 = 0; ; ++i2) {
              var child = chunk.children[i2], sz = child.chunkSize();
              if (n < sz) {
                chunk = child;
                break;
              }
              n -= sz;
            }
          }
          return chunk.lines[n];
        }
        function getBetween(doc2, start2, end) {
          var out = [], n = start2.line;
          doc2.iter(start2.line, end.line + 1, function(line) {
            var text = line.text;
            if (n == end.line) {
              text = text.slice(0, end.ch);
            }
            if (n == start2.line) {
              text = text.slice(start2.ch);
            }
            out.push(text);
            ++n;
          });
          return out;
        }
        function getLines(doc2, from, to) {
          var out = [];
          doc2.iter(from, to, function(line) {
            out.push(line.text);
          });
          return out;
        }
        function updateLineHeight(line, height) {
          var diff = height - line.height;
          if (diff) {
            for (var n = line; n; n = n.parent) {
              n.height += diff;
            }
          }
        }
        function lineNo(line) {
          if (line.parent == null) {
            return null;
          }
          var cur = line.parent, no = indexOf(cur.lines, line);
          for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i2 = 0; ; ++i2) {
              if (chunk.children[i2] == cur) {
                break;
              }
              no += chunk.children[i2].chunkSize();
            }
          }
          return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
          var n = chunk.first;
          outer:
            do {
              for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
                var child = chunk.children[i$12], ch2 = child.height;
                if (h < ch2) {
                  chunk = child;
                  continue outer;
                }
                h -= ch2;
                n += child.chunkSize();
              }
              return n;
            } while (!chunk.lines);
          var i2 = 0;
          for (; i2 < chunk.lines.length; ++i2) {
            var line = chunk.lines[i2], lh2 = line.height;
            if (h < lh2) {
              break;
            }
            h -= lh2;
          }
          return n + i2;
        }
        function isLine(doc2, l) {
          return l >= doc2.first && l < doc2.first + doc2.size;
        }
        function lineNumberFor(options, i2) {
          return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
        }
        function Pos(line, ch2, sticky) {
          if (sticky === void 0)
            sticky = null;
          if (!(this instanceof Pos)) {
            return new Pos(line, ch2, sticky);
          }
          this.line = line;
          this.ch = ch2;
          this.sticky = sticky;
        }
        function cmp(a, b) {
          return a.line - b.line || a.ch - b.ch;
        }
        function equalCursorPos(a, b) {
          return a.sticky == b.sticky && cmp(a, b) == 0;
        }
        function copyPos(x) {
          return Pos(x.line, x.ch);
        }
        function maxPos(a, b) {
          return cmp(a, b) < 0 ? b : a;
        }
        function minPos(a, b) {
          return cmp(a, b) < 0 ? a : b;
        }
        function clipLine(doc2, n) {
          return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));
        }
        function clipPos(doc2, pos) {
          if (pos.line < doc2.first) {
            return Pos(doc2.first, 0);
          }
          var last = doc2.first + doc2.size - 1;
          if (pos.line > last) {
            return Pos(last, getLine(doc2, last).text.length);
          }
          return clipToLen(pos, getLine(doc2, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
          var ch2 = pos.ch;
          if (ch2 == null || ch2 > linelen) {
            return Pos(pos.line, linelen);
          } else if (ch2 < 0) {
            return Pos(pos.line, 0);
          } else {
            return pos;
          }
        }
        function clipPosArray(doc2, array2) {
          var out = [];
          for (var i2 = 0; i2 < array2.length; i2++) {
            out[i2] = clipPos(doc2, array2[i2]);
          }
          return out;
        }
        var SavedContext = function(state, lookAhead) {
          this.state = state;
          this.lookAhead = lookAhead;
        };
        var Context = function(doc2, state, line, lookAhead) {
          this.state = state;
          this.doc = doc2;
          this.line = line;
          this.maxLookAhead = lookAhead || 0;
          this.baseTokens = null;
          this.baseTokenPos = 1;
        };
        Context.prototype.lookAhead = function(n) {
          var line = this.doc.getLine(this.line + n);
          if (line != null && n > this.maxLookAhead) {
            this.maxLookAhead = n;
          }
          return line;
        };
        Context.prototype.baseToken = function(n) {
          if (!this.baseTokens) {
            return null;
          }
          while (this.baseTokens[this.baseTokenPos] <= n) {
            this.baseTokenPos += 2;
          }
          var type = this.baseTokens[this.baseTokenPos + 1];
          return {
            type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n
          };
        };
        Context.prototype.nextLine = function() {
          this.line++;
          if (this.maxLookAhead > 0) {
            this.maxLookAhead--;
          }
        };
        Context.fromSaved = function(doc2, saved, line) {
          if (saved instanceof SavedContext) {
            return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
          } else {
            return new Context(doc2, copyState(doc2.mode, saved), line);
          }
        };
        Context.prototype.save = function(copy) {
          var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
          return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
        };
        function highlightLine(cm, line, context, forceToEnd) {
          var st = [cm.state.modeGen], lineClasses = {};
          runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
            return st.push(end, style);
          }, lineClasses, forceToEnd);
          var state = context.state;
          var loop = function(o2) {
            context.baseTokens = st;
            var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, function(end, style) {
              var start2 = i2;
              while (at < end) {
                var i_end = st[i2];
                if (i_end > end) {
                  st.splice(i2, 1, end, st[i2 + 1], i_end);
                }
                i2 += 2;
                at = Math.min(end, i_end);
              }
              if (!style) {
                return;
              }
              if (overlay.opaque) {
                st.splice(start2, i2 - start2, end, "overlay " + style);
                i2 = start2 + 2;
              } else {
                for (; start2 < i2; start2 += 2) {
                  var cur = st[start2 + 1];
                  st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
              }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
          };
          for (var o = 0; o < cm.state.overlays.length; ++o)
            loop(o);
          return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
        }
        function getLineStyles(cm, line, updateFrontier) {
          if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line));
            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
            var result = highlightLine(cm, line, context);
            if (resetState) {
              context.state = resetState;
            }
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes) {
              line.styleClasses = result.classes;
            } else if (line.styleClasses) {
              line.styleClasses = null;
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
              cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
            }
          }
          return line.styles;
        }
        function getContextBefore(cm, n, precise) {
          var doc2 = cm.doc, display = cm.display;
          if (!doc2.mode.startState) {
            return new Context(doc2, true, n);
          }
          var start2 = findStartLine(cm, n, precise);
          var saved = start2 > doc2.first && getLine(doc2, start2 - 1).stateAfter;
          var context = saved ? Context.fromSaved(doc2, saved, start2) : new Context(doc2, startState(doc2.mode), start2);
          doc2.iter(start2, n, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
          });
          if (precise) {
            doc2.modeFrontier = context.line;
          }
          return context;
        }
        function processLine(cm, text, context, startAt) {
          var mode = cm.doc.mode;
          var stream = new StringStream(text, cm.options.tabSize, context);
          stream.start = stream.pos = startAt || 0;
          if (text == "") {
            callBlankLine(mode, context.state);
          }
          while (!stream.eol()) {
            readToken2(mode, stream, context.state);
            stream.start = stream.pos;
          }
        }
        function callBlankLine(mode, state) {
          if (mode.blankLine) {
            return mode.blankLine(state);
          }
          if (!mode.innerMode) {
            return;
          }
          var inner = innerMode(mode, state);
          if (inner.mode.blankLine) {
            return inner.mode.blankLine(inner.state);
          }
        }
        function readToken2(mode, stream, state, inner) {
          for (var i2 = 0; i2 < 10; i2++) {
            if (inner) {
              inner[0] = innerMode(mode, state).mode;
            }
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) {
              return style;
            }
          }
          throw new Error("Mode " + mode.name + " failed to advance stream.");
        }
        var Token = function(stream, type, state) {
          this.start = stream.start;
          this.end = stream.pos;
          this.string = stream.current();
          this.type = type || null;
          this.state = state;
        };
        function takeToken(cm, pos, precise, asArray3) {
          var doc2 = cm.doc, mode = doc2.mode, style;
          pos = clipPos(doc2, pos);
          var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
          var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
          if (asArray3) {
            tokens = [];
          }
          while ((asArray3 || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken2(mode, stream, context.state);
            if (asArray3) {
              tokens.push(new Token(stream, style, copyState(doc2.mode, context.state)));
            }
          }
          return asArray3 ? tokens : new Token(stream, style, context.state);
        }
        function extractLineClasses(type, output) {
          if (type) {
            for (; ; ) {
              var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
              if (!lineClass) {
                break;
              }
              type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
              var prop2 = lineClass[1] ? "bgClass" : "textClass";
              if (output[prop2] == null) {
                output[prop2] = lineClass[2];
              } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
                output[prop2] += " " + lineClass[2];
              }
            }
          }
          return type;
        }
        function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
          var flattenSpans = mode.flattenSpans;
          if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans;
          }
          var curStart = 0, curStyle = null;
          var stream = new StringStream(text, cm.options.tabSize, context), style;
          var inner = cm.options.addModeClass && [null];
          if (text == "") {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
          }
          while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
              flattenSpans = false;
              if (forceToEnd) {
                processLine(cm, text, context, stream.pos);
              }
              stream.pos = text.length;
              style = null;
            } else {
              style = extractLineClasses(readToken2(mode, stream, context.state, inner), lineClasses);
            }
            if (inner) {
              var mName = inner[0].name;
              if (mName) {
                style = "m-" + (style ? mName + " " + style : mName);
              }
            }
            if (!flattenSpans || curStyle != style) {
              while (curStart < stream.start) {
                curStart = Math.min(stream.start, curStart + 5e3);
                f(curStart, curStyle);
              }
              curStyle = style;
            }
            stream.start = stream.pos;
          }
          while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f(pos, curStyle);
            curStart = pos;
          }
        }
        function findStartLine(cm, n, precise) {
          var minindent, minline, doc2 = cm.doc;
          var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
          for (var search = n; search > lim; --search) {
            if (search <= doc2.first) {
              return doc2.first;
            }
            var line = getLine(doc2, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
              return search;
            }
            var indented = countColumn2(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
              minline = search - 1;
              minindent = indented;
            }
          }
          return minline;
        }
        function retreatFrontier(doc2, n) {
          doc2.modeFrontier = Math.min(doc2.modeFrontier, n);
          if (doc2.highlightFrontier < n - 10) {
            return;
          }
          var start2 = doc2.first;
          for (var line = n - 1; line > start2; line--) {
            var saved = getLine(doc2, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
              start2 = line + 1;
              break;
            }
          }
          doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start2);
        }
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        function seeReadOnlySpans() {
          sawReadOnlySpans = true;
        }
        function seeCollapsedSpans() {
          sawCollapsedSpans = true;
        }
        function MarkedSpan(marker, from, to) {
          this.marker = marker;
          this.from = from;
          this.to = to;
        }
        function getMarkedSpanFor(spans, marker) {
          if (spans) {
            for (var i2 = 0; i2 < spans.length; ++i2) {
              var span = spans[i2];
              if (span.marker == marker) {
                return span;
              }
            }
          }
        }
        function removeMarkedSpan(spans, span) {
          var r6;
          for (var i2 = 0; i2 < spans.length; ++i2) {
            if (spans[i2] != span) {
              (r6 || (r6 = [])).push(spans[i2]);
            }
          }
          return r6;
        }
        function addMarkedSpan(line, span, op) {
          var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
          if (inThisOp && inThisOp.has(line.markedSpans)) {
            line.markedSpans.push(span);
          } else {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
            if (inThisOp) {
              inThisOp.add(line.markedSpans);
            }
          }
          span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
          var nw;
          if (old) {
            for (var i2 = 0; i2 < old.length; ++i2) {
              var span = old[i2], marker = span.marker;
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
              if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
              }
            }
          }
          return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
          var nw;
          if (old) {
            for (var i2 = 0; i2 < old.length; ++i2) {
              var span = old[i2], marker = span.marker;
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
              if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
              }
            }
          }
          return nw;
        }
        function stretchSpansOverChange(doc2, change) {
          if (change.full) {
            return null;
          }
          var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;
          var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;
          if (!oldFirst && !oldLast) {
            return null;
          }
          var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
          var first = markedSpansBefore(oldFirst, startCh, isInsert);
          var last = markedSpansAfter(oldLast, endCh, isInsert);
          var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
          if (first) {
            for (var i2 = 0; i2 < first.length; ++i2) {
              var span = first[i2];
              if (span.to == null) {
                var found = getMarkedSpanFor(last, span.marker);
                if (!found) {
                  span.to = startCh;
                } else if (sameLine) {
                  span.to = found.to == null ? null : found.to + offset;
                }
              }
            }
          }
          if (last) {
            for (var i$12 = 0; i$12 < last.length; ++i$12) {
              var span$1 = last[i$12];
              if (span$1.to != null) {
                span$1.to += offset;
              }
              if (span$1.from == null) {
                var found$1 = getMarkedSpanFor(first, span$1.marker);
                if (!found$1) {
                  span$1.from = offset;
                  if (sameLine) {
                    (first || (first = [])).push(span$1);
                  }
                }
              } else {
                span$1.from += offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            }
          }
          if (first) {
            first = clearEmptySpans(first);
          }
          if (last && last != first) {
            last = clearEmptySpans(last);
          }
          var newMarkers = [first];
          if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first) {
              for (var i$22 = 0; i$22 < first.length; ++i$22) {
                if (first[i$22].to == null) {
                  (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
                }
              }
            }
            for (var i$3 = 0; i$3 < gap; ++i$3) {
              newMarkers.push(gapMarkers);
            }
            newMarkers.push(last);
          }
          return newMarkers;
        }
        function clearEmptySpans(spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
              spans.splice(i2--, 1);
            }
          }
          if (!spans.length) {
            return null;
          }
          return spans;
        }
        function removeReadOnlyRanges(doc2, from, to) {
          var markers = null;
          doc2.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) {
              for (var i4 = 0; i4 < line.markedSpans.length; ++i4) {
                var mark = line.markedSpans[i4].marker;
                if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                  (markers || (markers = [])).push(mark);
                }
              }
            }
          });
          if (!markers) {
            return null;
          }
          var parts = [{ from, to }];
          for (var i2 = 0; i2 < markers.length; ++i2) {
            var mk = markers[i2], m = mk.find(0);
            for (var j = 0; j < parts.length; ++j) {
              var p = parts[j];
              if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
                continue;
              }
              var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
              if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
                newParts.push({ from: p.from, to: m.from });
              }
              if (dto > 0 || !mk.inclusiveRight && !dto) {
                newParts.push({ from: m.to, to: p.to });
              }
              parts.splice.apply(parts, newParts);
              j += newParts.length - 3;
            }
          }
          return parts;
        }
        function detachMarkedSpans(line) {
          var spans = line.markedSpans;
          if (!spans) {
            return;
          }
          for (var i2 = 0; i2 < spans.length; ++i2) {
            spans[i2].marker.detachLine(line);
          }
          line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
          if (!spans) {
            return;
          }
          for (var i2 = 0; i2 < spans.length; ++i2) {
            spans[i2].marker.attachLine(line);
          }
          line.markedSpans = spans;
        }
        function extraLeft(marker) {
          return marker.inclusiveLeft ? -1 : 0;
        }
        function extraRight(marker) {
          return marker.inclusiveRight ? 1 : 0;
        }
        function compareCollapsedMarkers(a, b) {
          var lenDiff = a.lines.length - b.lines.length;
          if (lenDiff != 0) {
            return lenDiff;
          }
          var aPos = a.find(), bPos = b.find();
          var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
          if (fromCmp) {
            return -fromCmp;
          }
          var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
          if (toCmp) {
            return toCmp;
          }
          return b.id - a.id;
        }
        function collapsedSpanAtSide(line, start2) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
              sp = sps[i2];
              if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function collapsedSpanAtStart(line) {
          return collapsedSpanAtSide(line, true);
        }
        function collapsedSpanAtEnd(line) {
          return collapsedSpanAtSide(line, false);
        }
        function collapsedSpanAround(line, ch2) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              var sp = sps[i2];
              if (sp.marker.collapsed && (sp.from == null || sp.from < ch2) && (sp.to == null || sp.to > ch2) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {
          var line = getLine(doc2, lineNo2);
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              var sp = sps[i2];
              if (!sp.marker.collapsed) {
                continue;
              }
              var found = sp.marker.find(0);
              var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
              var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
              if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
                continue;
              }
              if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
                return true;
              }
            }
          }
        }
        function visualLine(line) {
          var merged;
          while (merged = collapsedSpanAtStart(line)) {
            line = merged.find(-1, true).line;
          }
          return line;
        }
        function visualLineEnd(line) {
          var merged;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return line;
        }
        function visualLineContinued(line) {
          var merged, lines;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
          }
          return lines;
        }
        function visualLineNo(doc2, lineN) {
          var line = getLine(doc2, lineN), vis = visualLine(line);
          if (line == vis) {
            return lineN;
          }
          return lineNo(vis);
        }
        function visualLineEndNo(doc2, lineN) {
          if (lineN > doc2.lastLine()) {
            return lineN;
          }
          var line = getLine(doc2, lineN), merged;
          if (!lineIsHidden(doc2, line)) {
            return lineN;
          }
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return lineNo(line) + 1;
        }
        function lineIsHidden(doc2, line) {
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
              sp = sps[i2];
              if (!sp.marker.collapsed) {
                continue;
              }
              if (sp.from == null) {
                return true;
              }
              if (sp.marker.widgetNode) {
                continue;
              }
              if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
                return true;
              }
            }
          }
        }
        function lineIsHiddenInner(doc2, line, span) {
          if (span.to == null) {
            var end = span.marker.find(1, true);
            return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
          }
          if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true;
          }
          for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
            sp = line.markedSpans[i2];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
              return true;
            }
          }
        }
        function heightAtLine(lineObj) {
          lineObj = visualLine(lineObj);
          var h = 0, chunk = lineObj.parent;
          for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
            var line = chunk.lines[i2];
            if (line == lineObj) {
              break;
            } else {
              h += line.height;
            }
          }
          for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
              var cur = p.children[i$12];
              if (cur == chunk) {
                break;
              } else {
                h += cur.height;
              }
            }
          }
          return h;
        }
        function lineLength(line) {
          if (line.height == 0) {
            return 0;
          }
          var len = line.text.length, merged, cur = line;
          while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
          }
          cur = line;
          while (merged = collapsedSpanAtEnd(cur)) {
            var found$1 = merged.find(0, true);
            len -= cur.text.length - found$1.from.ch;
            cur = found$1.to.line;
            len += cur.text.length - found$1.to.ch;
          }
          return len;
        }
        function findMaxLine(cm) {
          var d = cm.display, doc2 = cm.doc;
          d.maxLine = getLine(doc2, doc2.first);
          d.maxLineLength = lineLength(d.maxLine);
          d.maxLineChanged = true;
          doc2.iter(function(line) {
            var len = lineLength(line);
            if (len > d.maxLineLength) {
              d.maxLineLength = len;
              d.maxLine = line;
            }
          });
        }
        var Line2 = function(text, markedSpans, estimateHeight2) {
          this.text = text;
          attachMarkedSpans(this, markedSpans);
          this.height = estimateHeight2 ? estimateHeight2(this) : 1;
        };
        Line2.prototype.lineNo = function() {
          return lineNo(this);
        };
        eventMixin(Line2);
        function updateLine(line, text, markedSpans, estimateHeight2) {
          line.text = text;
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
          if (line.order != null) {
            line.order = null;
          }
          detachMarkedSpans(line);
          attachMarkedSpans(line, markedSpans);
          var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        }
        function cleanUpLine(line) {
          line.parent = null;
          detachMarkedSpans(line);
        }
        var styleToClassCache = {}, styleToClassCacheWithMode = {};
        function interpretTokenStyle(style, options) {
          if (!style || /^\s*$/.test(style)) {
            return null;
          }
          var cache2 = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
          return cache2[style] || (cache2[style] = style.replace(/\S+/g, "cm-$&"));
        }
        function buildLineContent(cm, lineView) {
          var content2 = eltP("span", null, null, webkit2 ? "padding-right: .1px" : null);
          var builder = {
            pre: eltP("pre", [content2], "CodeMirror-line"),
            content: content2,
            col: 0,
            pos: 0,
            cm,
            trailingSpace: false,
            splitSpaces: cm.getOption("lineWrapping")
          };
          lineView.measure = {};
          for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
            var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
              builder.addToken = buildTokenBadBidi(builder.addToken, order);
            }
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
              if (line.styleClasses.bgClass) {
                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
              }
              if (line.styleClasses.textClass) {
                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
              }
            }
            if (builder.map.length == 0) {
              builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            }
            if (i2 == 0) {
              lineView.measure.map = builder.map;
              lineView.measure.cache = {};
            } else {
              (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
              (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
          }
          if (webkit2) {
            var last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
              builder.content.className = "cm-tab-wrap-hack";
            }
          }
          signal(cm, "renderLine", cm, lineView.line, builder.pre);
          if (builder.pre.className) {
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
          }
          return builder;
        }
        function defaultSpecialCharPlaceholder(ch2) {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + ch2.charCodeAt(0).toString(16);
          token.setAttribute("aria-label", token.title);
          return token;
        }
        function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
          if (!text) {
            return;
          }
          var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
          var special = builder.cm.state.specialChars, mustWrap = false;
          var content2;
          if (!special.test(text)) {
            builder.col += text.length;
            content2 = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content2);
            if (ie3 && ie_version < 9) {
              mustWrap = true;
            }
            builder.pos += text.length;
          } else {
            content2 = document.createDocumentFragment();
            var pos = 0;
            while (true) {
              special.lastIndex = pos;
              var m = special.exec(text);
              var skipped = m ? m.index - pos : text.length - pos;
              if (skipped) {
                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                if (ie3 && ie_version < 9) {
                  content2.appendChild(elt("span", [txt]));
                } else {
                  content2.appendChild(txt);
                }
                builder.map.push(builder.pos, builder.pos + skipped, txt);
                builder.col += skipped;
                builder.pos += skipped;
              }
              if (!m) {
                break;
              }
              pos += skipped + 1;
              var txt$1 = void 0;
              if (m[0] == "	") {
                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                txt$1 = content2.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                txt$1.setAttribute("role", "presentation");
                txt$1.setAttribute("cm-text", "	");
                builder.col += tabWidth;
              } else if (m[0] == "\r" || m[0] == "\n") {
                txt$1 = content2.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
                txt$1.setAttribute("cm-text", m[0]);
                builder.col += 1;
              } else {
                txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
                txt$1.setAttribute("cm-text", m[0]);
                if (ie3 && ie_version < 9) {
                  content2.appendChild(elt("span", [txt$1]));
                } else {
                  content2.appendChild(txt$1);
                }
                builder.col += 1;
              }
              builder.map.push(builder.pos, builder.pos + 1, txt$1);
              builder.pos++;
            }
          }
          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
          if (style || startStyle || endStyle || mustWrap || css || attributes) {
            var fullStyle = style || "";
            if (startStyle) {
              fullStyle += startStyle;
            }
            if (endStyle) {
              fullStyle += endStyle;
            }
            var token = elt("span", [content2], fullStyle, css);
            if (attributes) {
              for (var attr in attributes) {
                if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                  token.setAttribute(attr, attributes[attr]);
                }
              }
            }
            return builder.content.appendChild(token);
          }
          builder.content.appendChild(content2);
        }
        function splitSpaces(text, trailingBefore) {
          if (text.length > 1 && !/  /.test(text)) {
            return text;
          }
          var spaceBefore = trailingBefore, result = "";
          for (var i2 = 0; i2 < text.length; i2++) {
            var ch2 = text.charAt(i2);
            if (ch2 == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
              ch2 = "\xA0";
            }
            result += ch2;
            spaceBefore = ch2 == " ";
          }
          return result;
        }
        function buildTokenBadBidi(inner, order) {
          return function(builder, text, style, startStyle, endStyle, css, attributes) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            var start2 = builder.pos, end = start2 + text.length;
            for (; ; ) {
              var part = void 0;
              for (var i2 = 0; i2 < order.length; i2++) {
                part = order[i2];
                if (part.to > start2 && part.from <= start2) {
                  break;
                }
              }
              if (part.to >= end) {
                return inner(builder, text, style, startStyle, endStyle, css, attributes);
              }
              inner(builder, text.slice(0, part.to - start2), style, startStyle, null, css, attributes);
              startStyle = null;
              text = text.slice(part.to - start2);
              start2 = part.to;
            }
          };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
          var widget = !ignoreWidget && marker.widgetNode;
          if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
          }
          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
              widget = builder.content.appendChild(document.createElement("span"));
            }
            widget.setAttribute("cm-marker", marker.id);
          }
          if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
          }
          builder.pos += size;
          builder.trailingSpace = false;
        }
        function insertLineContent(line, builder, styles) {
          var spans = line.markedSpans, allText = line.text, at = 0;
          if (!spans) {
            for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
              builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
            }
            return;
          }
          var len = allText.length, pos = 0, i2 = 1, text = "", style, css;
          var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
          for (; ; ) {
            if (nextChange == pos) {
              spanStyle = spanEndStyle = spanStartStyle = css = "";
              attributes = null;
              collapsed = null;
              nextChange = Infinity;
              var foundBookmarks = [], endStyles = void 0;
              for (var j = 0; j < spans.length; ++j) {
                var sp = spans[j], m = sp.marker;
                if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                  foundBookmarks.push(m);
                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                    nextChange = sp.to;
                    spanEndStyle = "";
                  }
                  if (m.className) {
                    spanStyle += " " + m.className;
                  }
                  if (m.css) {
                    css = (css ? css + ";" : "") + m.css;
                  }
                  if (m.startStyle && sp.from == pos) {
                    spanStartStyle += " " + m.startStyle;
                  }
                  if (m.endStyle && sp.to == nextChange) {
                    (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                  }
                  if (m.title) {
                    (attributes || (attributes = {})).title = m.title;
                  }
                  if (m.attributes) {
                    for (var attr in m.attributes) {
                      (attributes || (attributes = {}))[attr] = m.attributes[attr];
                    }
                  }
                  if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                    collapsed = sp;
                  }
                } else if (sp.from > pos && nextChange > sp.from) {
                  nextChange = sp.from;
                }
              }
              if (endStyles) {
                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                  if (endStyles[j$1 + 1] == nextChange) {
                    spanEndStyle += " " + endStyles[j$1];
                  }
                }
              }
              if (!collapsed || collapsed.from == pos) {
                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                }
              }
              if (collapsed && (collapsed.from || 0) == pos) {
                buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                if (collapsed.to == null) {
                  return;
                }
                if (collapsed.to == pos) {
                  collapsed = false;
                }
              }
            }
            if (pos >= len) {
              break;
            }
            var upto = Math.min(len, nextChange);
            while (true) {
              if (text) {
                var end = pos + text.length;
                if (!collapsed) {
                  var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                  builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
                }
                if (end >= upto) {
                  text = text.slice(upto - pos);
                  pos = upto;
                  break;
                }
                pos = end;
                spanStartStyle = "";
              }
              text = allText.slice(at, at = styles[i2++]);
              style = interpretTokenStyle(styles[i2++], builder.cm.options);
            }
          }
        }
        function LineView2(doc2, line, lineN) {
          this.line = line;
          this.rest = visualLineContinued(line);
          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
          this.node = this.text = null;
          this.hidden = lineIsHidden(doc2, line);
        }
        function buildViewArray(cm, from, to) {
          var array2 = [], nextPos;
          for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView2(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array2.push(view);
          }
          return array2;
        }
        var operationGroup = null;
        function pushOperation(op) {
          if (operationGroup) {
            operationGroup.ops.push(op);
          } else {
            op.ownsGroup = operationGroup = {
              ops: [op],
              delayedCallbacks: []
            };
          }
        }
        function fireCallbacksForOps(group) {
          var callbacks = group.delayedCallbacks, i2 = 0;
          do {
            for (; i2 < callbacks.length; i2++) {
              callbacks[i2].call(null);
            }
            for (var j = 0; j < group.ops.length; j++) {
              var op = group.ops[j];
              if (op.cursorActivityHandlers) {
                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                }
              }
            }
          } while (i2 < callbacks.length);
        }
        function finishOperation(op, endCb) {
          var group = op.ownsGroup;
          if (!group) {
            return;
          }
          try {
            fireCallbacksForOps(group);
          } finally {
            operationGroup = null;
            endCb(group);
          }
        }
        var orphanDelayedCallbacks = null;
        function signalLater(emitter, type) {
          var arr = getHandlers(emitter, type);
          if (!arr.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2), list;
          if (operationGroup) {
            list = operationGroup.delayedCallbacks;
          } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
          } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
          }
          var loop = function(i4) {
            list.push(function() {
              return arr[i4].apply(null, args);
            });
          };
          for (var i2 = 0; i2 < arr.length; ++i2)
            loop(i2);
        }
        function fireOrphanDelayed() {
          var delayed = orphanDelayedCallbacks;
          orphanDelayedCallbacks = null;
          for (var i2 = 0; i2 < delayed.length; ++i2) {
            delayed[i2]();
          }
        }
        function updateLineForChanges(cm, lineView, lineN, dims) {
          for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            if (type == "text") {
              updateLineText(cm, lineView);
            } else if (type == "gutter") {
              updateLineGutter(cm, lineView, lineN, dims);
            } else if (type == "class") {
              updateLineClasses(cm, lineView);
            } else if (type == "widget") {
              updateLineWidgets(cm, lineView, dims);
            }
          }
          lineView.changes = null;
        }
        function ensureLineWrapped(lineView) {
          if (lineView.node == lineView.text) {
            lineView.node = elt("div", null, null, "position: relative");
            if (lineView.text.parentNode) {
              lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            }
            lineView.node.appendChild(lineView.text);
            if (ie3 && ie_version < 8) {
              lineView.node.style.zIndex = 2;
            }
          }
          return lineView.node;
        }
        function updateLineBackground(cm, lineView) {
          var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
          if (cls) {
            cls += " CodeMirror-linebackground";
          }
          if (lineView.background) {
            if (cls) {
              lineView.background.className = cls;
            } else {
              lineView.background.parentNode.removeChild(lineView.background);
              lineView.background = null;
            }
          } else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
            cm.display.input.setUneditable(lineView.background);
          }
        }
        function getLineContent(cm, lineView) {
          var ext = cm.display.externalMeasured;
          if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
          }
          return buildLineContent(cm, lineView);
        }
        function updateLineText(cm, lineView) {
          var cls = lineView.text.className;
          var built = getLineContent(cm, lineView);
          if (lineView.text == lineView.node) {
            lineView.node = built.pre;
          }
          lineView.text.parentNode.replaceChild(built.pre, lineView.text);
          lineView.text = built.pre;
          if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
          } else if (cls) {
            lineView.text.className = cls;
          }
        }
        function updateLineClasses(cm, lineView) {
          updateLineBackground(cm, lineView);
          if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
          } else if (lineView.node != lineView.text) {
            lineView.node.className = "";
          }
          var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
          lineView.text.className = textClass || "";
        }
        function updateLineGutter(cm, lineView, lineN, dims) {
          if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
          }
          if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
          }
          if (lineView.line.gutterClass) {
            var wrap = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap.insertBefore(lineView.gutterBackground, lineView.text);
          }
          var markers = lineView.line.gutterMarkers;
          if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            gutterWrap.setAttribute("aria-hidden", "true");
            cm.display.input.setUneditable(gutterWrap);
            wrap$1.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass) {
              gutterWrap.className += " " + lineView.line.gutterClass;
            }
            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
              lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
            }
            if (markers) {
              for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
                var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
                if (found) {
                  gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                }
              }
            }
          }
        }
        function updateLineWidgets(cm, lineView, dims) {
          if (lineView.alignable) {
            lineView.alignable = null;
          }
          var isWidget = classTest("CodeMirror-linewidget");
          for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
            next = node.nextSibling;
            if (isWidget.test(node.className)) {
              lineView.node.removeChild(node);
            }
          }
          insertLineWidgets(cm, lineView, dims);
        }
        function buildLineElement(cm, lineView, lineN, dims) {
          var built = getLineContent(cm, lineView);
          lineView.text = lineView.node = built.pre;
          if (built.bgClass) {
            lineView.bgClass = built.bgClass;
          }
          if (built.textClass) {
            lineView.textClass = built.textClass;
          }
          updateLineClasses(cm, lineView);
          updateLineGutter(cm, lineView, lineN, dims);
          insertLineWidgets(cm, lineView, dims);
          return lineView.node;
        }
        function insertLineWidgets(cm, lineView, dims) {
          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
            }
          }
        }
        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
          if (!line.widgets) {
            return;
          }
          var wrap = ensureLineWrapped(lineView);
          for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
            var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
            if (!widget.handleMouseEvents) {
              node.setAttribute("cm-ignore-events", "true");
            }
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above) {
              wrap.insertBefore(node, lineView.gutter || lineView.text);
            } else {
              wrap.appendChild(node);
            }
            signalLater(widget, "redraw");
          }
        }
        function positionLineWidget(widget, node, lineView, dims) {
          if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px";
            if (!widget.coverGutter) {
              width -= dims.gutterTotalWidth;
              node.style.paddingLeft = dims.gutterTotalWidth + "px";
            }
            node.style.width = width + "px";
          }
          if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = "relative";
            if (!widget.noHScroll) {
              node.style.marginLeft = -dims.gutterTotalWidth + "px";
            }
          }
        }
        function widgetHeight(widget) {
          if (widget.height != null) {
            return widget.height;
          }
          var cm = widget.doc.cm;
          if (!cm) {
            return 0;
          }
          if (!contains2(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            if (widget.coverGutter) {
              parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
            }
            if (widget.noHScroll) {
              parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
            }
            removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
          }
          return widget.height = widget.node.parentNode.offsetHeight;
        }
        function eventInWidget(display, e) {
          for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
            if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
              return true;
            }
          }
        }
        function paddingTop(display) {
          return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
          return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingH(display) {
          if (display.cachedPaddingH) {
            return display.cachedPaddingH;
          }
          var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
          var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
          var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
          if (!isNaN(data.left) && !isNaN(data.right)) {
            display.cachedPaddingH = data;
          }
          return data;
        }
        function scrollGap(cm) {
          return scrollerGap - cm.display.nativeBarWidth;
        }
        function displayWidth(cm) {
          return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
        }
        function displayHeight(cm) {
          return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
        }
        function ensureLineHeights(cm, lineView, rect) {
          var wrapping = cm.options.lineWrapping;
          var curWidth = wrapping && displayWidth(cm);
          if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
              lineView.measure.width = curWidth;
              var rects = lineView.text.firstChild.getClientRects();
              for (var i2 = 0; i2 < rects.length - 1; i2++) {
                var cur = rects[i2], next = rects[i2 + 1];
                if (Math.abs(cur.bottom - next.bottom) > 2) {
                  heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
              }
            }
            heights.push(rect.bottom - rect.top);
          }
        }
        function mapFromLineView(lineView, line, lineN) {
          if (lineView.line == line) {
            return { map: lineView.measure.map, cache: lineView.measure.cache };
          }
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            if (lineView.rest[i2] == line) {
              return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
            }
          }
          for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
            if (lineNo(lineView.rest[i$12]) > lineN) {
              return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
            }
          }
        }
        function updateExternalMeasurement(cm, line) {
          line = visualLine(line);
          var lineN = lineNo(line);
          var view = cm.display.externalMeasured = new LineView2(cm.doc, line, lineN);
          view.lineN = lineN;
          var built = view.built = buildLineContent(cm, view);
          view.text = built.pre;
          removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
          return view;
        }
        function measureChar(cm, line, ch2, bias) {
          return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch2, bias);
        }
        function findViewForLine(cm, lineN) {
          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)];
          }
          var ext = cm.display.externalMeasured;
          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext;
          }
        }
        function prepareMeasureForLine(cm, line) {
          var lineN = lineNo(line);
          var view = findViewForLine(cm, lineN);
          if (view && !view.text) {
            view = null;
          } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
          }
          if (!view) {
            view = updateExternalMeasurement(cm, line);
          }
          var info = mapFromLineView(view, line, lineN);
          return {
            line,
            view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
          };
        }
        function measureCharPrepared(cm, prepared, ch2, bias, varHeight) {
          if (prepared.before) {
            ch2 = -1;
          }
          var key = ch2 + (bias || ""), found;
          if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
          } else {
            if (!prepared.rect) {
              prepared.rect = prepared.view.text.getBoundingClientRect();
            }
            if (!prepared.hasHeights) {
              ensureLineHeights(cm, prepared.view, prepared.rect);
              prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch2, bias);
            if (!found.bogus) {
              prepared.cache[key] = found;
            }
          }
          return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
          };
        }
        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
        function nodeAndOffsetInLineMap(map3, ch2, bias) {
          var node, start2, end, collapse, mStart, mEnd;
          for (var i2 = 0; i2 < map3.length; i2 += 3) {
            mStart = map3[i2];
            mEnd = map3[i2 + 1];
            if (ch2 < mStart) {
              start2 = 0;
              end = 1;
              collapse = "left";
            } else if (ch2 < mEnd) {
              start2 = ch2 - mStart;
              end = start2 + 1;
            } else if (i2 == map3.length - 3 || ch2 == mEnd && map3[i2 + 3] > ch2) {
              end = mEnd - mStart;
              start2 = end - 1;
              if (ch2 >= mEnd) {
                collapse = "right";
              }
            }
            if (start2 != null) {
              node = map3[i2 + 2];
              if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
                collapse = bias;
              }
              if (bias == "left" && start2 == 0) {
                while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {
                  node = map3[(i2 -= 3) + 2];
                  collapse = "left";
                }
              }
              if (bias == "right" && start2 == mEnd - mStart) {
                while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {
                  node = map3[(i2 += 3) + 2];
                  collapse = "right";
                }
              }
              break;
            }
          }
          return { node, start: start2, end, collapse, coverStart: mStart, coverEnd: mEnd };
        }
        function getUsefulRect(rects, bias) {
          var rect = nullRect;
          if (bias == "left") {
            for (var i2 = 0; i2 < rects.length; i2++) {
              if ((rect = rects[i2]).left != rect.right) {
                break;
              }
            }
          } else {
            for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
              if ((rect = rects[i$12]).left != rect.right) {
                break;
              }
            }
          }
          return rect;
        }
        function measureCharInner(cm, prepared, ch2, bias) {
          var place = nodeAndOffsetInLineMap(prepared.map, ch2, bias);
          var node = place.node, start2 = place.start, end = place.end, collapse = place.collapse;
          var rect;
          if (node.nodeType == 3) {
            for (var i$12 = 0; i$12 < 4; i$12++) {
              while (start2 && isExtendingChar2(prepared.line.text.charAt(place.coverStart + start2))) {
                --start2;
              }
              while (place.coverStart + end < place.coverEnd && isExtendingChar2(prepared.line.text.charAt(place.coverStart + end))) {
                ++end;
              }
              if (ie3 && ie_version < 9 && start2 == 0 && end == place.coverEnd - place.coverStart) {
                rect = node.parentNode.getBoundingClientRect();
              } else {
                rect = getUsefulRect(range(node, start2, end).getClientRects(), bias);
              }
              if (rect.left || rect.right || start2 == 0) {
                break;
              }
              end = start2;
              start2 = start2 - 1;
              collapse = "right";
            }
            if (ie3 && ie_version < 11) {
              rect = maybeUpdateRectForZooming(cm.display.measure, rect);
            }
          } else {
            if (start2 > 0) {
              collapse = bias = "right";
            }
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
              rect = rects[bias == "right" ? rects.length - 1 : 0];
            } else {
              rect = node.getBoundingClientRect();
            }
          }
          if (ie3 && ie_version < 9 && !start2 && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan) {
              rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
            } else {
              rect = nullRect;
            }
          }
          var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
          var mid = (rtop + rbot) / 2;
          var heights = prepared.view.measure.heights;
          var i2 = 0;
          for (; i2 < heights.length - 1; i2++) {
            if (mid < heights[i2]) {
              break;
            }
          }
          var top2 = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
          var result = {
            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
            top: top2,
            bottom: bot
          };
          if (!rect.left && !rect.right) {
            result.bogus = true;
          }
          if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
          }
          return result;
        }
        function maybeUpdateRectForZooming(measure, rect) {
          if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
            return rect;
          }
          var scaleX = screen.logicalXDPI / screen.deviceXDPI;
          var scaleY = screen.logicalYDPI / screen.deviceYDPI;
          return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
          };
        }
        function clearLineMeasurementCacheFor(lineView) {
          if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest) {
              for (var i2 = 0; i2 < lineView.rest.length; i2++) {
                lineView.measure.caches[i2] = {};
              }
            }
          }
        }
        function clearLineMeasurementCache(cm) {
          cm.display.externalMeasure = null;
          removeChildren(cm.display.lineMeasure);
          for (var i2 = 0; i2 < cm.display.view.length; i2++) {
            clearLineMeasurementCacheFor(cm.display.view[i2]);
          }
        }
        function clearCaches(cm) {
          clearLineMeasurementCache(cm);
          cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
          if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true;
          }
          cm.display.lineNumChars = null;
        }
        function pageScrollX() {
          if (chrome3 && android) {
            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
          }
          return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
        }
        function pageScrollY() {
          if (chrome3 && android) {
            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
          }
          return window.pageYOffset || (document.documentElement || document.body).scrollTop;
        }
        function widgetTopHeight(lineObj) {
          var height = 0;
          if (lineObj.widgets) {
            for (var i2 = 0; i2 < lineObj.widgets.length; ++i2) {
              if (lineObj.widgets[i2].above) {
                height += widgetHeight(lineObj.widgets[i2]);
              }
            }
          }
          return height;
        }
        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
          if (!includeWidgets) {
            var height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
          }
          if (context == "line") {
            return rect;
          }
          if (!context) {
            context = "local";
          }
          var yOff = heightAtLine(lineObj);
          if (context == "local") {
            yOff += paddingTop(cm.display);
          } else {
            yOff -= cm.display.viewOffset;
          }
          if (context == "page" || context == "window") {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
          }
          rect.top += yOff;
          rect.bottom += yOff;
          return rect;
        }
        function fromCoordSystem(cm, coords, context) {
          if (context == "div") {
            return coords;
          }
          var left = coords.left, top2 = coords.top;
          if (context == "page") {
            left -= pageScrollX();
            top2 -= pageScrollY();
          } else if (context == "local" || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top2 += localBox.top;
          }
          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
          return { left: left - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
          if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line);
          }
          return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
          lineObj = lineObj || getLine(cm.doc, pos.line);
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          function get4(ch3, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch3, right ? "right" : "left", varHeight);
            if (right) {
              m.left = m.right;
            } else {
              m.right = m.left;
            }
            return intoCoordSystem(cm, lineObj, m, context);
          }
          var order = getOrder(lineObj, cm.doc.direction), ch2 = pos.ch, sticky = pos.sticky;
          if (ch2 >= lineObj.text.length) {
            ch2 = lineObj.text.length;
            sticky = "before";
          } else if (ch2 <= 0) {
            ch2 = 0;
            sticky = "after";
          }
          if (!order) {
            return get4(sticky == "before" ? ch2 - 1 : ch2, sticky == "before");
          }
          function getBidi(ch3, partPos2, invert) {
            var part = order[partPos2], right = part.level == 1;
            return get4(invert ? ch3 - 1 : ch3, right != invert);
          }
          var partPos = getBidiPartAt(order, ch2, sticky);
          var other = bidiOther;
          var val = getBidi(ch2, partPos, sticky == "before");
          if (other != null) {
            val.other = getBidi(ch2, other, sticky != "before");
          }
          return val;
        }
        function estimateCoords(cm, pos) {
          var left = 0;
          pos = clipPos(cm.doc, pos);
          if (!cm.options.lineWrapping) {
            left = charWidth(cm.display) * pos.ch;
          }
          var lineObj = getLine(cm.doc, pos.line);
          var top2 = heightAtLine(lineObj) + paddingTop(cm.display);
          return { left, right: left, top: top2, bottom: top2 + lineObj.height };
        }
        function PosWithInfo(line, ch2, sticky, outside, xRel) {
          var pos = Pos(line, ch2, sticky);
          pos.xRel = xRel;
          if (outside) {
            pos.outside = outside;
          }
          return pos;
        }
        function coordsChar(cm, x, y) {
          var doc2 = cm.doc;
          y += cm.display.viewOffset;
          if (y < 0) {
            return PosWithInfo(doc2.first, 0, null, -1, -1);
          }
          var lineN = lineAtHeight(doc2, y), last = doc2.first + doc2.size - 1;
          if (lineN > last) {
            return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);
          }
          if (x < 0) {
            x = 0;
          }
          var lineObj = getLine(doc2, lineN);
          for (; ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y);
            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
            if (!collapsed) {
              return found;
            }
            var rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN) {
              return rangeEnd;
            }
            lineObj = getLine(doc2, lineN = rangeEnd.line);
          }
        }
        function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
          y -= widgetTopHeight(lineObj);
          var end = lineObj.text.length;
          var begin = findFirst(function(ch2) {
            return measureCharPrepared(cm, preparedMeasure, ch2 - 1).bottom <= y;
          }, end, 0);
          end = findFirst(function(ch2) {
            return measureCharPrepared(cm, preparedMeasure, ch2).top > y;
          }, begin, end);
          return { begin, end };
        }
        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
        }
        function boxIsAfter(box2, x, y, left) {
          return box2.bottom <= y ? false : box2.top > y ? true : (left ? box2.left : box2.right) > x;
        }
        function coordsCharInner(cm, lineObj, lineNo2, x, y) {
          y -= heightAtLine(lineObj);
          var preparedMeasure = prepareMeasureForLine(cm, lineObj);
          var widgetHeight2 = widgetTopHeight(lineObj);
          var begin = 0, end = lineObj.text.length, ltr = true;
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end = ltr ? part.to : part.from - 1;
          }
          var chAround = null, boxAround = null;
          var ch2 = findFirst(function(ch3) {
            var box2 = measureCharPrepared(cm, preparedMeasure, ch3);
            box2.top += widgetHeight2;
            box2.bottom += widgetHeight2;
            if (!boxIsAfter(box2, x, y, false)) {
              return false;
            }
            if (box2.top <= y && box2.left <= x) {
              chAround = ch3;
              boxAround = box2;
            }
            return true;
          }, begin, end);
          var baseX, sticky, outside = false;
          if (boxAround) {
            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
            ch2 = chAround + (atStart ? 0 : 1);
            sticky = atStart ? "after" : "before";
            baseX = atLeft ? boxAround.left : boxAround.right;
          } else {
            if (!ltr && (ch2 == end || ch2 == begin)) {
              ch2++;
            }
            sticky = ch2 == 0 ? "after" : ch2 == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch2 - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
            var coords = cursorCoords(cm, Pos(lineNo2, ch2, sticky), "line", lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
          }
          ch2 = skipExtendingChars(lineObj.text, ch2, 1);
          return PosWithInfo(lineNo2, ch2, sticky, outside, x - baseX);
        }
        function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
          var index = findFirst(function(i2) {
            var part2 = order[i2], ltr2 = part2.level != 1;
            return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
          }, 0, order.length - 1);
          var part = order[index];
          if (index > 0) {
            var ltr = part.level != 1;
            var start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
            if (boxIsAfter(start2, x, y, true) && start2.top > y) {
              part = order[index - 1];
            }
          }
          return part;
        }
        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
          var begin = ref.begin;
          var end = ref.end;
          if (/\s/.test(lineObj.text.charAt(end - 1))) {
            end--;
          }
          var part = null, closestDist = null;
          for (var i2 = 0; i2 < order.length; i2++) {
            var p = order[i2];
            if (p.from >= end || p.to <= begin) {
              continue;
            }
            var ltr = p.level != 1;
            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
            var dist = endX < x ? x - endX + 1e9 : endX - x;
            if (!part || closestDist > dist) {
              part = p;
              closestDist = dist;
            }
          }
          if (!part) {
            part = order[order.length - 1];
          }
          if (part.from < begin) {
            part = { from: begin, to: part.to, level: part.level };
          }
          if (part.to > end) {
            part = { from: part.from, to: end, level: part.level };
          }
          return part;
        }
        var measureText;
        function textHeight(display) {
          if (display.cachedTextHeight != null) {
            return display.cachedTextHeight;
          }
          if (measureText == null) {
            measureText = elt("pre", null, "CodeMirror-line-like");
            for (var i2 = 0; i2 < 49; ++i2) {
              measureText.appendChild(document.createTextNode("x"));
              measureText.appendChild(elt("br"));
            }
            measureText.appendChild(document.createTextNode("x"));
          }
          removeChildrenAndAdd(display.measure, measureText);
          var height = measureText.offsetHeight / 50;
          if (height > 3) {
            display.cachedTextHeight = height;
          }
          removeChildren(display.measure);
          return height || 1;
        }
        function charWidth(display) {
          if (display.cachedCharWidth != null) {
            return display.cachedCharWidth;
          }
          var anchor = elt("span", "xxxxxxxxxx");
          var pre = elt("pre", [anchor], "CodeMirror-line-like");
          removeChildrenAndAdd(display.measure, pre);
          var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
          if (width > 2) {
            display.cachedCharWidth = width;
          }
          return width || 10;
        }
        function getDimensions(cm) {
          var d = cm.display, left = {}, width = {};
          var gutterLeft = d.gutters.clientLeft;
          for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
            var id = cm.display.gutterSpecs[i2].className;
            left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
            width[id] = n.clientWidth;
          }
          return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
          };
        }
        function compensateForHScroll(display) {
          return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
        }
        function estimateHeight(cm) {
          var th2 = textHeight(cm.display), wrapping = cm.options.lineWrapping;
          var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
          return function(line) {
            if (lineIsHidden(cm.doc, line)) {
              return 0;
            }
            var widgetsHeight = 0;
            if (line.widgets) {
              for (var i2 = 0; i2 < line.widgets.length; i2++) {
                if (line.widgets[i2].height) {
                  widgetsHeight += line.widgets[i2].height;
                }
              }
            }
            if (wrapping) {
              return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th2;
            } else {
              return widgetsHeight + th2;
            }
          };
        }
        function estimateLineHeights(cm) {
          var doc2 = cm.doc, est = estimateHeight(cm);
          doc2.iter(function(line) {
            var estHeight = est(line);
            if (estHeight != line.height) {
              updateLineHeight(line, estHeight);
            }
          });
        }
        function posFromMouse(cm, e, liberal, forRect) {
          var display = cm.display;
          if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
            return null;
          }
          var x, y, space = display.lineSpace.getBoundingClientRect();
          try {
            x = e.clientX - space.left;
            y = e.clientY - space.top;
          } catch (e$1) {
            return null;
          }
          var coords = coordsChar(cm, x, y), line;
          if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn2(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
          }
          return coords;
        }
        function findViewIndex(cm, n) {
          if (n >= cm.display.viewTo) {
            return null;
          }
          n -= cm.display.viewFrom;
          if (n < 0) {
            return null;
          }
          var view = cm.display.view;
          for (var i2 = 0; i2 < view.length; i2++) {
            n -= view[i2].size;
            if (n < 0) {
              return i2;
            }
          }
        }
        function regChange(cm, from, to, lendiff) {
          if (from == null) {
            from = cm.doc.first;
          }
          if (to == null) {
            to = cm.doc.first + cm.doc.size;
          }
          if (!lendiff) {
            lendiff = 0;
          }
          var display = cm.display;
          if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
            display.updateLineNumbers = from;
          }
          cm.curOp.viewChanged = true;
          if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
              resetView(cm);
            }
          } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
              resetView(cm);
            } else {
              display.viewFrom += lendiff;
              display.viewTo += lendiff;
            }
          } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
          } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
              display.view = display.view.slice(cut.index);
              display.viewFrom = cut.lineN;
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            if (cut$1) {
              display.view = display.view.slice(0, cut$1.index);
              display.viewTo = cut$1.lineN;
            } else {
              resetView(cm);
            }
          } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
              display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          }
          var ext = display.externalMeasured;
          if (ext) {
            if (to < ext.lineN) {
              ext.lineN += lendiff;
            } else if (from < ext.lineN + ext.size) {
              display.externalMeasured = null;
            }
          }
        }
        function regLineChange(cm, line, type) {
          cm.curOp.viewChanged = true;
          var display = cm.display, ext = cm.display.externalMeasured;
          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
          if (line < display.viewFrom || line >= display.viewTo) {
            return;
          }
          var lineView = display.view[findViewIndex(cm, line)];
          if (lineView.node == null) {
            return;
          }
          var arr = lineView.changes || (lineView.changes = []);
          if (indexOf(arr, type) == -1) {
            arr.push(type);
          }
        }
        function resetView(cm) {
          cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
          cm.display.view = [];
          cm.display.viewOffset = 0;
        }
        function viewCuttingPoint(cm, oldN, newN, dir) {
          var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return { index, lineN: newN };
          }
          var n = cm.display.viewFrom;
          for (var i2 = 0; i2 < index; i2++) {
            n += view[i2].size;
          }
          if (n != oldN) {
            if (dir > 0) {
              if (index == view.length - 1) {
                return null;
              }
              diff = n + view[index].size - oldN;
              index++;
            } else {
              diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
          }
          while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1)) {
              return null;
            }
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
          }
          return { index, lineN: newN };
        }
        function adjustView(cm, from, to) {
          var display = cm.display, view = display.view;
          if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
          } else {
            if (display.viewFrom > from) {
              display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            } else if (display.viewFrom < from) {
              display.view = display.view.slice(findViewIndex(cm, from));
            }
            display.viewFrom = from;
            if (display.viewTo < to) {
              display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            } else if (display.viewTo > to) {
              display.view = display.view.slice(0, findViewIndex(cm, to));
            }
          }
          display.viewTo = to;
        }
        function countDirtyView(cm) {
          var view = cm.display.view, dirty = 0;
          for (var i2 = 0; i2 < view.length; i2++) {
            var lineView = view[i2];
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
              ++dirty;
            }
          }
          return dirty;
        }
        function updateSelection(cm) {
          cm.display.input.showSelection(cm.display.input.prepareSelection());
        }
        function prepareSelection(cm, primary) {
          if (primary === void 0)
            primary = true;
          var doc2 = cm.doc, result = {};
          var curFragment = result.cursors = document.createDocumentFragment();
          var selFragment = result.selection = document.createDocumentFragment();
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            if (!primary && i2 == doc2.sel.primIndex) {
              continue;
            }
            var range2 = doc2.sel.ranges[i2];
            if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
              continue;
            }
            var collapsed = range2.empty();
            if (collapsed || cm.options.showCursorWhenSelecting) {
              drawSelectionCursor(cm, range2.head, curFragment);
            }
            if (!collapsed) {
              drawSelectionRange(cm, range2, selFragment);
            }
          }
          return result;
        }
        function drawSelectionCursor(cm, head, output) {
          var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
          var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
          cursor.style.left = pos.left + "px";
          cursor.style.top = pos.top + "px";
          cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
          if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
            var charPos = charCoords(cm, head, "div", null, null);
            if (charPos.right - charPos.left > 0) {
              cursor.style.width = charPos.right - charPos.left + "px";
            }
          }
          if (pos.other) {
            var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "";
            otherCursor.style.left = pos.other.left + "px";
            otherCursor.style.top = pos.other.top + "px";
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
          }
        }
        function cmpCoords(a, b) {
          return a.top - b.top || a.left - b.left;
        }
        function drawSelectionRange(cm, range2, output) {
          var display = cm.display, doc2 = cm.doc;
          var fragment = document.createDocumentFragment();
          var padding = paddingH(cm.display), leftSide = padding.left;
          var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
          var docLTR = doc2.direction == "ltr";
          function add(left, top2, width, bottom) {
            if (top2 < 0) {
              top2 = 0;
            }
            top2 = Math.round(top2);
            bottom = Math.round(bottom);
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top2 + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top2) + "px"));
          }
          function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc2, line);
            var lineLen = lineObj.text.length;
            var start2, end;
            function coords(ch2, bias) {
              return charCoords(cm, Pos(line, ch2), "div", lineObj, bias);
            }
            function wrapX(pos, dir, side) {
              var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
              var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
              var ch2 = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
              return coords(ch2, prop2)[prop2];
            }
            var order = getOrder(lineObj, doc2.direction);
            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
              var ltr = dir == "ltr";
              var fromPos = coords(from, ltr ? "left" : "right");
              var toPos = coords(to - 1, ltr ? "right" : "left");
              var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
              var first = i2 == 0, last = !order || i2 == order.length - 1;
              if (toPos.top - fromPos.top <= 3) {
                var openLeft = (docLTR ? openStart : openEnd) && first;
                var openRight = (docLTR ? openEnd : openStart) && last;
                var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                add(left, fromPos.top, right - left, fromPos.bottom);
              } else {
                var topLeft, topRight, botLeft, botRight;
                if (ltr) {
                  topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                  topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                  botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                  botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                } else {
                  topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                  topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                  botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                  botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
                }
                add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                if (fromPos.bottom < toPos.top) {
                  add(leftSide, fromPos.bottom, null, toPos.top);
                }
                add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
              }
              if (!start2 || cmpCoords(fromPos, start2) < 0) {
                start2 = fromPos;
              }
              if (cmpCoords(toPos, start2) < 0) {
                start2 = toPos;
              }
              if (!end || cmpCoords(fromPos, end) < 0) {
                end = fromPos;
              }
              if (cmpCoords(toPos, end) < 0) {
                end = toPos;
              }
            });
            return { start: start2, end };
          }
          var sFrom = range2.from(), sTo = range2.to();
          if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
          } else {
            var fromLine = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
              if (leftEnd.top < rightStart.top - 2) {
                add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
              } else {
                add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
              }
            }
            if (leftEnd.bottom < rightStart.top) {
              add(leftSide, leftEnd.bottom, null, rightStart.top);
            }
          }
          output.appendChild(fragment);
        }
        function restartBlink(cm) {
          if (!cm.state.focused) {
            return;
          }
          var display = cm.display;
          clearInterval(display.blinker);
          var on2 = true;
          display.cursorDiv.style.visibility = "";
          if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function() {
              if (!cm.hasFocus()) {
                onBlur(cm);
              }
              display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
            }, cm.options.cursorBlinkRate);
          } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
          }
        }
        function ensureFocus(cm) {
          if (!cm.hasFocus()) {
            cm.display.input.focus();
            if (!cm.state.focused) {
              onFocus(cm);
            }
          }
        }
        function delayBlurEvent(cm) {
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            if (cm.state.delayingBlurEvent) {
              cm.state.delayingBlurEvent = false;
              if (cm.state.focused) {
                onBlur(cm);
              }
            }
          }, 100);
        }
        function onFocus(cm, e) {
          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false;
          }
          if (cm.options.readOnly == "nocursor") {
            return;
          }
          if (!cm.state.focused) {
            signal(cm, "focus", cm, e);
            cm.state.focused = true;
            addClass(cm.display.wrapper, "CodeMirror-focused");
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
              cm.display.input.reset();
              if (webkit2) {
                setTimeout(function() {
                  return cm.display.input.reset(true);
                }, 20);
              }
            }
            cm.display.input.receivedFocus();
          }
          restartBlink(cm);
        }
        function onBlur(cm, e) {
          if (cm.state.delayingBlurEvent) {
            return;
          }
          if (cm.state.focused) {
            signal(cm, "blur", cm, e);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, "CodeMirror-focused");
          }
          clearInterval(cm.display.blinker);
          setTimeout(function() {
            if (!cm.state.focused) {
              cm.display.shift = false;
            }
          }, 150);
        }
        function updateHeightsInViewport(cm) {
          var display = cm.display;
          var prevBottom = display.lineDiv.offsetTop;
          var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
          var oldHeight = display.lineDiv.getBoundingClientRect().top;
          var mustScroll = 0;
          for (var i2 = 0; i2 < display.view.length; i2++) {
            var cur = display.view[i2], wrapping = cm.options.lineWrapping;
            var height = void 0, width = 0;
            if (cur.hidden) {
              continue;
            }
            oldHeight += cur.line.height;
            if (ie3 && ie_version < 8) {
              var bot = cur.node.offsetTop + cur.node.offsetHeight;
              height = bot - prevBottom;
              prevBottom = bot;
            } else {
              var box2 = cur.node.getBoundingClientRect();
              height = box2.bottom - box2.top;
              if (!wrapping && cur.text.firstChild) {
                width = cur.text.firstChild.getBoundingClientRect().right - box2.left - 1;
              }
            }
            var diff = cur.line.height - height;
            if (diff > 5e-3 || diff < -5e-3) {
              if (oldHeight < viewTop) {
                mustScroll -= diff;
              }
              updateLineHeight(cur.line, height);
              updateWidgetHeight(cur.line);
              if (cur.rest) {
                for (var j = 0; j < cur.rest.length; j++) {
                  updateWidgetHeight(cur.rest[j]);
                }
              }
            }
            if (width > cm.display.sizerWidth) {
              var chWidth = Math.ceil(width / charWidth(cm.display));
              if (chWidth > cm.display.maxLineLength) {
                cm.display.maxLineLength = chWidth;
                cm.display.maxLine = cur.line;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (Math.abs(mustScroll) > 2) {
            display.scroller.scrollTop += mustScroll;
          }
        }
        function updateWidgetHeight(line) {
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; ++i2) {
              var w = line.widgets[i2], parent = w.node.parentNode;
              if (parent) {
                w.height = parent.offsetHeight;
              }
            }
          }
        }
        function visibleLines(display, doc2, viewport) {
          var top2 = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
          top2 = Math.floor(top2 - paddingTop(display));
          var bottom = viewport && viewport.bottom != null ? viewport.bottom : top2 + display.wrapper.clientHeight;
          var from = lineAtHeight(doc2, top2), to = lineAtHeight(doc2, bottom);
          if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from) {
              from = ensureFrom;
              to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
              from = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);
              to = ensureTo;
            }
          }
          return { from, to: Math.max(to, from + 1) };
        }
        function maybeScrollWindow(cm, rect) {
          if (signalDOMEvent(cm, "scrollCursorIntoView")) {
            return;
          }
          var display = cm.display, box2 = display.sizer.getBoundingClientRect(), doScroll = null;
          if (rect.top + box2.top < 0) {
            doScroll = true;
          } else if (rect.bottom + box2.top > (window.innerHeight || document.documentElement.clientHeight)) {
            doScroll = false;
          }
          if (doScroll != null && !phantom) {
            var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
          }
        }
        function scrollPosIntoView(cm, pos, end, margin) {
          if (margin == null) {
            margin = 0;
          }
          var rect;
          if (!cm.options.lineWrapping && pos == end) {
            end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
          }
          for (var limit = 0; limit < 5; limit++) {
            var changed = false;
            var coords = cursorCoords(cm, pos);
            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
            rect = {
              left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            var scrollPos = calculateScrollPos(cm, rect);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
              updateScrollTop(cm, scrollPos.scrollTop);
              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                changed = true;
              }
            }
            if (scrollPos.scrollLeft != null) {
              setScrollLeft(cm, scrollPos.scrollLeft);
              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                changed = true;
              }
            }
            if (!changed) {
              break;
            }
          }
          return rect;
        }
        function scrollIntoView(cm, rect) {
          var scrollPos = calculateScrollPos(cm, rect);
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
          }
        }
        function calculateScrollPos(cm, rect) {
          var display = cm.display, snapMargin = textHeight(cm.display);
          if (rect.top < 0) {
            rect.top = 0;
          }
          var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
          var screen2 = displayHeight(cm), result = {};
          if (rect.bottom - rect.top > screen2) {
            rect.bottom = rect.top + screen2;
          }
          var docBottom = cm.doc.height + paddingVert(display);
          var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
          if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
          } else if (rect.bottom > screentop + screen2) {
            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
            if (newTop != screentop) {
              result.scrollTop = newTop;
            }
          }
          var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
          var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
          var screenw = displayWidth(cm) - display.gutters.offsetWidth;
          var tooWide = rect.right - rect.left > screenw;
          if (tooWide) {
            rect.right = rect.left + screenw;
          }
          if (rect.left < 10) {
            result.scrollLeft = 0;
          } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
          } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
          }
          return result;
        }
        function addToScrollTop(cm, top2) {
          if (top2 == null) {
            return;
          }
          resolveScrollToPos(cm);
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
        }
        function ensureCursorVisible(cm) {
          resolveScrollToPos(cm);
          var cur = cm.getCursor();
          cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
        }
        function scrollToCoords(cm, x, y) {
          if (x != null || y != null) {
            resolveScrollToPos(cm);
          }
          if (x != null) {
            cm.curOp.scrollLeft = x;
          }
          if (y != null) {
            cm.curOp.scrollTop = y;
          }
        }
        function scrollToRange(cm, range2) {
          resolveScrollToPos(cm);
          cm.curOp.scrollToPos = range2;
        }
        function resolveScrollToPos(cm) {
          var range2 = cm.curOp.scrollToPos;
          if (range2) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
            scrollToCoordsRange(cm, from, to, range2.margin);
          }
        }
        function scrollToCoordsRange(cm, from, to, margin) {
          var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
          });
          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
        }
        function updateScrollTop(cm, val) {
          if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return;
          }
          if (!gecko3) {
            updateDisplaySimple(cm, { top: val });
          }
          setScrollTop(cm, val, true);
          if (gecko3) {
            updateDisplaySimple(cm);
          }
          startWorker(cm, 100);
        }
        function setScrollTop(cm, val, forceScroll) {
          val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
          if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return;
          }
          cm.doc.scrollTop = val;
          cm.display.scrollbars.setScrollTop(val);
          if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val;
          }
        }
        function setScrollLeft(cm, val, isScroller, forceScroll) {
          val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
          if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
            return;
          }
          cm.doc.scrollLeft = val;
          alignHorizontally(cm);
          if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val;
          }
          cm.display.scrollbars.setScrollLeft(val);
        }
        function measureForScrollbars(cm) {
          var d = cm.display, gutterW = d.gutters.offsetWidth;
          var docH = Math.round(cm.doc.height + paddingVert(cm.display));
          return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
          };
        }
        var NativeScrollbars = function(place, scroll, cm) {
          this.cm = cm;
          var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
          var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
          vert.tabIndex = horiz.tabIndex = -1;
          place(vert);
          place(horiz);
          on(vert, "scroll", function() {
            if (vert.clientHeight) {
              scroll(vert.scrollTop, "vertical");
            }
          });
          on(horiz, "scroll", function() {
            if (horiz.clientWidth) {
              scroll(horiz.scrollLeft, "horizontal");
            }
          });
          this.checkedZeroWidth = false;
          if (ie3 && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
          }
        };
        NativeScrollbars.prototype.update = function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
          }
          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
        };
        NativeScrollbars.prototype.setScrollLeft = function(pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
          }
        };
        NativeScrollbars.prototype.setScrollTop = function(pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
          }
        };
        NativeScrollbars.prototype.zeroWidthHack = function() {
          var w = mac2 && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
          this.disableHoriz = new Delayed();
          this.disableVert = new Delayed();
        };
        NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
          bar.style.pointerEvents = "auto";
          function maybeDisable() {
            var box2 = bar.getBoundingClientRect();
            var elt2 = type == "vert" ? document.elementFromPoint(box2.right - 1, (box2.top + box2.bottom) / 2) : document.elementFromPoint((box2.right + box2.left) / 2, box2.bottom - 1);
            if (elt2 != bar) {
              bar.style.pointerEvents = "none";
            } else {
              delay.set(1e3, maybeDisable);
            }
          }
          delay.set(1e3, maybeDisable);
        };
        NativeScrollbars.prototype.clear = function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        };
        var NullScrollbars = function() {
        };
        NullScrollbars.prototype.update = function() {
          return { bottom: 0, right: 0 };
        };
        NullScrollbars.prototype.setScrollLeft = function() {
        };
        NullScrollbars.prototype.setScrollTop = function() {
        };
        NullScrollbars.prototype.clear = function() {
        };
        function updateScrollbars(cm, measure) {
          if (!measure) {
            measure = measureForScrollbars(cm);
          }
          var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
          updateScrollbarsInner(cm, measure);
          for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
              updateHeightsInViewport(cm);
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
          }
        }
        function updateScrollbarsInner(cm, measure) {
          var d = cm.display;
          var sizes = d.scrollbars.update(measure);
          d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
          d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
          d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
          if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = "block";
            d.scrollbarFiller.style.height = sizes.bottom + "px";
            d.scrollbarFiller.style.width = sizes.right + "px";
          } else {
            d.scrollbarFiller.style.display = "";
          }
          if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = "block";
            d.gutterFiller.style.height = sizes.bottom + "px";
            d.gutterFiller.style.width = measure.gutterWidth + "px";
          } else {
            d.gutterFiller.style.display = "";
          }
        }
        var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
        function initScrollbars(cm) {
          if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass) {
              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
          }
          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, "mousedown", function() {
              if (cm.state.focused) {
                setTimeout(function() {
                  return cm.display.input.focus();
                }, 0);
              }
            });
            node.setAttribute("cm-not-content", "true");
          }, function(pos, axis) {
            if (axis == "horizontal") {
              setScrollLeft(cm, pos);
            } else {
              updateScrollTop(cm, pos);
            }
          }, cm);
          if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        var nextOpId = 0;
        function startOperation(cm) {
          cm.curOp = {
            cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: 0,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId,
            markArrays: null
          };
          pushOperation(cm.curOp);
        }
        function endOperation(cm) {
          var op = cm.curOp;
          if (op) {
            finishOperation(op, function(group) {
              for (var i2 = 0; i2 < group.ops.length; i2++) {
                group.ops[i2].cm.curOp = null;
              }
              endOperations(group);
            });
          }
        }
        function endOperations(group) {
          var ops = group.ops;
          for (var i2 = 0; i2 < ops.length; i2++) {
            endOperation_R1(ops[i2]);
          }
          for (var i$12 = 0; i$12 < ops.length; i$12++) {
            endOperation_W1(ops[i$12]);
          }
          for (var i$22 = 0; i$22 < ops.length; i$22++) {
            endOperation_R2(ops[i$22]);
          }
          for (var i$3 = 0; i$3 < ops.length; i$3++) {
            endOperation_W2(ops[i$3]);
          }
          for (var i$4 = 0; i$4 < ops.length; i$4++) {
            endOperation_finish(ops[i$4]);
          }
        }
        function endOperation_R1(op) {
          var cm = op.cm, display = cm.display;
          maybeClipScrollbars(cm);
          if (op.updateMaxLine) {
            findMaxLine(cm);
          }
          op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
          op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
        }
        function endOperation_W1(op) {
          op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
        }
        function endOperation_R2(op) {
          var cm = op.cm, display = cm.display;
          if (op.updatedDisplay) {
            updateHeightsInViewport(cm);
          }
          op.barMeasure = measureForScrollbars(cm);
          if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
          }
          if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection();
          }
        }
        function endOperation_W2(op) {
          var cm = op.cm;
          if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
              setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            }
            cm.display.maxLineChanged = false;
          }
          var takeFocus = op.focus && op.focus == activeElt();
          if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
          }
          if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure);
          }
          if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure);
          }
          if (op.selectionChanged) {
            restartBlink(cm);
          }
          if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing);
          }
          if (takeFocus) {
            ensureFocus(op.cm);
          }
        }
        function endOperation_finish(op) {
          var cm = op.cm, display = cm.display, doc2 = cm.doc;
          if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update);
          }
          if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
            display.wheelStartX = display.wheelStartY = null;
          }
          if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll);
          }
          if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true);
          }
          if (op.scrollToPos) {
            var rect = scrollPosIntoView(cm, clipPos(doc2, op.scrollToPos.from), clipPos(doc2, op.scrollToPos.to), op.scrollToPos.margin);
            maybeScrollWindow(cm, rect);
          }
          var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
          if (hidden) {
            for (var i2 = 0; i2 < hidden.length; ++i2) {
              if (!hidden[i2].lines.length) {
                signal(hidden[i2], "hide");
              }
            }
          }
          if (unhidden) {
            for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
              if (unhidden[i$12].lines.length) {
                signal(unhidden[i$12], "unhide");
              }
            }
          }
          if (display.wrapper.offsetHeight) {
            doc2.scrollTop = cm.display.scroller.scrollTop;
          }
          if (op.changeObjs) {
            signal(cm, "changes", cm, op.changeObjs);
          }
          if (op.update) {
            op.update.finish();
          }
        }
        function runInOp(cm, f) {
          if (cm.curOp) {
            return f();
          }
          startOperation(cm);
          try {
            return f();
          } finally {
            endOperation(cm);
          }
        }
        function operation(cm, f) {
          return function() {
            if (cm.curOp) {
              return f.apply(cm, arguments);
            }
            startOperation(cm);
            try {
              return f.apply(cm, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function methodOp(f) {
          return function() {
            if (this.curOp) {
              return f.apply(this, arguments);
            }
            startOperation(this);
            try {
              return f.apply(this, arguments);
            } finally {
              endOperation(this);
            }
          };
        }
        function docMethodOp(f) {
          return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) {
              return f.apply(this, arguments);
            }
            startOperation(cm);
            try {
              return f.apply(this, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function startWorker(cm, time) {
          if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind(highlightWorker, cm));
          }
        }
        function highlightWorker(cm) {
          var doc2 = cm.doc;
          if (doc2.highlightFrontier >= cm.display.viewTo) {
            return;
          }
          var end = +new Date() + cm.options.workTime;
          var context = getContextBefore(cm, doc2.highlightFrontier);
          var changedLines = [];
          doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
              var oldStyles = line.styles;
              var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
              var highlighted = highlightLine(cm, line, context, true);
              if (resetState) {
                context.state = resetState;
              }
              line.styles = highlighted.styles;
              var oldCls = line.styleClasses, newCls = highlighted.classes;
              if (newCls) {
                line.styleClasses = newCls;
              } else if (oldCls) {
                line.styleClasses = null;
              }
              var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
              for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
                ischange = oldStyles[i2] != line.styles[i2];
              }
              if (ischange) {
                changedLines.push(context.line);
              }
              line.stateAfter = context.save();
              context.nextLine();
            } else {
              if (line.text.length <= cm.options.maxHighlightLength) {
                processLine(cm, line.text, context);
              }
              line.stateAfter = context.line % 5 == 0 ? context.save() : null;
              context.nextLine();
            }
            if (+new Date() > end) {
              startWorker(cm, cm.options.workDelay);
              return true;
            }
          });
          doc2.highlightFrontier = context.line;
          doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
          if (changedLines.length) {
            runInOp(cm, function() {
              for (var i2 = 0; i2 < changedLines.length; i2++) {
                regLineChange(cm, changedLines[i2], "text");
              }
            });
          }
        }
        var DisplayUpdate = function(cm, viewport, force) {
          var display = cm.display;
          this.viewport = viewport;
          this.visible = visibleLines(display, cm.doc, viewport);
          this.editorIsHidden = !display.wrapper.offsetWidth;
          this.wrapperHeight = display.wrapper.clientHeight;
          this.wrapperWidth = display.wrapper.clientWidth;
          this.oldDisplayWidth = displayWidth(cm);
          this.force = force;
          this.dims = getDimensions(cm);
          this.events = [];
        };
        DisplayUpdate.prototype.signal = function(emitter, type) {
          if (hasHandler(emitter, type)) {
            this.events.push(arguments);
          }
        };
        DisplayUpdate.prototype.finish = function() {
          for (var i2 = 0; i2 < this.events.length; i2++) {
            signal.apply(null, this.events[i2]);
          }
        };
        function maybeClipScrollbars(cm) {
          var display = cm.display;
          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + "px";
            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
            display.scrollbarsClipped = true;
          }
        }
        function selectionSnapshot(cm) {
          if (cm.hasFocus()) {
            return null;
          }
          var active = activeElt();
          if (!active || !contains2(cm.display.lineDiv, active)) {
            return null;
          }
          var result = { activeElt: active };
          if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
              result.anchorNode = sel.anchorNode;
              result.anchorOffset = sel.anchorOffset;
              result.focusNode = sel.focusNode;
              result.focusOffset = sel.focusOffset;
            }
          }
          return result;
        }
        function restoreSelection(snapshot) {
          if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
            return;
          }
          snapshot.activeElt.focus();
          if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
            var sel = window.getSelection(), range2 = document.createRange();
            range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range2.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range2);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
          }
        }
        function updateDisplayIfNeeded(cm, update) {
          var display = cm.display, doc2 = cm.doc;
          if (update.editorIsHidden) {
            resetView(cm);
            return false;
          }
          if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
            return false;
          }
          if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
          }
          var end = doc2.first + doc2.size;
          var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
          var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
          if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc2.first, display.viewFrom);
          }
          if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end, display.viewTo);
          }
          if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
          }
          var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
          adjustView(cm, from, to);
          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
          cm.display.mover.style.top = display.viewOffset + "px";
          var toUpdate = countDirtyView(cm);
          if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
            return false;
          }
          var selSnapshot = selectionSnapshot(cm);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "none";
          }
          patchDisplay(cm, display.updateLineNumbers, update.dims);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "";
          }
          display.renderedView = display.view;
          restoreSelection(selSnapshot);
          removeChildren(display.cursorDiv);
          removeChildren(display.selectionDiv);
          display.gutters.style.height = display.sizer.style.minHeight = 0;
          if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
          }
          display.updateLineNumbers = null;
          return true;
        }
        function postUpdateDisplay(cm, update) {
          var viewport = update.viewport;
          for (var first = true; ; first = false) {
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
              if (viewport && viewport.top != null) {
                viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
              }
              update.visible = visibleLines(cm.display, cm.doc, viewport);
              if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
                break;
              }
            } else if (first) {
              update.visible = visibleLines(cm.display, cm.doc, viewport);
            }
            if (!updateDisplayIfNeeded(cm, update)) {
              break;
            }
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
          }
          update.signal(cm, "update", cm);
          if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
          }
        }
        function updateDisplaySimple(cm, viewport) {
          var update = new DisplayUpdate(cm, viewport);
          if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
          }
        }
        function patchDisplay(cm, updateNumbersFrom, dims) {
          var display = cm.display, lineNumbers2 = cm.options.lineNumbers;
          var container = display.lineDiv, cur = container.firstChild;
          function rm2(node2) {
            var next = node2.nextSibling;
            if (webkit2 && mac2 && cm.display.currentWheelTarget == node2) {
              node2.style.display = "none";
            } else {
              node2.parentNode.removeChild(node2);
            }
            return next;
          }
          var view = display.view, lineN = display.viewFrom;
          for (var i2 = 0; i2 < view.length; i2++) {
            var lineView = view[i2];
            if (lineView.hidden)
              ;
            else if (!lineView.node || lineView.node.parentNode != container) {
              var node = buildLineElement(cm, lineView, lineN, dims);
              container.insertBefore(node, cur);
            } else {
              while (cur != lineView.node) {
                cur = rm2(cur);
              }
              var updateNumber = lineNumbers2 && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
              if (lineView.changes) {
                if (indexOf(lineView.changes, "gutter") > -1) {
                  updateNumber = false;
                }
                updateLineForChanges(cm, lineView, lineN, dims);
              }
              if (updateNumber) {
                removeChildren(lineView.lineNumber);
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
              }
              cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
          }
          while (cur) {
            cur = rm2(cur);
          }
        }
        function updateGutterSpace(display) {
          var width = display.gutters.offsetWidth;
          display.sizer.style.marginLeft = width + "px";
          signalLater(display, "gutterChanged", display);
        }
        function setDocumentHeight(cm, measure) {
          cm.display.sizer.style.minHeight = measure.docHeight + "px";
          cm.display.heightForcer.style.top = measure.docHeight + "px";
          cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
        }
        function alignHorizontally(cm) {
          var display = cm.display, view = display.view;
          if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
            return;
          }
          var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
          var gutterW = display.gutters.offsetWidth, left = comp + "px";
          for (var i2 = 0; i2 < view.length; i2++) {
            if (!view[i2].hidden) {
              if (cm.options.fixedGutter) {
                if (view[i2].gutter) {
                  view[i2].gutter.style.left = left;
                }
                if (view[i2].gutterBackground) {
                  view[i2].gutterBackground.style.left = left;
                }
              }
              var align = view[i2].alignable;
              if (align) {
                for (var j = 0; j < align.length; j++) {
                  align[j].style.left = left;
                }
              }
            }
          }
          if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + "px";
          }
        }
        function maybeUpdateLineNumberWidth(cm) {
          if (!cm.options.lineNumbers) {
            return false;
          }
          var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
          if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = "";
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + "px";
            updateGutterSpace(cm.display);
            return true;
          }
          return false;
        }
        function getGutters(gutters2, lineNumbers2) {
          var result = [], sawLineNumbers = false;
          for (var i2 = 0; i2 < gutters2.length; i2++) {
            var name2 = gutters2[i2], style = null;
            if (typeof name2 != "string") {
              style = name2.style;
              name2 = name2.className;
            }
            if (name2 == "CodeMirror-linenumbers") {
              if (!lineNumbers2) {
                continue;
              } else {
                sawLineNumbers = true;
              }
            }
            result.push({ className: name2, style });
          }
          if (lineNumbers2 && !sawLineNumbers) {
            result.push({ className: "CodeMirror-linenumbers", style: null });
          }
          return result;
        }
        function renderGutters(display) {
          var gutters2 = display.gutters, specs = display.gutterSpecs;
          removeChildren(gutters2);
          display.lineGutter = null;
          for (var i2 = 0; i2 < specs.length; ++i2) {
            var ref = specs[i2];
            var className = ref.className;
            var style = ref.style;
            var gElt = gutters2.appendChild(elt("div", null, "CodeMirror-gutter " + className));
            if (style) {
              gElt.style.cssText = style;
            }
            if (className == "CodeMirror-linenumbers") {
              display.lineGutter = gElt;
              gElt.style.width = (display.lineNumWidth || 1) + "px";
            }
          }
          gutters2.style.display = specs.length ? "" : "none";
          updateGutterSpace(display);
        }
        function updateGutters(cm) {
          renderGutters(cm.display);
          regChange(cm);
          alignHorizontally(cm);
        }
        function Display(place, doc2, input, options) {
          var d = this;
          this.input = input;
          d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
          d.scrollbarFiller.setAttribute("cm-not-content", "true");
          d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
          d.gutterFiller.setAttribute("cm-not-content", "true");
          d.lineDiv = eltP("div", null, "CodeMirror-code");
          d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
          d.cursorDiv = elt("div", null, "CodeMirror-cursors");
          d.measure = elt("div", null, "CodeMirror-measure");
          d.lineMeasure = elt("div", null, "CodeMirror-measure");
          d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
          var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
          d.mover = elt("div", [lines], null, "position: relative");
          d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
          d.sizerWidth = null;
          d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
          d.gutters = elt("div", null, "CodeMirror-gutters");
          d.lineGutter = null;
          d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
          d.scroller.setAttribute("tabIndex", "-1");
          d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
          d.wrapper.setAttribute("translate", "no");
          if (ie3 && ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
          }
          if (!webkit2 && !(gecko3 && mobile)) {
            d.scroller.draggable = true;
          }
          if (place) {
            if (place.appendChild) {
              place.appendChild(d.wrapper);
            } else {
              place(d.wrapper);
            }
          }
          d.viewFrom = d.viewTo = doc2.first;
          d.reportedViewFrom = d.reportedViewTo = doc2.first;
          d.view = [];
          d.renderedView = null;
          d.externalMeasured = null;
          d.viewOffset = 0;
          d.lastWrapHeight = d.lastWrapWidth = 0;
          d.updateLineNumbers = null;
          d.nativeBarWidth = d.barHeight = d.barWidth = 0;
          d.scrollbarsClipped = false;
          d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
          d.alignWidgets = false;
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
          d.maxLine = null;
          d.maxLineLength = 0;
          d.maxLineChanged = false;
          d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
          d.shift = false;
          d.selForContextMenu = null;
          d.activeTouch = null;
          d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
          renderGutters(d);
          input.init(d);
        }
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        if (ie3) {
          wheelPixelsPerUnit = -0.53;
        } else if (gecko3) {
          wheelPixelsPerUnit = 15;
        } else if (chrome3) {
          wheelPixelsPerUnit = -0.7;
        } else if (safari3) {
          wheelPixelsPerUnit = -1 / 3;
        }
        function wheelEventDelta(e) {
          var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
          if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
            dx = e.detail;
          }
          if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
            dy = e.detail;
          } else if (dy == null) {
            dy = e.wheelDelta;
          }
          return { x: dx, y: dy };
        }
        function wheelEventPixels(e) {
          var delta = wheelEventDelta(e);
          delta.x *= wheelPixelsPerUnit;
          delta.y *= wheelPixelsPerUnit;
          return delta;
        }
        function onScrollWheel(cm, e) {
          var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
          var pixelsPerUnit = wheelPixelsPerUnit;
          if (e.deltaMode === 0) {
            dx = e.deltaX;
            dy = e.deltaY;
            pixelsPerUnit = 1;
          }
          var display = cm.display, scroll = display.scroller;
          var canScrollX = scroll.scrollWidth > scroll.clientWidth;
          var canScrollY = scroll.scrollHeight > scroll.clientHeight;
          if (!(dx && canScrollX || dy && canScrollY)) {
            return;
          }
          if (dy && mac2 && webkit2) {
            outer:
              for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                for (var i2 = 0; i2 < view.length; i2++) {
                  if (view[i2].node == cur) {
                    cm.display.currentWheelTarget = cur;
                    break outer;
                  }
                }
              }
          }
          if (dx && !gecko3 && !presto && pixelsPerUnit != null) {
            if (dy && canScrollY) {
              updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
            }
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
            if (!dy || dy && canScrollY) {
              e_preventDefault(e);
            }
            display.wheelStartX = null;
            return;
          }
          if (dy && pixelsPerUnit != null) {
            var pixels = dy * pixelsPerUnit;
            var top2 = cm.doc.scrollTop, bot = top2 + display.wrapper.clientHeight;
            if (pixels < 0) {
              top2 = Math.max(0, top2 + pixels - 50);
            } else {
              bot = Math.min(cm.doc.height, bot + pixels + 50);
            }
            updateDisplaySimple(cm, { top: top2, bottom: bot });
          }
          if (wheelSamples < 20 && e.deltaMode !== 0) {
            if (display.wheelStartX == null) {
              display.wheelStartX = scroll.scrollLeft;
              display.wheelStartY = scroll.scrollTop;
              display.wheelDX = dx;
              display.wheelDY = dy;
              setTimeout(function() {
                if (display.wheelStartX == null) {
                  return;
                }
                var movedX = scroll.scrollLeft - display.wheelStartX;
                var movedY = scroll.scrollTop - display.wheelStartY;
                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                display.wheelStartX = display.wheelStartY = null;
                if (!sample) {
                  return;
                }
                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                ++wheelSamples;
              }, 200);
            } else {
              display.wheelDX += dx;
              display.wheelDY += dy;
            }
          }
        }
        var Selection = function(ranges, primIndex) {
          this.ranges = ranges;
          this.primIndex = primIndex;
        };
        Selection.prototype.primary = function() {
          return this.ranges[this.primIndex];
        };
        Selection.prototype.equals = function(other) {
          if (other == this) {
            return true;
          }
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
          }
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            var here = this.ranges[i2], there = other.ranges[i2];
            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
              return false;
            }
          }
          return true;
        };
        Selection.prototype.deepCopy = function() {
          var out = [];
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            out[i2] = new Range4(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
          }
          return new Selection(out, this.primIndex);
        };
        Selection.prototype.somethingSelected = function() {
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            if (!this.ranges[i2].empty()) {
              return true;
            }
          }
          return false;
        };
        Selection.prototype.contains = function(pos, end) {
          if (!end) {
            end = pos;
          }
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            var range2 = this.ranges[i2];
            if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
              return i2;
            }
          }
          return -1;
        };
        var Range4 = function(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        };
        Range4.prototype.from = function() {
          return minPos(this.anchor, this.head);
        };
        Range4.prototype.to = function() {
          return maxPos(this.anchor, this.head);
        };
        Range4.prototype.empty = function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        };
        function normalizeSelection(cm, ranges, primIndex) {
          var mayTouch = cm && cm.options.selectionsMayTouch;
          var prim = ranges[primIndex];
          ranges.sort(function(a, b) {
            return cmp(a.from(), b.from());
          });
          primIndex = indexOf(ranges, prim);
          for (var i2 = 1; i2 < ranges.length; i2++) {
            var cur = ranges[i2], prev = ranges[i2 - 1];
            var diff = cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
              var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
              var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
              if (i2 <= primIndex) {
                --primIndex;
              }
              ranges.splice(--i2, 2, new Range4(inv ? to : from, inv ? from : to));
            }
          }
          return new Selection(ranges, primIndex);
        }
        function simpleSelection(anchor, head) {
          return new Selection([new Range4(anchor, head || anchor)], 0);
        }
        function changeEnd(change) {
          if (!change.text) {
            return change.to;
          }
          return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
        }
        function adjustForChange(pos, change) {
          if (cmp(pos, change.from) < 0) {
            return pos;
          }
          if (cmp(pos, change.to) <= 0) {
            return changeEnd(change);
          }
          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch2 = pos.ch;
          if (pos.line == change.to.line) {
            ch2 += changeEnd(change).ch - change.to.ch;
          }
          return Pos(line, ch2);
        }
        function computeSelAfterChange(doc2, change) {
          var out = [];
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            var range2 = doc2.sel.ranges[i2];
            out.push(new Range4(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
          }
          return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
        }
        function offsetPos(pos, old, nw) {
          if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
          } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch);
          }
        }
        function computeReplacedSel(doc2, changes, hint) {
          var out = [];
          var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
          for (var i2 = 0; i2 < changes.length; i2++) {
            var change = changes[i2];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == "around") {
              var range2 = doc2.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
              out[i2] = new Range4(inv ? to : from, inv ? from : to);
            } else {
              out[i2] = new Range4(from, from);
            }
          }
          return new Selection(out, doc2.sel.primIndex);
        }
        function loadMode(cm) {
          cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
          resetModeState(cm);
        }
        function resetModeState(cm) {
          cm.doc.iter(function(line) {
            if (line.stateAfter) {
              line.stateAfter = null;
            }
            if (line.styles) {
              line.styles = null;
            }
          });
          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
          startWorker(cm, 100);
          cm.state.modeGen++;
          if (cm.curOp) {
            regChange(cm);
          }
        }
        function isWholeLineUpdate(doc2, change) {
          return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
        }
        function updateDoc(doc2, change, markedSpans, estimateHeight2) {
          function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
          }
          function update(line, text2, spans) {
            updateLine(line, text2, spans, estimateHeight2);
            signalLater(line, "change", line, change);
          }
          function linesFor(start2, end) {
            var result = [];
            for (var i2 = start2; i2 < end; ++i2) {
              result.push(new Line2(text[i2], spansFor(i2), estimateHeight2));
            }
            return result;
          }
          var from = change.from, to = change.to, text = change.text;
          var firstLine = getLine(doc2, from.line), lastLine = getLine(doc2, to.line);
          var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
          if (change.full) {
            doc2.insert(0, linesFor(0, text.length));
            doc2.remove(text.length, doc2.size - text.length);
          } else if (isWholeLineUpdate(doc2, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines) {
              doc2.remove(from.line, nlines);
            }
            if (added.length) {
              doc2.insert(from.line, added);
            }
          } else if (firstLine == lastLine) {
            if (text.length == 1) {
              update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
              var added$1 = linesFor(1, text.length - 1);
              added$1.push(new Line2(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
              update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
              doc2.insert(from.line + 1, added$1);
            }
          } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc2.remove(from.line + 1, nlines);
          } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            if (nlines > 1) {
              doc2.remove(from.line + 1, nlines - 1);
            }
            doc2.insert(from.line + 1, added$2);
          }
          signalLater(doc2, "change", doc2, change);
        }
        function linkedDocs(doc2, f, sharedHistOnly) {
          function propagate(doc3, skip, sharedHist) {
            if (doc3.linked) {
              for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
                var rel = doc3.linked[i2];
                if (rel.doc == skip) {
                  continue;
                }
                var shared = sharedHist && rel.sharedHist;
                if (sharedHistOnly && !shared) {
                  continue;
                }
                f(rel.doc, shared);
                propagate(rel.doc, doc3, shared);
              }
            }
          }
          propagate(doc2, null, true);
        }
        function attachDoc(cm, doc2) {
          if (doc2.cm) {
            throw new Error("This document is already in use.");
          }
          cm.doc = doc2;
          doc2.cm = cm;
          estimateLineHeights(cm);
          loadMode(cm);
          setDirectionClass(cm);
          cm.options.direction = doc2.direction;
          if (!cm.options.lineWrapping) {
            findMaxLine(cm);
          }
          cm.options.mode = doc2.modeOption;
          regChange(cm);
        }
        function setDirectionClass(cm) {
          (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
        }
        function directionChanged(cm) {
          runInOp(cm, function() {
            setDirectionClass(cm);
            regChange(cm);
          });
        }
        function History(prev) {
          this.done = [];
          this.undone = [];
          this.undoDepth = prev ? prev.undoDepth : Infinity;
          this.lastModTime = this.lastSelTime = 0;
          this.lastOp = this.lastSelOp = null;
          this.lastOrigin = this.lastSelOrigin = null;
          this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
        }
        function historyChangeFromChange(doc2, change) {
          var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
          attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
          linkedDocs(doc2, function(doc3) {
            return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
          }, true);
          return histChange;
        }
        function clearSelectionEvents(array2) {
          while (array2.length) {
            var last = lst(array2);
            if (last.ranges) {
              array2.pop();
            } else {
              break;
            }
          }
        }
        function lastChangeEvent(hist, force) {
          if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
          } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
          } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
          }
        }
        function addChangeToHistory(doc2, change, selAfter, opId) {
          var hist = doc2.history;
          hist.undone.length = 0;
          var time = +new Date(), cur;
          var last;
          if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
              last.to = changeEnd(change);
            } else {
              cur.changes.push(historyChangeFromChange(doc2, change));
            }
          } else {
            var before = lst(hist.done);
            if (!before || !before.ranges) {
              pushSelectionToHistory(doc2.sel, hist.done);
            }
            cur = {
              changes: [historyChangeFromChange(doc2, change)],
              generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
              hist.done.shift();
              if (!hist.done[0].ranges) {
                hist.done.shift();
              }
            }
          }
          hist.done.push(selAfter);
          hist.generation = ++hist.maxGeneration;
          hist.lastModTime = hist.lastSelTime = time;
          hist.lastOp = hist.lastSelOp = opId;
          hist.lastOrigin = hist.lastSelOrigin = change.origin;
          if (!last) {
            signal(doc2, "historyAdded");
          }
        }
        function selectionEventCanBeMerged(doc2, origin, prev, sel) {
          var ch2 = origin.charAt(0);
          return ch2 == "*" || ch2 == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
        }
        function addSelectionToHistory(doc2, sel, opId, options) {
          var hist = doc2.history, origin = options && options.origin;
          if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
            hist.done[hist.done.length - 1] = sel;
          } else {
            pushSelectionToHistory(sel, hist.done);
          }
          hist.lastSelTime = +new Date();
          hist.lastSelOrigin = origin;
          hist.lastSelOp = opId;
          if (options && options.clearRedo !== false) {
            clearSelectionEvents(hist.undone);
          }
        }
        function pushSelectionToHistory(sel, dest) {
          var top2 = lst(dest);
          if (!(top2 && top2.ranges && top2.equals(sel))) {
            dest.push(sel);
          }
        }
        function attachLocalSpans(doc2, change, from, to) {
          var existing = change["spans_" + doc2.id], n = 0;
          doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {
            if (line.markedSpans) {
              (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;
            }
            ++n;
          });
        }
        function removeClearedSpans(spans) {
          if (!spans) {
            return null;
          }
          var out;
          for (var i2 = 0; i2 < spans.length; ++i2) {
            if (spans[i2].marker.explicitlyCleared) {
              if (!out) {
                out = spans.slice(0, i2);
              }
            } else if (out) {
              out.push(spans[i2]);
            }
          }
          return !out ? spans : out.length ? out : null;
        }
        function getOldSpans(doc2, change) {
          var found = change["spans_" + doc2.id];
          if (!found) {
            return null;
          }
          var nw = [];
          for (var i2 = 0; i2 < change.text.length; ++i2) {
            nw.push(removeClearedSpans(found[i2]));
          }
          return nw;
        }
        function mergeOldSpans(doc2, change) {
          var old = getOldSpans(doc2, change);
          var stretched = stretchSpansOverChange(doc2, change);
          if (!old) {
            return stretched;
          }
          if (!stretched) {
            return old;
          }
          for (var i2 = 0; i2 < old.length; ++i2) {
            var oldCur = old[i2], stretchCur = stretched[i2];
            if (oldCur && stretchCur) {
              spans:
                for (var j = 0; j < stretchCur.length; ++j) {
                  var span = stretchCur[j];
                  for (var k = 0; k < oldCur.length; ++k) {
                    if (oldCur[k].marker == span.marker) {
                      continue spans;
                    }
                  }
                  oldCur.push(span);
                }
            } else if (stretchCur) {
              old[i2] = stretchCur;
            }
          }
          return old;
        }
        function copyHistoryArray(events, newGroup, instantiateSel) {
          var copy = [];
          for (var i2 = 0; i2 < events.length; ++i2) {
            var event = events[i2];
            if (event.ranges) {
              copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
              continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (var j = 0; j < changes.length; ++j) {
              var change = changes[j], m = void 0;
              newChanges.push({ from: change.from, to: change.to, text: change.text });
              if (newGroup) {
                for (var prop2 in change) {
                  if (m = prop2.match(/^spans_(\d+)$/)) {
                    if (indexOf(newGroup, Number(m[1])) > -1) {
                      lst(newChanges)[prop2] = change[prop2];
                      delete change[prop2];
                    }
                  }
                }
              }
            }
          }
          return copy;
        }
        function extendRange(range2, head, other, extend2) {
          if (extend2) {
            var anchor = range2.anchor;
            if (other) {
              var posBefore = cmp(head, anchor) < 0;
              if (posBefore != cmp(other, anchor) < 0) {
                anchor = head;
                head = other;
              } else if (posBefore != cmp(head, other) < 0) {
                head = other;
              }
            }
            return new Range4(anchor, head);
          } else {
            return new Range4(other || head, head);
          }
        }
        function extendSelection(doc2, head, other, options, extend2) {
          if (extend2 == null) {
            extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
          }
          setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend2)], 0), options);
        }
        function extendSelections(doc2, heads, options) {
          var out = [];
          var extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            out[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend2);
          }
          var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
          setSelection(doc2, newSel, options);
        }
        function replaceOneSelection(doc2, i2, range2, options) {
          var ranges = doc2.sel.ranges.slice(0);
          ranges[i2] = range2;
          setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
        }
        function setSimpleSelection(doc2, anchor, head, options) {
          setSelection(doc2, simpleSelection(anchor, head), options);
        }
        function filterSelectionChange(doc2, sel, options) {
          var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
              this.ranges = [];
              for (var i2 = 0; i2 < ranges.length; i2++) {
                this.ranges[i2] = new Range4(clipPos(doc2, ranges[i2].anchor), clipPos(doc2, ranges[i2].head));
              }
            },
            origin: options && options.origin
          };
          signal(doc2, "beforeSelectionChange", doc2, obj);
          if (doc2.cm) {
            signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
          }
          if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
          } else {
            return sel;
          }
        }
        function setSelectionReplaceHistory(doc2, sel, options) {
          var done = doc2.history.done, last = lst(done);
          if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc2, sel, options);
          } else {
            setSelection(doc2, sel, options);
          }
        }
        function setSelection(doc2, sel, options) {
          setSelectionNoUndo(doc2, sel, options);
          addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
        }
        function setSelectionNoUndo(doc2, sel, options) {
          if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
            sel = filterSelectionChange(doc2, sel, options);
          }
          var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
          setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
          if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
            ensureCursorVisible(doc2.cm);
          }
        }
        function setSelectionInner(doc2, sel) {
          if (sel.equals(doc2.sel)) {
            return;
          }
          doc2.sel = sel;
          if (doc2.cm) {
            doc2.cm.curOp.updateInput = 1;
            doc2.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc2.cm);
          }
          signalLater(doc2, "cursorActivity", doc2);
        }
        function reCheckSelection(doc2) {
          setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
        }
        function skipAtomicInSelection(doc2, sel, bias, mayClear) {
          var out;
          for (var i2 = 0; i2 < sel.ranges.length; i2++) {
            var range2 = sel.ranges[i2];
            var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];
            var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
            var newHead = skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
            if (out || newAnchor != range2.anchor || newHead != range2.head) {
              if (!out) {
                out = sel.ranges.slice(0, i2);
              }
              out[i2] = new Range4(newAnchor, newHead);
            }
          }
          return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
        }
        function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
          var line = getLine(doc2, pos.line);
          if (line.markedSpans) {
            for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
              var sp = line.markedSpans[i2], m = sp.marker;
              var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
              var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
              if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear) {
                  signal(m, "beforeCursorEnter");
                  if (m.explicitlyCleared) {
                    if (!line.markedSpans) {
                      break;
                    } else {
                      --i2;
                      continue;
                    }
                  }
                }
                if (!m.atomic) {
                  continue;
                }
                if (oldPos) {
                  var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                  if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                    near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);
                  }
                  if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                    return skipAtomicInner(doc2, near, pos, dir, mayClear);
                  }
                }
                var far = m.find(dir < 0 ? -1 : 1);
                if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                  far = movePos(doc2, far, dir, far.line == pos.line ? line : null);
                }
                return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
              }
            }
          }
          return pos;
        }
        function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
          var dir = bias || 1;
          var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
          if (!found) {
            doc2.cantEdit = true;
            return Pos(doc2.first, 0);
          }
          return found;
        }
        function movePos(doc2, pos, dir, line) {
          if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc2.first) {
              return clipPos(doc2, Pos(pos.line - 1));
            } else {
              return null;
            }
          } else if (dir > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {
            if (pos.line < doc2.first + doc2.size - 1) {
              return Pos(pos.line + 1, 0);
            } else {
              return null;
            }
          } else {
            return new Pos(pos.line, pos.ch + dir);
          }
        }
        function selectAll(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        }
        function filterChange(doc2, change, update) {
          var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
              return obj.canceled = true;
            }
          };
          if (update) {
            obj.update = function(from, to, text, origin) {
              if (from) {
                obj.from = clipPos(doc2, from);
              }
              if (to) {
                obj.to = clipPos(doc2, to);
              }
              if (text) {
                obj.text = text;
              }
              if (origin !== void 0) {
                obj.origin = origin;
              }
            };
          }
          signal(doc2, "beforeChange", doc2, obj);
          if (doc2.cm) {
            signal(doc2.cm, "beforeChange", doc2.cm, obj);
          }
          if (obj.canceled) {
            if (doc2.cm) {
              doc2.cm.curOp.updateInput = 2;
            }
            return null;
          }
          return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
        }
        function makeChange(doc2, change, ignoreReadOnly) {
          if (doc2.cm) {
            if (!doc2.cm.curOp) {
              return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
            }
            if (doc2.cm.state.suppressEdits) {
              return;
            }
          }
          if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
            change = filterChange(doc2, change, true);
            if (!change) {
              return;
            }
          }
          var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
          if (split) {
            for (var i2 = split.length - 1; i2 >= 0; --i2) {
              makeChangeInner(doc2, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
            }
          } else {
            makeChangeInner(doc2, change);
          }
        }
        function makeChangeInner(doc2, change) {
          if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
            return;
          }
          var selAfter = computeSelAfterChange(doc2, change);
          addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
          makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
          var rebased = [];
          linkedDocs(doc2, function(doc3, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
              rebaseHist(doc3.history, change);
              rebased.push(doc3.history);
            }
            makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
          });
        }
        function makeChangeFromHistory(doc2, type, allowSelectionOnly) {
          var suppress = doc2.cm && doc2.cm.state.suppressEdits;
          if (suppress && !allowSelectionOnly) {
            return;
          }
          var hist = doc2.history, event, selAfter = doc2.sel;
          var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
          var i2 = 0;
          for (; i2 < source.length; i2++) {
            event = source[i2];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
              break;
            }
          }
          if (i2 == source.length) {
            return;
          }
          hist.lastOrigin = hist.lastSelOrigin = null;
          for (; ; ) {
            event = source.pop();
            if (event.ranges) {
              pushSelectionToHistory(event, dest);
              if (allowSelectionOnly && !event.equals(doc2.sel)) {
                setSelection(doc2, event, { clearRedo: false });
                return;
              }
              selAfter = event;
            } else if (suppress) {
              source.push(event);
              return;
            } else {
              break;
            }
          }
          var antiChanges = [];
          pushSelectionToHistory(selAfter, dest);
          dest.push({ changes: antiChanges, generation: hist.generation });
          hist.generation = event.generation || ++hist.maxGeneration;
          var filter = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
          var loop = function(i4) {
            var change = event.changes[i4];
            change.origin = type;
            if (filter && !filterChange(doc2, change, false)) {
              source.length = 0;
              return {};
            }
            antiChanges.push(historyChangeFromChange(doc2, change));
            var after = i4 ? computeSelAfterChange(doc2, change) : lst(source);
            makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
            if (!i4 && doc2.cm) {
              doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
            }
            var rebased = [];
            linkedDocs(doc2, function(doc3, sharedHist) {
              if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
                rebaseHist(doc3.history, change);
                rebased.push(doc3.history);
              }
              makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
            });
          };
          for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
            var returned = loop(i$12);
            if (returned)
              return returned.v;
          }
        }
        function shiftDoc(doc2, distance) {
          if (distance == 0) {
            return;
          }
          doc2.first += distance;
          doc2.sel = new Selection(map2(doc2.sel.ranges, function(range2) {
            return new Range4(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));
          }), doc2.sel.primIndex);
          if (doc2.cm) {
            regChange(doc2.cm, doc2.first, doc2.first - distance, distance);
            for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
              regLineChange(doc2.cm, l, "gutter");
            }
          }
        }
        function makeChangeSingleDoc(doc2, change, selAfter, spans) {
          if (doc2.cm && !doc2.cm.curOp) {
            return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
          }
          if (change.to.line < doc2.first) {
            shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
            return;
          }
          if (change.from.line > doc2.lastLine()) {
            return;
          }
          if (change.from.line < doc2.first) {
            var shift3 = change.text.length - 1 - (doc2.first - change.from.line);
            shiftDoc(doc2, shift3);
            change = {
              from: Pos(doc2.first, 0),
              to: Pos(change.to.line + shift3, change.to.ch),
              text: [lst(change.text)],
              origin: change.origin
            };
          }
          var last = doc2.lastLine();
          if (change.to.line > last) {
            change = {
              from: change.from,
              to: Pos(last, getLine(doc2, last).text.length),
              text: [change.text[0]],
              origin: change.origin
            };
          }
          change.removed = getBetween(doc2, change.from, change.to);
          if (!selAfter) {
            selAfter = computeSelAfterChange(doc2, change);
          }
          if (doc2.cm) {
            makeChangeSingleDocInEditor(doc2.cm, change, spans);
          } else {
            updateDoc(doc2, change, spans);
          }
          setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
          if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
            doc2.cantEdit = false;
          }
        }
        function makeChangeSingleDocInEditor(cm, change, spans) {
          var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;
          var recomputeMaxLength = false, checkWidthStart = from.line;
          if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc2, from.line)));
            doc2.iter(checkWidthStart, to.line + 1, function(line) {
              if (line == display.maxLine) {
                recomputeMaxLength = true;
                return true;
              }
            });
          }
          if (doc2.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm);
          }
          updateDoc(doc2, change, spans, estimateHeight(cm));
          if (!cm.options.lineWrapping) {
            doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {
              var len = lineLength(line);
              if (len > display.maxLineLength) {
                display.maxLine = line;
                display.maxLineLength = len;
                display.maxLineChanged = true;
                recomputeMaxLength = false;
              }
            });
            if (recomputeMaxLength) {
              cm.curOp.updateMaxLine = true;
            }
          }
          retreatFrontier(doc2, from.line);
          startWorker(cm, 400);
          var lendiff = change.text.length - (to.line - from.line) - 1;
          if (change.full) {
            regChange(cm);
          } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
            regLineChange(cm, from.line, "text");
          } else {
            regChange(cm, from.line, to.line + 1, lendiff);
          }
          var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
          if (changeHandler || changesHandler) {
            var obj = {
              from,
              to,
              text: change.text,
              removed: change.removed,
              origin: change.origin
            };
            if (changeHandler) {
              signalLater(cm, "change", cm, obj);
            }
            if (changesHandler) {
              (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
            }
          }
          cm.display.selForContextMenu = null;
        }
        function replaceRange(doc2, code, from, to, origin) {
          var assign2;
          if (!to) {
            to = from;
          }
          if (cmp(to, from) < 0) {
            assign2 = [to, from], from = assign2[0], to = assign2[1];
          }
          if (typeof code == "string") {
            code = doc2.splitLines(code);
          }
          makeChange(doc2, { from, to, text: code, origin });
        }
        function rebaseHistSelSingle(pos, from, to, diff) {
          if (to < pos.line) {
            pos.line += diff;
          } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
          }
        }
        function rebaseHistArray(array2, from, to, diff) {
          for (var i2 = 0; i2 < array2.length; ++i2) {
            var sub = array2[i2], ok = true;
            if (sub.ranges) {
              if (!sub.copied) {
                sub = array2[i2] = sub.deepCopy();
                sub.copied = true;
              }
              for (var j = 0; j < sub.ranges.length; j++) {
                rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
              }
              continue;
            }
            for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
              var cur = sub.changes[j$1];
              if (to < cur.from.line) {
                cur.from = Pos(cur.from.line + diff, cur.from.ch);
                cur.to = Pos(cur.to.line + diff, cur.to.ch);
              } else if (from <= cur.to.line) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              array2.splice(0, i2 + 1);
              i2 = 0;
            }
          }
        }
        function rebaseHist(hist, change) {
          var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
          rebaseHistArray(hist.done, from, to, diff);
          rebaseHistArray(hist.undone, from, to, diff);
        }
        function changeLine(doc2, handle, changeType, op) {
          var no = handle, line = handle;
          if (typeof handle == "number") {
            line = getLine(doc2, clipLine(doc2, handle));
          } else {
            no = lineNo(handle);
          }
          if (no == null) {
            return null;
          }
          if (op(line, no) && doc2.cm) {
            regLineChange(doc2.cm, no, changeType);
          }
          return line;
        }
        function LeafChunk(lines) {
          this.lines = lines;
          this.parent = null;
          var height = 0;
          for (var i2 = 0; i2 < lines.length; ++i2) {
            lines[i2].parent = this;
            height += lines[i2].height;
          }
          this.height = height;
        }
        LeafChunk.prototype = {
          chunkSize: function() {
            return this.lines.length;
          },
          removeInner: function(at, n) {
            for (var i2 = at, e = at + n; i2 < e; ++i2) {
              var line = this.lines[i2];
              this.height -= line.height;
              cleanUpLine(line);
              signalLater(line, "delete");
            }
            this.lines.splice(at, n);
          },
          collapse: function(lines) {
            lines.push.apply(lines, this.lines);
          },
          insertInner: function(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i2 = 0; i2 < lines.length; ++i2) {
              lines[i2].parent = this;
            }
          },
          iterN: function(at, n, op) {
            for (var e = at + n; at < e; ++at) {
              if (op(this.lines[at])) {
                return true;
              }
            }
          }
        };
        function BranchChunk(children) {
          this.children = children;
          var size = 0, height = 0;
          for (var i2 = 0; i2 < children.length; ++i2) {
            var ch2 = children[i2];
            size += ch2.chunkSize();
            height += ch2.height;
            ch2.parent = this;
          }
          this.size = size;
          this.height = height;
          this.parent = null;
        }
        BranchChunk.prototype = {
          chunkSize: function() {
            return this.size;
          },
          removeInner: function(at, n) {
            this.size -= n;
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at < sz) {
                var rm2 = Math.min(n, sz - at), oldHeight = child.height;
                child.removeInner(at, rm2);
                this.height -= oldHeight - child.height;
                if (sz == rm2) {
                  this.children.splice(i2--, 1);
                  child.parent = null;
                }
                if ((n -= rm2) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
              var lines = [];
              this.collapse(lines);
              this.children = [new LeafChunk(lines)];
              this.children[0].parent = this;
            }
          },
          collapse: function(lines) {
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              this.children[i2].collapse(lines);
            }
          },
          insertInner: function(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at <= sz) {
                child.insertInner(at, lines, height);
                if (child.lines && child.lines.length > 50) {
                  var remaining = child.lines.length % 25 + 25;
                  for (var pos = remaining; pos < child.lines.length; ) {
                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                    child.height -= leaf.height;
                    this.children.splice(++i2, 0, leaf);
                    leaf.parent = this;
                  }
                  child.lines = child.lines.slice(0, remaining);
                  this.maybeSpill();
                }
                break;
              }
              at -= sz;
            }
          },
          maybeSpill: function() {
            if (this.children.length <= 10) {
              return;
            }
            var me = this;
            do {
              var spilled = me.children.splice(me.children.length - 5, 5);
              var sibling = new BranchChunk(spilled);
              if (!me.parent) {
                var copy = new BranchChunk(me.children);
                copy.parent = me;
                me.children = [copy, sibling];
                me = copy;
              } else {
                me.size -= sibling.size;
                me.height -= sibling.height;
                var myIndex = indexOf(me.parent.children, me);
                me.parent.children.splice(myIndex + 1, 0, sibling);
              }
              sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
          },
          iterN: function(at, n, op) {
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at < sz) {
                var used = Math.min(n, sz - at);
                if (child.iterN(at, used, op)) {
                  return true;
                }
                if ((n -= used) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
          }
        };
        var LineWidget = function(doc2, node, options) {
          if (options) {
            for (var opt in options) {
              if (options.hasOwnProperty(opt)) {
                this[opt] = options[opt];
              }
            }
          }
          this.doc = doc2;
          this.node = node;
        };
        LineWidget.prototype.clear = function() {
          var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
          if (no == null || !ws) {
            return;
          }
          for (var i2 = 0; i2 < ws.length; ++i2) {
            if (ws[i2] == this) {
              ws.splice(i2--, 1);
            }
          }
          if (!ws.length) {
            line.widgets = null;
          }
          var height = widgetHeight(this);
          updateLineHeight(line, Math.max(0, line.height - height));
          if (cm) {
            runInOp(cm, function() {
              adjustScrollWhenAboveVisible(cm, line, -height);
              regLineChange(cm, no, "widget");
            });
            signalLater(cm, "lineWidgetCleared", cm, this, no);
          }
        };
        LineWidget.prototype.changed = function() {
          var this$1 = this;
          var oldH = this.height, cm = this.doc.cm, line = this.line;
          this.height = null;
          var diff = widgetHeight(this) - oldH;
          if (!diff) {
            return;
          }
          if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff);
          }
          if (cm) {
            runInOp(cm, function() {
              cm.curOp.forceUpdate = true;
              adjustScrollWhenAboveVisible(cm, line, diff);
              signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
            });
          }
        };
        eventMixin(LineWidget);
        function adjustScrollWhenAboveVisible(cm, line, diff) {
          if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
            addToScrollTop(cm, diff);
          }
        }
        function addLineWidget(doc2, handle, node, options) {
          var widget = new LineWidget(doc2, node, options);
          var cm = doc2.cm;
          if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true;
          }
          changeLine(doc2, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null) {
              widgets.push(widget);
            } else {
              widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
            }
            widget.line = line;
            if (cm && !lineIsHidden(doc2, line)) {
              var aboveVisible = heightAtLine(line) < doc2.scrollTop;
              updateLineHeight(line, line.height + widgetHeight(widget));
              if (aboveVisible) {
                addToScrollTop(cm, widget.height);
              }
              cm.curOp.forceUpdate = true;
            }
            return true;
          });
          if (cm) {
            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
          }
          return widget;
        }
        var nextMarkerId = 0;
        var TextMarker = function(doc2, type) {
          this.lines = [];
          this.type = type;
          this.doc = doc2;
          this.id = ++nextMarkerId;
        };
        TextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          var cm = this.doc.cm, withOp = cm && !cm.curOp;
          if (withOp) {
            startOperation(cm);
          }
          if (hasHandler(this, "clear")) {
            var found = this.find();
            if (found) {
              signalLater(this, "clear", found.from, found.to);
            }
          }
          var min = null, max = null;
          for (var i2 = 0; i2 < this.lines.length; ++i2) {
            var line = this.lines[i2];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed) {
              regLineChange(cm, lineNo(line), "text");
            } else if (cm) {
              if (span.to != null) {
                max = lineNo(line);
              }
              if (span.from != null) {
                min = lineNo(line);
              }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
              updateLineHeight(line, textHeight(cm.display));
            }
          }
          if (cm && this.collapsed && !cm.options.lineWrapping) {
            for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
              var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
              if (len > cm.display.maxLineLength) {
                cm.display.maxLine = visual;
                cm.display.maxLineLength = len;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (min != null && cm && this.collapsed) {
            regChange(cm, min, max + 1);
          }
          this.lines.length = 0;
          this.explicitlyCleared = true;
          if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm) {
              reCheckSelection(cm.doc);
            }
          }
          if (cm) {
            signalLater(cm, "markerCleared", cm, this, min, max);
          }
          if (withOp) {
            endOperation(cm);
          }
          if (this.parent) {
            this.parent.clear();
          }
        };
        TextMarker.prototype.find = function(side, lineObj) {
          if (side == null && this.type == "bookmark") {
            side = 1;
          }
          var from, to;
          for (var i2 = 0; i2 < this.lines.length; ++i2) {
            var line = this.lines[i2];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
              from = Pos(lineObj ? line : lineNo(line), span.from);
              if (side == -1) {
                return from;
              }
            }
            if (span.to != null) {
              to = Pos(lineObj ? line : lineNo(line), span.to);
              if (side == 1) {
                return to;
              }
            }
          }
          return from && { from, to };
        };
        TextMarker.prototype.changed = function() {
          var this$1 = this;
          var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
          if (!pos || !cm) {
            return;
          }
          runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
              clearLineMeasurementCacheFor(view);
              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
              var oldHeight = widget.height;
              widget.height = null;
              var dHeight = widgetHeight(widget) - oldHeight;
              if (dHeight) {
                updateLineHeight(line, line.height + dHeight);
              }
            }
            signalLater(cm, "markerChanged", cm, this$1);
          });
        };
        TextMarker.prototype.attachLine = function(line) {
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
              (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
          }
          this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function(line) {
          this.lines.splice(indexOf(this.lines, line), 1);
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
          }
        };
        eventMixin(TextMarker);
        function markText(doc2, from, to, options, type) {
          if (options && options.shared) {
            return markTextShared(doc2, from, to, options, type);
          }
          if (doc2.cm && !doc2.cm.curOp) {
            return operation(doc2.cm, markText)(doc2, from, to, options, type);
          }
          var marker = new TextMarker(doc2, type), diff = cmp(from, to);
          if (options) {
            copyObj(options, marker, false);
          }
          if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
            return marker;
          }
          if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
            if (!options.handleMouseEvents) {
              marker.widgetNode.setAttribute("cm-ignore-events", "true");
            }
            if (options.insertLeft) {
              marker.widgetNode.insertLeft = true;
            }
          }
          if (marker.collapsed) {
            if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {
              throw new Error("Inserting collapsed marker partially overlapping an existing one");
            }
            seeCollapsedSpans();
          }
          if (marker.addToHistory) {
            addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);
          }
          var curLine = from.line, cm = doc2.cm, updateMaxLine;
          doc2.iter(curLine, to.line + 1, function(line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
              updateMaxLine = true;
            }
            if (marker.collapsed && curLine != from.line) {
              updateLineHeight(line, 0);
            }
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc2.cm && doc2.cm.curOp);
            ++curLine;
          });
          if (marker.collapsed) {
            doc2.iter(from.line, to.line + 1, function(line) {
              if (lineIsHidden(doc2, line)) {
                updateLineHeight(line, 0);
              }
            });
          }
          if (marker.clearOnEnter) {
            on(marker, "beforeCursorEnter", function() {
              return marker.clear();
            });
          }
          if (marker.readOnly) {
            seeReadOnlySpans();
            if (doc2.history.done.length || doc2.history.undone.length) {
              doc2.clearHistory();
            }
          }
          if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
          }
          if (cm) {
            if (updateMaxLine) {
              cm.curOp.updateMaxLine = true;
            }
            if (marker.collapsed) {
              regChange(cm, from.line, to.line + 1);
            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
              for (var i2 = from.line; i2 <= to.line; i2++) {
                regLineChange(cm, i2, "text");
              }
            }
            if (marker.atomic) {
              reCheckSelection(cm.doc);
            }
            signalLater(cm, "markerAdded", cm, marker);
          }
          return marker;
        }
        var SharedTextMarker = function(markers, primary) {
          this.markers = markers;
          this.primary = primary;
          for (var i2 = 0; i2 < markers.length; ++i2) {
            markers[i2].parent = this;
          }
        };
        SharedTextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          this.explicitlyCleared = true;
          for (var i2 = 0; i2 < this.markers.length; ++i2) {
            this.markers[i2].clear();
          }
          signalLater(this, "clear");
        };
        SharedTextMarker.prototype.find = function(side, lineObj) {
          return this.primary.find(side, lineObj);
        };
        eventMixin(SharedTextMarker);
        function markTextShared(doc2, from, to, options, type) {
          options = copyObj(options);
          options.shared = false;
          var markers = [markText(doc2, from, to, options, type)], primary = markers[0];
          var widget = options.widgetNode;
          linkedDocs(doc2, function(doc3) {
            if (widget) {
              options.widgetNode = widget.cloneNode(true);
            }
            markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options, type));
            for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
              if (doc3.linked[i2].isParent) {
                return;
              }
            }
            primary = lst(markers);
          });
          return new SharedTextMarker(markers, primary);
        }
        function findSharedMarkers(doc2) {
          return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m) {
            return m.parent;
          });
        }
        function copySharedMarkers(doc2, markers) {
          for (var i2 = 0; i2 < markers.length; i2++) {
            var marker = markers[i2], pos = marker.find();
            var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
              var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
              marker.markers.push(subMark);
              subMark.parent = marker;
            }
          }
        }
        function detachSharedMarkers(markers) {
          var loop = function(i4) {
            var marker = markers[i4], linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function(d) {
              return linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
              var subMarker = marker.markers[j];
              if (indexOf(linked, subMarker.doc) == -1) {
                subMarker.parent = null;
                marker.markers.splice(j--, 1);
              }
            }
          };
          for (var i2 = 0; i2 < markers.length; i2++)
            loop(i2);
        }
        var nextDocId = 0;
        var Doc = function(text, mode, firstLine, lineSep, direction) {
          if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction);
          }
          if (firstLine == null) {
            firstLine = 0;
          }
          BranchChunk.call(this, [new LeafChunk([new Line2("", null)])]);
          this.first = firstLine;
          this.scrollTop = this.scrollLeft = 0;
          this.cantEdit = false;
          this.cleanGeneration = 1;
          this.modeFrontier = this.highlightFrontier = firstLine;
          var start2 = Pos(firstLine, 0);
          this.sel = simpleSelection(start2);
          this.history = new History(null);
          this.id = ++nextDocId;
          this.modeOption = mode;
          this.lineSep = lineSep;
          this.direction = direction == "rtl" ? "rtl" : "ltr";
          this.extend = false;
          if (typeof text == "string") {
            text = this.splitLines(text);
          }
          updateDoc(this, { from: start2, to: start2, text });
          setSelection(this, simpleSelection(start2), sel_dontScroll);
        };
        Doc.prototype = createObj(BranchChunk.prototype, {
          constructor: Doc,
          iter: function(from, to, op) {
            if (op) {
              this.iterN(from - this.first, to - from, op);
            } else {
              this.iterN(this.first, this.first + this.size, from);
            }
          },
          insert: function(at, lines) {
            var height = 0;
            for (var i2 = 0; i2 < lines.length; ++i2) {
              height += lines[i2].height;
            }
            this.insertInner(at - this.first, lines, height);
          },
          remove: function(at, n) {
            this.removeInner(at - this.first, n);
          },
          getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          setValue: docMethodOp(function(code) {
            var top2 = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
              from: top2,
              to: Pos(last, getLine(this, last).text.length),
              text: this.splitLines(code),
              origin: "setValue",
              full: true
            }, true);
            if (this.cm) {
              scrollToCoords(this.cm, 0, 0);
            }
            setSelection(this, simpleSelection(top2), sel_dontScroll);
          }),
          replaceRange: function(code, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code, from, to, origin);
          },
          getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false) {
              return lines;
            }
            if (lineSep === "") {
              return lines.join("");
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          getLine: function(line) {
            var l = this.getLineHandle(line);
            return l && l.text;
          },
          getLineHandle: function(line) {
            if (isLine(this, line)) {
              return getLine(this, line);
            }
          },
          getLineNumber: function(line) {
            return lineNo(line);
          },
          getLineHandleVisualStart: function(line) {
            if (typeof line == "number") {
              line = getLine(this, line);
            }
            return visualLine(line);
          },
          lineCount: function() {
            return this.size;
          },
          firstLine: function() {
            return this.first;
          },
          lastLine: function() {
            return this.first + this.size - 1;
          },
          clipPos: function(pos) {
            return clipPos(this, pos);
          },
          getCursor: function(start2) {
            var range2 = this.sel.primary(), pos;
            if (start2 == null || start2 == "head") {
              pos = range2.head;
            } else if (start2 == "anchor") {
              pos = range2.anchor;
            } else if (start2 == "end" || start2 == "to" || start2 === false) {
              pos = range2.to();
            } else {
              pos = range2.from();
            }
            return pos;
          },
          listSelections: function() {
            return this.sel.ranges;
          },
          somethingSelected: function() {
            return this.sel.somethingSelected();
          },
          setCursor: docMethodOp(function(line, ch2, options) {
            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch2 || 0) : line), null, options);
          }),
          setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
          }),
          extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
          }),
          extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          extendSelectionsBy: docMethodOp(function(f, options) {
            var heads = map2(this.sel.ranges, f);
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          setSelections: docMethodOp(function(ranges, primary, options) {
            if (!ranges.length) {
              return;
            }
            var out = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              out[i2] = new Range4(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
            }
            if (primary == null) {
              primary = Math.min(ranges.length - 1, this.sel.primIndex);
            }
            setSelection(this, normalizeSelection(this.cm, out, primary), options);
          }),
          addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range4(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
          }),
          getSelection: function(lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
              lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false) {
              return lines;
            } else {
              return lines.join(lineSep || this.lineSeparator());
            }
          },
          getSelections: function(lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
              if (lineSep !== false) {
                sel = sel.join(lineSep || this.lineSeparator());
              }
              parts[i2] = sel;
            }
            return parts;
          },
          replaceSelection: function(code, collapse, origin) {
            var dup = [];
            for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
              dup[i2] = code;
            }
            this.replaceSelections(dup, collapse, origin || "+input");
          },
          replaceSelections: docMethodOp(function(code, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i2 = 0; i2 < sel.ranges.length; i2++) {
              var range2 = sel.ranges[i2];
              changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
            }
            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
            for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
              makeChange(this, changes[i$12]);
            }
            if (newSel) {
              setSelectionReplaceHistory(this, newSel);
            } else if (this.cm) {
              ensureCursorVisible(this.cm);
            }
          }),
          undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
          }),
          redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
          }),
          undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", true);
          }),
          redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", true);
          }),
          setExtending: function(val) {
            this.extend = val;
          },
          getExtending: function() {
            return this.extend;
          },
          historySize: function() {
            var hist = this.history, done = 0, undone = 0;
            for (var i2 = 0; i2 < hist.done.length; i2++) {
              if (!hist.done[i2].ranges) {
                ++done;
              }
            }
            for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
              if (!hist.undone[i$12].ranges) {
                ++undone;
              }
            }
            return { undo: done, redo: undone };
          },
          clearHistory: function() {
            var this$1 = this;
            this.history = new History(this.history);
            linkedDocs(this, function(doc2) {
              return doc2.history = this$1.history;
            }, true);
          },
          markClean: function() {
            this.cleanGeneration = this.changeGeneration(true);
          },
          changeGeneration: function(forceSplit) {
            if (forceSplit) {
              this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            }
            return this.history.generation;
          },
          isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
          },
          getHistory: function() {
            return {
              done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)
            };
          },
          setHistory: function(histData) {
            var hist = this.history = new History(this.history);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
          },
          setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line2) {
              var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
              markers[gutterID] = value;
              if (!value && isEmpty(markers)) {
                line2.gutterMarkers = null;
              }
              return true;
            });
          }),
          clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                changeLine(this$1, line, "gutter", function() {
                  line.gutterMarkers[gutterID] = null;
                  if (isEmpty(line.gutterMarkers)) {
                    line.gutterMarkers = null;
                  }
                  return true;
                });
              }
            });
          }),
          lineInfo: function(line) {
            var n;
            if (typeof line == "number") {
              if (!isLine(this, line)) {
                return null;
              }
              n = line;
              line = getLine(this, line);
              if (!line) {
                return null;
              }
            } else {
              n = lineNo(line);
              if (n == null) {
                return null;
              }
            }
            return {
              line: n,
              handle: line,
              text: line.text,
              gutterMarkers: line.gutterMarkers,
              textClass: line.textClass,
              bgClass: line.bgClass,
              wrapClass: line.wrapClass,
              widgets: line.widgets
            };
          },
          addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              if (!line[prop2]) {
                line[prop2] = cls;
              } else if (classTest(cls).test(line[prop2])) {
                return false;
              } else {
                line[prop2] += " " + cls;
              }
              return true;
            });
          }),
          removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              var cur = line[prop2];
              if (!cur) {
                return false;
              } else if (cls == null) {
                line[prop2] = null;
              } else {
                var found = cur.match(classTest(cls));
                if (!found) {
                  return false;
                }
                var end = found.index + found[0].length;
                line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
              }
              return true;
            });
          }),
          addLineWidget: docMethodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options);
          }),
          removeLineWidget: function(widget) {
            widget.clear();
          },
          markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
          },
          setBookmark: function(pos, options) {
            var realOpts = {
              replacedWith: options && (options.nodeType == null ? options.widget : options),
              insertLeft: options && options.insertLeft,
              clearWhenEmpty: false,
              shared: options && options.shared,
              handleMouseEvents: options && options.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, "bookmark");
          },
          findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) {
              for (var i2 = 0; i2 < spans.length; ++i2) {
                var span = spans[i2];
                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                  markers.push(span.marker.parent || span.marker);
                }
              }
            }
            return markers;
          },
          findMarks: function(from, to, filter) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo2 = from.line;
            this.iter(from.line, to.line + 1, function(line) {
              var spans = line.markedSpans;
              if (spans) {
                for (var i2 = 0; i2 < spans.length; i2++) {
                  var span = spans[i2];
                  if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                    found.push(span.marker.parent || span.marker);
                  }
                }
              }
              ++lineNo2;
            });
            return found;
          },
          getAllMarks: function() {
            var markers = [];
            this.iter(function(line) {
              var sps = line.markedSpans;
              if (sps) {
                for (var i2 = 0; i2 < sps.length; ++i2) {
                  if (sps[i2].from != null) {
                    markers.push(sps[i2].marker);
                  }
                }
              }
            });
            return markers;
          },
          posFromIndex: function(off2) {
            var ch2, lineNo2 = this.first, sepSize = this.lineSeparator().length;
            this.iter(function(line) {
              var sz = line.text.length + sepSize;
              if (sz > off2) {
                ch2 = off2;
                return true;
              }
              off2 -= sz;
              ++lineNo2;
            });
            return clipPos(this, Pos(lineNo2, ch2));
          },
          indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) {
              return 0;
            }
            var sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, function(line) {
              index += line.text.length + sepSize;
            });
            return index;
          },
          copy: function(copyHistory) {
            var doc2 = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            doc2.scrollTop = this.scrollTop;
            doc2.scrollLeft = this.scrollLeft;
            doc2.sel = this.sel;
            doc2.extend = false;
            if (copyHistory) {
              doc2.history.undoDepth = this.history.undoDepth;
              doc2.setHistory(this.getHistory());
            }
            return doc2;
          },
          linkedDoc: function(options) {
            if (!options) {
              options = {};
            }
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from) {
              from = options.from;
            }
            if (options.to != null && options.to < to) {
              to = options.to;
            }
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options.sharedHist) {
              copy.history = this.history;
            }
            (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
            copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
          },
          unlinkDoc: function(other) {
            if (other instanceof CodeMirror3) {
              other = other.doc;
            }
            if (this.linked) {
              for (var i2 = 0; i2 < this.linked.length; ++i2) {
                var link = this.linked[i2];
                if (link.doc != other) {
                  continue;
                }
                this.linked.splice(i2, 1);
                other.unlinkDoc(this);
                detachSharedMarkers(findSharedMarkers(this));
                break;
              }
            }
            if (other.history == this.history) {
              var splitIds = [other.id];
              linkedDocs(other, function(doc2) {
                return splitIds.push(doc2.id);
              }, true);
              other.history = new History(null);
              other.history.done = copyHistoryArray(this.history.done, splitIds);
              other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
          },
          iterLinkedDocs: function(f) {
            linkedDocs(this, f);
          },
          getMode: function() {
            return this.mode;
          },
          getEditor: function() {
            return this.cm;
          },
          splitLines: function(str) {
            if (this.lineSep) {
              return str.split(this.lineSep);
            }
            return splitLinesAuto(str);
          },
          lineSeparator: function() {
            return this.lineSep || "\n";
          },
          setDirection: docMethodOp(function(dir) {
            if (dir != "rtl") {
              dir = "ltr";
            }
            if (dir == this.direction) {
              return;
            }
            this.direction = dir;
            this.iter(function(line) {
              return line.order = null;
            });
            if (this.cm) {
              directionChanged(this.cm);
            }
          })
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        var lastDrop = 0;
        function onDrop(e) {
          var cm = this;
          clearDragCursor(cm);
          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e_preventDefault(e);
          if (ie3) {
            lastDrop = +new Date();
          }
          var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
          if (!pos || cm.isReadOnly()) {
            return;
          }
          if (files && files.length && window.FileReader && window.File) {
            var n = files.length, text = Array(n), read = 0;
            var markAsReadAndPasteIfAllFilesAreRead = function() {
              if (++read == n) {
                operation(cm, function() {
                  pos = clipPos(cm.doc, pos);
                  var change = {
                    from: pos,
                    to: pos,
                    text: cm.doc.splitLines(text.filter(function(t2) {
                      return t2 != null;
                    }).join(cm.doc.lineSeparator())),
                    origin: "paste"
                  };
                  makeChange(cm.doc, change);
                  setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                })();
              }
            };
            var readTextFromFile = function(file, i4) {
              if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              var reader = new FileReader();
              reader.onerror = function() {
                return markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.onload = function() {
                var content2 = reader.result;
                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content2)) {
                  markAsReadAndPasteIfAllFilesAreRead();
                  return;
                }
                text[i4] = content2;
                markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.readAsText(file);
            };
            for (var i2 = 0; i2 < files.length; i2++) {
              readTextFromFile(files[i2], i2);
            }
          } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
              cm.state.draggingText(e);
              setTimeout(function() {
                return cm.display.input.focus();
              }, 20);
              return;
            }
            try {
              var text$1 = e.dataTransfer.getData("Text");
              if (text$1) {
                var selected;
                if (cm.state.draggingText && !cm.state.draggingText.copy) {
                  selected = cm.listSelections();
                }
                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                if (selected) {
                  for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                    replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                  }
                }
                cm.replaceSelection(text$1, "around", "paste");
                cm.display.input.focus();
              }
            } catch (e$1) {
            }
          }
        }
        function onDragStart(cm, e) {
          if (ie3 && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e);
            return;
          }
          if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e.dataTransfer.setData("Text", cm.getSelection());
          e.dataTransfer.effectAllowed = "copyMove";
          if (e.dataTransfer.setDragImage && !safari3) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            if (presto) {
              img.width = img.height = 1;
              cm.display.wrapper.appendChild(img);
              img._top = img.offsetTop;
            }
            e.dataTransfer.setDragImage(img, 0, 0);
            if (presto) {
              img.parentNode.removeChild(img);
            }
          }
        }
        function onDragOver(cm, e) {
          var pos = posFromMouse(cm, e);
          if (!pos) {
            return;
          }
          var frag = document.createDocumentFragment();
          drawSelectionCursor(cm, pos, frag);
          if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
          }
          removeChildrenAndAdd(cm.display.dragCursor, frag);
        }
        function clearDragCursor(cm) {
          if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
          }
        }
        function forEachCodeMirror(f) {
          if (!document.getElementsByClassName) {
            return;
          }
          var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
          for (var i2 = 0; i2 < byClass.length; i2++) {
            var cm = byClass[i2].CodeMirror;
            if (cm) {
              editors.push(cm);
            }
          }
          if (editors.length) {
            editors[0].operation(function() {
              for (var i4 = 0; i4 < editors.length; i4++) {
                f(editors[i4]);
              }
            });
          }
        }
        var globalsRegistered = false;
        function ensureGlobalHandlers() {
          if (globalsRegistered) {
            return;
          }
          registerGlobalHandlers();
          globalsRegistered = true;
        }
        function registerGlobalHandlers() {
          var resizeTimer;
          on(window, "resize", function() {
            if (resizeTimer == null) {
              resizeTimer = setTimeout(function() {
                resizeTimer = null;
                forEachCodeMirror(onResize);
              }, 100);
            }
          });
          on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
          });
        }
        function onResize(cm) {
          var d = cm.display;
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
          d.scrollbarsClipped = false;
          cm.setSize();
        }
        var keyNames = {
          3: "Pause",
          8: "Backspace",
          9: "Tab",
          13: "Enter",
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "PrintScrn",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Mod",
          92: "Mod",
          93: "Mod",
          106: "*",
          107: "=",
          109: "-",
          110: ".",
          111: "/",
          145: "ScrollLock",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          224: "Mod",
          63232: "Up",
          63233: "Down",
          63234: "Left",
          63235: "Right",
          63272: "Delete",
          63273: "Home",
          63275: "End",
          63276: "PageUp",
          63277: "PageDown",
          63302: "Insert"
        };
        for (var i = 0; i < 10; i++) {
          keyNames[i + 48] = keyNames[i + 96] = String(i);
        }
        for (var i$1 = 65; i$1 <= 90; i$1++) {
          keyNames[i$1] = String.fromCharCode(i$1);
        }
        for (var i$2 = 1; i$2 <= 12; i$2++) {
          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
        }
        var keyMap = {};
        keyMap.basic = {
          "Left": "goCharLeft",
          "Right": "goCharRight",
          "Up": "goLineUp",
          "Down": "goLineDown",
          "End": "goLineEnd",
          "Home": "goLineStartSmart",
          "PageUp": "goPageUp",
          "PageDown": "goPageDown",
          "Delete": "delCharAfter",
          "Backspace": "delCharBefore",
          "Shift-Backspace": "delCharBefore",
          "Tab": "defaultTab",
          "Shift-Tab": "indentAuto",
          "Enter": "newlineAndIndent",
          "Insert": "toggleOverwrite",
          "Esc": "singleSelection"
        };
        keyMap.pcDefault = {
          "Ctrl-A": "selectAll",
          "Ctrl-D": "deleteLine",
          "Ctrl-Z": "undo",
          "Shift-Ctrl-Z": "redo",
          "Ctrl-Y": "redo",
          "Ctrl-Home": "goDocStart",
          "Ctrl-End": "goDocEnd",
          "Ctrl-Up": "goLineUp",
          "Ctrl-Down": "goLineDown",
          "Ctrl-Left": "goGroupLeft",
          "Ctrl-Right": "goGroupRight",
          "Alt-Left": "goLineStart",
          "Alt-Right": "goLineEnd",
          "Ctrl-Backspace": "delGroupBefore",
          "Ctrl-Delete": "delGroupAfter",
          "Ctrl-S": "save",
          "Ctrl-F": "find",
          "Ctrl-G": "findNext",
          "Shift-Ctrl-G": "findPrev",
          "Shift-Ctrl-F": "replace",
          "Shift-Ctrl-R": "replaceAll",
          "Ctrl-[": "indentLess",
          "Ctrl-]": "indentMore",
          "Ctrl-U": "undoSelection",
          "Shift-Ctrl-U": "redoSelection",
          "Alt-U": "redoSelection",
          "fallthrough": "basic"
        };
        keyMap.emacsy = {
          "Ctrl-F": "goCharRight",
          "Ctrl-B": "goCharLeft",
          "Ctrl-P": "goLineUp",
          "Ctrl-N": "goLineDown",
          "Ctrl-A": "goLineStart",
          "Ctrl-E": "goLineEnd",
          "Ctrl-V": "goPageDown",
          "Shift-Ctrl-V": "goPageUp",
          "Ctrl-D": "delCharAfter",
          "Ctrl-H": "delCharBefore",
          "Alt-Backspace": "delWordBefore",
          "Ctrl-K": "killLine",
          "Ctrl-T": "transposeChars",
          "Ctrl-O": "openLine"
        };
        keyMap.macDefault = {
          "Cmd-A": "selectAll",
          "Cmd-D": "deleteLine",
          "Cmd-Z": "undo",
          "Shift-Cmd-Z": "redo",
          "Cmd-Y": "redo",
          "Cmd-Home": "goDocStart",
          "Cmd-Up": "goDocStart",
          "Cmd-End": "goDocEnd",
          "Cmd-Down": "goDocEnd",
          "Alt-Left": "goGroupLeft",
          "Alt-Right": "goGroupRight",
          "Cmd-Left": "goLineLeft",
          "Cmd-Right": "goLineRight",
          "Alt-Backspace": "delGroupBefore",
          "Ctrl-Alt-Backspace": "delGroupAfter",
          "Alt-Delete": "delGroupAfter",
          "Cmd-S": "save",
          "Cmd-F": "find",
          "Cmd-G": "findNext",
          "Shift-Cmd-G": "findPrev",
          "Cmd-Alt-F": "replace",
          "Shift-Cmd-Alt-F": "replaceAll",
          "Cmd-[": "indentLess",
          "Cmd-]": "indentMore",
          "Cmd-Backspace": "delWrappedLineLeft",
          "Cmd-Delete": "delWrappedLineRight",
          "Cmd-U": "undoSelection",
          "Shift-Cmd-U": "redoSelection",
          "Ctrl-Up": "goDocStart",
          "Ctrl-Down": "goDocEnd",
          "fallthrough": ["basic", "emacsy"]
        };
        keyMap["default"] = mac2 ? keyMap.macDefault : keyMap.pcDefault;
        function normalizeKeyName2(name2) {
          var parts = name2.split(/-(?!$)/);
          name2 = parts[parts.length - 1];
          var alt, ctrl, shift3, cmd;
          for (var i2 = 0; i2 < parts.length - 1; i2++) {
            var mod = parts[i2];
            if (/^(cmd|meta|m)$/i.test(mod)) {
              cmd = true;
            } else if (/^a(lt)?$/i.test(mod)) {
              alt = true;
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true;
            } else if (/^s(hift)?$/i.test(mod)) {
              shift3 = true;
            } else {
              throw new Error("Unrecognized modifier name: " + mod);
            }
          }
          if (alt) {
            name2 = "Alt-" + name2;
          }
          if (ctrl) {
            name2 = "Ctrl-" + name2;
          }
          if (cmd) {
            name2 = "Cmd-" + name2;
          }
          if (shift3) {
            name2 = "Shift-" + name2;
          }
          return name2;
        }
        function normalizeKeyMap(keymap2) {
          var copy = {};
          for (var keyname in keymap2) {
            if (keymap2.hasOwnProperty(keyname)) {
              var value = keymap2[keyname];
              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                continue;
              }
              if (value == "...") {
                delete keymap2[keyname];
                continue;
              }
              var keys2 = map2(keyname.split(" "), normalizeKeyName2);
              for (var i2 = 0; i2 < keys2.length; i2++) {
                var val = void 0, name2 = void 0;
                if (i2 == keys2.length - 1) {
                  name2 = keys2.join(" ");
                  val = value;
                } else {
                  name2 = keys2.slice(0, i2 + 1).join(" ");
                  val = "...";
                }
                var prev = copy[name2];
                if (!prev) {
                  copy[name2] = val;
                } else if (prev != val) {
                  throw new Error("Inconsistent bindings for " + name2);
                }
              }
              delete keymap2[keyname];
            }
          }
          for (var prop2 in copy) {
            keymap2[prop2] = copy[prop2];
          }
          return keymap2;
        }
        function lookupKey(key, map3, handle, context) {
          map3 = getKeyMap(map3);
          var found = map3.call ? map3.call(key, context) : map3[key];
          if (found === false) {
            return "nothing";
          }
          if (found === "...") {
            return "multi";
          }
          if (found != null && handle(found)) {
            return "handled";
          }
          if (map3.fallthrough) {
            if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
              return lookupKey(key, map3.fallthrough, handle, context);
            }
            for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {
              var result = lookupKey(key, map3.fallthrough[i2], handle, context);
              if (result) {
                return result;
              }
            }
          }
        }
        function isModifierKey(value) {
          var name2 = typeof value == "string" ? value : keyNames[value.keyCode];
          return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
        }
        function addModifierNames(name2, event, noShift) {
          var base2 = name2;
          if (event.altKey && base2 != "Alt") {
            name2 = "Alt-" + name2;
          }
          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != "Ctrl") {
            name2 = "Ctrl-" + name2;
          }
          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != "Mod") {
            name2 = "Cmd-" + name2;
          }
          if (!noShift && event.shiftKey && base2 != "Shift") {
            name2 = "Shift-" + name2;
          }
          return name2;
        }
        function keyName2(event, noShift) {
          if (presto && event.keyCode == 34 && event["char"]) {
            return false;
          }
          var name2 = keyNames[event.keyCode];
          if (name2 == null || event.altGraphKey) {
            return false;
          }
          if (event.keyCode == 3 && event.code) {
            name2 = event.code;
          }
          return addModifierNames(name2, event, noShift);
        }
        function getKeyMap(val) {
          return typeof val == "string" ? keyMap[val] : val;
        }
        function deleteNearSelection(cm, compute) {
          var ranges = cm.doc.sel.ranges, kill = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var toKill = compute(ranges[i2]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
              var replaced = kill.pop();
              if (cmp(replaced.from, toKill.from) < 0) {
                toKill.from = replaced.from;
                break;
              }
            }
            kill.push(toKill);
          }
          runInOp(cm, function() {
            for (var i4 = kill.length - 1; i4 >= 0; i4--) {
              replaceRange(cm.doc, "", kill[i4].from, kill[i4].to, "+delete");
            }
            ensureCursorVisible(cm);
          });
        }
        function moveCharLogically(line, ch2, dir) {
          var target = skipExtendingChars(line.text, ch2 + dir, dir);
          return target < 0 || target > line.text.length ? null : target;
        }
        function moveLogically(line, start2, dir) {
          var ch2 = moveCharLogically(line, start2.ch, dir);
          return ch2 == null ? null : new Pos(start2.line, ch2, dir < 0 ? "after" : "before");
        }
        function endOfLine(visually, cm, lineObj, lineNo2, dir) {
          if (visually) {
            if (cm.doc.direction == "rtl") {
              dir = -dir;
            }
            var order = getOrder(lineObj, cm.doc.direction);
            if (order) {
              var part = dir < 0 ? lst(order) : order[0];
              var moveInStorageOrder = dir < 0 == (part.level == 1);
              var sticky = moveInStorageOrder ? "after" : "before";
              var ch2;
              if (part.level > 0 || cm.doc.direction == "rtl") {
                var prep = prepareMeasureForLine(cm, lineObj);
                ch2 = dir < 0 ? lineObj.text.length - 1 : 0;
                var targetTop = measureCharPrepared(cm, prep, ch2).top;
                ch2 = findFirst(function(ch3) {
                  return measureCharPrepared(cm, prep, ch3).top == targetTop;
                }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch2);
                if (sticky == "before") {
                  ch2 = moveCharLogically(lineObj, ch2, 1);
                }
              } else {
                ch2 = dir < 0 ? part.to : part.from;
              }
              return new Pos(lineNo2, ch2, sticky);
            }
          }
          return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
        }
        function moveVisually2(cm, line, start2, dir) {
          var bidi = getOrder(line, cm.doc.direction);
          if (!bidi) {
            return moveLogically(line, start2, dir);
          }
          if (start2.ch >= line.text.length) {
            start2.ch = line.text.length;
            start2.sticky = "before";
          } else if (start2.ch <= 0) {
            start2.ch = 0;
            start2.sticky = "after";
          }
          var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part = bidi[partPos];
          if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start2.ch : part.from < start2.ch)) {
            return moveLogically(line, start2, dir);
          }
          var mv = function(pos, dir2) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
          };
          var prep;
          var getWrappedLineExtent = function(ch3) {
            if (!cm.options.lineWrapping) {
              return { begin: 0, end: line.text.length };
            }
            prep = prep || prepareMeasureForLine(cm, line);
            return wrappedLineExtentChar(cm, line, prep, ch3);
          };
          var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
          if (cm.doc.direction == "rtl" || part.level == 1) {
            var moveInStorageOrder = part.level == 1 == dir < 0;
            var ch2 = mv(start2, moveInStorageOrder ? 1 : -1);
            if (ch2 != null && (!moveInStorageOrder ? ch2 >= part.from && ch2 >= wrappedLineExtent2.begin : ch2 <= part.to && ch2 <= wrappedLineExtent2.end)) {
              var sticky = moveInStorageOrder ? "before" : "after";
              return new Pos(start2.line, ch2, sticky);
            }
          }
          var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
            var getRes = function(ch4, moveInStorageOrder3) {
              return moveInStorageOrder3 ? new Pos(start2.line, mv(ch4, 1), "before") : new Pos(start2.line, ch4, "after");
            };
            for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
              var part2 = bidi[partPos2];
              var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
              var ch3 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
              if (part2.from <= ch3 && ch3 < part2.to) {
                return getRes(ch3, moveInStorageOrder2);
              }
              ch3 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
              if (wrappedLineExtent3.begin <= ch3 && ch3 < wrappedLineExtent3.end) {
                return getRes(ch3, moveInStorageOrder2);
              }
            }
          };
          var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
          if (res) {
            return res;
          }
          var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
          if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
            if (res) {
              return res;
            }
          }
          return null;
        }
        var commands = {
          selectAll,
          singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
          },
          killLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              if (range2.empty()) {
                var len = getLine(cm.doc, range2.head.line).text.length;
                if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
                  return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
                } else {
                  return { from: range2.head, to: Pos(range2.head.line, len) };
                }
              } else {
                return { from: range2.from(), to: range2.to() };
              }
            });
          },
          deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
              };
            });
          },
          delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: range2.from()
              };
            });
          },
          delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top2 = cm.charCoords(range2.head, "div").top + 5;
              var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
              return { from: leftPos, to: range2.from() };
            });
          },
          delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top2 = cm.charCoords(range2.head, "div").top + 5;
              var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
              return { from: range2.from(), to: rightPos };
            });
          },
          undo: function(cm) {
            return cm.undo();
          },
          redo: function(cm) {
            return cm.redo();
          },
          undoSelection: function(cm) {
            return cm.undoSelection();
          },
          redoSelection: function(cm) {
            return cm.redoSelection();
          },
          goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
          },
          goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
          },
          goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStart(cm, range2.head.line);
            }, { origin: "+move", bias: 1 });
          },
          goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStartSmart(cm, range2.head);
            }, { origin: "+move", bias: 1 });
          },
          goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineEnd(cm, range2.head.line);
            }, { origin: "+move", bias: -1 });
          },
          goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
            }, sel_move);
          },
          goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: 0, top: top2 }, "div");
            }, sel_move);
          },
          goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
              if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                return lineStartSmart(cm, range2.head);
              }
              return pos;
            }, sel_move);
          },
          goLineUp: function(cm) {
            return cm.moveV(-1, "line");
          },
          goLineDown: function(cm) {
            return cm.moveV(1, "line");
          },
          goPageUp: function(cm) {
            return cm.moveV(-1, "page");
          },
          goPageDown: function(cm) {
            return cm.moveV(1, "page");
          },
          goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
          },
          goCharRight: function(cm) {
            return cm.moveH(1, "char");
          },
          goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
          },
          goColumnRight: function(cm) {
            return cm.moveH(1, "column");
          },
          goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
          },
          goGroupRight: function(cm) {
            return cm.moveH(1, "group");
          },
          goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
          },
          goWordRight: function(cm) {
            return cm.moveH(1, "word");
          },
          delCharBefore: function(cm) {
            return cm.deleteH(-1, "codepoint");
          },
          delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
          },
          delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
          },
          delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
          },
          delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
          },
          delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
          },
          indentAuto: function(cm) {
            return cm.indentSelection("smart");
          },
          indentMore: function(cm) {
            return cm.indentSelection("add");
          },
          indentLess: function(cm) {
            return cm.indentSelection("subtract");
          },
          insertTab: function(cm) {
            return cm.replaceSelection("	");
          },
          insertSoftTab: function(cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var pos = ranges[i2].from();
              var col = countColumn2(cm.getLine(pos.line), pos.ch, tabSize);
              spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
          },
          defaultTab: function(cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.execCommand("insertTab");
            }
          },
          transposeChars: function(cm) {
            return runInOp(cm, function() {
              var ranges = cm.listSelections(), newSel = [];
              for (var i2 = 0; i2 < ranges.length; i2++) {
                if (!ranges[i2].empty()) {
                  continue;
                }
                var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
                if (line) {
                  if (cur.ch == line.length) {
                    cur = new Pos(cur.line, cur.ch - 1);
                  }
                  if (cur.ch > 0) {
                    cur = new Pos(cur.line, cur.ch + 1);
                    cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                  } else if (cur.line > cm.doc.first) {
                    var prev = getLine(cm.doc, cur.line - 1).text;
                    if (prev) {
                      cur = new Pos(cur.line, 1);
                      cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                    }
                  }
                }
                newSel.push(new Range4(cur, cur));
              }
              cm.setSelections(newSel);
            });
          },
          newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
              var sels = cm.listSelections();
              for (var i2 = sels.length - 1; i2 >= 0; i2--) {
                cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
              }
              sels = cm.listSelections();
              for (var i$12 = 0; i$12 < sels.length; i$12++) {
                cm.indentLine(sels[i$12].from().line, null, true);
              }
              ensureCursorVisible(cm);
            });
          },
          openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
          },
          toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
          }
        };
        function lineStart(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLine(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, visual, lineN, 1);
        }
        function lineEnd(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLineEnd(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, line, lineN, -1);
        }
        function lineStartSmart(cm, pos) {
          var start2 = lineStart(cm, pos.line);
          var line = getLine(cm.doc, start2.line);
          var order = getOrder(line, cm.doc.direction);
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
            var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
          }
          return start2;
        }
        function doHandleBinding(cm, bound, dropShift) {
          if (typeof bound == "string") {
            bound = commands[bound];
            if (!bound) {
              return false;
            }
          }
          cm.display.input.ensurePolled();
          var prevShift = cm.display.shift, done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            if (dropShift) {
              cm.display.shift = false;
            }
            done = bound(cm) != Pass;
          } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
          }
          return done;
        }
        function lookupKeyForEditor(cm, name2, handle) {
          for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
            var result = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
            if (result) {
              return result;
            }
          }
          return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
        }
        var stopSeq = new Delayed();
        function dispatchKey2(cm, name2, e, handle) {
          var seq = cm.state.keySeq;
          if (seq) {
            if (isModifierKey(name2)) {
              return "handled";
            }
            if (/\'$/.test(name2)) {
              cm.state.keySeq = null;
            } else {
              stopSeq.set(50, function() {
                if (cm.state.keySeq == seq) {
                  cm.state.keySeq = null;
                  cm.display.input.reset();
                }
              });
            }
            if (dispatchKeyInner(cm, seq + " " + name2, e, handle)) {
              return true;
            }
          }
          return dispatchKeyInner(cm, name2, e, handle);
        }
        function dispatchKeyInner(cm, name2, e, handle) {
          var result = lookupKeyForEditor(cm, name2, handle);
          if (result == "multi") {
            cm.state.keySeq = name2;
          }
          if (result == "handled") {
            signalLater(cm, "keyHandled", cm, name2, e);
          }
          if (result == "handled" || result == "multi") {
            e_preventDefault(e);
            restartBlink(cm);
          }
          return !!result;
        }
        function handleKeyBinding(cm, e) {
          var name2 = keyName2(e, true);
          if (!name2) {
            return false;
          }
          if (e.shiftKey && !cm.state.keySeq) {
            return dispatchKey2(cm, "Shift-" + name2, e, function(b) {
              return doHandleBinding(cm, b, true);
            }) || dispatchKey2(cm, name2, e, function(b) {
              if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
                return doHandleBinding(cm, b);
              }
            });
          } else {
            return dispatchKey2(cm, name2, e, function(b) {
              return doHandleBinding(cm, b);
            });
          }
        }
        function handleCharBinding(cm, e, ch2) {
          return dispatchKey2(cm, "'" + ch2 + "'", e, function(b) {
            return doHandleBinding(cm, b, true);
          });
        }
        var lastStoppedKey = null;
        function onKeyDown(e) {
          var cm = this;
          if (e.target && e.target != cm.display.input.getField()) {
            return;
          }
          cm.curOp.focus = activeElt();
          if (signalDOMEvent(cm, e)) {
            return;
          }
          if (ie3 && ie_version < 11 && e.keyCode == 27) {
            e.returnValue = false;
          }
          var code = e.keyCode;
          cm.display.shift = code == 16 || e.shiftKey;
          var handled = handleKeyBinding(cm, e);
          if (presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !hasCopyEvent && (mac2 ? e.metaKey : e.ctrlKey)) {
              cm.replaceSelection("", null, "cut");
            }
          }
          if (gecko3 && !mac2 && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
            document.execCommand("cut");
          }
          if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
            showCrossHair(cm);
          }
        }
        function showCrossHair(cm) {
          var lineDiv = cm.display.lineDiv;
          addClass(lineDiv, "CodeMirror-crosshair");
          function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
              rmClass(lineDiv, "CodeMirror-crosshair");
              off(document, "keyup", up);
              off(document, "mouseover", up);
            }
          }
          on(document, "keyup", up);
          on(document, "mouseover", up);
        }
        function onKeyUp(e) {
          if (e.keyCode == 16) {
            this.doc.sel.shift = false;
          }
          signalDOMEvent(this, e);
        }
        function onKeyPress(e) {
          var cm = this;
          if (e.target && e.target != cm.display.input.getField()) {
            return;
          }
          if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac2 && e.metaKey) {
            return;
          }
          var keyCode = e.keyCode, charCode = e.charCode;
          if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e);
            return;
          }
          if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
            return;
          }
          var ch2 = String.fromCharCode(charCode == null ? keyCode : charCode);
          if (ch2 == "\b") {
            return;
          }
          if (handleCharBinding(cm, e, ch2)) {
            return;
          }
          cm.display.input.onKeyPress(e);
        }
        var DOUBLECLICK_DELAY = 400;
        var PastClick = function(time, pos, button) {
          this.time = time;
          this.pos = pos;
          this.button = button;
        };
        PastClick.prototype.compare = function(time, pos, button) {
          return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
        };
        var lastClick, lastDoubleClick;
        function clickRepeat(pos, button) {
          var now = +new Date();
          if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
            lastClick = lastDoubleClick = null;
            return "triple";
          } else if (lastClick && lastClick.compare(now, pos, button)) {
            lastDoubleClick = new PastClick(now, pos, button);
            lastClick = null;
            return "double";
          } else {
            lastClick = new PastClick(now, pos, button);
            lastDoubleClick = null;
            return "single";
          }
        }
        function onMouseDown(e) {
          var cm = this, display = cm.display;
          if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
            return;
          }
          display.input.ensurePolled();
          display.shift = e.shiftKey;
          if (eventInWidget(display, e)) {
            if (!webkit2) {
              display.scroller.draggable = false;
              setTimeout(function() {
                return display.scroller.draggable = true;
              }, 100);
            }
            return;
          }
          if (clickInGutter(cm, e)) {
            return;
          }
          var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
          window.focus();
          if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e);
          }
          if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
            return;
          }
          if (button == 1) {
            if (pos) {
              leftButtonDown(cm, pos, repeat, e);
            } else if (e_target(e) == display.scroller) {
              e_preventDefault(e);
            }
          } else if (button == 2) {
            if (pos) {
              extendSelection(cm.doc, pos);
            }
            setTimeout(function() {
              return display.input.focus();
            }, 20);
          } else if (button == 3) {
            if (captureRightClick) {
              cm.display.input.onContextMenu(e);
            } else {
              delayBlurEvent(cm);
            }
          }
        }
        function handleMappedButton(cm, button, pos, repeat, event) {
          var name2 = "Click";
          if (repeat == "double") {
            name2 = "Double" + name2;
          } else if (repeat == "triple") {
            name2 = "Triple" + name2;
          }
          name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
          return dispatchKey2(cm, addModifierNames(name2, event), event, function(bound) {
            if (typeof bound == "string") {
              bound = commands[bound];
            }
            if (!bound) {
              return false;
            }
            var done = false;
            try {
              if (cm.isReadOnly()) {
                cm.state.suppressEdits = true;
              }
              done = bound(cm, pos) != Pass;
            } finally {
              cm.state.suppressEdits = false;
            }
            return done;
          });
        }
        function configureMouse(cm, repeat, event) {
          var option = cm.getOption("configureMouse");
          var value = option ? option(cm, repeat, event) : {};
          if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
          }
          if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey;
          }
          if (value.addNew == null) {
            value.addNew = mac2 ? event.metaKey : event.ctrlKey;
          }
          if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac2 ? event.altKey : event.ctrlKey);
          }
          return value;
        }
        function leftButtonDown(cm, pos, repeat, event) {
          if (ie3) {
            setTimeout(bind(ensureFocus, cm), 0);
          } else {
            cm.curOp.focus = activeElt();
          }
          var behavior = configureMouse(cm, repeat, event);
          var sel = cm.doc.sel, contained;
          if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
            leftButtonStartDrag(cm, event, pos, behavior);
          } else {
            leftButtonSelect(cm, event, pos, behavior);
          }
        }
        function leftButtonStartDrag(cm, event, pos, behavior) {
          var display = cm.display, moved = false;
          var dragEnd = operation(cm, function(e) {
            if (webkit2) {
              display.scroller.draggable = false;
            }
            cm.state.draggingText = false;
            if (cm.state.delayingBlurEvent) {
              if (cm.hasFocus()) {
                cm.state.delayingBlurEvent = false;
              } else {
                delayBlurEvent(cm);
              }
            }
            off(display.wrapper.ownerDocument, "mouseup", dragEnd);
            off(display.wrapper.ownerDocument, "mousemove", mouseMove);
            off(display.scroller, "dragstart", dragStart);
            off(display.scroller, "drop", dragEnd);
            if (!moved) {
              e_preventDefault(e);
              if (!behavior.addNew) {
                extendSelection(cm.doc, pos, null, null, behavior.extend);
              }
              if (webkit2 && !safari3 || ie3 && ie_version == 9) {
                setTimeout(function() {
                  display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                  display.input.focus();
                }, 20);
              } else {
                display.input.focus();
              }
            }
          });
          var mouseMove = function(e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
          };
          var dragStart = function() {
            return moved = true;
          };
          if (webkit2) {
            display.scroller.draggable = true;
          }
          cm.state.draggingText = dragEnd;
          dragEnd.copy = !behavior.moveOnDrag;
          on(display.wrapper.ownerDocument, "mouseup", dragEnd);
          on(display.wrapper.ownerDocument, "mousemove", mouseMove);
          on(display.scroller, "dragstart", dragStart);
          on(display.scroller, "drop", dragEnd);
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            return display.input.focus();
          }, 20);
          if (display.scroller.dragDrop) {
            display.scroller.dragDrop();
          }
        }
        function rangeForUnit(cm, pos, unit) {
          if (unit == "char") {
            return new Range4(pos, pos);
          }
          if (unit == "word") {
            return cm.findWordAt(pos);
          }
          if (unit == "line") {
            return new Range4(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          var result = unit(cm, pos);
          return new Range4(result.from, result.to);
        }
        function leftButtonSelect(cm, event, start2, behavior) {
          if (ie3) {
            delayBlurEvent(cm);
          }
          var display = cm.display, doc2 = cm.doc;
          e_preventDefault(event);
          var ourRange, ourIndex, startSel = doc2.sel, ranges = startSel.ranges;
          if (behavior.addNew && !behavior.extend) {
            ourIndex = doc2.sel.contains(start2);
            if (ourIndex > -1) {
              ourRange = ranges[ourIndex];
            } else {
              ourRange = new Range4(start2, start2);
            }
          } else {
            ourRange = doc2.sel.primary();
            ourIndex = doc2.sel.primIndex;
          }
          if (behavior.unit == "rectangle") {
            if (!behavior.addNew) {
              ourRange = new Range4(start2, start2);
            }
            start2 = posFromMouse(cm, event, true, true);
            ourIndex = -1;
          } else {
            var range2 = rangeForUnit(cm, start2, behavior.unit);
            if (behavior.extend) {
              ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
            } else {
              ourRange = range2;
            }
          }
          if (!behavior.addNew) {
            ourIndex = 0;
            setSelection(doc2, new Selection([ourRange], 0), sel_mouse);
            startSel = doc2.sel;
          } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(doc2, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
          } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
            setSelection(doc2, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
            startSel = doc2.sel;
          } else {
            replaceOneSelection(doc2, ourIndex, ourRange, sel_mouse);
          }
          var lastPos = start2;
          function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
              return;
            }
            lastPos = pos;
            if (behavior.unit == "rectangle") {
              var ranges2 = [], tabSize = cm.options.tabSize;
              var startCol = countColumn2(getLine(doc2, start2.line).text, start2.ch, tabSize);
              var posCol = countColumn2(getLine(doc2, pos.line).text, pos.ch, tabSize);
              var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
              for (var line = Math.min(start2.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end; line++) {
                var text = getLine(doc2, line).text, leftPos = findColumn2(text, left, tabSize);
                if (left == right) {
                  ranges2.push(new Range4(Pos(line, leftPos), Pos(line, leftPos)));
                } else if (text.length > leftPos) {
                  ranges2.push(new Range4(Pos(line, leftPos), Pos(line, findColumn2(text, right, tabSize))));
                }
              }
              if (!ranges2.length) {
                ranges2.push(new Range4(start2, start2));
              }
              setSelection(doc2, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
              cm.scrollIntoView(pos);
            } else {
              var oldRange = ourRange;
              var range3 = rangeForUnit(cm, pos, behavior.unit);
              var anchor = oldRange.anchor, head;
              if (cmp(range3.anchor, anchor) > 0) {
                head = range3.head;
                anchor = minPos(oldRange.from(), range3.anchor);
              } else {
                head = range3.anchor;
                anchor = maxPos(oldRange.to(), range3.head);
              }
              var ranges$1 = startSel.ranges.slice(0);
              ranges$1[ourIndex] = bidiSimplify(cm, new Range4(clipPos(doc2, anchor), head));
              setSelection(doc2, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
            }
          }
          var editorSize = display.wrapper.getBoundingClientRect();
          var counter = 0;
          function extend2(e) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
            if (!cur) {
              return;
            }
            if (cmp(cur, lastPos) != 0) {
              cm.curOp.focus = activeElt();
              extendTo(cur);
              var visible = visibleLines(display, doc2);
              if (cur.line >= visible.to || cur.line < visible.from) {
                setTimeout(operation(cm, function() {
                  if (counter == curCount) {
                    extend2(e);
                  }
                }), 150);
              }
            } else {
              var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
              if (outside) {
                setTimeout(operation(cm, function() {
                  if (counter != curCount) {
                    return;
                  }
                  display.scroller.scrollTop += outside;
                  extend2(e);
                }), 50);
              }
            }
          }
          function done(e) {
            cm.state.selectingText = false;
            counter = Infinity;
            if (e) {
              e_preventDefault(e);
              display.input.focus();
            }
            off(display.wrapper.ownerDocument, "mousemove", move);
            off(display.wrapper.ownerDocument, "mouseup", up);
            doc2.history.lastSelOrigin = null;
          }
          var move = operation(cm, function(e) {
            if (e.buttons === 0 || !e_button(e)) {
              done(e);
            } else {
              extend2(e);
            }
          });
          var up = operation(cm, done);
          cm.state.selectingText = up;
          on(display.wrapper.ownerDocument, "mousemove", move);
          on(display.wrapper.ownerDocument, "mouseup", up);
        }
        function bidiSimplify(cm, range2) {
          var anchor = range2.anchor;
          var head = range2.head;
          var anchorLine = getLine(cm.doc, anchor.line);
          if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range2;
          }
          var order = getOrder(anchorLine);
          if (!order) {
            return range2;
          }
          var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
          if (part.from != anchor.ch && part.to != anchor.ch) {
            return range2;
          }
          var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
          if (boundary == 0 || boundary == order.length) {
            return range2;
          }
          var leftSide;
          if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
          } else {
            var headIndex = getBidiPartAt(order, head.ch, head.sticky);
            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary) {
              leftSide = dir < 0;
            } else {
              leftSide = dir > 0;
            }
          }
          var usePart = order[boundary + (leftSide ? -1 : 0)];
          var from = leftSide == (usePart.level == 1);
          var ch2 = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
          return anchor.ch == ch2 && anchor.sticky == sticky ? range2 : new Range4(new Pos(anchor.line, ch2, sticky), head);
        }
        function gutterEvent(cm, e, type, prevent) {
          var mX, mY;
          if (e.touches) {
            mX = e.touches[0].clientX;
            mY = e.touches[0].clientY;
          } else {
            try {
              mX = e.clientX;
              mY = e.clientY;
            } catch (e$1) {
              return false;
            }
          }
          if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
            return false;
          }
          if (prevent) {
            e_preventDefault(e);
          }
          var display = cm.display;
          var lineBox = display.lineDiv.getBoundingClientRect();
          if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e);
          }
          mY -= lineBox.top - display.viewOffset;
          for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
            var g = display.gutters.childNodes[i2];
            if (g && g.getBoundingClientRect().right >= mX) {
              var line = lineAtHeight(cm.doc, mY);
              var gutter2 = cm.display.gutterSpecs[i2];
              signal(cm, type, cm, line, gutter2.className, e);
              return e_defaultPrevented(e);
            }
          }
        }
        function clickInGutter(cm, e) {
          return gutterEvent(cm, e, "gutterClick", true);
        }
        function onContextMenu(cm, e) {
          if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
            return;
          }
          if (signalDOMEvent(cm, e, "contextmenu")) {
            return;
          }
          if (!captureRightClick) {
            cm.display.input.onContextMenu(e);
          }
        }
        function contextMenuInGutter(cm, e) {
          if (!hasHandler(cm, "gutterContextMenu")) {
            return false;
          }
          return gutterEvent(cm, e, "gutterContextMenu", false);
        }
        function themeChanged(cm) {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
          clearCaches(cm);
        }
        var Init = { toString: function() {
          return "CodeMirror.Init";
        } };
        var defaults2 = {};
        var optionHandlers = {};
        function defineOptions(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          function option(name2, deflt, handle, notOnInit) {
            CodeMirror4.defaults[name2] = deflt;
            if (handle) {
              optionHandlers2[name2] = notOnInit ? function(cm, val, old) {
                if (old != Init) {
                  handle(cm, val, old);
                }
              } : handle;
            }
          }
          CodeMirror4.defineOption = option;
          CodeMirror4.Init = Init;
          option("value", "", function(cm, val) {
            return cm.setValue(val);
          }, true);
          option("mode", null, function(cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
          }, true);
          option("indentUnit", 2, loadMode, true);
          option("indentWithTabs", false);
          option("smartIndent", true);
          option("tabSize", 4, function(cm) {
            resetModeState(cm);
            clearCaches(cm);
            regChange(cm);
          }, true);
          option("lineSeparator", null, function(cm, val) {
            cm.doc.lineSep = val;
            if (!val) {
              return;
            }
            var newBreaks = [], lineNo2 = cm.doc.first;
            cm.doc.iter(function(line) {
              for (var pos = 0; ; ) {
                var found = line.text.indexOf(val, pos);
                if (found == -1) {
                  break;
                }
                pos = found + val.length;
                newBreaks.push(Pos(lineNo2, found));
              }
              lineNo2++;
            });
            for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
              replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
            }
          });
          option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
            if (old != Init) {
              cm.refresh();
            }
          });
          option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
          }, true);
          option("electricChars", true);
          option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
          }, true);
          option("spellcheck", false, function(cm, val) {
            return cm.getInputField().spellcheck = val;
          }, true);
          option("autocorrect", false, function(cm, val) {
            return cm.getInputField().autocorrect = val;
          }, true);
          option("autocapitalize", false, function(cm, val) {
            return cm.getInputField().autocapitalize = val;
          }, true);
          option("rtlMoveVisually", !windows);
          option("wholeLineUpdateBefore", true);
          option("theme", "default", function(cm) {
            themeChanged(cm);
            updateGutters(cm);
          }, true);
          option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val);
            var prev = old != Init && getKeyMap(old);
            if (prev && prev.detach) {
              prev.detach(cm, next);
            }
            if (next.attach) {
              next.attach(cm, prev || null);
            }
          });
          option("extraKeys", null);
          option("configureMouse", null);
          option("lineWrapping", false, wrappingChanged, true);
          option("gutters", [], function(cm, val) {
            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
            updateGutters(cm);
          }, true);
          option("fixedGutter", true, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
            cm.refresh();
          }, true);
          option("coverGutterNextToScrollbar", false, function(cm) {
            return updateScrollbars(cm);
          }, true);
          option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm);
            updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
          }, true);
          option("lineNumbers", false, function(cm, val) {
            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
            updateGutters(cm);
          }, true);
          option("firstLineNumber", 1, updateGutters, true);
          option("lineNumberFormatter", function(integer) {
            return integer;
          }, updateGutters, true);
          option("showCursorWhenSelecting", false, updateSelection, true);
          option("resetSelectionOnContextMenu", true);
          option("lineWiseCopyCut", true);
          option("pasteLinesPerSelection", true);
          option("selectionsMayTouch", false);
          option("readOnly", false, function(cm, val) {
            if (val == "nocursor") {
              onBlur(cm);
              cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
          });
          option("screenReaderLabel", null, function(cm, val) {
            val = val === "" ? null : val;
            cm.display.input.screenReaderLabelChanged(val);
          });
          option("disableInput", false, function(cm, val) {
            if (!val) {
              cm.display.input.reset();
            }
          }, true);
          option("dragDrop", true, dragDropChanged);
          option("allowDropFileTypes", null);
          option("cursorBlinkRate", 530);
          option("cursorScrollMargin", 0);
          option("cursorHeight", 1, updateSelection, true);
          option("singleCursorHeightPerLine", true, updateSelection, true);
          option("workTime", 100);
          option("workDelay", 100);
          option("flattenSpans", true, resetModeState, true);
          option("addModeClass", false, resetModeState, true);
          option("pollInterval", 100);
          option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
          });
          option("historyEventDelay", 1250);
          option("viewportMargin", 10, function(cm) {
            return cm.refresh();
          }, true);
          option("maxHighlightLength", 1e4, resetModeState, true);
          option("moveInputWithCursor", true, function(cm, val) {
            if (!val) {
              cm.display.input.resetPosition();
            }
          });
          option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
          });
          option("autofocus", null);
          option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
          }, true);
          option("phrases", null);
        }
        function dragDropChanged(cm, value, old) {
          var wasOn = old && old != Init;
          if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start);
            toggle(cm.display.scroller, "dragenter", funcs.enter);
            toggle(cm.display.scroller, "dragover", funcs.over);
            toggle(cm.display.scroller, "dragleave", funcs.leave);
            toggle(cm.display.scroller, "drop", funcs.drop);
          }
        }
        function wrappingChanged(cm) {
          if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, "CodeMirror-wrap");
            cm.display.sizer.style.minWidth = "";
            cm.display.sizerWidth = null;
          } else {
            rmClass(cm.display.wrapper, "CodeMirror-wrap");
            findMaxLine(cm);
          }
          estimateLineHeights(cm);
          regChange(cm);
          clearCaches(cm);
          setTimeout(function() {
            return updateScrollbars(cm);
          }, 100);
        }
        function CodeMirror3(place, options) {
          var this$1 = this;
          if (!(this instanceof CodeMirror3)) {
            return new CodeMirror3(place, options);
          }
          this.options = options = options ? copyObj(options) : {};
          copyObj(defaults2, options, false);
          var doc2 = options.value;
          if (typeof doc2 == "string") {
            doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
          } else if (options.mode) {
            doc2.modeOption = options.mode;
          }
          this.doc = doc2;
          var input = new CodeMirror3.inputStyles[options.inputStyle](this);
          var display = this.display = new Display(place, doc2, input, options);
          display.wrapper.CodeMirror = this;
          themeChanged(this);
          if (options.lineWrapping) {
            this.display.wrapper.className += " CodeMirror-wrap";
          }
          initScrollbars(this);
          this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
          };
          if (options.autofocus && !mobile) {
            display.input.focus();
          }
          if (ie3 && ie_version < 11) {
            setTimeout(function() {
              return this$1.display.input.reset(true);
            }, 20);
          }
          registerEventHandlers(this);
          ensureGlobalHandlers();
          startOperation(this);
          this.curOp.forceUpdate = true;
          attachDoc(this, doc2);
          if (options.autofocus && !mobile || this.hasFocus()) {
            setTimeout(function() {
              if (this$1.hasFocus() && !this$1.state.focused) {
                onFocus(this$1);
              }
            }, 20);
          } else {
            onBlur(this);
          }
          for (var opt in optionHandlers) {
            if (optionHandlers.hasOwnProperty(opt)) {
              optionHandlers[opt](this, options[opt], Init);
            }
          }
          maybeUpdateLineNumberWidth(this);
          if (options.finishInit) {
            options.finishInit(this);
          }
          for (var i2 = 0; i2 < initHooks.length; ++i2) {
            initHooks[i2](this);
          }
          endOperation(this);
          if (webkit2 && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
            display.lineDiv.style.textRendering = "auto";
          }
        }
        CodeMirror3.defaults = defaults2;
        CodeMirror3.optionHandlers = optionHandlers;
        function registerEventHandlers(cm) {
          var d = cm.display;
          on(d.scroller, "mousedown", operation(cm, onMouseDown));
          if (ie3 && ie_version < 11) {
            on(d.scroller, "dblclick", operation(cm, function(e) {
              if (signalDOMEvent(cm, e)) {
                return;
              }
              var pos = posFromMouse(cm, e);
              if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
                return;
              }
              e_preventDefault(e);
              var word = cm.findWordAt(pos);
              extendSelection(cm.doc, word.anchor, word.head);
            }));
          } else {
            on(d.scroller, "dblclick", function(e) {
              return signalDOMEvent(cm, e) || e_preventDefault(e);
            });
          }
          on(d.scroller, "contextmenu", function(e) {
            return onContextMenu(cm, e);
          });
          on(d.input.getField(), "contextmenu", function(e) {
            if (!d.scroller.contains(e.target)) {
              onContextMenu(cm, e);
            }
          });
          var touchFinished, prevTouch = { end: 0 };
          function finishTouch() {
            if (d.activeTouch) {
              touchFinished = setTimeout(function() {
                return d.activeTouch = null;
              }, 1e3);
              prevTouch = d.activeTouch;
              prevTouch.end = +new Date();
            }
          }
          function isMouseLikeTouchEvent(e) {
            if (e.touches.length != 1) {
              return false;
            }
            var touch = e.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
          }
          function farAway(touch, other) {
            if (other.left == null) {
              return true;
            }
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
          }
          on(d.scroller, "touchstart", function(e) {
            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
              d.input.ensurePolled();
              clearTimeout(touchFinished);
              var now = +new Date();
              d.activeTouch = {
                start: now,
                moved: false,
                prev: now - prevTouch.end <= 300 ? prevTouch : null
              };
              if (e.touches.length == 1) {
                d.activeTouch.left = e.touches[0].pageX;
                d.activeTouch.top = e.touches[0].pageY;
              }
            }
          });
          on(d.scroller, "touchmove", function() {
            if (d.activeTouch) {
              d.activeTouch.moved = true;
            }
          });
          on(d.scroller, "touchend", function(e) {
            var touch = d.activeTouch;
            if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
              var pos = cm.coordsChar(d.activeTouch, "page"), range2;
              if (!touch.prev || farAway(touch, touch.prev)) {
                range2 = new Range4(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                range2 = cm.findWordAt(pos);
              } else {
                range2 = new Range4(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }
              cm.setSelection(range2.anchor, range2.head);
              cm.focus();
              e_preventDefault(e);
            }
            finishTouch();
          });
          on(d.scroller, "touchcancel", finishTouch);
          on(d.scroller, "scroll", function() {
            if (d.scroller.clientHeight) {
              updateScrollTop(cm, d.scroller.scrollTop);
              setScrollLeft(cm, d.scroller.scrollLeft, true);
              signal(cm, "scroll", cm);
            }
          });
          on(d.scroller, "mousewheel", function(e) {
            return onScrollWheel(cm, e);
          });
          on(d.scroller, "DOMMouseScroll", function(e) {
            return onScrollWheel(cm, e);
          });
          on(d.wrapper, "scroll", function() {
            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
          });
          d.dragFunctions = {
            enter: function(e) {
              if (!signalDOMEvent(cm, e)) {
                e_stop(e);
              }
            },
            over: function(e) {
              if (!signalDOMEvent(cm, e)) {
                onDragOver(cm, e);
                e_stop(e);
              }
            },
            start: function(e) {
              return onDragStart(cm, e);
            },
            drop: operation(cm, onDrop),
            leave: function(e) {
              if (!signalDOMEvent(cm, e)) {
                clearDragCursor(cm);
              }
            }
          };
          var inp = d.input.getField();
          on(inp, "keyup", function(e) {
            return onKeyUp.call(cm, e);
          });
          on(inp, "keydown", operation(cm, onKeyDown));
          on(inp, "keypress", operation(cm, onKeyPress));
          on(inp, "focus", function(e) {
            return onFocus(cm, e);
          });
          on(inp, "blur", function(e) {
            return onBlur(cm, e);
          });
        }
        var initHooks = [];
        CodeMirror3.defineInitHook = function(f) {
          return initHooks.push(f);
        };
        function indentLine(cm, n, how, aggressive) {
          var doc2 = cm.doc, state;
          if (how == null) {
            how = "add";
          }
          if (how == "smart") {
            if (!doc2.mode.indent) {
              how = "prev";
            } else {
              state = getContextBefore(cm, n).state;
            }
          }
          var tabSize = cm.options.tabSize;
          var line = getLine(doc2, n), curSpace = countColumn2(line.text, null, tabSize);
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          var curSpaceString = line.text.match(/^\s*/)[0], indentation;
          if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = "not";
          } else if (how == "smart") {
            indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
              if (!aggressive) {
                return;
              }
              how = "prev";
            }
          }
          if (how == "prev") {
            if (n > doc2.first) {
              indentation = countColumn2(getLine(doc2, n - 1).text, null, tabSize);
            } else {
              indentation = 0;
            }
          } else if (how == "add") {
            indentation = curSpace + cm.options.indentUnit;
          } else if (how == "subtract") {
            indentation = curSpace - cm.options.indentUnit;
          } else if (typeof how == "number") {
            indentation = curSpace + how;
          }
          indentation = Math.max(0, indentation);
          var indentString = "", pos = 0;
          if (cm.options.indentWithTabs) {
            for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
              pos += tabSize;
              indentString += "	";
            }
          }
          if (pos < indentation) {
            indentString += spaceStr(indentation - pos);
          }
          if (indentString != curSpaceString) {
            replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
            line.stateAfter = null;
            return true;
          } else {
            for (var i$12 = 0; i$12 < doc2.sel.ranges.length; i$12++) {
              var range2 = doc2.sel.ranges[i$12];
              if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
                var pos$1 = Pos(n, curSpaceString.length);
                replaceOneSelection(doc2, i$12, new Range4(pos$1, pos$1));
                break;
              }
            }
          }
        }
        var lastCopied = null;
        function setLastCopied(newLastCopied) {
          lastCopied = newLastCopied;
        }
        function applyTextInput(cm, inserted, deleted, sel, origin) {
          var doc2 = cm.doc;
          cm.display.shift = false;
          if (!sel) {
            sel = doc2.sel;
          }
          var recent = +new Date() - 200;
          var paste = origin == "paste" || cm.state.pasteIncoming > recent;
          var textLines = splitLinesAuto(inserted), multiPaste = null;
          if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join("\n") == inserted) {
              if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = [];
                for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
                  multiPaste.push(doc2.splitLines(lastCopied.text[i2]));
                }
              }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
              multiPaste = map2(textLines, function(l) {
                return [l];
              });
            }
          }
          var updateInput = cm.curOp.updateInput;
          for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
            var range2 = sel.ranges[i$12];
            var from = range2.from(), to = range2.to();
            if (range2.empty()) {
              if (deleted && deleted > 0) {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) {
                to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
                from = to = Pos(from.line, 0);
              }
            }
            var changeEvent = {
              from,
              to,
              text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
              origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, "inputRead", cm, changeEvent);
          }
          if (inserted && !paste) {
            triggerElectric(cm, inserted);
          }
          ensureCursorVisible(cm);
          if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput;
          }
          cm.curOp.typing = true;
          cm.state.pasteIncoming = cm.state.cutIncoming = -1;
        }
        function handlePaste(e, cm) {
          var pasted = e.clipboardData && e.clipboardData.getData("Text");
          if (pasted) {
            e.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput) {
              runInOp(cm, function() {
                return applyTextInput(cm, pasted, 0, null, "paste");
              });
            }
            return true;
          }
        }
        function triggerElectric(cm, inserted) {
          if (!cm.options.electricChars || !cm.options.smartIndent) {
            return;
          }
          var sel = cm.doc.sel;
          for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
            var range2 = sel.ranges[i2];
            if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
              continue;
            }
            var mode = cm.getModeAt(range2.head);
            var indented = false;
            if (mode.electricChars) {
              for (var j = 0; j < mode.electricChars.length; j++) {
                if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                  indented = indentLine(cm, range2.head.line, "smart");
                  break;
                }
              }
            } else if (mode.electricInput) {
              if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
                indented = indentLine(cm, range2.head.line, "smart");
              }
            }
            if (indented) {
              signalLater(cm, "electricInput", cm, range2.head.line);
            }
          }
        }
        function copyableRanges(cm) {
          var text = [], ranges = [];
          for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
            var line = cm.doc.sel.ranges[i2].head.line;
            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
          }
          return { text, ranges };
        }
        function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
          field.setAttribute("autocorrect", autocorrect ? "" : "off");
          field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
          field.setAttribute("spellcheck", !!spellcheck);
        }
        function hiddenTextarea() {
          var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
          var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
          if (webkit2) {
            te.style.width = "1000px";
          } else {
            te.setAttribute("wrap", "off");
          }
          if (ios) {
            te.style.border = "1px solid black";
          }
          disableBrowserMagic(te);
          return div;
        }
        function addEditorMethods(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          var helpers = CodeMirror4.helpers = {};
          CodeMirror4.prototype = {
            constructor: CodeMirror4,
            focus: function() {
              window.focus();
              this.display.input.focus();
            },
            setOption: function(option, value) {
              var options = this.options, old = options[option];
              if (options[option] == value && option != "mode") {
                return;
              }
              options[option] = value;
              if (optionHandlers2.hasOwnProperty(option)) {
                operation(this, optionHandlers2[option])(this, value, old);
              }
              signal(this, "optionChange", this, option);
            },
            getOption: function(option) {
              return this.options[option];
            },
            getDoc: function() {
              return this.doc;
            },
            addKeyMap: function(map3, bottom) {
              this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map3));
            },
            removeKeyMap: function(map3) {
              var maps = this.state.keyMaps;
              for (var i2 = 0; i2 < maps.length; ++i2) {
                if (maps[i2] == map3 || maps[i2].name == map3) {
                  maps.splice(i2, 1);
                  return true;
                }
              }
            },
            addOverlay: methodOp(function(spec, options) {
              var mode = spec.token ? spec : CodeMirror4.getMode(this.options, spec);
              if (mode.startState) {
                throw new Error("Overlays may not be stateful.");
              }
              insertSorted(this.state.overlays, {
                mode,
                modeSpec: spec,
                opaque: options && options.opaque,
                priority: options && options.priority || 0
              }, function(overlay) {
                return overlay.priority;
              });
              this.state.modeGen++;
              regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
              var overlays = this.state.overlays;
              for (var i2 = 0; i2 < overlays.length; ++i2) {
                var cur = overlays[i2].modeSpec;
                if (cur == spec || typeof spec == "string" && cur.name == spec) {
                  overlays.splice(i2, 1);
                  this.state.modeGen++;
                  regChange(this);
                  return;
                }
              }
            }),
            indentLine: methodOp(function(n, dir, aggressive) {
              if (typeof dir != "string" && typeof dir != "number") {
                if (dir == null) {
                  dir = this.options.smartIndent ? "smart" : "prev";
                } else {
                  dir = dir ? "add" : "subtract";
                }
              }
              if (isLine(this.doc, n)) {
                indentLine(this, n, dir, aggressive);
              }
            }),
            indentSelection: methodOp(function(how) {
              var ranges = this.doc.sel.ranges, end = -1;
              for (var i2 = 0; i2 < ranges.length; i2++) {
                var range2 = ranges[i2];
                if (!range2.empty()) {
                  var from = range2.from(), to = range2.to();
                  var start2 = Math.max(end, from.line);
                  end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                  for (var j = start2; j < end; ++j) {
                    indentLine(this, j, how);
                  }
                  var newRanges = this.doc.sel.ranges;
                  if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                    replaceOneSelection(this.doc, i2, new Range4(from, newRanges[i2].to()), sel_dontScroll);
                  }
                } else if (range2.head.line > end) {
                  indentLine(this, range2.head.line, how, true);
                  end = range2.head.line;
                  if (i2 == this.doc.sel.primIndex) {
                    ensureCursorVisible(this);
                  }
                }
              }
            }),
            getTokenAt: function(pos, precise) {
              return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
              return takeToken(this, Pos(line), precise, true);
            },
            getTokenTypeAt: function(pos) {
              pos = clipPos(this.doc, pos);
              var styles = getLineStyles(this, getLine(this.doc, pos.line));
              var before = 0, after = (styles.length - 1) / 2, ch2 = pos.ch;
              var type;
              if (ch2 == 0) {
                type = styles[2];
              } else {
                for (; ; ) {
                  var mid = before + after >> 1;
                  if ((mid ? styles[mid * 2 - 1] : 0) >= ch2) {
                    after = mid;
                  } else if (styles[mid * 2 + 1] < ch2) {
                    before = mid + 1;
                  } else {
                    type = styles[mid * 2 + 2];
                    break;
                  }
                }
              }
              var cut = type ? type.indexOf("overlay ") : -1;
              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
              var mode = this.doc.mode;
              if (!mode.innerMode) {
                return mode;
              }
              return CodeMirror4.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function(pos, type) {
              return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
              var found = [];
              if (!helpers.hasOwnProperty(type)) {
                return found;
              }
              var help = helpers[type], mode = this.getModeAt(pos);
              if (typeof mode[type] == "string") {
                if (help[mode[type]]) {
                  found.push(help[mode[type]]);
                }
              } else if (mode[type]) {
                for (var i2 = 0; i2 < mode[type].length; i2++) {
                  var val = help[mode[type][i2]];
                  if (val) {
                    found.push(val);
                  }
                }
              } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
              } else if (help[mode.name]) {
                found.push(help[mode.name]);
              }
              for (var i$12 = 0; i$12 < help._global.length; i$12++) {
                var cur = help._global[i$12];
                if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                  found.push(cur.val);
                }
              }
              return found;
            },
            getStateAfter: function(line, precise) {
              var doc2 = this.doc;
              line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
              return getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function(start2, mode) {
              var pos, range2 = this.doc.sel.primary();
              if (start2 == null) {
                pos = range2.head;
              } else if (typeof start2 == "object") {
                pos = clipPos(this.doc, start2);
              } else {
                pos = start2 ? range2.from() : range2.to();
              }
              return cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
              return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
              coords = fromCoordSystem(this, coords, mode || "page");
              return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
              height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
              return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
              var end = false, lineObj;
              if (typeof line == "number") {
                var last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first) {
                  line = this.doc.first;
                } else if (line > last) {
                  line = last;
                  end = true;
                }
                lineObj = getLine(this.doc, line);
              } else {
                lineObj = line;
              }
              return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
              return textHeight(this.display);
            },
            defaultCharWidth: function() {
              return charWidth(this.display);
            },
            getViewport: function() {
              return { from: this.display.viewFrom, to: this.display.viewTo };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
              var display = this.display;
              pos = cursorCoords(this, clipPos(this.doc, pos));
              var top2 = pos.bottom, left = pos.left;
              node.style.position = "absolute";
              node.setAttribute("cm-ignore-events", "true");
              this.display.input.setUneditable(node);
              display.sizer.appendChild(node);
              if (vert == "over") {
                top2 = pos.top;
              } else if (vert == "above" || vert == "near") {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                  top2 = pos.top - node.offsetHeight;
                } else if (pos.bottom + node.offsetHeight <= vspace) {
                  top2 = pos.bottom;
                }
                if (left + node.offsetWidth > hspace) {
                  left = hspace - node.offsetWidth;
                }
              }
              node.style.top = top2 + "px";
              node.style.left = node.style.right = "";
              if (horiz == "right") {
                left = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = "0px";
              } else {
                if (horiz == "left") {
                  left = 0;
                } else if (horiz == "middle") {
                  left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                }
                node.style.left = left + "px";
              }
              if (scroll) {
                scrollIntoView(this, { left, top: top2, right: left + node.offsetWidth, bottom: top2 + node.offsetHeight });
              }
            },
            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
              if (commands.hasOwnProperty(cmd)) {
                return commands[cmd].call(null, this);
              }
            },
            triggerElectric: methodOp(function(text) {
              triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
              var dir = 1;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i2 = 0; i2 < amount; ++i2) {
                cur = findPosH(this.doc, cur, dir, unit, visually);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveH: methodOp(function(dir, unit) {
              var this$1 = this;
              this.extendSelectionsBy(function(range2) {
                if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
                  return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);
                } else {
                  return dir < 0 ? range2.from() : range2.to();
                }
              }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
              var sel = this.doc.sel, doc2 = this.doc;
              if (sel.somethingSelected()) {
                doc2.replaceSelection("", null, "+delete");
              } else {
                deleteNearSelection(this, function(range2) {
                  var other = findPosH(doc2, range2.head, dir, unit, false);
                  return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
                });
              }
            }),
            findPosV: function(from, amount, unit, goalColumn) {
              var dir = 1, x = goalColumn;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i2 = 0; i2 < amount; ++i2) {
                var coords = cursorCoords(this, cur, "div");
                if (x == null) {
                  x = coords.left;
                } else {
                  coords.left = x;
                }
                cur = findPosV(this, coords, dir, unit);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveV: methodOp(function(dir, unit) {
              var this$1 = this;
              var doc2 = this.doc, goals = [];
              var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
              doc2.extendSelectionsBy(function(range2) {
                if (collapse) {
                  return dir < 0 ? range2.from() : range2.to();
                }
                var headPos = cursorCoords(this$1, range2.head, "div");
                if (range2.goalColumn != null) {
                  headPos.left = range2.goalColumn;
                }
                goals.push(headPos.left);
                var pos = findPosV(this$1, headPos, dir, unit);
                if (unit == "page" && range2 == doc2.sel.primary()) {
                  addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
                }
                return pos;
              }, sel_move);
              if (goals.length) {
                for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
                  doc2.sel.ranges[i2].goalColumn = goals[i2];
                }
              }
            }),
            findWordAt: function(pos) {
              var doc2 = this.doc, line = getLine(doc2, pos.line).text;
              var start2 = pos.ch, end = pos.ch;
              if (line) {
                var helper = this.getHelper(pos, "wordChars");
                if ((pos.sticky == "before" || end == line.length) && start2) {
                  --start2;
                } else {
                  ++end;
                }
                var startChar = line.charAt(start2);
                var check = isWordChar(startChar, helper) ? function(ch2) {
                  return isWordChar(ch2, helper);
                } : /\s/.test(startChar) ? function(ch2) {
                  return /\s/.test(ch2);
                } : function(ch2) {
                  return !/\s/.test(ch2) && !isWordChar(ch2);
                };
                while (start2 > 0 && check(line.charAt(start2 - 1))) {
                  --start2;
                }
                while (end < line.length && check(line.charAt(end))) {
                  ++end;
                }
              }
              return new Range4(Pos(pos.line, start2), Pos(pos.line, end));
            },
            toggleOverwrite: function(value) {
              if (value != null && value == this.state.overwrite) {
                return;
              }
              if (this.state.overwrite = !this.state.overwrite) {
                addClass(this.display.cursorDiv, "CodeMirror-overwrite");
              } else {
                rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
              }
              signal(this, "overwriteToggle", this, this.state.overwrite);
            },
            hasFocus: function() {
              return this.display.input.getField() == activeElt();
            },
            isReadOnly: function() {
              return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x, y) {
              scrollToCoords(this, x, y);
            }),
            getScrollInfo: function() {
              var scroller = this.display.scroller;
              return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
              };
            },
            scrollIntoView: methodOp(function(range2, margin) {
              if (range2 == null) {
                range2 = { from: this.doc.sel.primary().head, to: null };
                if (margin == null) {
                  margin = this.options.cursorScrollMargin;
                }
              } else if (typeof range2 == "number") {
                range2 = { from: Pos(range2, 0), to: null };
              } else if (range2.from == null) {
                range2 = { from: range2, to: null };
              }
              if (!range2.to) {
                range2.to = range2.from;
              }
              range2.margin = margin || 0;
              if (range2.from.line != null) {
                scrollToRange(this, range2);
              } else {
                scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
              }
            }),
            setSize: methodOp(function(width, height) {
              var this$1 = this;
              var interpret = function(val) {
                return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
              };
              if (width != null) {
                this.display.wrapper.style.width = interpret(width);
              }
              if (height != null) {
                this.display.wrapper.style.height = interpret(height);
              }
              if (this.options.lineWrapping) {
                clearLineMeasurementCache(this);
              }
              var lineNo2 = this.display.viewFrom;
              this.doc.iter(lineNo2, this.display.viewTo, function(line) {
                if (line.widgets) {
                  for (var i2 = 0; i2 < line.widgets.length; i2++) {
                    if (line.widgets[i2].noHScroll) {
                      regLineChange(this$1, lineNo2, "widget");
                      break;
                    }
                  }
                }
                ++lineNo2;
              });
              this.curOp.forceUpdate = true;
              signal(this, "refresh", this);
            }),
            operation: function(f) {
              return runInOp(this, f);
            },
            startOperation: function() {
              return startOperation(this);
            },
            endOperation: function() {
              return endOperation(this);
            },
            refresh: methodOp(function() {
              var oldHeight = this.display.cachedTextHeight;
              regChange(this);
              this.curOp.forceUpdate = true;
              clearCaches(this);
              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
              updateGutterSpace(this.display);
              if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
                estimateLineHeights(this);
              }
              signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc2) {
              var old = this.doc;
              old.cm = null;
              if (this.state.selectingText) {
                this.state.selectingText();
              }
              attachDoc(this, doc2);
              clearCaches(this);
              this.display.input.reset();
              scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
              this.curOp.forceScroll = true;
              signalLater(this, "swapDoc", this, old);
              return old;
            }),
            phrase: function(phraseText) {
              var phrases = this.options.phrases;
              return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function() {
              return this.display.input.getField();
            },
            getWrapperElement: function() {
              return this.display.wrapper;
            },
            getScrollerElement: function() {
              return this.display.scroller;
            },
            getGutterElement: function() {
              return this.display.gutters;
            }
          };
          eventMixin(CodeMirror4);
          CodeMirror4.registerHelper = function(type, name2, value) {
            if (!helpers.hasOwnProperty(type)) {
              helpers[type] = CodeMirror4[type] = { _global: [] };
            }
            helpers[type][name2] = value;
          };
          CodeMirror4.registerGlobalHelper = function(type, name2, predicate, value) {
            CodeMirror4.registerHelper(type, name2, value);
            helpers[type]._global.push({ pred: predicate, val: value });
          };
        }
        function findPosH(doc2, pos, dir, unit, visually) {
          var oldPos = pos;
          var origDir = dir;
          var lineObj = getLine(doc2, pos.line);
          var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
          function findNextLine() {
            var l = pos.line + lineDir;
            if (l < doc2.first || l >= doc2.first + doc2.size) {
              return false;
            }
            pos = new Pos(l, pos.ch, pos.sticky);
            return lineObj = getLine(doc2, l);
          }
          function moveOnce(boundToLine) {
            var next;
            if (unit == "codepoint") {
              var ch2 = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
              if (isNaN(ch2)) {
                next = null;
              } else {
                var astral = dir > 0 ? ch2 >= 55296 && ch2 < 56320 : ch2 >= 56320 && ch2 < 57343;
                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
              }
            } else if (visually) {
              next = moveVisually2(doc2.cm, lineObj, pos, dir);
            } else {
              next = moveLogically(lineObj, pos, dir);
            }
            if (next == null) {
              if (!boundToLine && findNextLine()) {
                pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
              } else {
                return false;
              }
            } else {
              pos = next;
            }
            return true;
          }
          if (unit == "char" || unit == "codepoint") {
            moveOnce();
          } else if (unit == "column") {
            moveOnce(true);
          } else if (unit == "word" || unit == "group") {
            var sawType = null, group = unit == "group";
            var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
            for (var first = true; ; first = false) {
              if (dir < 0 && !moveOnce(!first)) {
                break;
              }
              var cur = lineObj.text.charAt(pos.ch) || "\n";
              var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
              if (group && !first && !type) {
                type = "s";
              }
              if (sawType && sawType != type) {
                if (dir < 0) {
                  dir = 1;
                  moveOnce();
                  pos.sticky = "after";
                }
                break;
              }
              if (type) {
                sawType = type;
              }
              if (dir > 0 && !moveOnce(!first)) {
                break;
              }
            }
          }
          var result = skipAtomic(doc2, pos, oldPos, origDir, true);
          if (equalCursorPos(oldPos, result)) {
            result.hitSide = true;
          }
          return result;
        }
        function findPosV(cm, pos, dir, unit) {
          var doc2 = cm.doc, x = pos.left, y;
          if (unit == "page") {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
          } else if (unit == "line") {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
          }
          var target;
          for (; ; ) {
            target = coordsChar(cm, x, y);
            if (!target.outside) {
              break;
            }
            if (dir < 0 ? y <= 0 : y >= doc2.height) {
              target.hitSide = true;
              break;
            }
            y += dir * 5;
          }
          return target;
        }
        var ContentEditableInput = function(cm) {
          this.cm = cm;
          this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
          this.polling = new Delayed();
          this.composing = null;
          this.gracePeriod = false;
          this.readDOMTimeout = null;
        };
        ContentEditableInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = input.cm;
          var div = input.div = display.lineDiv;
          div.contentEditable = true;
          disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
          function belongsToInput(e) {
            for (var t2 = e.target; t2; t2 = t2.parentNode) {
              if (t2 == div) {
                return true;
              }
              if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
                break;
              }
            }
            return false;
          }
          on(div, "paste", function(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return;
            }
            if (ie_version <= 11) {
              setTimeout(operation(cm, function() {
                return this$1.updateFromDOM();
              }), 20);
            }
          });
          on(div, "compositionstart", function(e) {
            this$1.composing = { data: e.data, done: false };
          });
          on(div, "compositionupdate", function(e) {
            if (!this$1.composing) {
              this$1.composing = { data: e.data, done: false };
            }
          });
          on(div, "compositionend", function(e) {
            if (this$1.composing) {
              if (e.data != this$1.composing.data) {
                this$1.readFromDOMSoon();
              }
              this$1.composing.done = true;
            }
          });
          on(div, "touchstart", function() {
            return input.forceCompositionEnd();
          });
          on(div, "input", function() {
            if (!this$1.composing) {
              this$1.readFromDOMSoon();
            }
          });
          function onCopyCut(e) {
            if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
              if (e.type == "cut") {
                cm.replaceSelection("", null, "cut");
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e.clipboardData) {
              e.clipboardData.clearData();
              var content2 = lastCopied.text.join("\n");
              e.clipboardData.setData("Text", content2);
              if (e.clipboardData.getData("Text") == content2) {
                e.preventDefault();
                return;
              }
            }
            var kludge = hiddenTextarea(), te = kludge.firstChild;
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = activeElt();
            selectInput(te);
            setTimeout(function() {
              cm.display.lineSpace.removeChild(kludge);
              hadFocus.focus();
              if (hadFocus == div) {
                input.showPrimarySelection();
              }
            }, 50);
          }
          on(div, "copy", onCopyCut);
          on(div, "cut", onCopyCut);
        };
        ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.div.setAttribute("aria-label", label);
          } else {
            this.div.removeAttribute("aria-label");
          }
        };
        ContentEditableInput.prototype.prepareSelection = function() {
          var result = prepareSelection(this.cm, false);
          result.focus = activeElt() == this.div;
          return result;
        };
        ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
          if (!info || !this.cm.display.view.length) {
            return;
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection();
          }
          this.showMultipleSelections(info);
        };
        ContentEditableInput.prototype.getSelection = function() {
          return this.cm.display.wrapper.ownerDocument.getSelection();
        };
        ContentEditableInput.prototype.showPrimarySelection = function() {
          var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
          var from = prim.from(), to = prim.to();
          if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
            sel.removeAllRanges();
            return;
          }
          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
            return;
          }
          var view = cm.display.view;
          var start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
          var end = to.line < cm.display.viewTo && posToDOM(cm, to);
          if (!end) {
            var measure = view[view.length - 1].measure;
            var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
          }
          if (!start2 || !end) {
            sel.removeAllRanges();
            return;
          }
          var old = sel.rangeCount && sel.getRangeAt(0), rng;
          try {
            rng = range(start2.node, start2.offset, end.offset, end.node);
          } catch (e) {
          }
          if (rng) {
            if (!gecko3 && cm.state.focused) {
              sel.collapse(start2.node, start2.offset);
              if (!rng.collapsed) {
                sel.removeAllRanges();
                sel.addRange(rng);
              }
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old);
            } else if (gecko3) {
              this.startGracePeriod();
            }
          }
          this.rememberSelection();
        };
        ContentEditableInput.prototype.startGracePeriod = function() {
          var this$1 = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = true;
              });
            }
          }, 20);
        };
        ContentEditableInput.prototype.showMultipleSelections = function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        };
        ContentEditableInput.prototype.rememberSelection = function() {
          var sel = this.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        };
        ContentEditableInput.prototype.selectionInEditor = function() {
          var sel = this.getSelection();
          if (!sel.rangeCount) {
            return false;
          }
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains2(this.div, node);
        };
        ContentEditableInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor() || activeElt() != this.div) {
              this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
          }
        };
        ContentEditableInput.prototype.blur = function() {
          this.div.blur();
        };
        ContentEditableInput.prototype.getField = function() {
          return this.div;
        };
        ContentEditableInput.prototype.supportsTouch = function() {
          return true;
        };
        ContentEditableInput.prototype.receivedFocus = function() {
          var this$1 = this;
          var input = this;
          if (this.selectionInEditor()) {
            setTimeout(function() {
              return this$1.pollSelection();
            }, 20);
          } else {
            runInOp(this.cm, function() {
              return input.cm.curOp.selectionChanged = true;
            });
          }
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        };
        ContentEditableInput.prototype.selectionChanged = function() {
          var sel = this.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        };
        ContentEditableInput.prototype.pollSelection = function() {
          if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
            return;
          }
          var sel = this.getSelection(), cm = this.cm;
          if (android && chrome3 && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
            this.blur();
            this.focus();
            return;
          }
          if (this.composing) {
            return;
          }
          this.rememberSelection();
          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var head = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (anchor && head) {
            runInOp(cm, function() {
              setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
              if (anchor.bad || head.bad) {
                cm.curOp.selectionChanged = true;
              }
            });
          }
        };
        ContentEditableInput.prototype.pollContent = function() {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
          }
          var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
          var from = sel.from(), to = sel.to();
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
          }
          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
          }
          var fromIndex, fromLine, fromNode;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
          } else {
            fromLine = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          var toLine, toNode;
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
          }
          if (!fromNode) {
            return false;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else {
              break;
            }
          }
          var cutFront = 0, cutEnd = 0;
          var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
            ++cutFront;
          }
          var newBot = lst(newText), oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            ++cutEnd;
          }
          if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
            while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
              cutFront--;
              cutEnd++;
            }
          }
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        };
        ContentEditableInput.prototype.ensurePolled = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.reset = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.forceCompositionEnd = function() {
          if (!this.composing) {
            return;
          }
          clearTimeout(this.readDOMTimeout);
          this.composing = null;
          this.updateFromDOM();
          this.div.blur();
          this.div.focus();
        };
        ContentEditableInput.prototype.readFromDOMSoon = function() {
          var this$1 = this;
          if (this.readDOMTimeout != null) {
            return;
          }
          this.readDOMTimeout = setTimeout(function() {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
              if (this$1.composing.done) {
                this$1.composing = null;
              } else {
                return;
              }
            }
            this$1.updateFromDOM();
          }, 80);
        };
        ContentEditableInput.prototype.updateFromDOM = function() {
          var this$1 = this;
          if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function() {
              return regChange(this$1.cm);
            });
          }
        };
        ContentEditableInput.prototype.setUneditable = function(node) {
          node.contentEditable = "false";
        };
        ContentEditableInput.prototype.onKeyPress = function(e) {
          if (e.charCode == 0 || this.composing) {
            return;
          }
          e.preventDefault();
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
          }
        };
        ContentEditableInput.prototype.readOnlyChanged = function(val) {
          this.div.contentEditable = String(val != "nocursor");
        };
        ContentEditableInput.prototype.onContextMenu = function() {
        };
        ContentEditableInput.prototype.resetPosition = function() {
        };
        ContentEditableInput.prototype.needsContentAttribute = true;
        function posToDOM(cm, pos) {
          var view = findViewForLine(cm, pos.line);
          if (!view || view.hidden) {
            return null;
          }
          var line = getLine(cm.doc, pos.line);
          var info = mapFromLineView(view, line, pos.line);
          var order = getOrder(line, cm.doc.direction), side = "left";
          if (order) {
            var partPos = getBidiPartAt(order, pos.ch);
            side = partPos % 2 ? "right" : "left";
          }
          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
          result.offset = result.collapse == "right" ? result.end : result.start;
          return result;
        }
        function isInGutter(node) {
          for (var scan = node; scan; scan = scan.parentNode) {
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
              return true;
            }
          }
          return false;
        }
        function badPos(pos, bad) {
          if (bad) {
            pos.bad = true;
          }
          return pos;
        }
        function domTextBetween(cm, from, to, fromLine, toLine) {
          var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
          function recognizeMarker(id) {
            return function(marker) {
              return marker.id == id;
            };
          }
          function close() {
            if (closing) {
              text += lineSep;
              if (extraLinebreak) {
                text += lineSep;
              }
              closing = extraLinebreak = false;
            }
          }
          function addText(str) {
            if (str) {
              close();
              text += str;
            }
          }
          function walk(node) {
            if (node.nodeType == 1) {
              var cmText = node.getAttribute("cm-text");
              if (cmText) {
                addText(cmText);
                return;
              }
              var markerID = node.getAttribute("cm-marker"), range2;
              if (markerID) {
                var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                if (found.length && (range2 = found[0].find(0))) {
                  addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
                }
                return;
              }
              if (node.getAttribute("contenteditable") == "false") {
                return;
              }
              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
              if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
                return;
              }
              if (isBlock) {
                close();
              }
              for (var i2 = 0; i2 < node.childNodes.length; i2++) {
                walk(node.childNodes[i2]);
              }
              if (/^(pre|p)$/i.test(node.nodeName)) {
                extraLinebreak = true;
              }
              if (isBlock) {
                closing = true;
              }
            } else if (node.nodeType == 3) {
              addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            }
          }
          for (; ; ) {
            walk(from);
            if (from == to) {
              break;
            }
            from = from.nextSibling;
            extraLinebreak = false;
          }
          return text;
        }
        function domToPos(cm, node, offset) {
          var lineNode;
          if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset];
            if (!lineNode) {
              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            }
            node = null;
            offset = 0;
          } else {
            for (lineNode = node; ; lineNode = lineNode.parentNode) {
              if (!lineNode || lineNode == cm.display.lineDiv) {
                return null;
              }
              if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
                break;
              }
            }
          }
          for (var i2 = 0; i2 < cm.display.view.length; i2++) {
            var lineView = cm.display.view[i2];
            if (lineView.node == lineNode) {
              return locateNodeInLineView(lineView, node, offset);
            }
          }
        }
        function locateNodeInLineView(lineView, node, offset) {
          var wrapper3 = lineView.text.firstChild, bad = false;
          if (!node || !contains2(wrapper3, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true);
          }
          if (node == wrapper3) {
            bad = true;
            node = wrapper3.childNodes[offset];
            offset = 0;
            if (!node) {
              var line = lineView.rest ? lst(lineView.rest) : lineView.line;
              return badPos(Pos(lineNo(line), line.text.length), bad);
            }
          }
          var textNode = node.nodeType == 3 ? node : null, topNode = node;
          if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset) {
              offset = textNode.nodeValue.length;
            }
          }
          while (topNode.parentNode != wrapper3) {
            topNode = topNode.parentNode;
          }
          var measure = lineView.measure, maps = measure.maps;
          function find2(textNode2, topNode2, offset2) {
            for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
              var map3 = i2 < 0 ? measure.map : maps[i2];
              for (var j = 0; j < map3.length; j += 3) {
                var curNode = map3[j + 2];
                if (curNode == textNode2 || curNode == topNode2) {
                  var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
                  var ch2 = map3[j] + offset2;
                  if (offset2 < 0 || curNode != textNode2) {
                    ch2 = map3[j + (offset2 ? 1 : 0)];
                  }
                  return Pos(line2, ch2);
                }
              }
            }
          }
          var found = find2(textNode, topNode, offset);
          if (found) {
            return badPos(found, bad);
          }
          for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
            found = find2(after, after.firstChild, 0);
            if (found) {
              return badPos(Pos(found.line, found.ch - dist), bad);
            } else {
              dist += after.textContent.length;
            }
          }
          for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
            found = find2(before, before.firstChild, -1);
            if (found) {
              return badPos(Pos(found.line, found.ch + dist$1), bad);
            } else {
              dist$1 += before.textContent.length;
            }
          }
        }
        var TextareaInput = function(cm) {
          this.cm = cm;
          this.prevInput = "";
          this.pollingFast = false;
          this.polling = new Delayed();
          this.hasSelection = false;
          this.composing = null;
        };
        TextareaInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = this.cm;
          this.createField(display);
          var te = this.textarea;
          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
          if (ios) {
            te.style.width = "0px";
          }
          on(te, "input", function() {
            if (ie3 && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null;
            }
            input.poll();
          });
          on(te, "paste", function(e) {
            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
              return;
            }
            cm.state.pasteIncoming = +new Date();
            input.fastPoll();
          });
          function prepareCopyCut(e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e.type == "cut") {
              cm.state.cutIncoming = +new Date();
            }
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e) {
            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
              return;
            }
            if (!te.dispatchEvent) {
              cm.state.pasteIncoming = +new Date();
              input.focus();
              return;
            }
            var event = new Event("paste");
            event.clipboardData = e.clipboardData;
            te.dispatchEvent(event);
          });
          on(display.lineSpace, "selectstart", function(e) {
            if (!eventInWidget(display, e)) {
              e_preventDefault(e);
            }
          });
          on(te, "compositionstart", function() {
            var start2 = cm.getCursor("from");
            if (input.composing) {
              input.composing.range.clear();
            }
            input.composing = {
              start: start2,
              range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        };
        TextareaInput.prototype.createField = function(_display) {
          this.wrapper = hiddenTextarea();
          this.textarea = this.wrapper.firstChild;
        };
        TextareaInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.textarea.setAttribute("aria-label", label);
          } else {
            this.textarea.removeAttribute("aria-label");
          }
        };
        TextareaInput.prototype.prepareSelection = function() {
          var cm = this.cm, display = cm.display, doc2 = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        };
        TextareaInput.prototype.showSelection = function(drawn) {
          var cm = this.cm, display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        };
        TextareaInput.prototype.reset = function(typing) {
          if (this.contextMenuPending || this.composing) {
            return;
          }
          var cm = this.cm;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var content2 = cm.getSelection();
            this.textarea.value = content2;
            if (cm.state.focused) {
              selectInput(this.textarea);
            }
            if (ie3 && ie_version >= 9) {
              this.hasSelection = content2;
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie3 && ie_version >= 9) {
              this.hasSelection = null;
            }
          }
        };
        TextareaInput.prototype.getField = function() {
          return this.textarea;
        };
        TextareaInput.prototype.supportsTouch = function() {
          return false;
        };
        TextareaInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e) {
            }
          }
        };
        TextareaInput.prototype.blur = function() {
          this.textarea.blur();
        };
        TextareaInput.prototype.resetPosition = function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        };
        TextareaInput.prototype.receivedFocus = function() {
          this.slowPoll();
        };
        TextareaInput.prototype.slowPoll = function() {
          var this$1 = this;
          if (this.pollingFast) {
            return;
          }
          this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll();
            if (this$1.cm.state.focused) {
              this$1.slowPoll();
            }
          });
        };
        TextareaInput.prototype.fastPoll = function() {
          var missed = false, input = this;
          input.pollingFast = true;
          function p() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p);
        };
        TextareaInput.prototype.poll = function() {
          var this$1 = this;
          var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
          if (this.contextMenuPending || !cm.state.focused || hasSelection2(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
          }
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected()) {
            return false;
          }
          if (ie3 && ie_version >= 9 && this.hasSelection === text || mac2 && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 8203 && !prevInput) {
              prevInput = "\u200B";
            }
            if (first == 8666) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0, l = Math.min(prevInput.length, text.length);
          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
            ++same;
          }
          runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
            if (text.length > 1e3 || text.indexOf("\n") > -1) {
              input.value = this$1.prevInput = "";
            } else {
              this$1.prevInput = text;
            }
            if (this$1.composing) {
              this$1.composing.range.clear();
              this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
            }
          });
          return true;
        };
        TextareaInput.prototype.ensurePolled = function() {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
          }
        };
        TextareaInput.prototype.onKeyPress = function() {
          if (ie3 && ie_version >= 9) {
            this.hasSelection = null;
          }
          this.fastPoll();
        };
        TextareaInput.prototype.onContextMenu = function(e) {
          var input = this, cm = input.cm, display = cm.display, te = input.textarea;
          if (input.contextMenuPending) {
            input.contextMenuPending();
          }
          var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
          if (!pos || presto) {
            return;
          }
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          }
          var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
          input.wrapper.style.cssText = "position: static";
          te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie3 ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          var oldScrollY;
          if (webkit2) {
            oldScrollY = window.scrollY;
          }
          display.input.focus();
          if (webkit2) {
            window.scrollTo(null, oldScrollY);
          }
          display.input.reset();
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
          }
          input.contextMenuPending = rehide;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200B" + (selected ? te.value : "");
              te.value = "\u21DA";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200B";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            if (input.contextMenuPending != rehide) {
              return;
            }
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie3 && ie_version < 9) {
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
              if (!ie3 || ie3 && ie_version < 9) {
                prepareSelectAllHack();
              }
              var i2 = 0, poll = function() {
                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
                  operation(cm, selectAll)(cm);
                } else if (i2++ < 10) {
                  display.detectingSelectAll = setTimeout(poll, 500);
                } else {
                  display.selForContextMenu = null;
                  display.input.reset();
                }
              };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie3 && ie_version >= 9) {
            prepareSelectAllHack();
          }
          if (captureRightClick) {
            e_stop(e);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        };
        TextareaInput.prototype.readOnlyChanged = function(val) {
          if (!val) {
            this.reset();
          }
          this.textarea.disabled = val == "nocursor";
          this.textarea.readOnly = !!val;
        };
        TextareaInput.prototype.setUneditable = function() {
        };
        TextareaInput.prototype.needsContentAttribute = false;
        function fromTextArea(textarea, options) {
          options = options ? copyObj(options) : {};
          options.value = textarea.value;
          if (!options.tabindex && textarea.tabIndex) {
            options.tabindex = textarea.tabIndex;
          }
          if (!options.placeholder && textarea.placeholder) {
            options.placeholder = textarea.placeholder;
          }
          if (options.autofocus == null) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
          }
          function save() {
            textarea.value = cm.getValue();
          }
          var realSubmit;
          if (textarea.form) {
            on(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone) {
              var form = textarea.form;
              realSubmit = form.submit;
              try {
                var wrappedSubmit = form.submit = function() {
                  save();
                  form.submit = realSubmit;
                  form.submit();
                  form.submit = wrappedSubmit;
                };
              } catch (e) {
              }
            }
          }
          options.finishInit = function(cm2) {
            cm2.save = save;
            cm2.getTextArea = function() {
              return textarea;
            };
            cm2.toTextArea = function() {
              cm2.toTextArea = isNaN;
              save();
              textarea.parentNode.removeChild(cm2.getWrapperElement());
              textarea.style.display = "";
              if (textarea.form) {
                off(textarea.form, "submit", save);
                if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                  textarea.form.submit = realSubmit;
                }
              }
            };
          };
          textarea.style.display = "none";
          var cm = CodeMirror3(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
          }, options);
          return cm;
        }
        function addLegacyProps(CodeMirror4) {
          CodeMirror4.off = off;
          CodeMirror4.on = on;
          CodeMirror4.wheelEventPixels = wheelEventPixels;
          CodeMirror4.Doc = Doc;
          CodeMirror4.splitLines = splitLinesAuto;
          CodeMirror4.countColumn = countColumn2;
          CodeMirror4.findColumn = findColumn2;
          CodeMirror4.isWordChar = isWordCharBasic;
          CodeMirror4.Pass = Pass;
          CodeMirror4.signal = signal;
          CodeMirror4.Line = Line2;
          CodeMirror4.changeEnd = changeEnd;
          CodeMirror4.scrollbarModel = scrollbarModel;
          CodeMirror4.Pos = Pos;
          CodeMirror4.cmpPos = cmp;
          CodeMirror4.modes = modes;
          CodeMirror4.mimeModes = mimeModes;
          CodeMirror4.resolveMode = resolveMode;
          CodeMirror4.getMode = getMode;
          CodeMirror4.modeExtensions = modeExtensions;
          CodeMirror4.extendMode = extendMode;
          CodeMirror4.copyState = copyState;
          CodeMirror4.startState = startState;
          CodeMirror4.innerMode = innerMode;
          CodeMirror4.commands = commands;
          CodeMirror4.keyMap = keyMap;
          CodeMirror4.keyName = keyName2;
          CodeMirror4.isModifierKey = isModifierKey;
          CodeMirror4.lookupKey = lookupKey;
          CodeMirror4.normalizeKeyMap = normalizeKeyMap;
          CodeMirror4.StringStream = StringStream;
          CodeMirror4.SharedTextMarker = SharedTextMarker;
          CodeMirror4.TextMarker = TextMarker;
          CodeMirror4.LineWidget = LineWidget;
          CodeMirror4.e_preventDefault = e_preventDefault;
          CodeMirror4.e_stopPropagation = e_stopPropagation;
          CodeMirror4.e_stop = e_stop;
          CodeMirror4.addClass = addClass;
          CodeMirror4.contains = contains2;
          CodeMirror4.rmClass = rmClass;
          CodeMirror4.keyNames = keyNames;
        }
        defineOptions(CodeMirror3);
        addEditorMethods(CodeMirror3);
        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
        for (var prop in Doc.prototype) {
          if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
            CodeMirror3.prototype[prop] = function(method) {
              return function() {
                return method.apply(this.doc, arguments);
              };
            }(Doc.prototype[prop]);
          }
        }
        eventMixin(Doc);
        CodeMirror3.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
        CodeMirror3.defineMode = function(name2) {
          if (!CodeMirror3.defaults.mode && name2 != "null") {
            CodeMirror3.defaults.mode = name2;
          }
          defineMode.apply(this, arguments);
        };
        CodeMirror3.defineMIME = defineMIME;
        CodeMirror3.defineMode("null", function() {
          return { token: function(stream) {
            return stream.skipToEnd();
          } };
        });
        CodeMirror3.defineMIME("text/plain", "null");
        CodeMirror3.defineExtension = function(name2, func) {
          CodeMirror3.prototype[name2] = func;
        };
        CodeMirror3.defineDocExtension = function(name2, func) {
          Doc.prototype[name2] = func;
        };
        CodeMirror3.fromTextArea = fromTextArea;
        addLegacyProps(CodeMirror3);
        CodeMirror3.version = "5.63.3";
        return CodeMirror3;
      });
    }
  });

  // ../../node_modules/react-codemirror/lib/Codemirror.js
  var require_Codemirror = __commonJS({
    "../../node_modules/react-codemirror/lib/Codemirror.js"(exports, module) {
      "use strict";
      var React6 = require_react();
      var ReactDOM2 = require_react_dom();
      var PropTypes2 = require_prop_types();
      var className = require_classnames();
      var debounce = require_lodash2();
      var isEqual = require_lodash3();
      var createReactClass = require_create_react_class();
      function normalizeLineEndings(str) {
        if (!str)
          return str;
        return str.replace(/\r\n|\r/g, "\n");
      }
      var CodeMirror3 = createReactClass({
        propTypes: {
          autoFocus: PropTypes2.bool,
          className: PropTypes2.any,
          codeMirrorInstance: PropTypes2.func,
          defaultValue: PropTypes2.string,
          name: PropTypes2.string,
          onChange: PropTypes2.func,
          onCursorActivity: PropTypes2.func,
          onFocusChange: PropTypes2.func,
          onScroll: PropTypes2.func,
          options: PropTypes2.object,
          path: PropTypes2.string,
          value: PropTypes2.string,
          preserveScrollPosition: PropTypes2.bool
        },
        getDefaultProps: function getDefaultProps() {
          return {
            preserveScrollPosition: false
          };
        },
        getCodeMirrorInstance: function getCodeMirrorInstance() {
          return this.props.codeMirrorInstance || require_codemirror();
        },
        getInitialState: function getInitialState() {
          return {
            isFocused: false
          };
        },
        componentWillMount: function componentWillMount() {
          this.componentWillReceiveProps = debounce(this.componentWillReceiveProps, 0);
          if (this.props.path) {
            console.error("Warning: react-codemirror: the `path` prop has been changed to `name`");
          }
        },
        componentDidMount: function componentDidMount() {
          var codeMirrorInstance = this.getCodeMirrorInstance();
          this.codeMirror = codeMirrorInstance.fromTextArea(this.textareaNode, this.props.options);
          this.codeMirror.on("change", this.codemirrorValueChanged);
          this.codeMirror.on("cursorActivity", this.cursorActivity);
          this.codeMirror.on("focus", this.focusChanged.bind(this, true));
          this.codeMirror.on("blur", this.focusChanged.bind(this, false));
          this.codeMirror.on("scroll", this.scrollChanged);
          this.codeMirror.setValue(this.props.defaultValue || this.props.value || "");
        },
        componentWillUnmount: function componentWillUnmount() {
          if (this.codeMirror) {
            this.codeMirror.toTextArea();
          }
        },
        componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
          if (this.codeMirror && nextProps.value !== void 0 && nextProps.value !== this.props.value && normalizeLineEndings(this.codeMirror.getValue()) !== normalizeLineEndings(nextProps.value)) {
            if (this.props.preserveScrollPosition) {
              var prevScrollPosition = this.codeMirror.getScrollInfo();
              this.codeMirror.setValue(nextProps.value);
              this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
            } else {
              this.codeMirror.setValue(nextProps.value);
            }
          }
          if (typeof nextProps.options === "object") {
            for (var optionName in nextProps.options) {
              if (nextProps.options.hasOwnProperty(optionName)) {
                this.setOptionIfChanged(optionName, nextProps.options[optionName]);
              }
            }
          }
        },
        setOptionIfChanged: function setOptionIfChanged(optionName, newValue) {
          var oldValue = this.codeMirror.getOption(optionName);
          if (!isEqual(oldValue, newValue)) {
            this.codeMirror.setOption(optionName, newValue);
          }
        },
        getCodeMirror: function getCodeMirror() {
          return this.codeMirror;
        },
        focus: function focus() {
          if (this.codeMirror) {
            this.codeMirror.focus();
          }
        },
        focusChanged: function focusChanged(focused) {
          this.setState({
            isFocused: focused
          });
          this.props.onFocusChange && this.props.onFocusChange(focused);
        },
        cursorActivity: function cursorActivity(cm) {
          this.props.onCursorActivity && this.props.onCursorActivity(cm);
        },
        scrollChanged: function scrollChanged(cm) {
          this.props.onScroll && this.props.onScroll(cm.getScrollInfo());
        },
        codemirrorValueChanged: function codemirrorValueChanged(doc2, change) {
          if (this.props.onChange && change.origin !== "setValue") {
            this.props.onChange(doc2.getValue(), change);
          }
        },
        render: function render() {
          var _this = this;
          var editorClassName = className("ReactCodeMirror", this.state.isFocused ? "ReactCodeMirror--focused" : null, this.props.className);
          return React6.createElement("div", { className: editorClassName }, React6.createElement("textarea", {
            ref: function(ref) {
              return _this.textareaNode = ref;
            },
            name: this.props.name || this.props.path,
            defaultValue: this.props.value,
            autoComplete: "off",
            autoFocus: this.props.autoFocus
          }));
        }
      });
      module.exports = CodeMirror3;
    }
  });

  // ../../node_modules/codemirror/mode/xml/xml.js
  var require_xml = __commonJS({
    "../../node_modules/codemirror/mode/xml/xml.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var htmlConfig = {
          autoSelfClosers: {
            "area": true,
            "base": true,
            "br": true,
            "col": true,
            "command": true,
            "embed": true,
            "frame": true,
            "hr": true,
            "img": true,
            "input": true,
            "keygen": true,
            "link": true,
            "meta": true,
            "param": true,
            "source": true,
            "track": true,
            "wbr": true,
            "menuitem": true
          },
          implicitlyClosed: {
            "dd": true,
            "li": true,
            "optgroup": true,
            "option": true,
            "p": true,
            "rp": true,
            "rt": true,
            "tbody": true,
            "td": true,
            "tfoot": true,
            "th": true,
            "tr": true
          },
          contextGrabbers: {
            "dd": { "dd": true, "dt": true },
            "dt": { "dd": true, "dt": true },
            "li": { "li": true },
            "option": { "option": true, "optgroup": true },
            "optgroup": { "optgroup": true },
            "p": {
              "address": true,
              "article": true,
              "aside": true,
              "blockquote": true,
              "dir": true,
              "div": true,
              "dl": true,
              "fieldset": true,
              "footer": true,
              "form": true,
              "h1": true,
              "h2": true,
              "h3": true,
              "h4": true,
              "h5": true,
              "h6": true,
              "header": true,
              "hgroup": true,
              "hr": true,
              "menu": true,
              "nav": true,
              "ol": true,
              "p": true,
              "pre": true,
              "section": true,
              "table": true,
              "ul": true
            },
            "rp": { "rp": true, "rt": true },
            "rt": { "rp": true, "rt": true },
            "tbody": { "tbody": true, "tfoot": true },
            "td": { "td": true, "th": true },
            "tfoot": { "tbody": true },
            "th": { "td": true, "th": true },
            "thead": { "tbody": true, "tfoot": true },
            "tr": { "tr": true }
          },
          doNotIndent: { "pre": true },
          allowUnquoted: true,
          allowMissing: true,
          caseFold: true
        };
        var xmlConfig = {
          autoSelfClosers: {},
          implicitlyClosed: {},
          contextGrabbers: {},
          doNotIndent: {},
          allowUnquoted: false,
          allowMissing: false,
          allowMissingTagName: false,
          caseFold: false
        };
        CodeMirror3.defineMode("xml", function(editorConf, config_) {
          var indentUnit = editorConf.indentUnit;
          var config = {};
          var defaults2 = config_.htmlMode ? htmlConfig : xmlConfig;
          for (var prop in defaults2)
            config[prop] = defaults2[prop];
          for (var prop in config_)
            config[prop] = config_[prop];
          var type, setStyle;
          function inText(stream, state) {
            function chain(parser2) {
              state.tokenize = parser2;
              return parser2(stream, state);
            }
            var ch2 = stream.next();
            if (ch2 == "<") {
              if (stream.eat("!")) {
                if (stream.eat("[")) {
                  if (stream.match("CDATA["))
                    return chain(inBlock("atom", "]]>"));
                  else
                    return null;
                } else if (stream.match("--")) {
                  return chain(inBlock("comment", "-->"));
                } else if (stream.match("DOCTYPE", true, true)) {
                  stream.eatWhile(/[\w\._\-]/);
                  return chain(doctype(1));
                } else {
                  return null;
                }
              } else if (stream.eat("?")) {
                stream.eatWhile(/[\w\._\-]/);
                state.tokenize = inBlock("meta", "?>");
                return "meta";
              } else {
                type = stream.eat("/") ? "closeTag" : "openTag";
                state.tokenize = inTag;
                return "tag bracket";
              }
            } else if (ch2 == "&") {
              var ok;
              if (stream.eat("#")) {
                if (stream.eat("x")) {
                  ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
                } else {
                  ok = stream.eatWhile(/[\d]/) && stream.eat(";");
                }
              } else {
                ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
              }
              return ok ? "atom" : "error";
            } else {
              stream.eatWhile(/[^&<]/);
              return null;
            }
          }
          inText.isInText = true;
          function inTag(stream, state) {
            var ch2 = stream.next();
            if (ch2 == ">" || ch2 == "/" && stream.eat(">")) {
              state.tokenize = inText;
              type = ch2 == ">" ? "endTag" : "selfcloseTag";
              return "tag bracket";
            } else if (ch2 == "=") {
              type = "equals";
              return null;
            } else if (ch2 == "<") {
              state.tokenize = inText;
              state.state = baseState;
              state.tagName = state.tagStart = null;
              var next = state.tokenize(stream, state);
              return next ? next + " tag error" : "tag error";
            } else if (/[\'\"]/.test(ch2)) {
              state.tokenize = inAttribute(ch2);
              state.stringStartCol = stream.column();
              return state.tokenize(stream, state);
            } else {
              stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
              return "word";
            }
          }
          function inAttribute(quote) {
            var closure = function(stream, state) {
              while (!stream.eol()) {
                if (stream.next() == quote) {
                  state.tokenize = inTag;
                  break;
                }
              }
              return "string";
            };
            closure.isInAttribute = true;
            return closure;
          }
          function inBlock(style, terminator) {
            return function(stream, state) {
              while (!stream.eol()) {
                if (stream.match(terminator)) {
                  state.tokenize = inText;
                  break;
                }
                stream.next();
              }
              return style;
            };
          }
          function doctype(depth) {
            return function(stream, state) {
              var ch2;
              while ((ch2 = stream.next()) != null) {
                if (ch2 == "<") {
                  state.tokenize = doctype(depth + 1);
                  return state.tokenize(stream, state);
                } else if (ch2 == ">") {
                  if (depth == 1) {
                    state.tokenize = inText;
                    break;
                  } else {
                    state.tokenize = doctype(depth - 1);
                    return state.tokenize(stream, state);
                  }
                }
              }
              return "meta";
            };
          }
          function lower(tagName) {
            return tagName && tagName.toLowerCase();
          }
          function Context(state, tagName, startOfLine) {
            this.prev = state.context;
            this.tagName = tagName || "";
            this.indent = state.indented;
            this.startOfLine = startOfLine;
            if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)
              this.noIndent = true;
          }
          function popContext(state) {
            if (state.context)
              state.context = state.context.prev;
          }
          function maybePopContext(state, nextTagName) {
            var parentTagName;
            while (true) {
              if (!state.context) {
                return;
              }
              parentTagName = state.context.tagName;
              if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {
                return;
              }
              popContext(state);
            }
          }
          function baseState(type2, stream, state) {
            if (type2 == "openTag") {
              state.tagStart = stream.column();
              return tagNameState;
            } else if (type2 == "closeTag") {
              return closeTagNameState;
            } else {
              return baseState;
            }
          }
          function tagNameState(type2, stream, state) {
            if (type2 == "word") {
              state.tagName = stream.current();
              setStyle = "tag";
              return attrState;
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle = "tag bracket";
              return attrState(type2, stream, state);
            } else {
              setStyle = "error";
              return tagNameState;
            }
          }
          function closeTagNameState(type2, stream, state) {
            if (type2 == "word") {
              var tagName = stream.current();
              if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))
                popContext(state);
              if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
                setStyle = "tag";
                return closeState;
              } else {
                setStyle = "tag error";
                return closeStateErr;
              }
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle = "tag bracket";
              return closeState(type2, stream, state);
            } else {
              setStyle = "error";
              return closeStateErr;
            }
          }
          function closeState(type2, _stream, state) {
            if (type2 != "endTag") {
              setStyle = "error";
              return closeState;
            }
            popContext(state);
            return baseState;
          }
          function closeStateErr(type2, stream, state) {
            setStyle = "error";
            return closeState(type2, stream, state);
          }
          function attrState(type2, _stream, state) {
            if (type2 == "word") {
              setStyle = "attribute";
              return attrEqState;
            } else if (type2 == "endTag" || type2 == "selfcloseTag") {
              var tagName = state.tagName, tagStart = state.tagStart;
              state.tagName = state.tagStart = null;
              if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {
                maybePopContext(state, tagName);
              } else {
                maybePopContext(state, tagName);
                state.context = new Context(state, tagName, tagStart == state.indented);
              }
              return baseState;
            }
            setStyle = "error";
            return attrState;
          }
          function attrEqState(type2, stream, state) {
            if (type2 == "equals")
              return attrValueState;
            if (!config.allowMissing)
              setStyle = "error";
            return attrState(type2, stream, state);
          }
          function attrValueState(type2, stream, state) {
            if (type2 == "string")
              return attrContinuedState;
            if (type2 == "word" && config.allowUnquoted) {
              setStyle = "string";
              return attrState;
            }
            setStyle = "error";
            return attrState(type2, stream, state);
          }
          function attrContinuedState(type2, stream, state) {
            if (type2 == "string")
              return attrContinuedState;
            return attrState(type2, stream, state);
          }
          return {
            startState: function(baseIndent) {
              var state = {
                tokenize: inText,
                state: baseState,
                indented: baseIndent || 0,
                tagName: null,
                tagStart: null,
                context: null
              };
              if (baseIndent != null)
                state.baseIndent = baseIndent;
              return state;
            },
            token: function(stream, state) {
              if (!state.tagName && stream.sol())
                state.indented = stream.indentation();
              if (stream.eatSpace())
                return null;
              type = null;
              var style = state.tokenize(stream, state);
              if ((style || type) && style != "comment") {
                setStyle = null;
                state.state = state.state(type || style, stream, state);
                if (setStyle)
                  style = setStyle == "error" ? style + " error" : setStyle;
              }
              return style;
            },
            indent: function(state, textAfter, fullLine) {
              var context = state.context;
              if (state.tokenize.isInAttribute) {
                if (state.tagStart == state.indented)
                  return state.stringStartCol + 1;
                else
                  return state.indented + indentUnit;
              }
              if (context && context.noIndent)
                return CodeMirror3.Pass;
              if (state.tokenize != inTag && state.tokenize != inText)
                return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
              if (state.tagName) {
                if (config.multilineTagIndentPastTag !== false)
                  return state.tagStart + state.tagName.length + 2;
                else
                  return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
              }
              if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter))
                return 0;
              var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
              if (tagAfter && tagAfter[1]) {
                while (context) {
                  if (context.tagName == tagAfter[2]) {
                    context = context.prev;
                    break;
                  } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {
                    context = context.prev;
                  } else {
                    break;
                  }
                }
              } else if (tagAfter) {
                while (context) {
                  var grabbers = config.contextGrabbers[lower(context.tagName)];
                  if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))
                    context = context.prev;
                  else
                    break;
                }
              }
              while (context && context.prev && !context.startOfLine)
                context = context.prev;
              if (context)
                return context.indent + indentUnit;
              else
                return state.baseIndent || 0;
            },
            electricInput: /<\/[\s\w:]+>$/,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            configuration: config.htmlMode ? "html" : "xml",
            helperType: config.htmlMode ? "html" : "xml",
            skipAttribute: function(state) {
              if (state.state == attrValueState)
                state.state = attrState;
            },
            xmlCurrentTag: function(state) {
              return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;
            },
            xmlCurrentContext: function(state) {
              var context = [];
              for (var cx = state.context; cx; cx = cx.prev)
                context.push(cx.tagName);
              return context.reverse();
            }
          };
        });
        CodeMirror3.defineMIME("text/xml", "xml");
        CodeMirror3.defineMIME("application/xml", "xml");
        if (!CodeMirror3.mimeModes.hasOwnProperty("text/html"))
          CodeMirror3.defineMIME("text/html", { name: "xml", htmlMode: true });
      });
    }
  });

  // ../../node_modules/codemirror/mode/javascript/javascript.js
  var require_javascript = __commonJS({
    "../../node_modules/codemirror/mode/javascript/javascript.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("javascript", function(config, parserConfig) {
          var indentUnit = config.indentUnit;
          var statementIndent = parserConfig.statementIndent;
          var jsonldMode = parserConfig.jsonld;
          var jsonMode = parserConfig.json || jsonldMode;
          var trackScope = parserConfig.trackScope !== false;
          var isTS = parserConfig.typescript;
          var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
          var keywords = function() {
            function kw(type2) {
              return { type: type2, style: "keyword" };
            }
            var A = kw("keyword a"), B = kw("keyword b"), C2 = kw("keyword c"), D = kw("keyword d");
            var operator2 = kw("operator"), atom = { type: "atom", style: "atom" };
            return {
              "if": kw("if"),
              "while": A,
              "with": A,
              "else": B,
              "do": B,
              "try": B,
              "finally": B,
              "return": D,
              "break": D,
              "continue": D,
              "new": kw("new"),
              "delete": C2,
              "void": C2,
              "throw": C2,
              "debugger": kw("debugger"),
              "var": kw("var"),
              "const": kw("var"),
              "let": kw("var"),
              "function": kw("function"),
              "catch": kw("catch"),
              "for": kw("for"),
              "switch": kw("switch"),
              "case": kw("case"),
              "default": kw("default"),
              "in": operator2,
              "typeof": operator2,
              "instanceof": operator2,
              "true": atom,
              "false": atom,
              "null": atom,
              "undefined": atom,
              "NaN": atom,
              "Infinity": atom,
              "this": kw("this"),
              "class": kw("class"),
              "super": kw("atom"),
              "yield": C2,
              "export": kw("export"),
              "import": kw("import"),
              "extends": C2,
              "await": C2
            };
          }();
          var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
          var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
          function readRegexp(stream) {
            var escaped = false, next, inSet = false;
            while ((next = stream.next()) != null) {
              if (!escaped) {
                if (next == "/" && !inSet)
                  return;
                if (next == "[")
                  inSet = true;
                else if (inSet && next == "]")
                  inSet = false;
              }
              escaped = !escaped && next == "\\";
            }
          }
          var type, content2;
          function ret(tp, style, cont2) {
            type = tp;
            content2 = cont2;
            return style;
          }
          function tokenBase(stream, state) {
            var ch2 = stream.next();
            if (ch2 == '"' || ch2 == "'") {
              state.tokenize = tokenString(ch2);
              return state.tokenize(stream, state);
            } else if (ch2 == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
              return ret("number", "number");
            } else if (ch2 == "." && stream.match("..")) {
              return ret("spread", "meta");
            } else if (/[\[\]{}\(\),;\:\.]/.test(ch2)) {
              return ret(ch2);
            } else if (ch2 == "=" && stream.eat(">")) {
              return ret("=>", "operator");
            } else if (ch2 == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
              return ret("number", "number");
            } else if (/\d/.test(ch2)) {
              stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
              return ret("number", "number");
            } else if (ch2 == "/") {
              if (stream.eat("*")) {
                state.tokenize = tokenComment;
                return tokenComment(stream, state);
              } else if (stream.eat("/")) {
                stream.skipToEnd();
                return ret("comment", "comment");
              } else if (expressionAllowed(stream, state, 1)) {
                readRegexp(stream);
                stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
                return ret("regexp", "string-2");
              } else {
                stream.eat("=");
                return ret("operator", "operator", stream.current());
              }
            } else if (ch2 == "`") {
              state.tokenize = tokenQuasi;
              return tokenQuasi(stream, state);
            } else if (ch2 == "#" && stream.peek() == "!") {
              stream.skipToEnd();
              return ret("meta", "meta");
            } else if (ch2 == "#" && stream.eatWhile(wordRE)) {
              return ret("variable", "property");
            } else if (ch2 == "<" && stream.match("!--") || ch2 == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (isOperatorChar.test(ch2)) {
              if (ch2 != ">" || !state.lexical || state.lexical.type != ">") {
                if (stream.eat("=")) {
                  if (ch2 == "!" || ch2 == "=")
                    stream.eat("=");
                } else if (/[<>*+\-|&?]/.test(ch2)) {
                  stream.eat(ch2);
                  if (ch2 == ">")
                    stream.eat(ch2);
                }
              }
              if (ch2 == "?" && stream.eat("."))
                return ret(".");
              return ret("operator", "operator", stream.current());
            } else if (wordRE.test(ch2)) {
              stream.eatWhile(wordRE);
              var word = stream.current();
              if (state.lastType != ".") {
                if (keywords.propertyIsEnumerable(word)) {
                  var kw = keywords[word];
                  return ret(kw.type, kw.style, word);
                }
                if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
                  return ret("async", "keyword", word);
              }
              return ret("variable", "variable", word);
            }
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, next;
              if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
                state.tokenize = tokenBase;
                return ret("jsonld-keyword", "meta");
              }
              while ((next = stream.next()) != null) {
                if (next == quote && !escaped)
                  break;
                escaped = !escaped && next == "\\";
              }
              if (!escaped)
                state.tokenize = tokenBase;
              return ret("string", "string");
            };
          }
          function tokenComment(stream, state) {
            var maybeEnd = false, ch2;
            while (ch2 = stream.next()) {
              if (ch2 == "/" && maybeEnd) {
                state.tokenize = tokenBase;
                break;
              }
              maybeEnd = ch2 == "*";
            }
            return ret("comment", "comment");
          }
          function tokenQuasi(stream, state) {
            var escaped = false, next;
            while ((next = stream.next()) != null) {
              if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
                state.tokenize = tokenBase;
                break;
              }
              escaped = !escaped && next == "\\";
            }
            return ret("quasi", "string-2", stream.current());
          }
          var brackets = "([{}])";
          function findFatArrow(stream, state) {
            if (state.fatArrowAt)
              state.fatArrowAt = null;
            var arrow = stream.string.indexOf("=>", stream.start);
            if (arrow < 0)
              return;
            if (isTS) {
              var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
              if (m)
                arrow = m.index;
            }
            var depth = 0, sawSomething = false;
            for (var pos = arrow - 1; pos >= 0; --pos) {
              var ch2 = stream.string.charAt(pos);
              var bracket2 = brackets.indexOf(ch2);
              if (bracket2 >= 0 && bracket2 < 3) {
                if (!depth) {
                  ++pos;
                  break;
                }
                if (--depth == 0) {
                  if (ch2 == "(")
                    sawSomething = true;
                  break;
                }
              } else if (bracket2 >= 3 && bracket2 < 6) {
                ++depth;
              } else if (wordRE.test(ch2)) {
                sawSomething = true;
              } else if (/["'\/`]/.test(ch2)) {
                for (; ; --pos) {
                  if (pos == 0)
                    return;
                  var next = stream.string.charAt(pos - 1);
                  if (next == ch2 && stream.string.charAt(pos - 2) != "\\") {
                    pos--;
                    break;
                  }
                }
              } else if (sawSomething && !depth) {
                ++pos;
                break;
              }
            }
            if (sawSomething && !depth)
              state.fatArrowAt = pos;
          }
          var atomicTypes = {
            "atom": true,
            "number": true,
            "variable": true,
            "string": true,
            "regexp": true,
            "this": true,
            "import": true,
            "jsonld-keyword": true
          };
          function JSLexical(indented, column, type2, align, prev, info) {
            this.indented = indented;
            this.column = column;
            this.type = type2;
            this.prev = prev;
            this.info = info;
            if (align != null)
              this.align = align;
          }
          function inScope(state, varname) {
            if (!trackScope)
              return false;
            for (var v = state.localVars; v; v = v.next)
              if (v.name == varname)
                return true;
            for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
              for (var v = cx2.vars; v; v = v.next)
                if (v.name == varname)
                  return true;
            }
          }
          function parseJS(state, style, type2, content3, stream) {
            var cc = state.cc;
            cx.state = state;
            cx.stream = stream;
            cx.marked = null, cx.cc = cc;
            cx.style = style;
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = true;
            while (true) {
              var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
              if (combinator(type2, content3)) {
                while (cc.length && cc[cc.length - 1].lex)
                  cc.pop()();
                if (cx.marked)
                  return cx.marked;
                if (type2 == "variable" && inScope(state, content3))
                  return "variable-2";
                return style;
              }
            }
          }
          var cx = { state: null, column: null, marked: null, cc: null };
          function pass() {
            for (var i = arguments.length - 1; i >= 0; i--)
              cx.cc.push(arguments[i]);
          }
          function cont() {
            pass.apply(null, arguments);
            return true;
          }
          function inList(name2, list) {
            for (var v = list; v; v = v.next)
              if (v.name == name2)
                return true;
            return false;
          }
          function register(varname) {
            var state = cx.state;
            cx.marked = "def";
            if (!trackScope)
              return;
            if (state.context) {
              if (state.lexical.info == "var" && state.context && state.context.block) {
                var newContext = registerVarScoped(varname, state.context);
                if (newContext != null) {
                  state.context = newContext;
                  return;
                }
              } else if (!inList(varname, state.localVars)) {
                state.localVars = new Var(varname, state.localVars);
                return;
              }
            }
            if (parserConfig.globalVars && !inList(varname, state.globalVars))
              state.globalVars = new Var(varname, state.globalVars);
          }
          function registerVarScoped(varname, context) {
            if (!context) {
              return null;
            } else if (context.block) {
              var inner = registerVarScoped(varname, context.prev);
              if (!inner)
                return null;
              if (inner == context.prev)
                return context;
              return new Context(inner, context.vars, true);
            } else if (inList(varname, context.vars)) {
              return context;
            } else {
              return new Context(context.prev, new Var(varname, context.vars), false);
            }
          }
          function isModifier(name2) {
            return name2 == "public" || name2 == "private" || name2 == "protected" || name2 == "abstract" || name2 == "readonly";
          }
          function Context(prev, vars, block2) {
            this.prev = prev;
            this.vars = vars;
            this.block = block2;
          }
          function Var(name2, next) {
            this.name = name2;
            this.next = next;
          }
          var defaultVars = new Var("this", new Var("arguments", null));
          function pushcontext() {
            cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
            cx.state.localVars = defaultVars;
          }
          function pushblockcontext() {
            cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
            cx.state.localVars = null;
          }
          function popcontext() {
            cx.state.localVars = cx.state.context.vars;
            cx.state.context = cx.state.context.prev;
          }
          popcontext.lex = true;
          function pushlex(type2, info) {
            var result = function() {
              var state = cx.state, indent = state.indented;
              if (state.lexical.type == "stat")
                indent = state.lexical.indented;
              else
                for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
                  indent = outer.indented;
              state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);
            };
            result.lex = true;
            return result;
          }
          function poplex() {
            var state = cx.state;
            if (state.lexical.prev) {
              if (state.lexical.type == ")")
                state.indented = state.lexical.indented;
              state.lexical = state.lexical.prev;
            }
          }
          poplex.lex = true;
          function expect(wanted) {
            function exp(type2) {
              if (type2 == wanted)
                return cont();
              else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]")
                return pass();
              else
                return cont(exp);
            }
            ;
            return exp;
          }
          function statement(type2, value) {
            if (type2 == "var")
              return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
            if (type2 == "keyword a")
              return cont(pushlex("form"), parenExpr, statement, poplex);
            if (type2 == "keyword b")
              return cont(pushlex("form"), statement, poplex);
            if (type2 == "keyword d")
              return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
            if (type2 == "debugger")
              return cont(expect(";"));
            if (type2 == "{")
              return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
            if (type2 == ";")
              return cont();
            if (type2 == "if") {
              if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
                cx.state.cc.pop()();
              return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
            }
            if (type2 == "function")
              return cont(functiondef);
            if (type2 == "for")
              return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
            if (type2 == "class" || isTS && value == "interface") {
              cx.marked = "keyword";
              return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);
            }
            if (type2 == "variable") {
              if (isTS && value == "declare") {
                cx.marked = "keyword";
                return cont(statement);
              } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
                cx.marked = "keyword";
                if (value == "enum")
                  return cont(enumdef);
                else if (value == "type")
                  return cont(typename, expect("operator"), typeexpr, expect(";"));
                else
                  return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
              } else if (isTS && value == "namespace") {
                cx.marked = "keyword";
                return cont(pushlex("form"), expression, statement, poplex);
              } else if (isTS && value == "abstract") {
                cx.marked = "keyword";
                return cont(statement);
              } else {
                return cont(pushlex("stat"), maybelabel);
              }
            }
            if (type2 == "switch")
              return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
            if (type2 == "case")
              return cont(expression, expect(":"));
            if (type2 == "default")
              return cont(expect(":"));
            if (type2 == "catch")
              return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
            if (type2 == "export")
              return cont(pushlex("stat"), afterExport, poplex);
            if (type2 == "import")
              return cont(pushlex("stat"), afterImport, poplex);
            if (type2 == "async")
              return cont(statement);
            if (value == "@")
              return cont(expression, statement);
            return pass(pushlex("stat"), expression, expect(";"), poplex);
          }
          function maybeCatchBinding(type2) {
            if (type2 == "(")
              return cont(funarg, expect(")"));
          }
          function expression(type2, value) {
            return expressionInner(type2, value, false);
          }
          function expressionNoComma(type2, value) {
            return expressionInner(type2, value, true);
          }
          function parenExpr(type2) {
            if (type2 != "(")
              return pass();
            return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
          }
          function expressionInner(type2, value, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
              var body = noComma ? arrowBodyNoComma : arrowBody;
              if (type2 == "(")
                return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
              else if (type2 == "variable")
                return pass(pushcontext, pattern, expect("=>"), body, popcontext);
            }
            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
            if (atomicTypes.hasOwnProperty(type2))
              return cont(maybeop);
            if (type2 == "function")
              return cont(functiondef, maybeop);
            if (type2 == "class" || isTS && value == "interface") {
              cx.marked = "keyword";
              return cont(pushlex("form"), classExpression, poplex);
            }
            if (type2 == "keyword c" || type2 == "async")
              return cont(noComma ? expressionNoComma : expression);
            if (type2 == "(")
              return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
            if (type2 == "operator" || type2 == "spread")
              return cont(noComma ? expressionNoComma : expression);
            if (type2 == "[")
              return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
            if (type2 == "{")
              return contCommasep(objprop, "}", null, maybeop);
            if (type2 == "quasi")
              return pass(quasi, maybeop);
            if (type2 == "new")
              return cont(maybeTarget(noComma));
            return cont();
          }
          function maybeexpression(type2) {
            if (type2.match(/[;\}\)\],]/))
              return pass();
            return pass(expression);
          }
          function maybeoperatorComma(type2, value) {
            if (type2 == ",")
              return cont(maybeexpression);
            return maybeoperatorNoComma(type2, value, false);
          }
          function maybeoperatorNoComma(type2, value, noComma) {
            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
            var expr = noComma == false ? expression : expressionNoComma;
            if (type2 == "=>")
              return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
            if (type2 == "operator") {
              if (/\+\+|--/.test(value) || isTS && value == "!")
                return cont(me);
              if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
                return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
              if (value == "?")
                return cont(expression, expect(":"), expr);
              return cont(expr);
            }
            if (type2 == "quasi") {
              return pass(quasi, me);
            }
            if (type2 == ";")
              return;
            if (type2 == "(")
              return contCommasep(expressionNoComma, ")", "call", me);
            if (type2 == ".")
              return cont(property, me);
            if (type2 == "[")
              return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
            if (isTS && value == "as") {
              cx.marked = "keyword";
              return cont(typeexpr, me);
            }
            if (type2 == "regexp") {
              cx.state.lastType = cx.marked = "operator";
              cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
              return cont(expr);
            }
          }
          function quasi(type2, value) {
            if (type2 != "quasi")
              return pass();
            if (value.slice(value.length - 2) != "${")
              return cont(quasi);
            return cont(maybeexpression, continueQuasi);
          }
          function continueQuasi(type2) {
            if (type2 == "}") {
              cx.marked = "string-2";
              cx.state.tokenize = tokenQuasi;
              return cont(quasi);
            }
          }
          function arrowBody(type2) {
            findFatArrow(cx.stream, cx.state);
            return pass(type2 == "{" ? statement : expression);
          }
          function arrowBodyNoComma(type2) {
            findFatArrow(cx.stream, cx.state);
            return pass(type2 == "{" ? statement : expressionNoComma);
          }
          function maybeTarget(noComma) {
            return function(type2) {
              if (type2 == ".")
                return cont(noComma ? targetNoComma : target);
              else if (type2 == "variable" && isTS)
                return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
              else
                return pass(noComma ? expressionNoComma : expression);
            };
          }
          function target(_14, value) {
            if (value == "target") {
              cx.marked = "keyword";
              return cont(maybeoperatorComma);
            }
          }
          function targetNoComma(_14, value) {
            if (value == "target") {
              cx.marked = "keyword";
              return cont(maybeoperatorNoComma);
            }
          }
          function maybelabel(type2) {
            if (type2 == ":")
              return cont(poplex, statement);
            return pass(maybeoperatorComma, expect(";"), poplex);
          }
          function property(type2) {
            if (type2 == "variable") {
              cx.marked = "property";
              return cont();
            }
          }
          function objprop(type2, value) {
            if (type2 == "async") {
              cx.marked = "property";
              return cont(objprop);
            } else if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              if (value == "get" || value == "set")
                return cont(getterSetter);
              var m;
              if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
                cx.state.fatArrowAt = cx.stream.pos + m[0].length;
              return cont(afterprop);
            } else if (type2 == "number" || type2 == "string") {
              cx.marked = jsonldMode ? "property" : cx.style + " property";
              return cont(afterprop);
            } else if (type2 == "jsonld-keyword") {
              return cont(afterprop);
            } else if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(objprop);
            } else if (type2 == "[") {
              return cont(expression, maybetype, expect("]"), afterprop);
            } else if (type2 == "spread") {
              return cont(expressionNoComma, afterprop);
            } else if (value == "*") {
              cx.marked = "keyword";
              return cont(objprop);
            } else if (type2 == ":") {
              return pass(afterprop);
            }
          }
          function getterSetter(type2) {
            if (type2 != "variable")
              return pass(afterprop);
            cx.marked = "property";
            return cont(functiondef);
          }
          function afterprop(type2) {
            if (type2 == ":")
              return cont(expressionNoComma);
            if (type2 == "(")
              return pass(functiondef);
          }
          function commasep(what, end, sep) {
            function proceed(type2, value) {
              if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {
                var lex = cx.state.lexical;
                if (lex.info == "call")
                  lex.pos = (lex.pos || 0) + 1;
                return cont(function(type3, value2) {
                  if (type3 == end || value2 == end)
                    return pass();
                  return pass(what);
                }, proceed);
              }
              if (type2 == end || value == end)
                return cont();
              if (sep && sep.indexOf(";") > -1)
                return pass(what);
              return cont(expect(end));
            }
            return function(type2, value) {
              if (type2 == end || value == end)
                return cont();
              return pass(what, proceed);
            };
          }
          function contCommasep(what, end, info) {
            for (var i = 3; i < arguments.length; i++)
              cx.cc.push(arguments[i]);
            return cont(pushlex(end, info), commasep(what, end), poplex);
          }
          function block(type2) {
            if (type2 == "}")
              return cont();
            return pass(statement, block);
          }
          function maybetype(type2, value) {
            if (isTS) {
              if (type2 == ":")
                return cont(typeexpr);
              if (value == "?")
                return cont(maybetype);
            }
          }
          function maybetypeOrIn(type2, value) {
            if (isTS && (type2 == ":" || value == "in"))
              return cont(typeexpr);
          }
          function mayberettype(type2) {
            if (isTS && type2 == ":") {
              if (cx.stream.match(/^\s*\w+\s+is\b/, false))
                return cont(expression, isKW, typeexpr);
              else
                return cont(typeexpr);
            }
          }
          function isKW(_14, value) {
            if (value == "is") {
              cx.marked = "keyword";
              return cont();
            }
          }
          function typeexpr(type2, value) {
            if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
              cx.marked = "keyword";
              return cont(value == "typeof" ? expressionNoComma : typeexpr);
            }
            if (type2 == "variable" || value == "void") {
              cx.marked = "type";
              return cont(afterType);
            }
            if (value == "|" || value == "&")
              return cont(typeexpr);
            if (type2 == "string" || type2 == "number" || type2 == "atom")
              return cont(afterType);
            if (type2 == "[")
              return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
            if (type2 == "{")
              return cont(pushlex("}"), typeprops, poplex, afterType);
            if (type2 == "(")
              return cont(commasep(typearg, ")"), maybeReturnType, afterType);
            if (type2 == "<")
              return cont(commasep(typeexpr, ">"), typeexpr);
            if (type2 == "quasi") {
              return pass(quasiType, afterType);
            }
          }
          function maybeReturnType(type2) {
            if (type2 == "=>")
              return cont(typeexpr);
          }
          function typeprops(type2) {
            if (type2.match(/[\}\)\]]/))
              return cont();
            if (type2 == "," || type2 == ";")
              return cont(typeprops);
            return pass(typeprop, typeprops);
          }
          function typeprop(type2, value) {
            if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              return cont(typeprop);
            } else if (value == "?" || type2 == "number" || type2 == "string") {
              return cont(typeprop);
            } else if (type2 == ":") {
              return cont(typeexpr);
            } else if (type2 == "[") {
              return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
            } else if (type2 == "(") {
              return pass(functiondecl, typeprop);
            } else if (!type2.match(/[;\}\)\],]/)) {
              return cont();
            }
          }
          function quasiType(type2, value) {
            if (type2 != "quasi")
              return pass();
            if (value.slice(value.length - 2) != "${")
              return cont(quasiType);
            return cont(typeexpr, continueQuasiType);
          }
          function continueQuasiType(type2) {
            if (type2 == "}") {
              cx.marked = "string-2";
              cx.state.tokenize = tokenQuasi;
              return cont(quasiType);
            }
          }
          function typearg(type2, value) {
            if (type2 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?")
              return cont(typearg);
            if (type2 == ":")
              return cont(typeexpr);
            if (type2 == "spread")
              return cont(typearg);
            return pass(typeexpr);
          }
          function afterType(type2, value) {
            if (value == "<")
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
            if (value == "|" || type2 == "." || value == "&")
              return cont(typeexpr);
            if (type2 == "[")
              return cont(typeexpr, expect("]"), afterType);
            if (value == "extends" || value == "implements") {
              cx.marked = "keyword";
              return cont(typeexpr);
            }
            if (value == "?")
              return cont(typeexpr, expect(":"), typeexpr);
          }
          function maybeTypeArgs(_14, value) {
            if (value == "<")
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          }
          function typeparam() {
            return pass(typeexpr, maybeTypeDefault);
          }
          function maybeTypeDefault(_14, value) {
            if (value == "=")
              return cont(typeexpr);
          }
          function vardef(_14, value) {
            if (value == "enum") {
              cx.marked = "keyword";
              return cont(enumdef);
            }
            return pass(pattern, maybetype, maybeAssign, vardefCont);
          }
          function pattern(type2, value) {
            if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(pattern);
            }
            if (type2 == "variable") {
              register(value);
              return cont();
            }
            if (type2 == "spread")
              return cont(pattern);
            if (type2 == "[")
              return contCommasep(eltpattern, "]");
            if (type2 == "{")
              return contCommasep(proppattern, "}");
          }
          function proppattern(type2, value) {
            if (type2 == "variable" && !cx.stream.match(/^\s*:/, false)) {
              register(value);
              return cont(maybeAssign);
            }
            if (type2 == "variable")
              cx.marked = "property";
            if (type2 == "spread")
              return cont(pattern);
            if (type2 == "}")
              return pass();
            if (type2 == "[")
              return cont(expression, expect("]"), expect(":"), proppattern);
            return cont(expect(":"), pattern, maybeAssign);
          }
          function eltpattern() {
            return pass(pattern, maybeAssign);
          }
          function maybeAssign(_type, value) {
            if (value == "=")
              return cont(expressionNoComma);
          }
          function vardefCont(type2) {
            if (type2 == ",")
              return cont(vardef);
          }
          function maybeelse(type2, value) {
            if (type2 == "keyword b" && value == "else")
              return cont(pushlex("form", "else"), statement, poplex);
          }
          function forspec(type2, value) {
            if (value == "await")
              return cont(forspec);
            if (type2 == "(")
              return cont(pushlex(")"), forspec1, poplex);
          }
          function forspec1(type2) {
            if (type2 == "var")
              return cont(vardef, forspec2);
            if (type2 == "variable")
              return cont(forspec2);
            return pass(forspec2);
          }
          function forspec2(type2, value) {
            if (type2 == ")")
              return cont();
            if (type2 == ";")
              return cont(forspec2);
            if (value == "in" || value == "of") {
              cx.marked = "keyword";
              return cont(expression, forspec2);
            }
            return pass(expression, forspec2);
          }
          function functiondef(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(functiondef);
            }
            if (type2 == "variable") {
              register(value);
              return cont(functiondef);
            }
            if (type2 == "(")
              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
            if (isTS && value == "<")
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
          }
          function functiondecl(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(functiondecl);
            }
            if (type2 == "variable") {
              register(value);
              return cont(functiondecl);
            }
            if (type2 == "(")
              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
            if (isTS && value == "<")
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
          }
          function typename(type2, value) {
            if (type2 == "keyword" || type2 == "variable") {
              cx.marked = "type";
              return cont(typename);
            } else if (value == "<") {
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
            }
          }
          function funarg(type2, value) {
            if (value == "@")
              cont(expression, funarg);
            if (type2 == "spread")
              return cont(funarg);
            if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(funarg);
            }
            if (isTS && type2 == "this")
              return cont(maybetype, maybeAssign);
            return pass(pattern, maybetype, maybeAssign);
          }
          function classExpression(type2, value) {
            if (type2 == "variable")
              return className(type2, value);
            return classNameAfter(type2, value);
          }
          function className(type2, value) {
            if (type2 == "variable") {
              register(value);
              return cont(classNameAfter);
            }
          }
          function classNameAfter(type2, value) {
            if (value == "<")
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
            if (value == "extends" || value == "implements" || isTS && type2 == ",") {
              if (value == "implements")
                cx.marked = "keyword";
              return cont(isTS ? typeexpr : expression, classNameAfter);
            }
            if (type2 == "{")
              return cont(pushlex("}"), classBody, poplex);
          }
          function classBody(type2, value) {
            if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
              cx.marked = "keyword";
              return cont(classBody);
            }
            if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              return cont(classfield, classBody);
            }
            if (type2 == "number" || type2 == "string")
              return cont(classfield, classBody);
            if (type2 == "[")
              return cont(expression, maybetype, expect("]"), classfield, classBody);
            if (value == "*") {
              cx.marked = "keyword";
              return cont(classBody);
            }
            if (isTS && type2 == "(")
              return pass(functiondecl, classBody);
            if (type2 == ";" || type2 == ",")
              return cont(classBody);
            if (type2 == "}")
              return cont();
            if (value == "@")
              return cont(expression, classBody);
          }
          function classfield(type2, value) {
            if (value == "!")
              return cont(classfield);
            if (value == "?")
              return cont(classfield);
            if (type2 == ":")
              return cont(typeexpr, maybeAssign);
            if (value == "=")
              return cont(expressionNoComma);
            var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
            return pass(isInterface ? functiondecl : functiondef);
          }
          function afterExport(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(maybeFrom, expect(";"));
            }
            if (value == "default") {
              cx.marked = "keyword";
              return cont(expression, expect(";"));
            }
            if (type2 == "{")
              return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
            return pass(statement);
          }
          function exportField(type2, value) {
            if (value == "as") {
              cx.marked = "keyword";
              return cont(expect("variable"));
            }
            if (type2 == "variable")
              return pass(expressionNoComma, exportField);
          }
          function afterImport(type2) {
            if (type2 == "string")
              return cont();
            if (type2 == "(")
              return pass(expression);
            if (type2 == ".")
              return pass(maybeoperatorComma);
            return pass(importSpec, maybeMoreImports, maybeFrom);
          }
          function importSpec(type2, value) {
            if (type2 == "{")
              return contCommasep(importSpec, "}");
            if (type2 == "variable")
              register(value);
            if (value == "*")
              cx.marked = "keyword";
            return cont(maybeAs);
          }
          function maybeMoreImports(type2) {
            if (type2 == ",")
              return cont(importSpec, maybeMoreImports);
          }
          function maybeAs(_type, value) {
            if (value == "as") {
              cx.marked = "keyword";
              return cont(importSpec);
            }
          }
          function maybeFrom(_type, value) {
            if (value == "from") {
              cx.marked = "keyword";
              return cont(expression);
            }
          }
          function arrayLiteral(type2) {
            if (type2 == "]")
              return cont();
            return pass(commasep(expressionNoComma, "]"));
          }
          function enumdef() {
            return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
          }
          function enummember() {
            return pass(pattern, maybeAssign);
          }
          function isContinuedStatement(state, textAfter) {
            return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
          }
          function expressionAllowed(stream, state, backUp) {
            return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
          }
          return {
            startState: function(basecolumn) {
              var state = {
                tokenize: tokenBase,
                lastType: "sof",
                cc: [],
                lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
                localVars: parserConfig.localVars,
                context: parserConfig.localVars && new Context(null, null, false),
                indented: basecolumn || 0
              };
              if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
                state.globalVars = parserConfig.globalVars;
              return state;
            },
            token: function(stream, state) {
              if (stream.sol()) {
                if (!state.lexical.hasOwnProperty("align"))
                  state.lexical.align = false;
                state.indented = stream.indentation();
                findFatArrow(stream, state);
              }
              if (state.tokenize != tokenComment && stream.eatSpace())
                return null;
              var style = state.tokenize(stream, state);
              if (type == "comment")
                return style;
              state.lastType = type == "operator" && (content2 == "++" || content2 == "--") ? "incdec" : type;
              return parseJS(state, style, type, content2, stream);
            },
            indent: function(state, textAfter) {
              if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
                return CodeMirror3.Pass;
              if (state.tokenize != tokenBase)
                return 0;
              var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top2;
              if (!/^\s*else\b/.test(textAfter))
                for (var i = state.cc.length - 1; i >= 0; --i) {
                  var c = state.cc[i];
                  if (c == poplex)
                    lexical = lexical.prev;
                  else if (c != maybeelse && c != popcontext)
                    break;
                }
              while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top2 = state.cc[state.cc.length - 1]) && (top2 == maybeoperatorComma || top2 == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
                lexical = lexical.prev;
              if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
                lexical = lexical.prev;
              var type2 = lexical.type, closing = firstChar == type2;
              if (type2 == "vardef")
                return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
              else if (type2 == "form" && firstChar == "{")
                return lexical.indented;
              else if (type2 == "form")
                return lexical.indented + indentUnit;
              else if (type2 == "stat")
                return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
              else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
                return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
              else if (lexical.align)
                return lexical.column + (closing ? 0 : 1);
              else
                return lexical.indented + (closing ? 0 : indentUnit);
            },
            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : "/*",
            blockCommentEnd: jsonMode ? null : "*/",
            blockCommentContinue: jsonMode ? null : " * ",
            lineComment: jsonMode ? null : "//",
            fold: "brace",
            closeBrackets: "()[]{}''\"\"``",
            helperType: jsonMode ? "json" : "javascript",
            jsonldMode,
            jsonMode,
            expressionAllowed,
            skipExpression: function(state) {
              parseJS(state, "atom", "atom", "true", new CodeMirror3.StringStream("", 2, null));
            }
          };
        });
        CodeMirror3.registerHelper("wordChars", "javascript", /[\w$]/);
        CodeMirror3.defineMIME("text/javascript", "javascript");
        CodeMirror3.defineMIME("text/ecmascript", "javascript");
        CodeMirror3.defineMIME("application/javascript", "javascript");
        CodeMirror3.defineMIME("application/x-javascript", "javascript");
        CodeMirror3.defineMIME("application/ecmascript", "javascript");
        CodeMirror3.defineMIME("application/json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/x-json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/manifest+json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
        CodeMirror3.defineMIME("text/typescript", { name: "javascript", typescript: true });
        CodeMirror3.defineMIME("application/typescript", { name: "javascript", typescript: true });
      });
    }
  });

  // ../../node_modules/codemirror/mode/jsx/jsx.js
  var require_jsx = __commonJS({
    "../../node_modules/codemirror/mode/jsx/jsx.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_xml(), require_javascript());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        function Context(state, mode, depth, prev) {
          this.state = state;
          this.mode = mode;
          this.depth = depth;
          this.prev = prev;
        }
        function copyContext(context) {
          return new Context(CodeMirror3.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));
        }
        CodeMirror3.defineMode("jsx", function(config, modeConfig) {
          var xmlMode = CodeMirror3.getMode(config, { name: "xml", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true });
          var jsMode = CodeMirror3.getMode(config, modeConfig && modeConfig.base || "javascript");
          function flatXMLIndent(state) {
            var tagName = state.tagName;
            state.tagName = null;
            var result = xmlMode.indent(state, "", "");
            state.tagName = tagName;
            return result;
          }
          function token(stream, state) {
            if (state.context.mode == xmlMode)
              return xmlToken(stream, state, state.context);
            else
              return jsToken(stream, state, state.context);
          }
          function xmlToken(stream, state, cx) {
            if (cx.depth == 2) {
              if (stream.match(/^.*?\*\//))
                cx.depth = 1;
              else
                stream.skipToEnd();
              return "comment";
            }
            if (stream.peek() == "{") {
              xmlMode.skipAttribute(cx.state);
              var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context;
              if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
                while (xmlContext.prev && !xmlContext.startOfLine)
                  xmlContext = xmlContext.prev;
                if (xmlContext.startOfLine)
                  indent -= config.indentUnit;
                else if (cx.prev.state.lexical)
                  indent = cx.prev.state.lexical.indented;
              } else if (cx.depth == 1) {
                indent += config.indentUnit;
              }
              state.context = new Context(CodeMirror3.startState(jsMode, indent), jsMode, 0, state.context);
              return null;
            }
            if (cx.depth == 1) {
              if (stream.peek() == "<") {
                xmlMode.skipAttribute(cx.state);
                state.context = new Context(CodeMirror3.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context);
                return null;
              } else if (stream.match("//")) {
                stream.skipToEnd();
                return "comment";
              } else if (stream.match("/*")) {
                cx.depth = 2;
                return token(stream, state);
              }
            }
            var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop;
            if (/\btag\b/.test(style)) {
              if (/>$/.test(cur)) {
                if (cx.state.context)
                  cx.depth = 0;
                else
                  state.context = state.context.prev;
              } else if (/^</.test(cur)) {
                cx.depth = 1;
              }
            } else if (!style && (stop = cur.indexOf("{")) > -1) {
              stream.backUp(cur.length - stop);
            }
            return style;
          }
          function jsToken(stream, state, cx) {
            if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
              state.context = new Context(CodeMirror3.startState(xmlMode, jsMode.indent(cx.state, "", "")), xmlMode, 0, state.context);
              jsMode.skipExpression(cx.state);
              return null;
            }
            var style = jsMode.token(stream, cx.state);
            if (!style && cx.depth != null) {
              var cur = stream.current();
              if (cur == "{") {
                cx.depth++;
              } else if (cur == "}") {
                if (--cx.depth == 0)
                  state.context = state.context.prev;
              }
            }
            return style;
          }
          return {
            startState: function() {
              return { context: new Context(CodeMirror3.startState(jsMode), jsMode) };
            },
            copyState: function(state) {
              return { context: copyContext(state.context) };
            },
            token,
            indent: function(state, textAfter, fullLine) {
              return state.context.mode.indent(state.context.state, textAfter, fullLine);
            },
            innerMode: function(state) {
              return state.context;
            }
          };
        }, "xml", "javascript");
        CodeMirror3.defineMIME("text/jsx", "jsx");
        CodeMirror3.defineMIME("text/typescript-jsx", { name: "jsx", base: { name: "javascript", typescript: true } });
      });
    }
  });

  // ../../packages/nota-cli/lib/page.tsx
  var import_react14 = __toModule(require_react());
  var import_react_dom2 = __toModule(require_react_dom());

  // ../../packages/nota/dist/nota.js
  var nota_exports = {};
  __export(nota_exports, {
    $: () => yA,
    $$: () => Aa,
    Abstract: () => KA,
    Affiliation: () => GA,
    Author: () => $A,
    Authors: () => XA,
    Caption: () => OA,
    Center: () => PA,
    Cite: () => Qc,
    Comment: () => dT,
    Commentary: () => mT,
    Correspondence: () => cT,
    Definition: () => G0,
    Document: () => HA,
    Expandable: () => LA,
    Figure: () => Vc,
    Footnote: () => IA,
    FootnoteDef: () => Yc,
    IR: () => yf,
    IRToggle: () => lT,
    Institution: () => WA,
    Language: () => gf,
    Link: () => fT,
    Listing: () => MA,
    ListingConfigure: () => CA,
    ListingPlugin: () => es,
    Loader: () => WT,
    LoaderContext: () => ch,
    LoggerPlugin: () => Jl,
    Name: () => VA,
    Pluggable: () => xr,
    Plugin: () => wr,
    Premise: () => oT,
    PremiseRow: () => sT,
    Ref: () => Jo,
    References: () => jA,
    Row: () => g8,
    Section: () => d8,
    SectionTitle: () => h8,
    Smallcaps: () => p8,
    SubSection: () => DA,
    SubSubSection: () => BA,
    Subfigure: () => NA,
    Tex: () => l8,
    Theorem: () => uT,
    Title: () => YA,
    ToggleButton: () => au,
    Togglebox: () => aT,
    Wrap: () => qA,
    add_highlight: () => Hc,
    clear_highlights: () => jc,
    linecol_to_pos: () => TA,
    newcommand: () => Zl,
    pos_to_linecol: () => EA,
    usePlugin: () => kt,
    useStateOnInterval: () => Uo,
    zipExn: () => Ul
  });
  var N = __toModule(require_react());
  var VT = __toModule(require_react());

  // ../../node_modules/mobx-react/dist/mobxreact.esm.js
  var mobxreact_esm_exports = {};
  __export(mobxreact_esm_exports, {
    MobXProviderContext: () => MobXProviderContext,
    Observer: () => ObserverComponent,
    PropTypes: () => PropTypes,
    Provider: () => Provider,
    disposeOnUnmount: () => disposeOnUnmount,
    enableStaticRendering: () => enableStaticRendering,
    inject: () => inject,
    isUsingStaticRendering: () => isUsingStaticRendering,
    observer: () => observer2,
    observerBatching: () => observerBatching,
    useAsObservableSource: () => useAsObservableSource,
    useLocalObservable: () => useLocalObservable,
    useLocalStore: () => useLocalStore,
    useObserver: () => useObserver2,
    useStaticRendering: () => useStaticRendering
  });

  // ../../node_modules/mobx/dist/mobx.esm.js
  var mobx_esm_exports = {};
  __export(mobx_esm_exports, {
    $mobx: () => $mobx,
    FlowCancellationError: () => FlowCancellationError,
    ObservableMap: () => ObservableMap,
    ObservableSet: () => ObservableSet,
    Reaction: () => Reaction,
    _allowStateChanges: () => allowStateChanges,
    _allowStateChangesInsideComputed: () => runInAction,
    _allowStateReadsEnd: () => allowStateReadsEnd,
    _allowStateReadsStart: () => allowStateReadsStart,
    _autoAction: () => autoAction,
    _endAction: () => _endAction,
    _getAdministration: () => getAdministration,
    _getGlobalState: () => getGlobalState,
    _interceptReads: () => interceptReads,
    _isComputingDerivation: () => isComputingDerivation,
    _resetGlobalState: () => resetGlobalState,
    _startAction: () => _startAction,
    action: () => action,
    autorun: () => autorun,
    comparer: () => comparer,
    computed: () => computed,
    configure: () => configure,
    createAtom: () => createAtom,
    defineProperty: () => apiDefineProperty,
    entries: () => entries,
    extendObservable: () => extendObservable,
    flow: () => flow,
    flowResult: () => flowResult,
    get: () => get,
    getAtom: () => getAtom,
    getDebugName: () => getDebugName,
    getDependencyTree: () => getDependencyTree,
    getObserverTree: () => getObserverTree,
    has: () => has,
    intercept: () => intercept,
    isAction: () => isAction,
    isBoxedObservable: () => isObservableValue,
    isComputed: () => isComputed,
    isComputedProp: () => isComputedProp,
    isFlow: () => isFlow,
    isFlowCancellationError: () => isFlowCancellationError,
    isObservable: () => isObservable,
    isObservableArray: () => isObservableArray,
    isObservableMap: () => isObservableMap,
    isObservableObject: () => isObservableObject,
    isObservableProp: () => isObservableProp,
    isObservableSet: () => isObservableSet,
    keys: () => keys,
    makeAutoObservable: () => makeAutoObservable,
    makeObservable: () => makeObservable,
    observable: () => observable,
    observe: () => observe,
    onBecomeObserved: () => onBecomeObserved,
    onBecomeUnobserved: () => onBecomeUnobserved,
    onReactionError: () => onReactionError,
    override: () => override,
    ownKeys: () => apiOwnKeys,
    reaction: () => reaction,
    remove: () => remove,
    runInAction: () => runInAction,
    set: () => set2,
    spy: () => spy,
    toJS: () => toJS,
    trace: () => trace,
    transaction: () => transaction,
    untracked: () => untracked,
    values: () => values,
    when: () => when
  });
  var niceErrors = {
    0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
    1: function _(annotationType, key) {
      return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
    },
    5: "'keys()' can only be used on observable objects, arrays, sets and maps",
    6: "'values()' can only be used on observable objects, arrays, sets and maps",
    7: "'entries()' can only be used on observable objects, arrays and maps",
    8: "'set()' can only be used on observable objects, arrays and maps",
    9: "'remove()' can only be used on observable objects, arrays and maps",
    10: "'has()' can only be used on observable objects, arrays and maps",
    11: "'get()' can only be used on observable objects, arrays and maps",
    12: "Invalid annotation",
    13: "Dynamic observable objects cannot be frozen",
    14: "Intercept handlers should return nothing or a change object",
    15: "Observable arrays cannot be frozen",
    16: "Modification exception: the internal structure of an observable array was changed.",
    17: function _2(index, length) {
      return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
    },
    18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
    19: function _3(other) {
      return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
    },
    20: function _4(other) {
      return "Cannot initialize map from " + other;
    },
    21: function _5(dataStructure) {
      return "Cannot convert to map from '" + dataStructure + "'";
    },
    22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
    23: "It is not possible to get index atoms from arrays",
    24: function _6(thing) {
      return "Cannot obtain administration from " + thing;
    },
    25: function _7(property, name2) {
      return "the entry '" + property + "' does not exist in the observable map '" + name2 + "'";
    },
    26: "please specify a property",
    27: function _8(property, name2) {
      return "no observable property '" + property.toString() + "' found on the observable object '" + name2 + "'";
    },
    28: function _9(thing) {
      return "Cannot obtain atom from " + thing;
    },
    29: "Expecting some object",
    30: "invalid action stack. did you forget to finish an action?",
    31: "missing option for computed: get",
    32: function _10(name2, derivation) {
      return "Cycle detected in computation " + name2 + ": " + derivation;
    },
    33: function _11(name2) {
      return "The setter of computed value '" + name2 + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
    },
    34: function _12(name2) {
      return "[ComputedValue '" + name2 + "'] It is not possible to assign a new value to a computed value.";
    },
    35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
    36: "isolateGlobalState should be called before MobX is running any reactions",
    37: function _13(method) {
      return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
    },
    38: "'ownKeys()' can only be used on observable objects",
    39: "'defineProperty()' can only be used on observable objects"
  };
  var errors = true ? niceErrors : {};
  function die(error) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (true) {
      var e = typeof error === "string" ? error : errors[error];
      if (typeof e === "function")
        e = e.apply(null, args);
      throw new Error("[MobX] " + e);
    }
    throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
  }
  var mockGlobal = {};
  function getGlobal() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    return mockGlobal;
  }
  var assign = Object.assign;
  var getDescriptor = Object.getOwnPropertyDescriptor;
  var defineProperty = Object.defineProperty;
  var objectPrototype = Object.prototype;
  var EMPTY_ARRAY = [];
  Object.freeze(EMPTY_ARRAY);
  var EMPTY_OBJECT = {};
  Object.freeze(EMPTY_OBJECT);
  var hasProxy = typeof Proxy !== "undefined";
  var plainObjectString = /* @__PURE__ */ Object.toString();
  function assertProxies() {
    if (!hasProxy) {
      die(true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
    }
  }
  function warnAboutProxyRequirement(msg) {
    if (globalState.verifyProxies) {
      die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
    }
  }
  function getNextId() {
    return ++globalState.mobxGuid;
  }
  function once(func) {
    var invoked = false;
    return function() {
      if (invoked)
        return;
      invoked = true;
      return func.apply(this, arguments);
    };
  }
  var noop = function noop2() {
  };
  function isFunction(fn) {
    return typeof fn === "function";
  }
  function isStringish(value) {
    var t2 = typeof value;
    switch (t2) {
      case "string":
      case "symbol":
      case "number":
        return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  function isPlainObject(value) {
    var _proto$constructor;
    if (!isObject(value))
      return false;
    var proto = Object.getPrototypeOf(value);
    if (proto == null)
      return true;
    return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
  }
  function isGenerator(obj) {
    var constructor = obj == null ? void 0 : obj.constructor;
    if (!constructor)
      return false;
    if (constructor.name === "GeneratorFunction" || constructor.displayName === "GeneratorFunction")
      return true;
    return false;
  }
  function addHiddenProp(object2, propName, value) {
    defineProperty(object2, propName, {
      enumerable: false,
      writable: true,
      configurable: true,
      value
    });
  }
  function addHiddenFinalProp(object2, propName, value) {
    defineProperty(object2, propName, {
      enumerable: false,
      writable: false,
      configurable: true,
      value
    });
  }
  function createInstanceofPredicate(name2, theClass) {
    var propName = "isMobX" + name2;
    theClass.prototype[propName] = true;
    return function(x) {
      return isObject(x) && x[propName] === true;
    };
  }
  function isES6Map(thing) {
    return thing instanceof Map;
  }
  function isES6Set(thing) {
    return thing instanceof Set;
  }
  var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
  function getPlainObjectKeys(object2) {
    var keys2 = Object.keys(object2);
    if (!hasGetOwnPropertySymbols)
      return keys2;
    var symbols = Object.getOwnPropertySymbols(object2);
    if (!symbols.length)
      return keys2;
    return [].concat(keys2, symbols.filter(function(s) {
      return objectPrototype.propertyIsEnumerable.call(object2, s);
    }));
  }
  var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
  } : Object.getOwnPropertyNames;
  function stringifyKey(key) {
    if (typeof key === "string")
      return key;
    if (typeof key === "symbol")
      return key.toString();
    return new String(key).toString();
  }
  function toPrimitive(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
  }
  function hasProp(target, prop) {
    return objectPrototype.hasOwnProperty.call(target, prop);
  }
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
    var res = {};
    ownKeys(target).forEach(function(key) {
      res[key] = getDescriptor(target, key);
    });
    return res;
  };
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }
  var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
  function createDecoratorAnnotation(annotation) {
    function decorator(target, property) {
      storeAnnotation(target, property, annotation);
    }
    return Object.assign(decorator, annotation);
  }
  function storeAnnotation(prototype, key, annotation) {
    if (!hasProp(prototype, storedAnnotationsSymbol)) {
      addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
    }
    if (isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
      var fieldName = prototype.constructor.name + ".prototype." + key.toString();
      die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
    }
    assertNotDecorated(prototype, annotation, key);
    if (!isOverride(annotation)) {
      prototype[storedAnnotationsSymbol][key] = annotation;
    }
  }
  function assertNotDecorated(prototype, annotation, key) {
    if (!isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
      var fieldName = prototype.constructor.name + ".prototype." + key.toString();
      var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
      var requestedAnnotationType = annotation.annotationType_;
      die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overriden by subclass.");
    }
  }
  function collectStoredAnnotations(target) {
    if (!hasProp(target, storedAnnotationsSymbol)) {
      if (!target[storedAnnotationsSymbol]) {
        die("No annotations were passed to makeObservable, but no decorated members have been found either");
      }
      addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
    }
    return target[storedAnnotationsSymbol];
  }
  var $mobx = /* @__PURE__ */ Symbol("mobx administration");
  var Atom = /* @__PURE__ */ function() {
    function Atom2(name_) {
      if (name_ === void 0) {
        name_ = true ? "Atom@" + getNextId() : "Atom";
      }
      this.name_ = void 0;
      this.isPendingUnobservation_ = false;
      this.isBeingObserved_ = false;
      this.observers_ = new Set();
      this.diffValue_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
      this.onBOL = void 0;
      this.onBUOL = void 0;
      this.name_ = name_;
    }
    var _proto = Atom2.prototype;
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.reportObserved = function reportObserved$1() {
      return reportObserved(this);
    };
    _proto.reportChanged = function reportChanged() {
      startBatch();
      propagateChanged(this);
      endBatch();
    };
    _proto.toString = function toString2() {
      return this.name_;
    };
    return Atom2;
  }();
  var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
  function createAtom(name2, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === void 0) {
      onBecomeObservedHandler = noop;
    }
    if (onBecomeUnobservedHandler === void 0) {
      onBecomeUnobservedHandler = noop;
    }
    var atom = new Atom(name2);
    if (onBecomeObservedHandler !== noop) {
      onBecomeObserved(atom, onBecomeObservedHandler);
    }
    if (onBecomeUnobservedHandler !== noop) {
      onBecomeUnobserved(atom, onBecomeUnobservedHandler);
    }
    return atom;
  }
  function identityComparer(a, b) {
    return a === b;
  }
  function structuralComparer(a, b) {
    return deepEqual(a, b);
  }
  function shallowComparer(a, b) {
    return deepEqual(a, b, 1);
  }
  function defaultComparer(a, b) {
    if (Object.is)
      return Object.is(a, b);
    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
  }
  var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    "default": defaultComparer,
    shallow: shallowComparer
  };
  function deepEnhancer(v, _14, name2) {
    if (isObservable(v))
      return v;
    if (Array.isArray(v))
      return observable.array(v, {
        name: name2
      });
    if (isPlainObject(v))
      return observable.object(v, void 0, {
        name: name2
      });
    if (isES6Map(v))
      return observable.map(v, {
        name: name2
      });
    if (isES6Set(v))
      return observable.set(v, {
        name: name2
      });
    if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
      if (isGenerator(v)) {
        return flow(v);
      } else {
        return autoAction(name2, v);
      }
    }
    return v;
  }
  function shallowEnhancer(v, _14, name2) {
    if (v === void 0 || v === null)
      return v;
    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v))
      return v;
    if (Array.isArray(v))
      return observable.array(v, {
        name: name2,
        deep: false
      });
    if (isPlainObject(v))
      return observable.object(v, void 0, {
        name: name2,
        deep: false
      });
    if (isES6Map(v))
      return observable.map(v, {
        name: name2,
        deep: false
      });
    if (isES6Set(v))
      return observable.set(v, {
        name: name2,
        deep: false
      });
    if (true)
      die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
  }
  function referenceEnhancer(newValue) {
    return newValue;
  }
  function refStructEnhancer(v, oldValue) {
    if (isObservable(v))
      die("observable.struct should not be used with observable values");
    if (deepEqual(v, oldValue))
      return oldValue;
    return v;
  }
  var OVERRIDE = "override";
  var override = /* @__PURE__ */ createDecoratorAnnotation({
    annotationType_: OVERRIDE,
    make_,
    extend_
  });
  function isOverride(annotation) {
    return annotation.annotationType_ === OVERRIDE;
  }
  function make_(adm, key) {
    if (adm.isPlainObject_) {
      die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
    }
    if (!hasProp(adm.appliedAnnotations_, key)) {
      die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', but no such annotated member was found on prototype.");
    }
    return 0;
  }
  function extend_(adm, key, descriptor, proxyTrap) {
    die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
  }
  function createActionAnnotation(name2, options) {
    return {
      annotationType_: name2,
      options_: options,
      make_: make_$1,
      extend_: extend_$1
    };
  }
  function make_$1(adm, key, descriptor, source) {
    var _this$options_;
    if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
    }
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if (isAction(descriptor.value)) {
      return 1;
    }
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
    defineProperty(source, key, actionDescriptor);
    return 2;
  }
  function extend_$1(adm, key, descriptor, proxyTrap) {
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
    return adm.defineProperty_(key, actionDescriptor, proxyTrap);
  }
  function assertActionDescriptor(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var value = _ref2.value;
    if (!isFunction(value)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
    }
  }
  function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
    if (safeDescriptors === void 0) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertActionDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return {
      value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, ((_annotation$options_4 = annotation.options_) == null ? void 0 : _annotation$options_4.bound) ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0),
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      enumerable: false,
      writable: safeDescriptors ? false : true
    };
  }
  function createFlowAnnotation(name2, options) {
    return {
      annotationType_: name2,
      options_: options,
      make_: make_$2,
      extend_: extend_$2
    };
  }
  function make_$2(adm, key, descriptor, source) {
    var _this$options_;
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key])) {
      if (this.extend_(adm, key, descriptor, false) === null)
        return 0;
    }
    if (isFlow(descriptor.value)) {
      return 1;
    }
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
    defineProperty(source, key, flowDescriptor);
    return 2;
  }
  function extend_$2(adm, key, descriptor, proxyTrap) {
    var _this$options_2;
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
    return adm.defineProperty_(key, flowDescriptor, proxyTrap);
  }
  function assertFlowDescriptor(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var value = _ref2.value;
    if (!isFunction(value)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
    }
  }
  function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
    if (safeDescriptors === void 0) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertFlowDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if (bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return {
      value: flow(value),
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      enumerable: false,
      writable: safeDescriptors ? false : true
    };
  }
  function createComputedAnnotation(name2, options) {
    return {
      annotationType_: name2,
      options_: options,
      make_: make_$3,
      extend_: extend_$3
    };
  }
  function make_$3(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  function extend_$3(adm, key, descriptor, proxyTrap) {
    assertComputedDescriptor(adm, this, key, descriptor);
    return adm.defineComputedProperty_(key, _extends({}, this.options_, {
      get: descriptor.get,
      set: descriptor.set
    }), proxyTrap);
  }
  function assertComputedDescriptor(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var get4 = _ref2.get;
    if (!get4) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
    }
  }
  function createObservableAnnotation(name2, options) {
    return {
      annotationType_: name2,
      options_: options,
      make_: make_$4,
      extend_: extend_$4
    };
  }
  function make_$4(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  function extend_$4(adm, key, descriptor, proxyTrap) {
    var _this$options_$enhanc, _this$options_;
    assertObservableDescriptor(adm, this, key, descriptor);
    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
  }
  function assertObservableDescriptor(adm, _ref, key, descriptor) {
    var annotationType_ = _ref.annotationType_;
    if (!("value" in descriptor)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
    }
  }
  var AUTO = "true";
  var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
  function createAutoAnnotation(options) {
    return {
      annotationType_: AUTO,
      options_: options,
      make_: make_$5,
      extend_: extend_$5
    };
  }
  function make_$5(adm, key, descriptor, source) {
    var _this$options_3, _this$options_4;
    if (descriptor.get) {
      return computed.make_(adm, key, descriptor, source);
    }
    if (descriptor.set) {
      var set5 = createAction(key.toString(), descriptor.set);
      if (source === adm.target_) {
        return adm.defineProperty_(key, {
          configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
          set: set5
        }) === null ? 0 : 2;
      }
      defineProperty(source, key, {
        configurable: true,
        set: set5
      });
      return 2;
    }
    if (source !== adm.target_ && typeof descriptor.value === "function") {
      var _this$options_2;
      if (isGenerator(descriptor.value)) {
        var _this$options_;
        var flowAnnotation2 = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
        return flowAnnotation2.make_(adm, key, descriptor, source);
      }
      var actionAnnotation2 = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
      return actionAnnotation2.make_(adm, key, descriptor, source);
    }
    var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
    if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
      var _adm$proxy_;
      descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return observableAnnotation2.make_(adm, key, descriptor, source);
  }
  function extend_$5(adm, key, descriptor, proxyTrap) {
    var _this$options_5, _this$options_6;
    if (descriptor.get) {
      return computed.extend_(adm, key, descriptor, proxyTrap);
    }
    if (descriptor.set) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: createAction(key.toString(), descriptor.set)
      }, proxyTrap);
    }
    if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
      var _adm$proxy_2;
      descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
    }
    var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
    return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
  }
  var OBSERVABLE = "observable";
  var OBSERVABLE_REF = "observable.ref";
  var OBSERVABLE_SHALLOW = "observable.shallow";
  var OBSERVABLE_STRUCT = "observable.struct";
  var defaultCreateObservableOptions = {
    deep: true,
    name: void 0,
    defaultDecorator: void 0,
    proxy: true
  };
  Object.freeze(defaultCreateObservableOptions);
  function asCreateObservableOptions(thing) {
    return thing || defaultCreateObservableOptions;
  }
  var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
  var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
    enhancer: referenceEnhancer
  });
  var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
    enhancer: shallowEnhancer
  });
  var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
    enhancer: refStructEnhancer
  });
  var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
  function getEnhancerFromOptions(options) {
    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
  }
  function getAnnotationFromOptions(options) {
    var _options$defaultDecor;
    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
  }
  function getEnhancerFromAnnotation(annotation) {
    var _annotation$options_$, _annotation$options_;
    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
  }
  function createObservable(v, arg2, arg3) {
    if (isStringish(arg2)) {
      storeAnnotation(v, arg2, observableAnnotation);
      return;
    }
    if (isObservable(v))
      return v;
    if (isPlainObject(v))
      return observable.object(v, arg2, arg3);
    if (Array.isArray(v))
      return observable.array(v, arg2);
    if (isES6Map(v))
      return observable.map(v, arg2);
    if (isES6Set(v))
      return observable.set(v, arg2);
    if (typeof v === "object" && v !== null)
      return v;
    return observable.box(v, arg2);
  }
  Object.assign(createObservable, observableDecoratorAnnotation);
  var observableFactories = {
    box: function box(value, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
    },
    array: function array(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
    },
    map: function map(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
    },
    set: function set(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
    },
    object: function object(props, decorators, options) {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    },
    ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
    shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
    deep: observableDecoratorAnnotation,
    struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
  };
  var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
  var COMPUTED = "computed";
  var COMPUTED_STRUCT = "computed.struct";
  var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
  var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
    equals: comparer.structural
  });
  var computed = function computed2(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, computedAnnotation);
    }
    if (isPlainObject(arg1)) {
      return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
    }
    if (true) {
      if (!isFunction(arg1))
        die("First argument to `computed` should be an expression.");
      if (isFunction(arg2))
        die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
    }
    var opts = isPlainObject(arg2) ? arg2 : {};
    opts.get = arg1;
    opts.name || (opts.name = arg1.name || "");
    return new ComputedValue(opts);
  };
  Object.assign(computed, computedAnnotation);
  computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
  var _getDescriptor$config;
  var _getDescriptor;
  var currentActionId = 0;
  var nextActionId = 1;
  var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
  }, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
  var tmpNameDescriptor = {
    value: "action",
    configurable: true,
    writable: false,
    enumerable: false
  };
  function createAction(actionName, fn, autoAction2, ref) {
    if (autoAction2 === void 0) {
      autoAction2 = false;
    }
    if (true) {
      if (!isFunction(fn))
        die("`action` can only be invoked on functions");
      if (typeof actionName !== "string" || !actionName)
        die("actions should have valid names, got: '" + actionName + "'");
    }
    function res() {
      return executeAction(actionName, autoAction2, fn, ref || this, arguments);
    }
    res.isMobxAction = true;
    if (isFunctionNameConfigurable) {
      tmpNameDescriptor.value = actionName;
      Object.defineProperty(res, "name", tmpNameDescriptor);
    }
    return res;
  }
  function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
    var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
    try {
      return fn.apply(scope, args);
    } catch (err) {
      runInfo.error_ = err;
      throw err;
    } finally {
      _endAction(runInfo);
    }
  }
  function _startAction(actionName, canRunAsDerivation, scope, args) {
    var notifySpy_ = isSpyEnabled() && !!actionName;
    var startTime_ = 0;
    if (notifySpy_) {
      startTime_ = Date.now();
      var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
      spyReportStart({
        type: ACTION,
        name: actionName,
        object: scope,
        arguments: flattenedArgs
      });
    }
    var prevDerivation_ = globalState.trackingDerivation;
    var runAsAction = !canRunAsDerivation || !prevDerivation_;
    startBatch();
    var prevAllowStateChanges_ = globalState.allowStateChanges;
    if (runAsAction) {
      untrackedStart();
      prevAllowStateChanges_ = allowStateChangesStart(true);
    }
    var prevAllowStateReads_ = allowStateReadsStart(true);
    var runInfo = {
      runAsAction_: runAsAction,
      prevDerivation_,
      prevAllowStateChanges_,
      prevAllowStateReads_,
      notifySpy_,
      startTime_,
      actionId_: nextActionId++,
      parentActionId_: currentActionId
    };
    currentActionId = runInfo.actionId_;
    return runInfo;
  }
  function _endAction(runInfo) {
    if (currentActionId !== runInfo.actionId_) {
      die(30);
    }
    currentActionId = runInfo.parentActionId_;
    if (runInfo.error_ !== void 0) {
      globalState.suppressReactionErrors = true;
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges_);
    allowStateReadsEnd(runInfo.prevAllowStateReads_);
    endBatch();
    if (runInfo.runAsAction_)
      untrackedEnd(runInfo.prevDerivation_);
    if (runInfo.notifySpy_) {
      spyReportEnd({
        time: Date.now() - runInfo.startTime_
      });
    }
    globalState.suppressReactionErrors = false;
  }
  function allowStateChanges(allowStateChanges2, func) {
    var prev = allowStateChangesStart(allowStateChanges2);
    try {
      return func();
    } finally {
      allowStateChangesEnd(prev);
    }
  }
  function allowStateChangesStart(allowStateChanges2) {
    var prev = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges2;
    return prev;
  }
  function allowStateChangesEnd(prev) {
    globalState.allowStateChanges = prev;
  }
  var _Symbol$toPrimitive;
  var CREATE = "create";
  _Symbol$toPrimitive = Symbol.toPrimitive;
  var ObservableValue = /* @__PURE__ */ function(_Atom) {
    _inheritsLoose(ObservableValue2, _Atom);
    function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
      var _this;
      if (name_ === void 0) {
        name_ = true ? "ObservableValue@" + getNextId() : "ObservableValue";
      }
      if (notifySpy === void 0) {
        notifySpy = true;
      }
      if (equals === void 0) {
        equals = comparer["default"];
      }
      _this = _Atom.call(this, name_) || this;
      _this.enhancer = void 0;
      _this.name_ = void 0;
      _this.equals = void 0;
      _this.hasUnreportedChange_ = false;
      _this.interceptors_ = void 0;
      _this.changeListeners_ = void 0;
      _this.value_ = void 0;
      _this.dehancer = void 0;
      _this.enhancer = enhancer;
      _this.name_ = name_;
      _this.equals = equals;
      _this.value_ = enhancer(value, void 0, name_);
      if (notifySpy && isSpyEnabled()) {
        spyReport({
          type: CREATE,
          object: _assertThisInitialized(_this),
          observableKind: "value",
          debugObjectName: _this.name_,
          newValue: "" + _this.value_
        });
      }
      return _this;
    }
    var _proto = ObservableValue2.prototype;
    _proto.dehanceValue = function dehanceValue(value) {
      if (this.dehancer !== void 0)
        return this.dehancer(value);
      return value;
    };
    _proto.set = function set5(newValue) {
      var oldValue = this.value_;
      newValue = this.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        if (notifySpy) {
          spyReportStart({
            type: UPDATE,
            object: this,
            observableKind: "value",
            debugObjectName: this.name_,
            newValue,
            oldValue
          });
        }
        this.setNewValue_(newValue);
        if (notifySpy)
          spyReportEnd();
      }
    };
    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
      checkIfStateModificationsAreAllowed(this);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this,
          type: UPDATE,
          newValue
        });
        if (!change)
          return globalState.UNCHANGED;
        newValue = change.newValue;
      }
      newValue = this.enhancer(newValue, this.value_, this.name_);
      return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
    };
    _proto.setNewValue_ = function setNewValue_(newValue) {
      var oldValue = this.value_;
      this.value_ = newValue;
      this.reportChanged();
      if (hasListeners(this)) {
        notifyListeners(this, {
          type: UPDATE,
          object: this,
          newValue,
          oldValue
        });
      }
    };
    _proto.get = function get4() {
      this.reportObserved();
      return this.dehanceValue(this.value_);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately)
        listener({
          observableKind: "value",
          debugObjectName: this.name_,
          object: this,
          type: UPDATE,
          newValue: this.value_,
          oldValue: void 0
        });
      return registerListener(this, listener);
    };
    _proto.raw = function raw() {
      return this.value_;
    };
    _proto.toJSON = function toJSON2() {
      return this.get();
    };
    _proto.toString = function toString2() {
      return this.name_ + "[" + this.value_ + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive] = function() {
      return this.valueOf();
    };
    return ObservableValue2;
  }(Atom);
  var isObservableValue = /* @__PURE__ */ createInstanceofPredicate("ObservableValue", ObservableValue);
  var _Symbol$toPrimitive$1;
  _Symbol$toPrimitive$1 = Symbol.toPrimitive;
  var ComputedValue = /* @__PURE__ */ function() {
    function ComputedValue2(options) {
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.observing_ = [];
      this.newObserving_ = null;
      this.isBeingObserved_ = false;
      this.isPendingUnobservation_ = false;
      this.observers_ = new Set();
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      this.unboundDepsCount_ = 0;
      this.value_ = new CaughtException(null);
      this.name_ = void 0;
      this.triggeredBy_ = void 0;
      this.isComputing_ = false;
      this.isRunningSetter_ = false;
      this.derivation = void 0;
      this.setter_ = void 0;
      this.isTracing_ = TraceMode.NONE;
      this.scope_ = void 0;
      this.equals_ = void 0;
      this.requiresReaction_ = void 0;
      this.keepAlive_ = void 0;
      this.onBOL = void 0;
      this.onBUOL = void 0;
      if (!options.get)
        die(31);
      this.derivation = options.get;
      this.name_ = options.name || (true ? "ComputedValue@" + getNextId() : "ComputedValue");
      if (options.set) {
        this.setter_ = createAction(true ? this.name_ + "-setter" : "ComputedValue-setter", options.set);
      }
      this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
      this.scope_ = options.context;
      this.requiresReaction_ = !!options.requiresReaction;
      this.keepAlive_ = !!options.keepAlive;
    }
    var _proto = ComputedValue2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      propagateMaybeChanged(this);
    };
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.get = function get4() {
      if (this.isComputing_)
        die(32, this.name_, this.derivation);
      if (globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {
        if (shouldCompute(this)) {
          this.warnAboutUntrackedRead_();
          startBatch();
          this.value_ = this.computeValue_(false);
          endBatch();
        }
      } else {
        reportObserved(this);
        if (shouldCompute(this)) {
          var prevTrackingContext = globalState.trackingContext;
          if (this.keepAlive_ && !prevTrackingContext)
            globalState.trackingContext = this;
          if (this.trackAndCompute())
            propagateChangeConfirmed(this);
          globalState.trackingContext = prevTrackingContext;
        }
      }
      var result = this.value_;
      if (isCaughtException(result))
        throw result.cause;
      return result;
    };
    _proto.set = function set5(value) {
      if (this.setter_) {
        if (this.isRunningSetter_)
          die(33, this.name_);
        this.isRunningSetter_ = true;
        try {
          this.setter_.call(this.scope_, value);
        } finally {
          this.isRunningSetter_ = false;
        }
      } else
        die(34, this.name_);
    };
    _proto.trackAndCompute = function trackAndCompute() {
      var oldValue = this.value_;
      var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
      var newValue = this.computeValue_(true);
      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
      if (changed) {
        this.value_ = newValue;
        if (isSpyEnabled()) {
          spyReport({
            observableKind: "computed",
            debugObjectName: this.name_,
            object: this.scope_,
            type: "update",
            oldValue,
            newValue
          });
        }
      }
      return changed;
    };
    _proto.computeValue_ = function computeValue_(track) {
      this.isComputing_ = true;
      var prev = allowStateChangesStart(false);
      var res;
      if (track) {
        res = trackDerivedFunction(this, this.derivation, this.scope_);
      } else {
        if (globalState.disableErrorBoundaries === true) {
          res = this.derivation.call(this.scope_);
        } else {
          try {
            res = this.derivation.call(this.scope_);
          } catch (e) {
            res = new CaughtException(e);
          }
        }
      }
      allowStateChangesEnd(prev);
      this.isComputing_ = false;
      return res;
    };
    _proto.suspend_ = function suspend_() {
      if (!this.keepAlive_) {
        clearObserving(this);
        this.value_ = void 0;
        if (this.isTracing_ !== TraceMode.NONE) {
          console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
        }
      }
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      var _this = this;
      var firstTime = true;
      var prevValue = void 0;
      return autorun(function() {
        var newValue = _this.get();
        if (!firstTime || fireImmediately) {
          var prevU = untrackedStart();
          listener({
            observableKind: "computed",
            debugObjectName: _this.name_,
            type: UPDATE,
            object: _this,
            newValue,
            oldValue: prevValue
          });
          untrackedEnd(prevU);
        }
        firstTime = false;
        prevValue = newValue;
      });
    };
    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
      if (false)
        return;
      if (this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
      }
      if (globalState.computedRequiresReaction || this.requiresReaction_) {
        console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
      }
    };
    _proto.toString = function toString2() {
      return this.name_ + "[" + this.derivation.toString() + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive$1] = function() {
      return this.valueOf();
    };
    return ComputedValue2;
  }();
  var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
  var IDerivationState_;
  (function(IDerivationState_2) {
    IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
    IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
    IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
    IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
  })(IDerivationState_ || (IDerivationState_ = {}));
  var TraceMode;
  (function(TraceMode2) {
    TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
    TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
    TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
  })(TraceMode || (TraceMode = {}));
  var CaughtException = function CaughtException2(cause) {
    this.cause = void 0;
    this.cause = cause;
  };
  function isCaughtException(e) {
    return e instanceof CaughtException;
  }
  function shouldCompute(derivation) {
    switch (derivation.dependenciesState_) {
      case IDerivationState_.UP_TO_DATE_:
        return false;
      case IDerivationState_.NOT_TRACKING_:
      case IDerivationState_.STALE_:
        return true;
      case IDerivationState_.POSSIBLY_STALE_: {
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart();
        var obs = derivation.observing_, l = obs.length;
        for (var i = 0; i < l; i++) {
          var obj = obs[i];
          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            }
            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }
        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
    }
  }
  function isComputingDerivation() {
    return globalState.trackingDerivation !== null;
  }
  function checkIfStateModificationsAreAllowed(atom) {
    if (false) {
      return;
    }
    var hasObservers2 = atom.observers_.size > 0;
    if (!globalState.allowStateChanges && (hasObservers2 || globalState.enforceActions === "always"))
      console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
  }
  function checkIfStateReadsAreAllowed(observable2) {
    if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
      console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
    }
  }
  function trackDerivedFunction(derivation, f, context) {
    var prevAllowStateReads = allowStateReadsStart(true);
    changeDependenciesStateTo0(derivation);
    derivation.newObserving_ = new Array(derivation.observing_.length + 100);
    derivation.unboundDepsCount_ = 0;
    derivation.runId_ = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    globalState.inBatch++;
    var result;
    if (globalState.disableErrorBoundaries === true) {
      result = f.call(context);
    } else {
      try {
        result = f.call(context);
      } catch (e) {
        result = new CaughtException(e);
      }
    }
    globalState.inBatch--;
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    warnAboutDerivationWithoutDependencies(derivation);
    allowStateReadsEnd(prevAllowStateReads);
    return result;
  }
  function warnAboutDerivationWithoutDependencies(derivation) {
    if (false)
      return;
    if (derivation.observing_.length !== 0)
      return;
    if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
      console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
    }
  }
  function bindDependencies(derivation) {
    var prevObserving = derivation.observing_;
    var observing = derivation.observing_ = derivation.newObserving_;
    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
    var i0 = 0, l = derivation.unboundDepsCount_;
    for (var i = 0; i < l; i++) {
      var dep = observing[i];
      if (dep.diffValue_ === 0) {
        dep.diffValue_ = 1;
        if (i0 !== i)
          observing[i0] = dep;
        i0++;
      }
      if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
        lowestNewObservingDerivationState = dep.dependenciesState_;
      }
    }
    observing.length = i0;
    derivation.newObserving_ = null;
    l = prevObserving.length;
    while (l--) {
      var _dep = prevObserving[l];
      if (_dep.diffValue_ === 0) {
        removeObserver(_dep, derivation);
      }
      _dep.diffValue_ = 0;
    }
    while (i0--) {
      var _dep2 = observing[i0];
      if (_dep2.diffValue_ === 1) {
        _dep2.diffValue_ = 0;
        addObserver(_dep2, derivation);
      }
    }
    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
      derivation.dependenciesState_ = lowestNewObservingDerivationState;
      derivation.onBecomeStale_();
    }
  }
  function clearObserving(derivation) {
    var obs = derivation.observing_;
    derivation.observing_ = [];
    var i = obs.length;
    while (i--) {
      removeObserver(obs[i], derivation);
    }
    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
  }
  function untracked(action2) {
    var prev = untrackedStart();
    try {
      return action2();
    } finally {
      untrackedEnd(prev);
    }
  }
  function untrackedStart() {
    var prev = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev;
  }
  function untrackedEnd(prev) {
    globalState.trackingDerivation = prev;
  }
  function allowStateReadsStart(allowStateReads) {
    var prev = globalState.allowStateReads;
    globalState.allowStateReads = allowStateReads;
    return prev;
  }
  function allowStateReadsEnd(prev) {
    globalState.allowStateReads = prev;
  }
  function changeDependenciesStateTo0(derivation) {
    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_)
      return;
    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    var obs = derivation.observing_;
    var i = obs.length;
    while (i--) {
      obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  }
  var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
  var MobXGlobals = function MobXGlobals2() {
    this.version = 6;
    this.UNCHANGED = {};
    this.trackingDerivation = null;
    this.trackingContext = null;
    this.runId = 0;
    this.mobxGuid = 0;
    this.inBatch = 0;
    this.pendingUnobservations = [];
    this.pendingReactions = [];
    this.isRunningReactions = false;
    this.allowStateChanges = false;
    this.allowStateReads = true;
    this.enforceActions = true;
    this.spyListeners = [];
    this.globalReactionErrorHandlers = [];
    this.computedRequiresReaction = false;
    this.reactionRequiresObservable = false;
    this.observableRequiresReaction = false;
    this.disableErrorBoundaries = false;
    this.suppressReactionErrors = false;
    this.useProxies = true;
    this.verifyProxies = false;
    this.safeDescriptors = true;
  };
  var canMergeGlobalState = true;
  var isolateCalled = false;
  var globalState = /* @__PURE__ */ function() {
    var global2 = /* @__PURE__ */ getGlobal();
    if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals)
      canMergeGlobalState = false;
    if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version)
      canMergeGlobalState = false;
    if (!canMergeGlobalState) {
      setTimeout(function() {
        if (!isolateCalled) {
          die(35);
        }
      }, 1);
      return new MobXGlobals();
    } else if (global2.__mobxGlobals) {
      global2.__mobxInstanceCount += 1;
      if (!global2.__mobxGlobals.UNCHANGED)
        global2.__mobxGlobals.UNCHANGED = {};
      return global2.__mobxGlobals;
    } else {
      global2.__mobxInstanceCount = 1;
      return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
    }
  }();
  function isolateGlobalState() {
    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions)
      die(36);
    isolateCalled = true;
    if (canMergeGlobalState) {
      var global2 = getGlobal();
      if (--global2.__mobxInstanceCount === 0)
        global2.__mobxGlobals = void 0;
      globalState = new MobXGlobals();
    }
  }
  function getGlobalState() {
    return globalState;
  }
  function resetGlobalState() {
    var defaultGlobals = new MobXGlobals();
    for (var key in defaultGlobals) {
      if (persistentKeys.indexOf(key) === -1)
        globalState[key] = defaultGlobals[key];
    }
    globalState.allowStateChanges = !globalState.enforceActions;
  }
  function hasObservers(observable2) {
    return observable2.observers_ && observable2.observers_.size > 0;
  }
  function getObservers(observable2) {
    return observable2.observers_;
  }
  function addObserver(observable2, node) {
    observable2.observers_.add(node);
    if (observable2.lowestObserverState_ > node.dependenciesState_)
      observable2.lowestObserverState_ = node.dependenciesState_;
  }
  function removeObserver(observable2, node) {
    observable2.observers_["delete"](node);
    if (observable2.observers_.size === 0) {
      queueForUnobservation(observable2);
    }
  }
  function queueForUnobservation(observable2) {
    if (observable2.isPendingUnobservation_ === false) {
      observable2.isPendingUnobservation_ = true;
      globalState.pendingUnobservations.push(observable2);
    }
  }
  function startBatch() {
    globalState.inBatch++;
  }
  function endBatch() {
    if (--globalState.inBatch === 0) {
      runReactions();
      var list = globalState.pendingUnobservations;
      for (var i = 0; i < list.length; i++) {
        var observable2 = list[i];
        observable2.isPendingUnobservation_ = false;
        if (observable2.observers_.size === 0) {
          if (observable2.isBeingObserved_) {
            observable2.isBeingObserved_ = false;
            observable2.onBUO();
          }
          if (observable2 instanceof ComputedValue) {
            observable2.suspend_();
          }
        }
      }
      globalState.pendingUnobservations = [];
    }
  }
  function reportObserved(observable2) {
    checkIfStateReadsAreAllowed(observable2);
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
      if (derivation.runId_ !== observable2.lastAccessedBy_) {
        observable2.lastAccessedBy_ = derivation.runId_;
        derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
        if (!observable2.isBeingObserved_ && globalState.trackingContext) {
          observable2.isBeingObserved_ = true;
          observable2.onBO();
        }
      }
      return true;
    } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
      queueForUnobservation(observable2);
    }
    return false;
  }
  function propagateChanged(observable2) {
    if (observable2.lowestObserverState_ === IDerivationState_.STALE_)
      return;
    observable2.lowestObserverState_ = IDerivationState_.STALE_;
    observable2.observers_.forEach(function(d) {
      if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        if (d.isTracing_ !== TraceMode.NONE) {
          logTraceInfo(d, observable2);
        }
        d.onBecomeStale_();
      }
      d.dependenciesState_ = IDerivationState_.STALE_;
    });
  }
  function propagateChangeConfirmed(observable2) {
    if (observable2.lowestObserverState_ === IDerivationState_.STALE_)
      return;
    observable2.lowestObserverState_ = IDerivationState_.STALE_;
    observable2.observers_.forEach(function(d) {
      if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
        d.dependenciesState_ = IDerivationState_.STALE_;
        if (d.isTracing_ !== TraceMode.NONE) {
          logTraceInfo(d, observable2);
        }
      } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
    });
  }
  function propagateMaybeChanged(observable2) {
    if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_)
      return;
    observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
    observable2.observers_.forEach(function(d) {
      if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
        d.onBecomeStale_();
      }
    });
  }
  function logTraceInfo(derivation, observable2) {
    console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable2.name_ + "'");
    if (derivation.isTracing_ === TraceMode.BREAK) {
      var lines = [];
      printDepTree(getDependencyTree(derivation), lines, 1);
      new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable2.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
  }
  function printDepTree(tree, lines, depth) {
    if (lines.length >= 1e3) {
      lines.push("(and many more)");
      return;
    }
    lines.push("" + "	".repeat(depth - 1) + tree.name);
    if (tree.dependencies)
      tree.dependencies.forEach(function(child) {
        return printDepTree(child, lines, depth + 1);
      });
  }
  var Reaction = /* @__PURE__ */ function() {
    function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
      if (name_ === void 0) {
        name_ = true ? "Reaction@" + getNextId() : "Reaction";
      }
      if (requiresObservable_ === void 0) {
        requiresObservable_ = false;
      }
      this.name_ = void 0;
      this.onInvalidate_ = void 0;
      this.errorHandler_ = void 0;
      this.requiresObservable_ = void 0;
      this.observing_ = [];
      this.newObserving_ = [];
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.unboundDepsCount_ = 0;
      this.isDisposed_ = false;
      this.isScheduled_ = false;
      this.isTrackPending_ = false;
      this.isRunning_ = false;
      this.isTracing_ = TraceMode.NONE;
      this.name_ = name_;
      this.onInvalidate_ = onInvalidate_;
      this.errorHandler_ = errorHandler_;
      this.requiresObservable_ = requiresObservable_;
    }
    var _proto = Reaction2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      this.schedule_();
    };
    _proto.schedule_ = function schedule_() {
      if (!this.isScheduled_) {
        this.isScheduled_ = true;
        globalState.pendingReactions.push(this);
        runReactions();
      }
    };
    _proto.isScheduled = function isScheduled() {
      return this.isScheduled_;
    };
    _proto.runReaction_ = function runReaction_() {
      if (!this.isDisposed_) {
        startBatch();
        this.isScheduled_ = false;
        var prev = globalState.trackingContext;
        globalState.trackingContext = this;
        if (shouldCompute(this)) {
          this.isTrackPending_ = true;
          try {
            this.onInvalidate_();
            if (this.isTrackPending_ && isSpyEnabled()) {
              spyReport({
                name: this.name_,
                type: "scheduled-reaction"
              });
            }
          } catch (e) {
            this.reportExceptionInDerivation_(e);
          }
        }
        globalState.trackingContext = prev;
        endBatch();
      }
    };
    _proto.track = function track(fn) {
      if (this.isDisposed_) {
        return;
      }
      startBatch();
      var notify = isSpyEnabled();
      var startTime;
      if (notify) {
        startTime = Date.now();
        spyReportStart({
          name: this.name_,
          type: "reaction"
        });
      }
      this.isRunning_ = true;
      var prevReaction = globalState.trackingContext;
      globalState.trackingContext = this;
      var result = trackDerivedFunction(this, fn, void 0);
      globalState.trackingContext = prevReaction;
      this.isRunning_ = false;
      this.isTrackPending_ = false;
      if (this.isDisposed_) {
        clearObserving(this);
      }
      if (isCaughtException(result))
        this.reportExceptionInDerivation_(result.cause);
      if (notify) {
        spyReportEnd({
          time: Date.now() - startTime
        });
      }
      endBatch();
    };
    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
      var _this = this;
      if (this.errorHandler_) {
        this.errorHandler_(error, this);
        return;
      }
      if (globalState.disableErrorBoundaries)
        throw error;
      var message = true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
      if (!globalState.suppressReactionErrors) {
        console.error(message, error);
      } else if (true)
        console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
      if (isSpyEnabled()) {
        spyReport({
          type: "error",
          name: this.name_,
          message,
          error: "" + error
        });
      }
      globalState.globalReactionErrorHandlers.forEach(function(f) {
        return f(error, _this);
      });
    };
    _proto.dispose = function dispose() {
      if (!this.isDisposed_) {
        this.isDisposed_ = true;
        if (!this.isRunning_) {
          startBatch();
          clearObserving(this);
          endBatch();
        }
      }
    };
    _proto.getDisposer_ = function getDisposer_() {
      var r6 = this.dispose.bind(this);
      r6[$mobx] = this;
      return r6;
    };
    _proto.toString = function toString2() {
      return "Reaction[" + this.name_ + "]";
    };
    _proto.trace = function trace$1(enterBreakPoint) {
      if (enterBreakPoint === void 0) {
        enterBreakPoint = false;
      }
      trace(this, enterBreakPoint);
    };
    return Reaction2;
  }();
  function onReactionError(handler) {
    globalState.globalReactionErrorHandlers.push(handler);
    return function() {
      var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
      if (idx >= 0)
        globalState.globalReactionErrorHandlers.splice(idx, 1);
    };
  }
  var MAX_REACTION_ITERATIONS = 100;
  var reactionScheduler = function reactionScheduler2(f) {
    return f();
  };
  function runReactions() {
    if (globalState.inBatch > 0 || globalState.isRunningReactions)
      return;
    reactionScheduler(runReactionsHelper);
  }
  function runReactionsHelper() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    while (allReactions.length > 0) {
      if (++iterations === MAX_REACTION_ITERATIONS) {
        console.error(true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
        allReactions.splice(0);
      }
      var remainingReactions = allReactions.splice(0);
      for (var i = 0, l = remainingReactions.length; i < l; i++) {
        remainingReactions[i].runReaction_();
      }
    }
    globalState.isRunningReactions = false;
  }
  var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
  function setReactionScheduler(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function reactionScheduler3(f) {
      return fn(function() {
        return baseScheduler(f);
      });
    };
  }
  function isSpyEnabled() {
    return !!globalState.spyListeners.length;
  }
  function spyReport(event) {
    if (false)
      return;
    if (!globalState.spyListeners.length)
      return;
    var listeners = globalState.spyListeners;
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i](event);
    }
  }
  function spyReportStart(event) {
    if (false)
      return;
    var change = _extends({}, event, {
      spyReportStart: true
    });
    spyReport(change);
  }
  var END_EVENT = {
    type: "report-end",
    spyReportEnd: true
  };
  function spyReportEnd(change) {
    if (false)
      return;
    if (change)
      spyReport(_extends({}, change, {
        type: "report-end",
        spyReportEnd: true
      }));
    else
      spyReport(END_EVENT);
  }
  function spy(listener) {
    if (false) {
      console.warn("[mobx.spy] Is a no-op in production builds");
      return function() {
      };
    } else {
      globalState.spyListeners.push(listener);
      return once(function() {
        globalState.spyListeners = globalState.spyListeners.filter(function(l) {
          return l !== listener;
        });
      });
    }
  }
  var ACTION = "action";
  var ACTION_BOUND = "action.bound";
  var AUTOACTION = "autoAction";
  var AUTOACTION_BOUND = "autoAction.bound";
  var DEFAULT_ACTION_NAME = "<unnamed action>";
  var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
  var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
    bound: true
  });
  var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
    autoAction: true
  });
  var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
    autoAction: true,
    bound: true
  });
  function createActionFactory(autoAction2) {
    var res = function action2(arg1, arg2) {
      if (isFunction(arg1))
        return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
      if (isFunction(arg2))
        return createAction(arg1, arg2, autoAction2);
      if (isStringish(arg2)) {
        return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
      }
      if (isStringish(arg1)) {
        return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
          name: arg1,
          autoAction: autoAction2
        }));
      }
      if (true)
        die("Invalid arguments for `action`");
    };
    return res;
  }
  var action = /* @__PURE__ */ createActionFactory(false);
  Object.assign(action, actionAnnotation);
  var autoAction = /* @__PURE__ */ createActionFactory(true);
  Object.assign(autoAction, autoActionAnnotation);
  action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
  autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
  function runInAction(fn) {
    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
  }
  function isAction(thing) {
    return isFunction(thing) && thing.isMobxAction === true;
  }
  function autorun(view, opts) {
    var _opts$name, _opts;
    if (opts === void 0) {
      opts = EMPTY_OBJECT;
    }
    if (true) {
      if (!isFunction(view))
        die("Autorun expects a function as first argument");
      if (isAction(view))
        die("Autorun does not accept actions since actions are untrackable");
    }
    var name2 = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : true ? view.name || "Autorun@" + getNextId() : "Autorun";
    var runSync = !opts.scheduler && !opts.delay;
    var reaction2;
    if (runSync) {
      reaction2 = new Reaction(name2, function() {
        this.track(reactionRunner);
      }, opts.onError, opts.requiresObservable);
    } else {
      var scheduler = createSchedulerFromOptions(opts);
      var isScheduled = false;
      reaction2 = new Reaction(name2, function() {
        if (!isScheduled) {
          isScheduled = true;
          scheduler(function() {
            isScheduled = false;
            if (!reaction2.isDisposed_)
              reaction2.track(reactionRunner);
          });
        }
      }, opts.onError, opts.requiresObservable);
    }
    function reactionRunner() {
      view(reaction2);
    }
    reaction2.schedule_();
    return reaction2.getDisposer_();
  }
  var run = function run2(f) {
    return f();
  };
  function createSchedulerFromOptions(opts) {
    return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
      return setTimeout(f, opts.delay);
    } : run;
  }
  function reaction(expression, effect, opts) {
    var _opts$name2;
    if (opts === void 0) {
      opts = EMPTY_OBJECT;
    }
    if (true) {
      if (!isFunction(expression) || !isFunction(effect))
        die("First and second argument to reaction should be functions");
      if (!isPlainObject(opts))
        die("Third argument of reactions should be an object");
    }
    var name2 = (_opts$name2 = opts.name) != null ? _opts$name2 : true ? "Reaction@" + getNextId() : "Reaction";
    var effectAction = action(name2, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
    var runSync = !opts.scheduler && !opts.delay;
    var scheduler = createSchedulerFromOptions(opts);
    var firstTime = true;
    var isScheduled = false;
    var value;
    var oldValue;
    var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
    var r6 = new Reaction(name2, function() {
      if (firstTime || runSync) {
        reactionRunner();
      } else if (!isScheduled) {
        isScheduled = true;
        scheduler(reactionRunner);
      }
    }, opts.onError, opts.requiresObservable);
    function reactionRunner() {
      isScheduled = false;
      if (r6.isDisposed_)
        return;
      var changed = false;
      r6.track(function() {
        var nextValue = allowStateChanges(false, function() {
          return expression(r6);
        });
        changed = firstTime || !equals(value, nextValue);
        oldValue = value;
        value = nextValue;
      });
      if (firstTime && opts.fireImmediately)
        effectAction(value, oldValue, r6);
      else if (!firstTime && changed)
        effectAction(value, oldValue, r6);
      firstTime = false;
    }
    r6.schedule_();
    return r6.getDisposer_();
  }
  function wrapErrorHandler(errorHandler, baseFn) {
    return function() {
      try {
        return baseFn.apply(this, arguments);
      } catch (e) {
        errorHandler.call(this, e);
      }
    };
  }
  var ON_BECOME_OBSERVED = "onBO";
  var ON_BECOME_UNOBSERVED = "onBUO";
  function onBecomeObserved(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
  }
  function onBecomeUnobserved(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
  }
  function interceptHook(hook, thing, arg2, arg3) {
    var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
    var cb = isFunction(arg3) ? arg3 : arg2;
    var listenersKey = hook + "L";
    if (atom[listenersKey]) {
      atom[listenersKey].add(cb);
    } else {
      atom[listenersKey] = new Set([cb]);
    }
    return function() {
      var hookListeners = atom[listenersKey];
      if (hookListeners) {
        hookListeners["delete"](cb);
        if (hookListeners.size === 0) {
          delete atom[listenersKey];
        }
      }
    };
  }
  var NEVER = "never";
  var ALWAYS = "always";
  var OBSERVED = "observed";
  function configure(options) {
    if (options.isolateGlobalState === true) {
      isolateGlobalState();
    }
    var useProxies = options.useProxies, enforceActions = options.enforceActions;
    if (useProxies !== void 0) {
      globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
    }
    if (useProxies === "ifavailable")
      globalState.verifyProxies = true;
    if (enforceActions !== void 0) {
      var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
      globalState.enforceActions = ea;
      globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
    }
    ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
      if (key in options)
        globalState[key] = !!options[key];
    });
    globalState.allowStateReads = !globalState.observableRequiresReaction;
    if (globalState.disableErrorBoundaries === true) {
      console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
    }
    if (options.reactionScheduler) {
      setReactionScheduler(options.reactionScheduler);
    }
  }
  function extendObservable(target, properties, annotations, options) {
    if (true) {
      if (arguments.length > 4)
        die("'extendObservable' expected 2-4 arguments");
      if (typeof target !== "object")
        die("'extendObservable' expects an object as first argument");
      if (isObservableMap(target))
        die("'extendObservable' should not be used on maps, use map.merge instead");
      if (!isPlainObject(properties))
        die("'extendObservable' only accepts plain objects as second argument");
      if (isObservable(properties) || isObservable(annotations))
        die("Extending an object with another observable (object) is not supported");
    }
    var descriptors = getOwnPropertyDescriptors(properties);
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      ownKeys(descriptors).forEach(function(key) {
        adm.extend_(key, descriptors[key], !annotations ? true : key in annotations ? annotations[key] : true);
      });
    } finally {
      endBatch();
    }
    return target;
  }
  function getDependencyTree(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
  }
  function nodeToDependencyTree(node) {
    var result = {
      name: node.name_
    };
    if (node.observing_ && node.observing_.length > 0)
      result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
    return result;
  }
  function getObserverTree(thing, property) {
    return nodeToObserverTree(getAtom(thing, property));
  }
  function nodeToObserverTree(node) {
    var result = {
      name: node.name_
    };
    if (hasObservers(node))
      result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
    return result;
  }
  function unique(list) {
    return Array.from(new Set(list));
  }
  var generatorId = 0;
  function FlowCancellationError() {
    this.message = "FLOW_CANCELLED";
  }
  FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  function isFlowCancellationError(error) {
    return error instanceof FlowCancellationError;
  }
  var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
  var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
    bound: true
  });
  var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, flowAnnotation);
    }
    if (arguments.length !== 1)
      die("Flow expects single argument with generator function");
    var generator = arg1;
    var name2 = generator.name || "<unnamed flow>";
    var res = function res2() {
      var ctx = this;
      var args = arguments;
      var runId = ++generatorId;
      var gen = action(name2 + " - runid: " + runId + " - init", generator).apply(ctx, args);
      var rejector;
      var pendingPromise = void 0;
      var promise = new Promise(function(resolve, reject) {
        var stepId = 0;
        rejector = reject;
        function onFulfilled(res3) {
          pendingPromise = void 0;
          var ret;
          try {
            ret = action(name2 + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }
        function onRejected(err) {
          pendingPromise = void 0;
          var ret;
          try {
            ret = action(name2 + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }
        function next(ret) {
          if (isFunction(ret == null ? void 0 : ret.then)) {
            ret.then(next, reject);
            return;
          }
          if (ret.done)
            return resolve(ret.value);
          pendingPromise = Promise.resolve(ret.value);
          return pendingPromise.then(onFulfilled, onRejected);
        }
        onFulfilled(void 0);
      });
      promise.cancel = action(name2 + " - runid: " + runId + " - cancel", function() {
        try {
          if (pendingPromise)
            cancelPromise(pendingPromise);
          var _res = gen["return"](void 0);
          var yieldedPromise = Promise.resolve(_res.value);
          yieldedPromise.then(noop, noop);
          cancelPromise(yieldedPromise);
          rejector(new FlowCancellationError());
        } catch (e) {
          rejector(e);
        }
      });
      return promise;
    };
    res.isMobXFlow = true;
    return res;
  }, flowAnnotation);
  flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
  function cancelPromise(promise) {
    if (isFunction(promise.cancel))
      promise.cancel();
  }
  function flowResult(result) {
    return result;
  }
  function isFlow(fn) {
    return (fn == null ? void 0 : fn.isMobXFlow) === true;
  }
  function interceptReads(thing, propOrHandler, handler) {
    var target;
    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
      target = getAdministration(thing);
    } else if (isObservableObject(thing)) {
      if (!isStringish(propOrHandler))
        return die("InterceptReads can only be used with a specific property, not with an object in general");
      target = getAdministration(thing, propOrHandler);
    } else if (true) {
      return die("Expected observable map, object or array as first array");
    }
    if (target.dehancer !== void 0)
      return die("An intercept reader was already established");
    target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
    return function() {
      target.dehancer = void 0;
    };
  }
  function intercept(thing, propOrHandler, handler) {
    if (isFunction(handler))
      return interceptProperty(thing, propOrHandler, handler);
    else
      return interceptInterceptable(thing, propOrHandler);
  }
  function interceptInterceptable(thing, handler) {
    return getAdministration(thing).intercept_(handler);
  }
  function interceptProperty(thing, property, handler) {
    return getAdministration(thing, property).intercept_(handler);
  }
  function _isComputed(value, property) {
    if (property === void 0) {
      return isComputedValue(value);
    }
    if (isObservableObject(value) === false)
      return false;
    if (!value[$mobx].values_.has(property))
      return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }
  function isComputed(value) {
    if (arguments.length > 1)
      return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
    return _isComputed(value);
  }
  function isComputedProp(value, propName) {
    if (!isStringish(propName))
      return die("isComputed expected a property name as second argument");
    return _isComputed(value, propName);
  }
  function _isObservable(value, property) {
    if (!value)
      return false;
    if (property !== void 0) {
      if (isObservableMap(value) || isObservableArray(value))
        return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
      if (isObservableObject(value)) {
        return value[$mobx].values_.has(property);
      }
      return false;
    }
    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
  }
  function isObservable(value) {
    if (arguments.length !== 1)
      die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
    return _isObservable(value);
  }
  function isObservableProp(value, propName) {
    if (!isStringish(propName))
      return die("expected a property name as second argument");
    return _isObservable(value, propName);
  }
  function keys(obj) {
    if (isObservableObject(obj)) {
      return obj[$mobx].keys_();
    }
    if (isObservableMap(obj) || isObservableSet(obj)) {
      return Array.from(obj.keys());
    }
    if (isObservableArray(obj)) {
      return obj.map(function(_14, index) {
        return index;
      });
    }
    die(5);
  }
  function values(obj) {
    if (isObservableObject(obj)) {
      return keys(obj).map(function(key) {
        return obj[key];
      });
    }
    if (isObservableMap(obj)) {
      return keys(obj).map(function(key) {
        return obj.get(key);
      });
    }
    if (isObservableSet(obj)) {
      return Array.from(obj.values());
    }
    if (isObservableArray(obj)) {
      return obj.slice();
    }
    die(6);
  }
  function entries(obj) {
    if (isObservableObject(obj)) {
      return keys(obj).map(function(key) {
        return [key, obj[key]];
      });
    }
    if (isObservableMap(obj)) {
      return keys(obj).map(function(key) {
        return [key, obj.get(key)];
      });
    }
    if (isObservableSet(obj)) {
      return Array.from(obj.entries());
    }
    if (isObservableArray(obj)) {
      return obj.map(function(key, index) {
        return [index, key];
      });
    }
    die(7);
  }
  function set2(obj, key, value) {
    if (arguments.length === 2 && !isObservableSet(obj)) {
      startBatch();
      var _values = key;
      try {
        for (var _key in _values) {
          set2(obj, _key, _values[_key]);
        }
      } finally {
        endBatch();
      }
      return;
    }
    if (isObservableObject(obj)) {
      obj[$mobx].set_(key, value);
    } else if (isObservableMap(obj)) {
      obj.set(key, value);
    } else if (isObservableSet(obj)) {
      obj.add(key);
    } else if (isObservableArray(obj)) {
      if (typeof key !== "number")
        key = parseInt(key, 10);
      if (key < 0)
        die("Invalid index: '" + key + "'");
      startBatch();
      if (key >= obj.length)
        obj.length = key + 1;
      obj[key] = value;
      endBatch();
    } else
      die(8);
  }
  function remove(obj, key) {
    if (isObservableObject(obj)) {
      obj[$mobx].delete_(key);
    } else if (isObservableMap(obj)) {
      obj["delete"](key);
    } else if (isObservableSet(obj)) {
      obj["delete"](key);
    } else if (isObservableArray(obj)) {
      if (typeof key !== "number")
        key = parseInt(key, 10);
      obj.splice(key, 1);
    } else {
      die(9);
    }
  }
  function has(obj, key) {
    if (isObservableObject(obj)) {
      return obj[$mobx].has_(key);
    } else if (isObservableMap(obj)) {
      return obj.has(key);
    } else if (isObservableSet(obj)) {
      return obj.has(key);
    } else if (isObservableArray(obj)) {
      return key >= 0 && key < obj.length;
    }
    die(10);
  }
  function get(obj, key) {
    if (!has(obj, key))
      return void 0;
    if (isObservableObject(obj)) {
      return obj[$mobx].get_(key);
    } else if (isObservableMap(obj)) {
      return obj.get(key);
    } else if (isObservableArray(obj)) {
      return obj[key];
    }
    die(11);
  }
  function apiDefineProperty(obj, key, descriptor) {
    if (isObservableObject(obj)) {
      return obj[$mobx].defineProperty_(key, descriptor);
    }
    die(39);
  }
  function apiOwnKeys(obj) {
    if (isObservableObject(obj)) {
      return obj[$mobx].ownKeys_();
    }
    die(38);
  }
  function observe(thing, propOrCb, cbOrFire, fireImmediately) {
    if (isFunction(cbOrFire))
      return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else
      return observeObservable(thing, propOrCb, cbOrFire);
  }
  function observeObservable(thing, listener, fireImmediately) {
    return getAdministration(thing).observe_(listener, fireImmediately);
  }
  function observeObservableProperty(thing, property, listener, fireImmediately) {
    return getAdministration(thing, property).observe_(listener, fireImmediately);
  }
  function cache(map2, key, value) {
    map2.set(key, value);
    return value;
  }
  function toJSHelper(source, __alreadySeen) {
    if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source))
      return source;
    if (isObservableValue(source) || isComputedValue(source))
      return toJSHelper(source.get(), __alreadySeen);
    if (__alreadySeen.has(source)) {
      return __alreadySeen.get(source);
    }
    if (isObservableArray(source)) {
      var res = cache(__alreadySeen, source, new Array(source.length));
      source.forEach(function(value, idx) {
        res[idx] = toJSHelper(value, __alreadySeen);
      });
      return res;
    }
    if (isObservableSet(source)) {
      var _res = cache(__alreadySeen, source, new Set());
      source.forEach(function(value) {
        _res.add(toJSHelper(value, __alreadySeen));
      });
      return _res;
    }
    if (isObservableMap(source)) {
      var _res2 = cache(__alreadySeen, source, new Map());
      source.forEach(function(value, key) {
        _res2.set(key, toJSHelper(value, __alreadySeen));
      });
      return _res2;
    } else {
      var _res3 = cache(__alreadySeen, source, {});
      apiOwnKeys(source).forEach(function(key) {
        if (objectPrototype.propertyIsEnumerable.call(source, key)) {
          _res3[key] = toJSHelper(source[key], __alreadySeen);
        }
      });
      return _res3;
    }
  }
  function toJS(source, options) {
    if (options)
      die("toJS no longer supports options");
    return toJSHelper(source, new Map());
  }
  function trace() {
    if (false)
      die("trace() is not available in production builds");
    var enterBreakPoint = false;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[args.length - 1] === "boolean")
      enterBreakPoint = args.pop();
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    }
    if (derivation.isTracing_ === TraceMode.NONE) {
      console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
    }
    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
  }
  function getAtomFromArgs(args) {
    switch (args.length) {
      case 0:
        return globalState.trackingDerivation;
      case 1:
        return getAtom(args[0]);
      case 2:
        return getAtom(args[0], args[1]);
    }
  }
  function transaction(action2, thisArg) {
    if (thisArg === void 0) {
      thisArg = void 0;
    }
    startBatch();
    try {
      return action2.apply(thisArg);
    } finally {
      endBatch();
    }
  }
  function when(predicate, arg1, arg2) {
    if (arguments.length === 1 || arg1 && typeof arg1 === "object")
      return whenPromise(predicate, arg1);
    return _when(predicate, arg1, arg2 || {});
  }
  function _when(predicate, effect, opts) {
    var timeoutHandle;
    if (typeof opts.timeout === "number") {
      var error = new Error("WHEN_TIMEOUT");
      timeoutHandle = setTimeout(function() {
        if (!disposer[$mobx].isDisposed_) {
          disposer();
          if (opts.onError)
            opts.onError(error);
          else
            throw error;
        }
      }, opts.timeout);
    }
    opts.name = true ? opts.name || "When@" + getNextId() : "When";
    var effectAction = createAction(true ? opts.name + "-effect" : "When-effect", effect);
    var disposer = autorun(function(r6) {
      var cond = allowStateChanges(false, predicate);
      if (cond) {
        r6.dispose();
        if (timeoutHandle)
          clearTimeout(timeoutHandle);
        effectAction();
      }
    }, opts);
    return disposer;
  }
  function whenPromise(predicate, opts) {
    if (opts && opts.onError)
      return die("the options 'onError' and 'promise' cannot be combined");
    var cancel;
    var res = new Promise(function(resolve, reject) {
      var disposer = _when(predicate, resolve, _extends({}, opts, {
        onError: reject
      }));
      cancel = function cancel2() {
        disposer();
        reject("WHEN_CANCELLED");
      };
    });
    res.cancel = cancel;
    return res;
  }
  function getAdm(target) {
    return target[$mobx];
  }
  var objectProxyTraps = {
    has: function has2(target, name2) {
      if (globalState.trackingDerivation)
        warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
      return getAdm(target).has_(name2);
    },
    get: function get2(target, name2) {
      return getAdm(target).get_(name2);
    },
    set: function set3(target, name2, value) {
      var _getAdm$set_;
      if (!isStringish(name2))
        return false;
      if (!getAdm(target).values_.has(name2)) {
        warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
      }
      return (_getAdm$set_ = getAdm(target).set_(name2, value, true)) != null ? _getAdm$set_ : true;
    },
    deleteProperty: function deleteProperty(target, name2) {
      var _getAdm$delete_;
      if (true) {
        warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
      }
      if (!isStringish(name2))
        return false;
      return (_getAdm$delete_ = getAdm(target).delete_(name2, true)) != null ? _getAdm$delete_ : true;
    },
    defineProperty: function defineProperty2(target, name2, descriptor) {
      var _getAdm$definePropert;
      if (true) {
        warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
      }
      return (_getAdm$definePropert = getAdm(target).defineProperty_(name2, descriptor)) != null ? _getAdm$definePropert : true;
    },
    ownKeys: function ownKeys2(target) {
      if (globalState.trackingDerivation)
        warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
      return getAdm(target).ownKeys_();
    },
    preventExtensions: function preventExtensions(target) {
      die(13);
    }
  };
  function asDynamicObservableObject(target, options) {
    var _target$$mobx, _target$$mobx$proxy_;
    assertProxies();
    target = asObservableObject(target, options);
    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
  }
  function hasInterceptors(interceptable) {
    return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
  }
  function registerInterceptor(interceptable, handler) {
    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
    interceptors.push(handler);
    return once(function() {
      var idx = interceptors.indexOf(handler);
      if (idx !== -1)
        interceptors.splice(idx, 1);
    });
  }
  function interceptChange(interceptable, change) {
    var prevU = untrackedStart();
    try {
      var interceptors = [].concat(interceptable.interceptors_ || []);
      for (var i = 0, l = interceptors.length; i < l; i++) {
        change = interceptors[i](change);
        if (change && !change.type)
          die(14);
        if (!change)
          break;
      }
      return change;
    } finally {
      untrackedEnd(prevU);
    }
  }
  function hasListeners(listenable) {
    return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
  }
  function registerListener(listenable, handler) {
    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
    listeners.push(handler);
    return once(function() {
      var idx = listeners.indexOf(handler);
      if (idx !== -1)
        listeners.splice(idx, 1);
    });
  }
  function notifyListeners(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners_;
    if (!listeners)
      return;
    listeners = listeners.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i](change);
    }
    untrackedEnd(prevU);
  }
  function makeObservable(target, annotations, options) {
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      var _annotations;
      (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
      ownKeys(annotations).forEach(function(key) {
        return adm.make_(key, annotations[key]);
      });
    } finally {
      endBatch();
    }
    return target;
  }
  var keysSymbol = /* @__PURE__ */ Symbol("mobx-keys");
  function makeAutoObservable(target, overrides, options) {
    if (true) {
      if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target)))
        die("'makeAutoObservable' can only be used for classes that don't have a superclass");
      if (isObservableObject(target))
        die("makeAutoObservable can only be used on objects not already made observable");
    }
    if (isPlainObject(target)) {
      return extendObservable(target, target, overrides, options);
    }
    var adm = asObservableObject(target, options)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys2 = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys2["delete"]("constructor");
      keys2["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys2);
    }
    startBatch();
    try {
      target[keysSymbol].forEach(function(key) {
        return adm.make_(key, !overrides ? true : key in overrides ? overrides[key] : true);
      });
    } finally {
      endBatch();
    }
    return target;
  }
  var SPLICE = "splice";
  var UPDATE = "update";
  var MAX_SPLICE_SIZE = 1e4;
  var arrayTraps = {
    get: function get3(target, name2) {
      var adm = target[$mobx];
      if (name2 === $mobx)
        return adm;
      if (name2 === "length")
        return adm.getArrayLength_();
      if (typeof name2 === "string" && !isNaN(name2)) {
        return adm.get_(parseInt(name2));
      }
      if (hasProp(arrayExtensions, name2)) {
        return arrayExtensions[name2];
      }
      return target[name2];
    },
    set: function set4(target, name2, value) {
      var adm = target[$mobx];
      if (name2 === "length") {
        adm.setArrayLength_(value);
      }
      if (typeof name2 === "symbol" || isNaN(name2)) {
        target[name2] = value;
      } else {
        adm.set_(parseInt(name2), value);
      }
      return true;
    },
    preventExtensions: function preventExtensions2() {
      die(15);
    }
  };
  var ObservableArrayAdministration = /* @__PURE__ */ function() {
    function ObservableArrayAdministration2(name2, enhancer, owned_, legacyMode_) {
      if (name2 === void 0) {
        name2 = true ? "ObservableArray@" + getNextId() : "ObservableArray";
      }
      this.owned_ = void 0;
      this.legacyMode_ = void 0;
      this.atom_ = void 0;
      this.values_ = [];
      this.interceptors_ = void 0;
      this.changeListeners_ = void 0;
      this.enhancer_ = void 0;
      this.dehancer = void 0;
      this.proxy_ = void 0;
      this.lastKnownLength_ = 0;
      this.owned_ = owned_;
      this.legacyMode_ = legacyMode_;
      this.atom_ = new Atom(name2);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, true ? name2 + "[..]" : "ObservableArray[..]");
      };
    }
    var _proto = ObservableArrayAdministration2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0)
        return this.dehancer(value);
      return value;
    };
    _proto.dehanceValues_ = function dehanceValues_(values2) {
      if (this.dehancer !== void 0 && values2.length > 0)
        return values2.map(this.dehancer);
      return values2;
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === void 0) {
        fireImmediately = false;
      }
      if (fireImmediately) {
        listener({
          observableKind: "array",
          object: this.proxy_,
          debugObjectName: this.atom_.name_,
          type: "splice",
          index: 0,
          added: this.values_.slice(),
          addedCount: this.values_.length,
          removed: [],
          removedCount: 0
        });
      }
      return registerListener(this, listener);
    };
    _proto.getArrayLength_ = function getArrayLength_() {
      this.atom_.reportObserved();
      return this.values_.length;
    };
    _proto.setArrayLength_ = function setArrayLength_(newLength) {
      if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0)
        die("Out of range: " + newLength);
      var currentLength = this.values_.length;
      if (newLength === currentLength)
        return;
      else if (newLength > currentLength) {
        var newItems = new Array(newLength - currentLength);
        for (var i = 0; i < newLength - currentLength; i++) {
          newItems[i] = void 0;
        }
        this.spliceWithArray_(currentLength, 0, newItems);
      } else
        this.spliceWithArray_(newLength, currentLength - newLength);
    };
    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
      if (oldLength !== this.lastKnownLength_)
        die(16);
      this.lastKnownLength_ += delta;
      if (this.legacyMode_ && delta > 0)
        reserveArrayBuffer(oldLength + delta + 1);
    };
    _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      var length = this.values_.length;
      if (index === void 0)
        index = 0;
      else if (index > length)
        index = length;
      else if (index < 0)
        index = Math.max(0, length + index);
      if (arguments.length === 1)
        deleteCount = length - index;
      else if (deleteCount === void 0 || deleteCount === null)
        deleteCount = 0;
      else
        deleteCount = Math.max(0, Math.min(deleteCount, length - index));
      if (newItems === void 0)
        newItems = EMPTY_ARRAY;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_,
          type: SPLICE,
          index,
          removedCount: deleteCount,
          added: newItems
        });
        if (!change)
          return EMPTY_ARRAY;
        deleteCount = change.removedCount;
        newItems = change.added;
      }
      newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
        return _this.enhancer_(v, void 0);
      });
      if (this.legacyMode_ || true) {
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength_(length, lengthDelta);
      }
      var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
      if (deleteCount !== 0 || newItems.length !== 0)
        this.notifyArraySplice_(index, newItems, res);
      return this.dehanceValues_(res);
    };
    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
      if (newItems.length < MAX_SPLICE_SIZE) {
        var _this$values_;
        return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
      } else {
        var res = this.values_.slice(index, index + deleteCount);
        var oldItems = this.values_.slice(index + deleteCount);
        this.values_.length = index + newItems.length - deleteCount;
        for (var i = 0; i < newItems.length; i++) {
          this.values_[index + i] = newItems[i];
        }
        for (var _i2 = 0; _i2 < oldItems.length; _i2++) {
          this.values_[index + newItems.length + _i2] = oldItems[_i2];
        }
        return res;
      }
    };
    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        type: UPDATE,
        debugObjectName: this.atom_.name_,
        index,
        newValue,
        oldValue
      } : null;
      if (notifySpy)
        spyReportStart(change);
      this.atom_.reportChanged();
      if (notify)
        notifyListeners(this, change);
      if (notifySpy)
        spyReportEnd();
    };
    _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: SPLICE,
        index,
        removed,
        added,
        removedCount: removed.length,
        addedCount: added.length
      } : null;
      if (notifySpy)
        spyReportStart(change);
      this.atom_.reportChanged();
      if (notify)
        notifyListeners(this, change);
      if (notifySpy)
        spyReportEnd();
    };
    _proto.get_ = function get_(index) {
      if (index < this.values_.length) {
        this.atom_.reportObserved();
        return this.dehanceValue_(this.values_[index]);
      }
      console.warn(true ? "[mobx] Out of bounds read: " + index : "[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
    };
    _proto.set_ = function set_(index, newValue) {
      var values2 = this.values_;
      if (index < values2.length) {
        checkIfStateModificationsAreAllowed(this.atom_);
        var oldValue = values2[index];
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: UPDATE,
            object: this.proxy_,
            index,
            newValue
          });
          if (!change)
            return;
          newValue = change.newValue;
        }
        newValue = this.enhancer_(newValue, oldValue);
        var changed = newValue !== oldValue;
        if (changed) {
          values2[index] = newValue;
          this.notifyArrayChildUpdate_(index, newValue, oldValue);
        }
      } else if (index === values2.length) {
        this.spliceWithArray_(index, 0, [newValue]);
      } else {
        die(17, index, values2.length);
      }
    };
    return ObservableArrayAdministration2;
  }();
  function createObservableArray(initialValues, enhancer, name2, owned) {
    if (name2 === void 0) {
      name2 = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    assertProxies();
    var adm = new ObservableArrayAdministration(name2, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);
      adm.spliceWithArray_(0, 0, initialValues);
      allowStateChangesEnd(prev);
    }
    return proxy;
  }
  var arrayExtensions = {
    clear: function clear() {
      return this.splice(0);
    },
    replace: function replace(newItems) {
      var adm = this[$mobx];
      return adm.spliceWithArray_(0, adm.values_.length, newItems);
    },
    toJSON: function toJSON() {
      return this.slice();
    },
    splice: function splice(index, deleteCount) {
      for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        newItems[_key - 2] = arguments[_key];
      }
      var adm = this[$mobx];
      switch (arguments.length) {
        case 0:
          return [];
        case 1:
          return adm.spliceWithArray_(index);
        case 2:
          return adm.spliceWithArray_(index, deleteCount);
      }
      return adm.spliceWithArray_(index, deleteCount, newItems);
    },
    spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
      return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
    },
    push: function push() {
      var adm = this[$mobx];
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      adm.spliceWithArray_(adm.values_.length, 0, items);
      return adm.values_.length;
    },
    pop: function pop() {
      return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
    },
    shift: function shift() {
      return this.splice(0, 1)[0];
    },
    unshift: function unshift() {
      var adm = this[$mobx];
      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        items[_key3] = arguments[_key3];
      }
      adm.spliceWithArray_(0, 0, items);
      return adm.values_.length;
    },
    reverse: function reverse() {
      if (globalState.trackingDerivation) {
        die(37, "reverse");
      }
      this.replace(this.slice().reverse());
      return this;
    },
    sort: function sort() {
      if (globalState.trackingDerivation) {
        die(37, "sort");
      }
      var copy = this.slice();
      copy.sort.apply(copy, arguments);
      this.replace(copy);
      return this;
    },
    remove: function remove2(value) {
      var adm = this[$mobx];
      var idx = adm.dehanceValues_(adm.values_).indexOf(value);
      if (idx > -1) {
        this.splice(idx, 1);
        return true;
      }
      return false;
    }
  };
  addArrayExtension("concat", simpleFunc);
  addArrayExtension("flat", simpleFunc);
  addArrayExtension("includes", simpleFunc);
  addArrayExtension("indexOf", simpleFunc);
  addArrayExtension("join", simpleFunc);
  addArrayExtension("lastIndexOf", simpleFunc);
  addArrayExtension("slice", simpleFunc);
  addArrayExtension("toString", simpleFunc);
  addArrayExtension("toLocaleString", simpleFunc);
  addArrayExtension("every", mapLikeFunc);
  addArrayExtension("filter", mapLikeFunc);
  addArrayExtension("find", mapLikeFunc);
  addArrayExtension("findIndex", mapLikeFunc);
  addArrayExtension("flatMap", mapLikeFunc);
  addArrayExtension("forEach", mapLikeFunc);
  addArrayExtension("map", mapLikeFunc);
  addArrayExtension("some", mapLikeFunc);
  addArrayExtension("reduce", reduceLikeFunc);
  addArrayExtension("reduceRight", reduceLikeFunc);
  function addArrayExtension(funcName, funcFactory) {
    if (typeof Array.prototype[funcName] === "function") {
      arrayExtensions[funcName] = funcFactory(funcName);
    }
  }
  function simpleFunc(funcName) {
    return function() {
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  }
  function mapLikeFunc(funcName) {
    return function(callback, thisArg) {
      var _this2 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName](function(element, index) {
        return callback.call(thisArg, element, index, _this2);
      });
    };
  }
  function reduceLikeFunc(funcName) {
    return function() {
      var _this3 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      var callback = arguments[0];
      arguments[0] = function(accumulator, currentValue, index) {
        return callback(accumulator, currentValue, index, _this3);
      };
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  }
  var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
  function isObservableArray(thing) {
    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
  }
  var _Symbol$iterator;
  var _Symbol$toStringTag;
  var ObservableMapMarker = {};
  var ADD = "add";
  var DELETE = "delete";
  _Symbol$iterator = Symbol.iterator;
  _Symbol$toStringTag = Symbol.toStringTag;
  var ObservableMap = /* @__PURE__ */ function() {
    function ObservableMap2(initialData, enhancer_, name_) {
      if (enhancer_ === void 0) {
        enhancer_ = deepEnhancer;
      }
      if (name_ === void 0) {
        name_ = true ? "ObservableMap@" + getNextId() : "ObservableMap";
      }
      this.enhancer_ = void 0;
      this.name_ = void 0;
      this[$mobx] = ObservableMapMarker;
      this.data_ = void 0;
      this.hasMap_ = void 0;
      this.keysAtom_ = void 0;
      this.interceptors_ = void 0;
      this.changeListeners_ = void 0;
      this.dehancer = void 0;
      this.enhancer_ = enhancer_;
      this.name_ = name_;
      if (!isFunction(Map)) {
        die(18);
      }
      this.keysAtom_ = createAtom(true ? this.name_ + ".keys()" : "ObservableMap.keys()");
      this.data_ = new Map();
      this.hasMap_ = new Map();
      this.merge(initialData);
    }
    var _proto = ObservableMap2.prototype;
    _proto.has_ = function has_(key) {
      return this.data_.has(key);
    };
    _proto.has = function has3(key) {
      var _this = this;
      if (!globalState.trackingDerivation)
        return this.has_(key);
      var entry = this.hasMap_.get(key);
      if (!entry) {
        var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
        this.hasMap_.set(key, newEntry);
        onBecomeUnobserved(newEntry, function() {
          return _this.hasMap_["delete"](key);
        });
      }
      return entry.get();
    };
    _proto.set = function set5(key, value) {
      var hasKey = this.has_(key);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: hasKey ? UPDATE : ADD,
          object: this,
          newValue: value,
          name: key
        });
        if (!change)
          return this;
        value = change.newValue;
      }
      if (hasKey) {
        this.updateValue_(key, value);
      } else {
        this.addValue_(key, value);
      }
      return this;
    };
    _proto["delete"] = function _delete(key) {
      var _this2 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          name: key
        });
        if (!change)
          return false;
      }
      if (this.has_(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: this.data_.get(key).value_,
          name: key
        } : null;
        if (notifySpy)
          spyReportStart(_change);
        transaction(function() {
          var _this2$hasMap_$get;
          _this2.keysAtom_.reportChanged();
          (_this2$hasMap_$get = _this2.hasMap_.get(key)) == null ? void 0 : _this2$hasMap_$get.setNewValue_(false);
          var observable2 = _this2.data_.get(key);
          observable2.setNewValue_(void 0);
          _this2.data_["delete"](key);
        });
        if (notify)
          notifyListeners(this, _change);
        if (notifySpy)
          spyReportEnd();
        return true;
      }
      return false;
    };
    _proto.updateValue_ = function updateValue_(key, newValue) {
      var observable2 = this.data_.get(key);
      newValue = observable2.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: UPDATE,
          object: this,
          oldValue: observable2.value_,
          name: key,
          newValue
        } : null;
        if (notifySpy)
          spyReportStart(change);
        observable2.setNewValue_(newValue);
        if (notify)
          notifyListeners(this, change);
        if (notifySpy)
          spyReportEnd();
      }
    };
    _proto.addValue_ = function addValue_(key, newValue) {
      var _this3 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      transaction(function() {
        var _this3$hasMap_$get;
        var observable2 = new ObservableValue(newValue, _this3.enhancer_, true ? _this3.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
        _this3.data_.set(key, observable2);
        newValue = observable2.value_;
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(true);
        _this3.keysAtom_.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        name: key,
        newValue
      } : null;
      if (notifySpy)
        spyReportStart(change);
      if (notify)
        notifyListeners(this, change);
      if (notifySpy)
        spyReportEnd();
    };
    _proto.get = function get4(key) {
      if (this.has(key))
        return this.dehanceValue_(this.data_.get(key).get());
      return this.dehanceValue_(void 0);
    };
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.keys = function keys2() {
      this.keysAtom_.reportObserved();
      return this.data_.keys();
    };
    _proto.values = function values2() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function next() {
          var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
          return {
            done,
            value: done ? void 0 : self2.get(value)
          };
        }
      });
    };
    _proto.entries = function entries2() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function next() {
          var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
          return {
            done,
            value: done ? void 0 : [value, self2.get(value)]
          };
        }
      });
    };
    _proto[_Symbol$iterator] = function() {
      return this.entries();
    };
    _proto.forEach = function forEach(callback, thisArg) {
      for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
        var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
        callback.call(thisArg, value, key, this);
      }
    };
    _proto.merge = function merge(other) {
      var _this4 = this;
      if (isObservableMap(other)) {
        other = new Map(other);
      }
      transaction(function() {
        if (isPlainObject(other))
          getPlainObjectKeys(other).forEach(function(key) {
            return _this4.set(key, other[key]);
          });
        else if (Array.isArray(other))
          other.forEach(function(_ref) {
            var key = _ref[0], value = _ref[1];
            return _this4.set(key, value);
          });
        else if (isES6Map(other)) {
          if (other.constructor !== Map)
            die(19, other);
          other.forEach(function(value, key) {
            return _this4.set(key, value);
          });
        } else if (other !== null && other !== void 0)
          die(20, other);
      });
      return this;
    };
    _proto.clear = function clear2() {
      var _this5 = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done; ) {
            var key = _step2.value;
            _this5["delete"](key);
          }
        });
      });
    };
    _proto.replace = function replace2(values2) {
      var _this6 = this;
      transaction(function() {
        var replacementMap = convertToMap(values2);
        var orderedData = new Map();
        var keysReportChangedCalled = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
          var key = _step3.value;
          if (!replacementMap.has(key)) {
            var deleted = _this6["delete"](key);
            if (deleted) {
              keysReportChangedCalled = true;
            } else {
              var value = _this6.data_.get(key);
              orderedData.set(key, value);
            }
          }
        }
        for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
          var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
          var keyExisted = _this6.data_.has(_key);
          _this6.set(_key, _value);
          if (_this6.data_.has(_key)) {
            var _value2 = _this6.data_.get(_key);
            orderedData.set(_key, _value2);
            if (!keyExisted) {
              keysReportChangedCalled = true;
            }
          }
        }
        if (!keysReportChangedCalled) {
          if (_this6.data_.size !== orderedData.size) {
            _this6.keysAtom_.reportChanged();
          } else {
            var iter1 = _this6.data_.keys();
            var iter2 = orderedData.keys();
            var next1 = iter1.next();
            var next2 = iter2.next();
            while (!next1.done) {
              if (next1.value !== next2.value) {
                _this6.keysAtom_.reportChanged();
                break;
              }
              next1 = iter1.next();
              next2 = iter2.next();
            }
          }
        }
        _this6.data_ = orderedData;
      });
      return this;
    };
    _proto.toString = function toString2() {
      return "[object ObservableMap]";
    };
    _proto.toJSON = function toJSON2() {
      return Array.from(this);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === true)
        die("`observe` doesn't support fireImmediately=true in combination with maps.");
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _createClass(ObservableMap2, [{
      key: "size",
      get: function get4() {
        this.keysAtom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag,
      get: function get4() {
        return "Map";
      }
    }]);
    return ObservableMap2;
  }();
  var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
  function convertToMap(dataStructure) {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
      return dataStructure;
    } else if (Array.isArray(dataStructure)) {
      return new Map(dataStructure);
    } else if (isPlainObject(dataStructure)) {
      var map2 = new Map();
      for (var key in dataStructure) {
        map2.set(key, dataStructure[key]);
      }
      return map2;
    } else {
      return die(21, dataStructure);
    }
  }
  var _Symbol$iterator$1;
  var _Symbol$toStringTag$1;
  var ObservableSetMarker = {};
  _Symbol$iterator$1 = Symbol.iterator;
  _Symbol$toStringTag$1 = Symbol.toStringTag;
  var ObservableSet = /* @__PURE__ */ function() {
    function ObservableSet2(initialData, enhancer, name_) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name_ === void 0) {
        name_ = true ? "ObservableSet@" + getNextId() : "ObservableSet";
      }
      this.name_ = void 0;
      this[$mobx] = ObservableSetMarker;
      this.data_ = new Set();
      this.atom_ = void 0;
      this.changeListeners_ = void 0;
      this.interceptors_ = void 0;
      this.dehancer = void 0;
      this.enhancer_ = void 0;
      this.name_ = name_;
      if (!isFunction(Set)) {
        die(22);
      }
      this.atom_ = createAtom(this.name_);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, name_);
      };
      if (initialData) {
        this.replace(initialData);
      }
    }
    var _proto = ObservableSet2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.clear = function clear2() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
            var value = _step.value;
            _this["delete"](value);
          }
        });
      });
    };
    _proto.forEach = function forEach(callbackFn, thisArg) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
        var value = _step2.value;
        callbackFn.call(thisArg, value, value, this);
      }
    };
    _proto.add = function add(value) {
      var _this2 = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: ADD,
          object: this,
          newValue: value
        });
        if (!change)
          return this;
      }
      if (!this.has(value)) {
        transaction(function() {
          _this2.data_.add(_this2.enhancer_(value, void 0));
          _this2.atom_.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: ADD,
          object: this,
          newValue: value
        } : null;
        if (notifySpy && true)
          spyReportStart(_change);
        if (notify)
          notifyListeners(this, _change);
        if (notifySpy && true)
          spyReportEnd();
      }
      return this;
    };
    _proto["delete"] = function _delete(value) {
      var _this3 = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          oldValue: value
        });
        if (!change)
          return false;
      }
      if (this.has(value)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change2 = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: value
        } : null;
        if (notifySpy && true)
          spyReportStart(_change2);
        transaction(function() {
          _this3.atom_.reportChanged();
          _this3.data_["delete"](value);
        });
        if (notify)
          notifyListeners(this, _change2);
        if (notifySpy && true)
          spyReportEnd();
        return true;
      }
      return false;
    };
    _proto.has = function has3(value) {
      this.atom_.reportObserved();
      return this.data_.has(this.dehanceValue_(value));
    };
    _proto.entries = function entries2() {
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      var values2 = Array.from(this.values());
      return makeIterable({
        next: function next() {
          var index = nextIndex;
          nextIndex += 1;
          return index < values2.length ? {
            value: [keys2[index], values2[index]],
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.keys = function keys2() {
      return this.values();
    };
    _proto.values = function values2() {
      this.atom_.reportObserved();
      var self2 = this;
      var nextIndex = 0;
      var observableValues = Array.from(this.data_.values());
      return makeIterable({
        next: function next() {
          return nextIndex < observableValues.length ? {
            value: self2.dehanceValue_(observableValues[nextIndex++]),
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.replace = function replace2(other) {
      var _this4 = this;
      if (isObservableSet(other)) {
        other = new Set(other);
      }
      transaction(function() {
        if (Array.isArray(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (isES6Set(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (other !== null && other !== void 0) {
          die("Cannot initialize set from " + other);
        }
      });
      return this;
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === true)
        die("`observe` doesn't support fireImmediately=true in combination with sets.");
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.toJSON = function toJSON2() {
      return Array.from(this);
    };
    _proto.toString = function toString2() {
      return "[object ObservableSet]";
    };
    _proto[_Symbol$iterator$1] = function() {
      return this.values();
    };
    _createClass(ObservableSet2, [{
      key: "size",
      get: function get4() {
        this.atom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag$1,
      get: function get4() {
        return "Set";
      }
    }]);
    return ObservableSet2;
  }();
  var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
  var descriptorCache = /* @__PURE__ */ Object.create(null);
  var REMOVE = "remove";
  var ObservableObjectAdministration = /* @__PURE__ */ function() {
    function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
      if (values_ === void 0) {
        values_ = new Map();
      }
      if (defaultAnnotation_ === void 0) {
        defaultAnnotation_ = autoAnnotation;
      }
      this.target_ = void 0;
      this.values_ = void 0;
      this.name_ = void 0;
      this.defaultAnnotation_ = void 0;
      this.keysAtom_ = void 0;
      this.changeListeners_ = void 0;
      this.interceptors_ = void 0;
      this.proxy_ = void 0;
      this.isPlainObject_ = void 0;
      this.appliedAnnotations_ = void 0;
      this.pendingKeys_ = void 0;
      this.target_ = target_;
      this.values_ = values_;
      this.name_ = name_;
      this.defaultAnnotation_ = defaultAnnotation_;
      this.keysAtom_ = new Atom(true ? this.name_ + ".keys" : "ObservableObject.keys");
      this.isPlainObject_ = isPlainObject(this.target_);
      if (!isAnnotation(this.defaultAnnotation_)) {
        die("defaultAnnotation must be valid annotation");
      }
      if (true) {
        this.appliedAnnotations_ = {};
      }
    }
    var _proto = ObservableObjectAdministration2.prototype;
    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
      return this.values_.get(key).get();
    };
    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
      var observable2 = this.values_.get(key);
      if (observable2 instanceof ComputedValue) {
        observable2.set(newValue);
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_ || this.target_,
          name: key,
          newValue
        });
        if (!change)
          return null;
        newValue = change.newValue;
      }
      newValue = observable2.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var _change = notify || notifySpy ? {
          type: UPDATE,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          oldValue: observable2.value_,
          name: key,
          newValue
        } : null;
        if (notifySpy)
          spyReportStart(_change);
        observable2.setNewValue_(newValue);
        if (notify)
          notifyListeners(this, _change);
        if (notifySpy)
          spyReportEnd();
      }
      return true;
    };
    _proto.get_ = function get_(key) {
      if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
        this.has_(key);
      }
      return this.target_[key];
    };
    _proto.set_ = function set_(key, value, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (hasProp(this.target_, key)) {
        if (this.values_.has(key)) {
          return this.setObservablePropValue_(key, value);
        } else if (proxyTrap) {
          return Reflect.set(this.target_, key, value);
        } else {
          this.target_[key] = value;
          return true;
        }
      } else {
        return this.extend_(key, {
          value,
          enumerable: true,
          writable: true,
          configurable: true
        }, this.defaultAnnotation_, proxyTrap);
      }
    };
    _proto.has_ = function has_(key) {
      if (!globalState.trackingDerivation) {
        return key in this.target_;
      }
      this.pendingKeys_ || (this.pendingKeys_ = new Map());
      var entry = this.pendingKeys_.get(key);
      if (!entry) {
        entry = new ObservableValue(key in this.target_, referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
        this.pendingKeys_.set(key, entry);
      }
      return entry.get();
    };
    _proto.make_ = function make_2(key, annotation) {
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return;
      }
      assertAnnotable(this, annotation, key);
      if (!(key in this.target_)) {
        var _this$target_$storedA;
        if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) == null ? void 0 : _this$target_$storedA[key]) {
          return;
        } else {
          die(1, annotation.annotationType_, this.name_ + "." + key.toString());
        }
      }
      var source = this.target_;
      while (source && source !== objectPrototype) {
        var descriptor = getDescriptor(source, key);
        if (descriptor) {
          var outcome = annotation.make_(this, key, descriptor, source);
          if (outcome === 0)
            return;
          if (outcome === 1)
            break;
        }
        source = Object.getPrototypeOf(source);
      }
      recordAnnotationApplied(this, annotation, key);
    };
    _proto.extend_ = function extend_2(key, descriptor, annotation, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return this.defineProperty_(key, descriptor, proxyTrap);
      }
      assertAnnotable(this, annotation, key);
      var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
      if (outcome) {
        recordAnnotationApplied(this, annotation, key);
      }
      return outcome;
    };
    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: descriptor.value
          });
          if (!change)
            return null;
          var newValue = change.newValue;
          if (descriptor.value !== newValue) {
            descriptor = _extends({}, descriptor, {
              value: newValue
            });
          }
        }
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.notifyPropertyAddition_(key, descriptor.value);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: value
          });
          if (!change)
            return null;
          value = change.newValue;
        }
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: true,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        var observable2 = new ObservableValue(value, enhancer, true ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
        this.values_.set(key, observable2);
        this.notifyPropertyAddition_(key, observable2.value_);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: void 0
          });
          if (!change)
            return null;
        }
        options.name || (options.name = true ? this.name_ + "." + key.toString() : "ObservableObject.key");
        options.context = this.proxy_ || this.target_;
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: false,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.values_.set(key, new ComputedValue(options));
        this.notifyPropertyAddition_(key, void 0);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.delete_ = function delete_(key, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (!hasProp(this.target_, key)) {
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: REMOVE
        });
        if (!change)
          return null;
      }
      try {
        var _this$pendingKeys_, _this$pendingKeys_$ge;
        startBatch();
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var observable2 = this.values_.get(key);
        var value = void 0;
        if (!observable2 && (notify || notifySpy)) {
          var _getDescriptor2;
          value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
        }
        if (proxyTrap) {
          if (!Reflect.deleteProperty(this.target_, key)) {
            return false;
          }
        } else {
          delete this.target_[key];
        }
        if (true) {
          delete this.appliedAnnotations_[key];
        }
        if (observable2) {
          this.values_["delete"](key);
          if (observable2 instanceof ObservableValue) {
            value = observable2.value_;
          }
          propagateChanged(observable2);
        }
        this.keysAtom_.reportChanged();
        (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
        if (notify || notifySpy) {
          var _change2 = {
            type: REMOVE,
            observableKind: "object",
            object: this.proxy_ || this.target_,
            debugObjectName: this.name_,
            oldValue: value,
            name: key
          };
          if (notifySpy)
            spyReportStart(_change2);
          if (notify)
            notifyListeners(this, _change2);
          if (notifySpy)
            spyReportEnd();
        }
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.observe_ = function observe_(callback, fireImmediately) {
      if (fireImmediately === true)
        die("`observe` doesn't support the fire immediately property for observable objects.");
      return registerListener(this, callback);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
      var _this$pendingKeys_2, _this$pendingKeys_2$g;
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      if (notify || notifySpy) {
        var change = notify || notifySpy ? {
          type: ADD,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          name: key,
          newValue: value
        } : null;
        if (notifySpy)
          spyReportStart(change);
        if (notify)
          notifyListeners(this, change);
        if (notifySpy)
          spyReportEnd();
      }
      (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
      this.keysAtom_.reportChanged();
    };
    _proto.ownKeys_ = function ownKeys_() {
      this.keysAtom_.reportObserved();
      return ownKeys(this.target_);
    };
    _proto.keys_ = function keys_() {
      this.keysAtom_.reportObserved();
      return Object.keys(this.target_);
    };
    return ObservableObjectAdministration2;
  }();
  function asObservableObject(target, options) {
    var _options$name;
    if (options && isObservableObject(target)) {
      die("Options can't be provided for already observable objects.");
    }
    if (hasProp(target, $mobx)) {
      if (!(getAdministration(target) instanceof ObservableObjectAdministration)) {
        die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
      }
      return target;
    }
    if (!Object.isExtensible(target))
      die("Cannot make the designated object observable; it is not extensible");
    var name2 = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : true ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
    var adm = new ObservableObjectAdministration(target, new Map(), String(name2), getAnnotationFromOptions(options));
    addHiddenProp(target, $mobx, adm);
    return target;
  }
  var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
  function getCachedObservablePropDescriptor(key) {
    return descriptorCache[key] || (descriptorCache[key] = {
      get: function get4() {
        return this[$mobx].getObservablePropValue_(key);
      },
      set: function set5(value) {
        return this[$mobx].setObservablePropValue_(key, value);
      }
    });
  }
  function isObservableObject(thing) {
    if (isObject(thing)) {
      return isObservableObjectAdministration(thing[$mobx]);
    }
    return false;
  }
  function recordAnnotationApplied(adm, annotation, key) {
    var _adm$target_$storedAn;
    if (true) {
      adm.appliedAnnotations_[key] = annotation;
    }
    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
  }
  function assertAnnotable(adm, annotation, key) {
    if (!isAnnotation(annotation)) {
      die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
    }
    if (!isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
      var fieldName = adm.name_ + "." + key.toString();
      var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
      var requestedAnnotationType = annotation.annotationType_;
      die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overriden by subclass.");
    }
  }
  var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
  var StubArray = function StubArray2() {
  };
  function inherit(ctor, proto) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ctor.prototype, proto);
    } else if (ctor.prototype.__proto__ !== void 0) {
      ctor.prototype.__proto__ = proto;
    } else {
      ctor.prototype = proto;
    }
  }
  inherit(StubArray, Array.prototype);
  var LegacyObservableArray = /* @__PURE__ */ function(_StubArray) {
    _inheritsLoose(LegacyObservableArray2, _StubArray);
    function LegacyObservableArray2(initialValues, enhancer, name2, owned) {
      var _this;
      if (name2 === void 0) {
        name2 = true ? "ObservableArray@" + getNextId() : "ObservableArray";
      }
      if (owned === void 0) {
        owned = false;
      }
      _this = _StubArray.call(this) || this;
      var adm = new ObservableArrayAdministration(name2, enhancer, owned, true);
      adm.proxy_ = _assertThisInitialized(_this);
      addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
      if (initialValues && initialValues.length) {
        var prev = allowStateChangesStart(true);
        _this.spliceWithArray(0, 0, initialValues);
        allowStateChangesEnd(prev);
      }
      return _this;
    }
    var _proto = LegacyObservableArray2.prototype;
    _proto.concat = function concat() {
      this[$mobx].atom_.reportObserved();
      for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
        arrays[_key] = arguments[_key];
      }
      return Array.prototype.concat.apply(this.slice(), arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      }));
    };
    _proto[Symbol.iterator] = function() {
      var self2 = this;
      var nextIndex = 0;
      return makeIterable({
        next: function next() {
          return nextIndex < self2.length ? {
            value: self2[nextIndex++],
            done: false
          } : {
            done: true,
            value: void 0
          };
        }
      });
    };
    _createClass(LegacyObservableArray2, [{
      key: "length",
      get: function get4() {
        return this[$mobx].getArrayLength_();
      },
      set: function set5(newLength) {
        this[$mobx].setArrayLength_(newLength);
      }
    }, {
      key: Symbol.toStringTag,
      get: function get4() {
        return "Array";
      }
    }]);
    return LegacyObservableArray2;
  }(StubArray);
  Object.entries(arrayExtensions).forEach(function(_ref) {
    var prop = _ref[0], fn = _ref[1];
    if (prop !== "concat")
      addHiddenProp(LegacyObservableArray.prototype, prop, fn);
  });
  function createArrayEntryDescriptor(index) {
    return {
      enumerable: false,
      configurable: true,
      get: function get4() {
        return this[$mobx].get_(index);
      },
      set: function set5(value) {
        this[$mobx].set_(index, value);
      }
    };
  }
  function createArrayBufferItem(index) {
    defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
  }
  function reserveArrayBuffer(max) {
    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
      for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
        createArrayBufferItem(index);
      }
      OBSERVABLE_ARRAY_BUFFER_SIZE = max;
    }
  }
  reserveArrayBuffer(1e3);
  function createLegacyArray(initialValues, enhancer, name2) {
    return new LegacyObservableArray(initialValues, enhancer, name2);
  }
  function getAtom(thing, property) {
    if (typeof thing === "object" && thing !== null) {
      if (isObservableArray(thing)) {
        if (property !== void 0)
          die(23);
        return thing[$mobx].atom_;
      }
      if (isObservableSet(thing)) {
        return thing[$mobx];
      }
      if (isObservableMap(thing)) {
        if (property === void 0)
          return thing.keysAtom_;
        var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
        if (!observable2)
          die(25, property, getDebugName(thing));
        return observable2;
      }
      if (isObservableObject(thing)) {
        if (!property)
          return die(26);
        var _observable = thing[$mobx].values_.get(property);
        if (!_observable)
          die(27, property, getDebugName(thing));
        return _observable;
      }
      if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
        return thing;
      }
    } else if (isFunction(thing)) {
      if (isReaction(thing[$mobx])) {
        return thing[$mobx];
      }
    }
    die(28);
  }
  function getAdministration(thing, property) {
    if (!thing)
      die(29);
    if (property !== void 0)
      return getAdministration(getAtom(thing, property));
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
      return thing;
    if (isObservableMap(thing) || isObservableSet(thing))
      return thing;
    if (thing[$mobx])
      return thing[$mobx];
    die(24, thing);
  }
  function getDebugName(thing, property) {
    var named;
    if (property !== void 0) {
      named = getAtom(thing, property);
    } else if (isAction(thing)) {
      return thing.name;
    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
      named = getAdministration(thing);
    } else {
      named = getAtom(thing);
    }
    return named.name_;
  }
  var toString = objectPrototype.toString;
  function deepEqual(a, b, depth) {
    if (depth === void 0) {
      depth = -1;
    }
    return eq(a, b, depth);
  }
  function eq(a, b, depth, aStack, bStack) {
    if (a === b)
      return a !== 0 || 1 / a === 1 / b;
    if (a == null || b == null)
      return false;
    if (a !== a)
      return b !== b;
    var type = typeof a;
    if (!isFunction(type) && type !== "object" && typeof b != "object")
      return false;
    var className = toString.call(a);
    if (className !== toString.call(b))
      return false;
    switch (className) {
      case "[object RegExp]":
      case "[object String]":
        return "" + a === "" + b;
      case "[object Number]":
        if (+a !== +a)
          return +b !== +b;
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case "[object Date]":
      case "[object Boolean]":
        return +a === +b;
      case "[object Symbol]":
        return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
      case "[object Map]":
      case "[object Set]":
        if (depth >= 0) {
          depth++;
        }
        break;
    }
    a = unwrap(a);
    b = unwrap(b);
    var areArrays = className === "[object Array]";
    if (!areArrays) {
      if (typeof a != "object" || typeof b != "object")
        return false;
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
        return false;
      }
    }
    if (depth === 0) {
      return false;
    } else if (depth < 0) {
      depth = -1;
    }
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      if (aStack[length] === a)
        return bStack[length] === b;
    }
    aStack.push(a);
    bStack.push(b);
    if (areArrays) {
      length = a.length;
      if (length !== b.length)
        return false;
      while (length--) {
        if (!eq(a[length], b[length], depth - 1, aStack, bStack))
          return false;
      }
    } else {
      var keys2 = Object.keys(a);
      var key;
      length = keys2.length;
      if (Object.keys(b).length !== length)
        return false;
      while (length--) {
        key = keys2[length];
        if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack)))
          return false;
      }
    }
    aStack.pop();
    bStack.pop();
    return true;
  }
  function unwrap(a) {
    if (isObservableArray(a))
      return a.slice();
    if (isES6Map(a) || isObservableMap(a))
      return Array.from(a.entries());
    if (isES6Set(a) || isObservableSet(a))
      return Array.from(a.entries());
    return a;
  }
  function makeIterable(iterator) {
    iterator[Symbol.iterator] = getSelf;
    return iterator;
  }
  function getSelf() {
    return this;
  }
  function isAnnotation(thing) {
    return thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_);
  }
  ["Symbol", "Map", "Set"].forEach(function(m) {
    var g = getGlobal();
    if (typeof g[m] === "undefined") {
      die("MobX requires global '" + m + "' to be available or polyfilled");
    }
  });
  if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
      spy,
      extras: {
        getDebugName
      },
      $mobx
    });
  }

  // ../../node_modules/mobx-react/dist/mobxreact.esm.js
  var import_react7 = __toModule(require_react());

  // ../../node_modules/mobx-react-lite/es/utils/assertEnvironment.js
  var import_react = __toModule(require_react());
  if (!import_react.useState) {
    throw new Error("mobx-react-lite requires React with Hooks support");
  }
  if (!makeObservable) {
    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
  }

  // ../../node_modules/mobx-react-lite/es/utils/reactBatchedUpdates.js
  var import_react_dom = __toModule(require_react_dom());

  // ../../node_modules/mobx-react-lite/es/utils/observerBatching.js
  function defaultNoopBatch(callback) {
    callback();
  }
  function observerBatching(reactionScheduler3) {
    if (!reactionScheduler3) {
      reactionScheduler3 = defaultNoopBatch;
      if (true) {
        console.warn("[MobX] Failed to get unstable_batched updates from react-dom / react-native");
      }
    }
    configure({ reactionScheduler: reactionScheduler3 });
  }

  // ../../node_modules/mobx-react-lite/es/utils/utils.js
  var deprecatedMessages = [];
  function useDeprecated(msg) {
    if (!deprecatedMessages.includes(msg)) {
      deprecatedMessages.push(msg);
      console.warn(msg);
    }
  }

  // ../../node_modules/mobx-react-lite/es/useObserver.js
  var import_react2 = __toModule(require_react());

  // ../../node_modules/mobx-react-lite/es/utils/printDebugValue.js
  function printDebugValue(v) {
    return getDependencyTree(v);
  }

  // ../../node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js
  var FinalizationRegistryLocal = typeof FinalizationRegistry === "undefined" ? void 0 : FinalizationRegistry;

  // ../../node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js
  function createTrackingData(reaction2) {
    var trackingData = {
      reaction: reaction2,
      mounted: false,
      changedBeforeMount: false,
      cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS
    };
    return trackingData;
  }
  var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 1e4;
  var CLEANUP_TIMER_LOOP_MILLIS = 1e4;

  // ../../node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js
  function createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistry2) {
    var cleanupTokenToReactionTrackingMap = new Map();
    var globalCleanupTokensCounter = 1;
    var registry = new FinalizationRegistry2(function cleanupFunction(token) {
      var trackedReaction = cleanupTokenToReactionTrackingMap.get(token);
      if (trackedReaction) {
        trackedReaction.reaction.dispose();
        cleanupTokenToReactionTrackingMap.delete(token);
      }
    });
    return {
      addReactionToTrack: function(reactionTrackingRef, reaction2, objectRetainedByReact) {
        var token = globalCleanupTokensCounter++;
        registry.register(objectRetainedByReact, token, reactionTrackingRef);
        reactionTrackingRef.current = createTrackingData(reaction2);
        reactionTrackingRef.current.finalizationRegistryCleanupToken = token;
        cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current);
        return reactionTrackingRef.current;
      },
      recordReactionAsCommitted: function(reactionRef) {
        registry.unregister(reactionRef);
        if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {
          cleanupTokenToReactionTrackingMap.delete(reactionRef.current.finalizationRegistryCleanupToken);
        }
      },
      forceCleanupTimerToRunNowForTests: function() {
      },
      resetCleanupScheduleForTests: function() {
      }
    };
  }

  // ../../node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js
  var __values = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  function createTimerBasedReactionCleanupTracking() {
    var uncommittedReactionRefs = new Set();
    var reactionCleanupHandle;
    function forceCleanupTimerToRunNowForTests2() {
      if (reactionCleanupHandle) {
        clearTimeout(reactionCleanupHandle);
        cleanUncommittedReactions();
      }
    }
    function resetCleanupScheduleForTests2() {
      var e_1, _a3;
      if (uncommittedReactionRefs.size > 0) {
        try {
          for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {
            var ref = uncommittedReactionRefs_1_1.value;
            var tracking = ref.current;
            if (tracking) {
              tracking.reaction.dispose();
              ref.current = null;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a3 = uncommittedReactionRefs_1.return))
              _a3.call(uncommittedReactionRefs_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        uncommittedReactionRefs.clear();
      }
      if (reactionCleanupHandle) {
        clearTimeout(reactionCleanupHandle);
        reactionCleanupHandle = void 0;
      }
    }
    function ensureCleanupTimerRunning() {
      if (reactionCleanupHandle === void 0) {
        reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);
      }
    }
    function scheduleCleanupOfReactionIfLeaked(ref) {
      uncommittedReactionRefs.add(ref);
      ensureCleanupTimerRunning();
    }
    function recordReactionAsCommitted2(reactionRef) {
      uncommittedReactionRefs.delete(reactionRef);
    }
    function cleanUncommittedReactions() {
      reactionCleanupHandle = void 0;
      var now = Date.now();
      uncommittedReactionRefs.forEach(function(ref) {
        var tracking = ref.current;
        if (tracking) {
          if (now >= tracking.cleanAt) {
            tracking.reaction.dispose();
            ref.current = null;
            uncommittedReactionRefs.delete(ref);
          }
        }
      });
      if (uncommittedReactionRefs.size > 0) {
        ensureCleanupTimerRunning();
      }
    }
    return {
      addReactionToTrack: function(reactionTrackingRef, reaction2, objectRetainedByReact) {
        reactionTrackingRef.current = createTrackingData(reaction2);
        scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);
        return reactionTrackingRef.current;
      },
      recordReactionAsCommitted: recordReactionAsCommitted2,
      forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests2,
      resetCleanupScheduleForTests: resetCleanupScheduleForTests2
    };
  }

  // ../../node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js
  var _a = FinalizationRegistryLocal ? createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryLocal) : createTimerBasedReactionCleanupTracking();
  var addReactionToTrack = _a.addReactionToTrack;
  var recordReactionAsCommitted = _a.recordReactionAsCommitted;
  var resetCleanupScheduleForTests = _a.resetCleanupScheduleForTests;
  var forceCleanupTimerToRunNowForTests = _a.forceCleanupTimerToRunNowForTests;

  // ../../node_modules/mobx-react-lite/es/staticRendering.js
  var globalIsUsingStaticRendering = false;
  function enableStaticRendering(enable) {
    globalIsUsingStaticRendering = enable;
  }
  function isUsingStaticRendering() {
    return globalIsUsingStaticRendering;
  }

  // ../../node_modules/mobx-react-lite/es/useObserver.js
  var __read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r6, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r6 = i.next()).done)
        ar.push(r6.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r6 && !r6.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  function observerComponentNameFor(baseComponentName) {
    return "observer" + baseComponentName;
  }
  var ObjectToBeRetainedByReact = function() {
    function ObjectToBeRetainedByReact2() {
    }
    return ObjectToBeRetainedByReact2;
  }();
  function objectToBeRetainedByReactFactory() {
    return new ObjectToBeRetainedByReact();
  }
  function useObserver(fn, baseComponentName) {
    if (baseComponentName === void 0) {
      baseComponentName = "observed";
    }
    if (isUsingStaticRendering()) {
      return fn();
    }
    var _a3 = __read(import_react2.default.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a3[0];
    var _b2 = __read(import_react2.default.useState(), 2), setState = _b2[1];
    var forceUpdate = function() {
      return setState([]);
    };
    var reactionTrackingRef = import_react2.default.useRef(null);
    if (!reactionTrackingRef.current) {
      var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
        if (trackingData_1.mounted) {
          forceUpdate();
        } else {
          trackingData_1.changedBeforeMount = true;
        }
      });
      var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);
    }
    var reaction2 = reactionTrackingRef.current.reaction;
    import_react2.default.useDebugValue(reaction2, printDebugValue);
    import_react2.default.useEffect(function() {
      recordReactionAsCommitted(reactionTrackingRef);
      if (reactionTrackingRef.current) {
        reactionTrackingRef.current.mounted = true;
        if (reactionTrackingRef.current.changedBeforeMount) {
          reactionTrackingRef.current.changedBeforeMount = false;
          forceUpdate();
        }
      } else {
        reactionTrackingRef.current = {
          reaction: new Reaction(observerComponentNameFor(baseComponentName), function() {
            forceUpdate();
          }),
          mounted: true,
          changedBeforeMount: false,
          cleanAt: Infinity
        };
        forceUpdate();
      }
      return function() {
        reactionTrackingRef.current.reaction.dispose();
        reactionTrackingRef.current = null;
      };
    }, []);
    var rendering;
    var exception;
    reaction2.track(function() {
      try {
        rendering = fn();
      } catch (e) {
        exception = e;
      }
    });
    if (exception) {
      throw exception;
    }
    return rendering;
  }

  // ../../node_modules/mobx-react-lite/es/observer.js
  var import_react3 = __toModule(require_react());
  var __assign = function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function observer(baseComponent, options) {
    if (isUsingStaticRendering()) {
      return baseComponent;
    }
    var realOptions = __assign({ forwardRef: false }, options);
    var baseComponentName = baseComponent.displayName || baseComponent.name;
    var wrappedComponent = function(props, ref) {
      return useObserver(function() {
        return baseComponent(props, ref);
      }, baseComponentName);
    };
    wrappedComponent.displayName = baseComponentName;
    var memoComponent;
    if (realOptions.forwardRef) {
      memoComponent = (0, import_react3.memo)((0, import_react3.forwardRef)(wrappedComponent));
    } else {
      memoComponent = (0, import_react3.memo)(wrappedComponent);
    }
    copyStaticProperties(baseComponent, memoComponent);
    memoComponent.displayName = baseComponentName;
    return memoComponent;
  }
  var hoistBlackList = {
    $$typeof: true,
    render: true,
    compare: true,
    type: true
  };
  function copyStaticProperties(base2, target) {
    Object.keys(base2).forEach(function(key) {
      if (!hoistBlackList[key]) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base2, key));
      }
    });
  }

  // ../../node_modules/mobx-react-lite/es/ObserverComponent.js
  function ObserverComponent(_a3) {
    var children = _a3.children, render = _a3.render;
    var component = children || render;
    if (typeof component !== "function") {
      return null;
    }
    return useObserver(component);
  }
  if (true) {
    ObserverComponent.propTypes = {
      children: ObserverPropsCheck,
      render: ObserverPropsCheck
    };
  }
  ObserverComponent.displayName = "Observer";
  function ObserverPropsCheck(props, key, componentName, location, propFullName) {
    var extraKey = key === "children" ? "render" : "children";
    var hasProp2 = typeof props[key] === "function";
    var hasExtraProp = typeof props[extraKey] === "function";
    if (hasProp2 && hasExtraProp) {
      return new Error("MobX Observer: Do not use children and render in the same time in`" + componentName);
    }
    if (hasProp2 || hasExtraProp) {
      return null;
    }
    return new Error("Invalid prop `" + propFullName + "` of type `" + typeof props[key] + "` supplied to `" + componentName + "`, expected `function`.");
  }

  // ../../node_modules/mobx-react-lite/es/useLocalObservable.js
  var import_react4 = __toModule(require_react());
  function useLocalObservable(initializer, annotations) {
    return (0, import_react4.useState)(function() {
      return observable(initializer(), annotations, { autoBind: true });
    })[0];
  }

  // ../../node_modules/mobx-react-lite/es/useLocalStore.js
  var import_react6 = __toModule(require_react());

  // ../../node_modules/mobx-react-lite/es/useAsObservableSource.js
  var import_react5 = __toModule(require_react());
  var __read2 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r6, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r6 = i.next()).done)
        ar.push(r6.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r6 && !r6.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  function useAsObservableSource(current) {
    if (true)
      useDeprecated("[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.");
    var _a3 = __read2((0, import_react5.useState)(function() {
      return observable(current, {}, { deep: false });
    }), 1), res = _a3[0];
    runInAction(function() {
      Object.assign(res, current);
    });
    return res;
  }

  // ../../node_modules/mobx-react-lite/es/useLocalStore.js
  function useLocalStore(initializer, current) {
    if (true)
      useDeprecated("[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.");
    var source = current && useAsObservableSource(current);
    return (0, import_react6.useState)(function() {
      return observable(initializer(source), void 0, { autoBind: true });
    })[0];
  }

  // ../../node_modules/mobx-react-lite/es/index.js
  observerBatching(import_react_dom.unstable_batchedUpdates);
  function useObserver2(fn, baseComponentName) {
    if (baseComponentName === void 0) {
      baseComponentName = "observed";
    }
    if (true) {
      useDeprecated("[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.");
    }
    return useObserver(fn, baseComponentName);
  }
  function useStaticRendering(enable) {
    if (true) {
      console.warn("[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead");
    }
    enableStaticRendering(enable);
  }

  // ../../node_modules/mobx-react/dist/mobxreact.esm.js
  var symbolId = 0;
  function createSymbol(name2) {
    if (typeof Symbol === "function") {
      return Symbol(name2);
    }
    var symbol = "__$mobx-react " + name2 + " (" + symbolId + ")";
    symbolId++;
    return symbol;
  }
  var createdSymbols = {};
  function newSymbol(name2) {
    if (!createdSymbols[name2]) {
      createdSymbols[name2] = createSymbol(name2);
    }
    return createdSymbols[name2];
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB))
      return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length)
      return false;
    for (var i = 0; i < keysA.length; i++) {
      if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }
  function is(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  var hoistBlackList2 = {
    $$typeof: 1,
    render: 1,
    compare: 1,
    type: 1,
    childContextTypes: 1,
    contextType: 1,
    contextTypes: 1,
    defaultProps: 1,
    getDefaultProps: 1,
    getDerivedStateFromError: 1,
    getDerivedStateFromProps: 1,
    mixins: 1,
    displayName: 1,
    propTypes: 1
  };
  function copyStaticProperties2(base2, target) {
    var protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base2));
    Object.getOwnPropertyNames(base2).forEach(function(key) {
      if (!hoistBlackList2[key] && protoProps.indexOf(key) === -1) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base2, key));
      }
    });
  }
  function setHiddenProp(target, prop, value) {
    if (!Object.hasOwnProperty.call(target, prop)) {
      Object.defineProperty(target, prop, {
        enumerable: false,
        configurable: true,
        writable: true,
        value
      });
    } else {
      target[prop] = value;
    }
  }
  var mobxMixins = /* @__PURE__ */ newSymbol("patchMixins");
  var mobxPatchedDefinition = /* @__PURE__ */ newSymbol("patchedDefinition");
  function getMixins(target, methodName) {
    var mixins = target[mobxMixins] = target[mobxMixins] || {};
    var methodMixins = mixins[methodName] = mixins[methodName] || {};
    methodMixins.locks = methodMixins.locks || 0;
    methodMixins.methods = methodMixins.methods || [];
    return methodMixins;
  }
  function wrapper(realMethod, mixins) {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    mixins.locks++;
    try {
      var retVal;
      if (realMethod !== void 0 && realMethod !== null) {
        retVal = realMethod.apply(this, args);
      }
      return retVal;
    } finally {
      mixins.locks--;
      if (mixins.locks === 0) {
        mixins.methods.forEach(function(mx) {
          mx.apply(_this, args);
        });
      }
    }
  }
  function wrapFunction(realMethod, mixins) {
    var fn = function fn2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));
    };
    return fn;
  }
  function patch(target, methodName, mixinMethod) {
    var mixins = getMixins(target, methodName);
    if (mixins.methods.indexOf(mixinMethod) < 0) {
      mixins.methods.push(mixinMethod);
    }
    var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
      return;
    }
    var originalMethod = target[methodName];
    var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : void 0, mixins, originalMethod);
    Object.defineProperty(target, methodName, newDefinition);
  }
  function createDefinition(target, methodName, enumerable, mixins, originalMethod) {
    var _ref;
    var wrappedFunc = wrapFunction(originalMethod, mixins);
    return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get4() {
      return wrappedFunc;
    }, _ref.set = function set5(value) {
      if (this === target) {
        wrappedFunc = wrapFunction(value, mixins);
      } else {
        var newDefinition = createDefinition(this, methodName, enumerable, mixins, value);
        Object.defineProperty(this, methodName, newDefinition);
      }
    }, _ref.configurable = true, _ref.enumerable = enumerable, _ref;
  }
  var mobxAdminProperty = $mobx || "$mobx";
  var mobxObserverProperty = /* @__PURE__ */ newSymbol("isMobXReactObserver");
  var mobxIsUnmounted = /* @__PURE__ */ newSymbol("isUnmounted");
  var skipRenderKey = /* @__PURE__ */ newSymbol("skipRender");
  var isForcingUpdateKey = /* @__PURE__ */ newSymbol("isForcingUpdate");
  function makeClassComponentObserver(componentClass) {
    var target = componentClass.prototype;
    if (componentClass[mobxObserverProperty]) {
      var displayName = getDisplayName(target);
      console.warn("The provided component class (" + displayName + ") \n                has already been declared as an observer component.");
    } else {
      componentClass[mobxObserverProperty] = true;
    }
    if (target.componentWillReact)
      throw new Error("The componentWillReact life-cycle event is no longer supported");
    if (componentClass["__proto__"] !== import_react7.PureComponent) {
      if (!target.shouldComponentUpdate)
        target.shouldComponentUpdate = observerSCU;
      else if (target.shouldComponentUpdate !== observerSCU)
        throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
    }
    makeObservableProp(target, "props");
    makeObservableProp(target, "state");
    var baseRender = target.render;
    if (typeof baseRender !== "function") {
      var _displayName = getDisplayName(target);
      throw new Error("[mobx-react] class component (" + _displayName + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
    }
    target.render = function() {
      return makeComponentReactive.call(this, baseRender);
    };
    patch(target, "componentWillUnmount", function() {
      var _this$render$mobxAdmi;
      if (isUsingStaticRendering() === true)
        return;
      (_this$render$mobxAdmi = this.render[mobxAdminProperty]) == null ? void 0 : _this$render$mobxAdmi.dispose();
      this[mobxIsUnmounted] = true;
      if (!this.render[mobxAdminProperty]) {
        var _displayName2 = getDisplayName(this);
        console.warn("The reactive render of an observer class component (" + _displayName2 + ") \n                was overriden after MobX attached. This may result in a memory leak if the \n                overriden reactive render was not properly disposed.");
      }
    });
    return componentClass;
  }
  function getDisplayName(comp) {
    return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || "<component>";
  }
  function makeComponentReactive(render) {
    var _this = this;
    if (isUsingStaticRendering() === true)
      return render.call(this);
    setHiddenProp(this, skipRenderKey, false);
    setHiddenProp(this, isForcingUpdateKey, false);
    var initialName = getDisplayName(this);
    var baseRender = render.bind(this);
    var isRenderingPending = false;
    var reaction2 = new Reaction(initialName + ".render()", function() {
      if (!isRenderingPending) {
        isRenderingPending = true;
        if (_this[mobxIsUnmounted] !== true) {
          var hasError = true;
          try {
            setHiddenProp(_this, isForcingUpdateKey, true);
            if (!_this[skipRenderKey])
              import_react7.Component.prototype.forceUpdate.call(_this);
            hasError = false;
          } finally {
            setHiddenProp(_this, isForcingUpdateKey, false);
            if (hasError)
              reaction2.dispose();
          }
        }
      }
    });
    reaction2["reactComponent"] = this;
    reactiveRender[mobxAdminProperty] = reaction2;
    this.render = reactiveRender;
    function reactiveRender() {
      isRenderingPending = false;
      var exception = void 0;
      var rendering = void 0;
      reaction2.track(function() {
        try {
          rendering = allowStateChanges(false, baseRender);
        } catch (e) {
          exception = e;
        }
      });
      if (exception) {
        throw exception;
      }
      return rendering;
    }
    return reactiveRender.call(this);
  }
  function observerSCU(nextProps, nextState) {
    if (isUsingStaticRendering()) {
      console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
    }
    if (this.state !== nextState) {
      return true;
    }
    return !shallowEqual(this.props, nextProps);
  }
  function makeObservableProp(target, propName) {
    var valueHolderKey = newSymbol("reactProp_" + propName + "_valueHolder");
    var atomHolderKey = newSymbol("reactProp_" + propName + "_atomHolder");
    function getAtom2() {
      if (!this[atomHolderKey]) {
        setHiddenProp(this, atomHolderKey, createAtom("reactive " + propName));
      }
      return this[atomHolderKey];
    }
    Object.defineProperty(target, propName, {
      configurable: true,
      enumerable: true,
      get: function get4() {
        var prevReadState = false;
        if (allowStateReadsStart && allowStateReadsEnd) {
          prevReadState = allowStateReadsStart(true);
        }
        getAtom2.call(this).reportObserved();
        if (allowStateReadsStart && allowStateReadsEnd) {
          allowStateReadsEnd(prevReadState);
        }
        return this[valueHolderKey];
      },
      set: function set5(v) {
        if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {
          setHiddenProp(this, valueHolderKey, v);
          setHiddenProp(this, skipRenderKey, true);
          getAtom2.call(this).reportChanged();
          setHiddenProp(this, skipRenderKey, false);
        } else {
          setHiddenProp(this, valueHolderKey, v);
        }
      }
    });
  }
  var hasSymbol = typeof Symbol === "function" && Symbol["for"];
  var ReactForwardRefSymbol = hasSymbol ? /* @__PURE__ */ Symbol["for"]("react.forward_ref") : typeof import_react7.forwardRef === "function" && (0, import_react7.forwardRef)(function(props) {
    return null;
  })["$$typeof"];
  var ReactMemoSymbol = hasSymbol ? /* @__PURE__ */ Symbol["for"]("react.memo") : typeof import_react7.memo === "function" && (0, import_react7.memo)(function(props) {
    return null;
  })["$$typeof"];
  function observer2(component) {
    if (component["isMobxInjector"] === true) {
      console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'");
    }
    if (ReactMemoSymbol && component["$$typeof"] === ReactMemoSymbol) {
      throw new Error("Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.");
    }
    if (ReactForwardRefSymbol && component["$$typeof"] === ReactForwardRefSymbol) {
      var baseRender = component["render"];
      if (typeof baseRender !== "function")
        throw new Error("render property of ForwardRef was not a function");
      return (0, import_react7.forwardRef)(function ObserverForwardRef() {
        var args = arguments;
        return (0, import_react7.createElement)(ObserverComponent, null, function() {
          return baseRender.apply(void 0, args);
        });
      });
    }
    if (typeof component === "function" && (!component.prototype || !component.prototype.render) && !component["isReactClass"] && !Object.prototype.isPrototypeOf.call(import_react7.Component, component)) {
      return observer(component);
    }
    return makeClassComponentObserver(component);
  }
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var MobXProviderContext = /* @__PURE__ */ import_react7.default.createContext({});
  function Provider(props) {
    var children = props.children, stores = _objectWithoutPropertiesLoose(props, ["children"]);
    var parentValue = import_react7.default.useContext(MobXProviderContext);
    var mutableProviderRef = import_react7.default.useRef(_extends2({}, parentValue, stores));
    var value = mutableProviderRef.current;
    if (true) {
      var newValue = _extends2({}, value, stores);
      if (!shallowEqual(value, newValue)) {
        throw new Error("MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.");
      }
    }
    return import_react7.default.createElement(MobXProviderContext.Provider, {
      value
    }, children);
  }
  Provider.displayName = "MobXProvider";
  function createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {
    var Injector = import_react7.default.forwardRef(function(props, ref) {
      var newProps = _extends2({}, props);
      var context = import_react7.default.useContext(MobXProviderContext);
      Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});
      if (ref) {
        newProps.ref = ref;
      }
      return import_react7.default.createElement(component, newProps);
    });
    if (makeReactive)
      Injector = observer2(Injector);
    Injector["isMobxInjector"] = true;
    copyStaticProperties2(component, Injector);
    Injector["wrappedComponent"] = component;
    Injector.displayName = getInjectName(component, injectNames);
    return Injector;
  }
  function getInjectName(component, injectNames) {
    var displayName;
    var componentName = component.displayName || component.name || component.constructor && component.constructor.name || "Component";
    if (injectNames)
      displayName = "inject-with-" + injectNames + "(" + componentName + ")";
    else
      displayName = "inject(" + componentName + ")";
    return displayName;
  }
  function grabStoresByName(storeNames) {
    return function(baseStores, nextProps) {
      storeNames.forEach(function(storeName) {
        if (storeName in nextProps)
          return;
        if (!(storeName in baseStores))
          throw new Error("MobX injector: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
        nextProps[storeName] = baseStores[storeName];
      });
      return nextProps;
    };
  }
  function inject() {
    for (var _len = arguments.length, storeNames = new Array(_len), _key = 0; _key < _len; _key++) {
      storeNames[_key] = arguments[_key];
    }
    if (typeof arguments[0] === "function") {
      var grabStoresFn = arguments[0];
      return function(componentClass) {
        return createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);
      };
    } else {
      return function(componentClass) {
        return createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join("-"), false);
      };
    }
  }
  var protoStoreKey = /* @__PURE__ */ newSymbol("disposeOnUnmountProto");
  var instStoreKey = /* @__PURE__ */ newSymbol("disposeOnUnmountInst");
  function runDisposersOnWillUnmount() {
    var _this = this;
    [].concat(this[protoStoreKey] || [], this[instStoreKey] || []).forEach(function(propKeyOrFunction) {
      var prop = typeof propKeyOrFunction === "string" ? _this[propKeyOrFunction] : propKeyOrFunction;
      if (prop !== void 0 && prop !== null) {
        if (Array.isArray(prop))
          prop.map(function(f) {
            return f();
          });
        else
          prop();
      }
    });
  }
  function disposeOnUnmount(target, propertyKeyOrFunction) {
    if (Array.isArray(propertyKeyOrFunction)) {
      return propertyKeyOrFunction.map(function(fn) {
        return disposeOnUnmount(target, fn);
      });
    }
    var c = Object.getPrototypeOf(target).constructor;
    var c2 = Object.getPrototypeOf(target.constructor);
    var c3 = Object.getPrototypeOf(Object.getPrototypeOf(target));
    if (!(c === import_react7.default.Component || c === import_react7.default.PureComponent || c2 === import_react7.default.Component || c2 === import_react7.default.PureComponent || c3 === import_react7.default.Component || c3 === import_react7.default.PureComponent)) {
      throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");
    }
    if (typeof propertyKeyOrFunction !== "string" && typeof propertyKeyOrFunction !== "function" && !Array.isArray(propertyKeyOrFunction)) {
      throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
    }
    var isDecorator = typeof propertyKeyOrFunction === "string";
    var componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];
    var store = isDecorator ? target[protoStoreKey] || (target[protoStoreKey] = []) : target[instStoreKey] || (target[instStoreKey] = []);
    store.push(propertyKeyOrFunction);
    if (!componentWasAlreadyModified) {
      patch(target, "componentWillUnmount", runDisposersOnWillUnmount);
    }
    if (typeof propertyKeyOrFunction !== "string") {
      return propertyKeyOrFunction;
    }
  }
  function createChainableTypeChecker(validator) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
      for (var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
        rest[_key - 6] = arguments[_key];
      }
      return untracked(function() {
        componentName = componentName || "<<anonymous>>";
        propFullName = propFullName || propName;
        if (props[propName] == null) {
          if (isRequired) {
            var actual = props[propName] === null ? "null" : "undefined";
            return new Error("The " + location + " `" + propFullName + "` is marked as required in `" + componentName + "`, but its value is `" + actual + "`.");
          }
          return null;
        } else {
          return validator.apply(void 0, [props, propName, componentName, location, propFullName].concat(rest));
        }
      });
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }
  function isSymbol(propType, propValue) {
    if (propType === "symbol") {
      return true;
    }
    if (propValue["@@toStringTag"] === "Symbol") {
      return true;
    }
    if (typeof Symbol === "function" && propValue instanceof Symbol) {
      return true;
    }
    return false;
  }
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return "array";
    }
    if (propValue instanceof RegExp) {
      return "object";
    }
    if (isSymbol(propType, propValue)) {
      return "symbol";
    }
    return propType;
  }
  function getPreciseType(propValue) {
    var propType = getPropType(propValue);
    if (propType === "object") {
      if (propValue instanceof Date) {
        return "date";
      } else if (propValue instanceof RegExp) {
        return "regexp";
      }
    }
    return propType;
  }
  function createObservableTypeCheckerCreator(allowNativeType, mobxType) {
    return createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
      return untracked(function() {
        if (allowNativeType) {
          if (getPropType(props[propName]) === mobxType.toLowerCase())
            return null;
        }
        var mobxChecker;
        switch (mobxType) {
          case "Array":
            mobxChecker = isObservableArray;
            break;
          case "Object":
            mobxChecker = isObservableObject;
            break;
          case "Map":
            mobxChecker = isObservableMap;
            break;
          default:
            throw new Error("Unexpected mobxType: " + mobxType);
        }
        var propValue = props[propName];
        if (!mobxChecker(propValue)) {
          var preciseType = getPreciseType(propValue);
          var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
          return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
        }
        return null;
      });
    });
  }
  function createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
    return createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {
        rest[_key2 - 5] = arguments[_key2];
      }
      return untracked(function() {
        if (typeof typeChecker !== "function") {
          return new Error("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation.");
        } else {
          var error = createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName, location, propFullName);
          if (error instanceof Error)
            return error;
          var propValue = props[propName];
          for (var i = 0; i < propValue.length; i++) {
            error = typeChecker.apply(void 0, [propValue, i, componentName, location, propFullName + "[" + i + "]"].concat(rest));
            if (error instanceof Error)
              return error;
          }
          return null;
        }
      });
    });
  }
  var observableArray = /* @__PURE__ */ createObservableTypeCheckerCreator(false, "Array");
  var observableArrayOf = /* @__PURE__ */ createObservableArrayOfTypeChecker.bind(null, false);
  var observableMap = /* @__PURE__ */ createObservableTypeCheckerCreator(false, "Map");
  var observableObject = /* @__PURE__ */ createObservableTypeCheckerCreator(false, "Object");
  var arrayOrObservableArray = /* @__PURE__ */ createObservableTypeCheckerCreator(true, "Array");
  var arrayOrObservableArrayOf = /* @__PURE__ */ createObservableArrayOfTypeChecker.bind(null, true);
  var objectOrObservableObject = /* @__PURE__ */ createObservableTypeCheckerCreator(true, "Object");
  var PropTypes = {
    observableArray,
    observableArrayOf,
    observableMap,
    observableObject,
    arrayOrObservableArray,
    arrayOrObservableArrayOf,
    objectOrObservableObject
  };
  if (!import_react7.Component)
    throw new Error("mobx-react requires React to be available");
  if (!observable)
    throw new Error("mobx-react requires mobx to be available");

  // ../../packages/nota/dist/nota.js
  var Co = __toModule(require_react_dom());
  var YT = __toModule(require_react_dom());

  // ../../node_modules/@codemirror/view/dist/index.js
  var dist_exports2 = {};
  __export(dist_exports2, {
    BidiSpan: () => BidiSpan,
    BlockInfo: () => BlockInfo,
    BlockType: () => BlockType,
    Decoration: () => Decoration,
    Direction: () => Direction,
    EditorView: () => EditorView,
    MatchDecorator: () => MatchDecorator,
    PluginField: () => PluginField,
    PluginFieldProvider: () => PluginFieldProvider,
    Range: () => Range,
    ViewPlugin: () => ViewPlugin,
    ViewUpdate: () => ViewUpdate,
    WidgetType: () => WidgetType,
    __test: () => __test,
    drawSelection: () => drawSelection,
    highlightActiveLine: () => highlightActiveLine,
    highlightSpecialChars: () => highlightSpecialChars,
    keymap: () => keymap,
    logException: () => logException,
    placeholder: () => placeholder,
    runScopeHandlers: () => runScopeHandlers,
    scrollPastEnd: () => scrollPastEnd
  });

  // ../../node_modules/@codemirror/state/dist/index.js
  var dist_exports = {};
  __export(dist_exports, {
    Annotation: () => Annotation,
    AnnotationType: () => AnnotationType,
    ChangeDesc: () => ChangeDesc,
    ChangeSet: () => ChangeSet,
    CharCategory: () => CharCategory,
    Compartment: () => Compartment,
    EditorSelection: () => EditorSelection,
    EditorState: () => EditorState,
    Facet: () => Facet,
    MapMode: () => MapMode,
    Prec: () => Prec,
    SelectionRange: () => SelectionRange,
    StateEffect: () => StateEffect,
    StateEffectType: () => StateEffectType,
    StateField: () => StateField,
    Text: () => Text,
    Transaction: () => Transaction,
    combineConfig: () => combineConfig
  });

  // ../../node_modules/@codemirror/text/dist/index.js
  var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
  function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
      if (extend[i] > code)
        return extend[i - 1] <= code;
    return false;
  }
  function isRegionalIndicator(code) {
    return code >= 127462 && code <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);
  }
  function nextClusterBreak(str, pos) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i = pos - 2;
        while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
          countBefore++;
          i -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch2) {
    return ch2 >= 56320 && ch2 < 57344;
  }
  function surrogateHigh(ch2) {
    return ch2 >= 55296 && ch2 < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function codePointSize(code) {
    return code < 65536 ? 1 : 2;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n = 0;
    for (let i = 0; i < to; ) {
      if (string2.charCodeAt(i) == 9) {
        n += tabSize - n % tabSize;
        i++;
      } else {
        n++;
        i = findClusterBreak(string2, i);
      }
    }
    return n;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i = 0, n = 0; ; ) {
      if (n >= col)
        return i;
      if (i == string2.length)
        break;
      n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
      i = findClusterBreak(string2, i);
    }
    return strict === true ? -1 : string2.length;
  }
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text.length)
        text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start2 = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start2, pos = start2; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start2 = this.line(from).from;
        inner = this.iterRange(start2, Math.max(start2, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let string2 = this.text[i], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to, text) {
      if (!(text instanceof TextLeaf))
        return super.replace(from, to, text);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text.length - (to - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
        let line = this.text[i], end = pos + line.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i = 0; ; i++) {
        let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text) {
      if (text.lines < this.lines)
        for (let i = 0, pos = 0; i < this.children.length; i++) {
          let child = this.children[i], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i] = updated;
              return new TextNode(copy, this.length - (to - from) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos > from && i)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length = 0;
      let [iA2, iB, eA2, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA2 += dir, iB += dir) {
        if (iA2 == eA2 || iB == eB)
          return length;
        let chA = this.children[iA2], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch2) => l + ch2.length + 1, -1)) {
      let lines = 0;
      for (let ch2 of children)
        lines += ch2.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch2 of children)
          ch2.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add(child) {
        let last;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
      let line = text[i], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0)
              this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start2, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start2 > end ? -1 : 1);
      this.pos = start2 > end ? text.length : 0;
      this.from = Math.min(start2, end);
      this.to = Math.max(start2, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to, number2, text) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  };

  // ../../node_modules/@codemirror/state/dist/index.js
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2)
        result += this.sections[i];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i = 0; i < this.sections.length; i += 2) {
        let ins = this.sections[i + 1];
        result += ins < 0 ? this.sections[i] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
        let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i = 0; i < this.sections.length; ) {
        let len = this.sections[i++], ins = this.sections[i++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i = 0, pos = 0; i < sections.length; i += 2) {
        let len = sections[i], ins = sections[i + 1];
        if (ins >= 0) {
          sections[i] = ins;
          sections[i + 1] = len;
          let index = i >> 1;
          while (inserted.length < index)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return new ChangeDesc(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i = 0, pos = 0; ; ) {
          let next = i == ranges.length ? 1e9 : ranges[i++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: new ChangeDesc(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i = 0; i < this.sections.length; i += 2) {
        let len = this.sections[i], ins = this.sections[i + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set5 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set5.map(total)) : set5;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert2 } = spec;
          if (from > to || from < 0 || to > length)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i = 0; i < json.length; i++) {
        let part = json[i];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i)
            inserted.push(Text.empty);
          inserted[i] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
      sections[last] += len;
    else if (len == 0 && sections[last] == 0)
      sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values2, sections, value) {
    if (value.length == 0)
      return;
    let index = sections.length - 2 >> 1;
    if (index < values2.length) {
      values2[values2.length - 1] = values2[values2.length - 1].append(value);
    } else {
      while (values2.length < index)
        values2.push(Text.empty);
      values2.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
      let len = desc.sections[i++], ins = desc.sections[i++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text = text.append(inserted[i - 2 >> 1]);
          if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
            break;
          len = desc.sections[i++];
          ins = desc.sections[i++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let posA = 0, posB = 0; ; ) {
      if (a.ins == -1) {
        posA += a.len;
        a.next();
      } else if (b.ins == -1 && posB < posA) {
        let skip = Math.min(b.len, posA - posB);
        b.forward(skip);
        addSection(sections, skip, -1);
        posB += skip;
      } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
        addSection(sections, b.ins, -1);
        while (posA > posB && !a.done && posA + a.len < posB + b.len) {
          posA += a.len;
          a.next();
        }
        posB += b.len;
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, end = posA + a.len;
        for (; ; ) {
          if (b.ins >= 0 && posB > posA && posB + b.len < end) {
            len += b.ins;
            posB += b.len;
            b.next();
          } else if (b.ins == -1 && posB < end) {
            let skip = Math.min(b.len, end - posB);
            len += skip;
            b.forward(skip);
            posB += skip;
          } else {
            break;
          }
        }
        addSection(sections, len, a.ins);
        if (insert2)
          addInsert(insert2, sections, a.text);
        posA = end;
        a.next();
      } else if (a.done && b.done) {
        return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2)
          addInsert(insert2, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off)
            addInsert(insert2, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set5) {
      this.set = set5;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from = change.mapPos(this.from, assoc), to = change.mapPos(this.to, assoc);
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex = 0) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r6) => r6.map(change, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].eq(other.ranges[i]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main]);
    }
    addRange(range, main = true) {
      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r6) => r6.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r6) => SelectionRange.fromJSON(r6)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        if (range.empty ? range.from <= pos : range.from < pos)
          return normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn) {
      let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? new SelectionRange(head, anchor, 16 | goal) : new SelectionRange(anchor, head, goal);
    }
  };
  function normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i], prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
      }
    }
    return new EditorSelection(ranges, mainIndex);
  }
  function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, extensions) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.extensions = extensions;
      this.id = nextID++;
      this.default = combine([]);
    }
    static define(config = {}) {
      return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get4) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get4);
    }
    computeN(deps, get4) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get4);
    }
    from(field, get4) {
      if (!get4)
        get4 = (x) => x;
      return this.compute([field], (state) => get4(state.field(field)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a3;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let idx = addresses[this.id] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a3 = addresses[dep.id]) !== null && _a3 !== void 0 ? _a3 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return (state, tr) => {
        if (!tr || tr.reconfigured) {
          state.values[idx] = getter(state);
          return 1;
        } else {
          let depChanged = depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some((addr) => (ensureAddr(state, addr) & 1) > 0);
          if (!depChanged)
            return 0;
          let newVal = getter(state), oldVal = tr.startState.values[idx];
          if (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))
            return 0;
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compare2(a[i], b[i]))
        return false;
    return true;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    return (state, tr) => {
      let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;
      let changed = oldAddr == null;
      for (let dynAddr of dynamic) {
        if (ensureAddr(state, dynAddr) & 1)
          changed = true;
      }
      if (!changed)
        return 0;
      let values2 = [];
      for (let i = 0; i < providerAddrs.length; i++) {
        let value = getAddr(state, providerAddrs[i]);
        if (providerTypes[i] == 2)
          for (let val of value)
            values2.push(val);
        else
          values2.push(value);
      }
      let newVal = facet.combine(values2);
      if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))
        return 0;
      state.values[idx] = newVal;
      return 1;
    };
  }
  function maybeIndex(state, id) {
    let found = state.config.address[id];
    return found == null ? null : found >> 1;
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id, createF, updateF, compareF, spec) {
      this.id = id;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config) {
      let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
      if (config.provide)
        field.provides = config.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i) => i.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return (state, tr) => {
        if (!tr || tr.reconfigured && maybeIndex(tr.startState, this.id) == null) {
          state.values[idx] = this.create(state);
          return 1;
        }
        let oldVal, changed = 0;
        if (tr.reconfigured) {
          oldVal = tr.startState.values[maybeIndex(tr.startState, this.id)];
          changed = 1;
        } else {
          oldVal = tr.startState.values[idx];
        }
        let value = this.updateF(oldVal, tr);
        if (!changed && !this.compareF(oldVal, value))
          changed = 1;
        if (changed)
          state.values[idx] = value;
        return changed;
      };
    }
    init(create) {
      return [this, initField.of({ field: this, create })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { fallback: 3, default: 2, extend: 1, override: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    fallback: /* @__PURE__ */ prec(Prec_.fallback),
    default: /* @__PURE__ */ prec(Prec_.default),
    extend: /* @__PURE__ */ prec(Prec_.extend),
    override: /* @__PURE__ */ prec(Prec_.override)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = Object.create(null);
      let newCompartments = new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field.slot(a));
      }
      for (let id in facets) {
        let providers = facets[id], facet = providers[0].facet;
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          let value = facet.combine(providers.map((p) => p.value));
          let oldAddr = oldState ? oldState.config.address[facet.id] : null;
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (facet.compare(value, oldVal))
              value = oldVal;
          }
          staticValues.push(value);
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      return new Configuration(base2, newCompartments, dynamicSlots.map((f) => f(address)), address, staticValues);
    }
  };
  function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], []];
    let seen = new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known >= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext)
          inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, prec2);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state.status[idx] = 4;
    let changed = state.config.dynamicSlots[idx](state, state.applying);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : false
  });
  var Annotation = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map2) {
      this.map = map2;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction = class {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time))
        this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e = this.annotation(Transaction.userEvent);
      return e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == ".");
    }
  };
  Transaction.time = /* @__PURE__ */ Annotation.define();
  Transaction.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA2 = 0, iB = 0; ; ) {
      let from, to;
      if (iA2 < a.length && (iB == b.length || b[iB] >= a[iA2])) {
        from = a[iA2++];
        to = a[iA2++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a3;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a3 = a.selection) === null || _a3 === void 0 ? void 0 : _a3.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i = 1; i < specs.length; i++) {
      if (specs[i].filter === false)
        filter = false;
      let seq = !!specs[i].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.invertedDesc;
      }
      tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
      let filtered = filters[i](tr);
      if (filtered instanceof Transaction)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
        tr = filtered[0];
      else
        tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
      let extension = extenders[i](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_14) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
      let ch2 = str[i];
      if (/\w/.test(ch2) || ch2 > "\x80" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i = 0; i < wordChars.length; i++)
        if (char.indexOf(wordChars[i]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config, doc2, selection, tr = null) {
      this.config = config;
      this.doc = doc2;
      this.selection = selection;
      this.applying = null;
      this.status = config.statusTemplate.slice();
      if (tr && tr.startState.config == config) {
        this.values = tr.startState.values.slice();
      } else {
        this.values = config.dynamicSlots.map((_14) => null);
        if (tr)
          for (let id in config.address) {
            let cur = config.address[id], prev = tr.startState.config.address[id];
            if (prev != null && (cur & 1) == 0)
              this.values[cur >> 1] = getAddr(tr.startState, prev);
          }
      }
      this.applying = tr;
      if (tr)
        tr._state = this;
      for (let i = 0; i < this.config.dynamicSlots.length; i++)
        ensureAddr(this, i << 1);
      this.applying = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      new EditorState(conf || Configuration.resolve(base2, compartments, this), tr.newDoc, tr.newSelection, tr);
    }
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range) => ({
        changes: { from: range.from, to: range.to, insert: text },
        range: EditorSelection.cursor(range.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i = 1; i < sel.ranges.length; i++) {
        let result = f(sel.ranges[i]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
      });
    }
    static create(config = {}) {
      let configuration = Configuration.resolve(config.extensions || [], new Map());
      let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new EditorState(configuration, doc2, selection);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase) {
      for (let map2 of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map2, phrase))
          return map2[phrase];
      return phrase;
    }
    languageDataAt(name2, pos, side = -1) {
      let values2 = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2))
            values2.push(result[name2]);
        }
      }
      return values2;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text, from, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start2 = pos - from, end = pos - from;
      while (start2 > 0) {
        let prev = findClusterBreak(text, start2, false);
        if (cat(text.slice(prev, start2)) != CharCategory.Word)
          break;
        start2 = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start2 == end ? null : EditorSelection.range(start2 + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.length ? values2[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define();
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults2, combine = {}) {
    let result = {};
    for (let config of configs)
      for (let key of Object.keys(config)) {
        let value = config[key], current = result[key];
        if (current === void 0)
          result[key] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key))
          result[key] = combine[key](current, value);
        else
          throw new Error("Config merge conflict for field " + key);
      }
    for (let key in defaults2)
      if (result[key] === void 0)
        result[key] = defaults2[key];
    return result;
  }

  // ../../node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id = top[COUNT] || 1;
      top[COUNT] = id + 1;
      return C + id.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return root[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i = 0; i < modules.length; i++) {
        let mod = modules[i], index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text = "";
        for (let i = 0; i < this.modules.length; i++)
          text += this.modules[i].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
  };

  // ../../node_modules/@codemirror/rangeset/dist/index.js
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return new Range(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i = 0; i < this.value.length; i++) {
        let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer = RangeSet.empty, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk)
        size += chunk.value.length;
      return size;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      let { add = [], sort: sort2 = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add.length == 0 && !filter)
        return this;
      if (sort2)
        add.slice().sort(cmpRange);
      if (this.isEmpty)
        return add.length ? RangeSet.of(add) : this;
      let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur.value || i < add.length) {
        if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
          let range = add[i++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
          cur.nextChunk();
        } else {
          if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
            if (!builder.addInner(cur.from, cur.to, cur.value))
              spill.push(new Range(cur.from, cur.to, cur.value));
          }
          cur.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.length == 0 || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        let touch = changes.touchesRange(start2, start2 + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start2));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start2, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty)
        return;
      for (let i = 0; i < this.chunk.length; i++) {
        let start2 = this.chunkPos[i], chunk = this.chunk[i];
        if (to >= start2 && from <= start2 + chunk.length && chunk.between(start2, from - start2, to - start2, f) === false)
          return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set5) => set5.maxPoint >= 500 || !set5.isEmpty && newSets.indexOf(set5) < 0 && set5.maxPoint >= minPointSize);
      let b = newSets.filter((set5) => set5.maxPoint >= 500 || !set5.isEmpty && oldSets.indexOf(set5) < 0 && set5.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9;
      let a = oldSets.filter((set5) => !set5.isEmpty && newSets.indexOf(set5) < 0);
      let b = newSets.filter((set5) => !set5.isEmpty && oldSets.indexOf(set5) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to >= to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let open = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);
          open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, open);
          open = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          break;
        pos = cursor.to;
        cursor.next();
      }
      return open;
    }
    static of(ranges, sort2 = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range ? [ranges] : sort2 ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
        let cur = ranges[i];
        if (cmpRange(prev, cur) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b) {
    let inA = new Map();
    for (let set5 of a)
      for (let i = 0; i < set5.chunk.length; i++)
        if (set5.chunk[i].maxPoint < 500)
          inA.set(set5.chunk[i], set5.chunkPos[i]);
    let shared = new Set();
    for (let set5 of b)
      for (let i = 0; i < set5.chunk.length; i++)
        if (inA.get(set5.chunk[i]) == set5.chunkPos[i])
          shared.add(set5.chunk[i]);
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i = 0; i < sets.length; i++) {
        for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
          if (cur.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur, skip, minPoint, i));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur of this.heap)
        cur.goto(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur of this.heap)
        cur.forward(pos, side);
      for (let i = this.heap.length >> 1; i >= 0; i--)
        heapBubble(this.heap, i);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index) {
    for (let cur = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur.compare(child) < 0)
        break;
      heap[childIndex] = cur;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove3(this.active, index);
      remove3(this.activeTo, index);
      remove3(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i = 0, { value, to, rank } = this.cursor;
      while (i < this.activeRank.length && this.activeRank[i] <= rank)
        i++;
      insert(this.active, i, value);
      insert(this.activeTo, i, to);
      insert(this.activeRank, i, rank);
      if (trackOpen)
        insert(trackOpen, i, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove3(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            if (this.cursor.from < from)
              trackExtra = 1;
            this.cursor.next();
            if (this.to > from)
              this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        let openStart = 0;
        while (openStart < trackOpen.length && trackOpen[openStart] < from)
          openStart++;
        this.openStart = openStart + trackExtra;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i = this.active.length - 1; i >= 0; i--) {
        if (this.activeRank[i] < this.pointRank)
          break;
        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
          active.push(this.active[i]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (a[i] != b[i] && !a[i].eq(b[i]))
        return false;
    return true;
  }
  function remove3(array2, index) {
    for (let i = index, e = array2.length - 1; i < e; i++)
      array2[i] = array2[i + 1];
    array2.pop();
  }
  function insert(array2, index, value) {
    for (let i = array2.length - 1; i >= index; i--)
      array2[i + 1] = array2[i];
    array2[index] = value;
  }
  function findMinIndex(value, array2) {
    let found = -1, foundPos = 1e9;
    for (let i = 0; i < array2.length; i++)
      if ((array2[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
        found = i;
        foundPos = array2[i];
      }
    return found;
  }

  // ../../node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    229: "q"
  };
  var shift2 = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"',
    229: "Q"
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;
  for (i = 0; i < 10; i++)
    base[48 + i] = base[96 + i] = String(i);
  var i;
  for (i = 1; i <= 24; i++)
    base[i + 111] = "F" + i;
  var i;
  for (i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift2[i] = String.fromCharCode(i);
  }
  var i;
  for (code in base)
    if (!shift2.hasOwnProperty(code))
      shift2[code] = base[code];
  var code;
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;
    var name2 = !ignoreKey && event.key || (event.shiftKey ? shift2 : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc")
      name2 = "Escape";
    if (name2 == "Del")
      name2 = "Delete";
    if (name2 == "Left")
      name2 = "ArrowLeft";
    if (name2 == "Up")
      name2 = "ArrowUp";
    if (name2 == "Right")
      name2 = "ArrowRight";
    if (name2 == "Down")
      name2 = "ArrowDown";
    return name2;
  }

  // ../../node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement() {
    let elt = document.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains(dom, selection.anchorNode);
    } catch (_14) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3)
      return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
      return dom.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  var ScrollSpace = 5;
  function scrollRectIntoView(dom, rect, side) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView;
    for (let cur = dom.parentNode; cur; ) {
      if (cur.nodeType == 1) {
        let bounding, top2 = cur == doc2.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
            cur = cur.parentNode;
            continue;
          }
          let rect2 = cur.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (rect.top < bounding.top) {
          moveY = -(bounding.top - rect.top + ScrollSpace);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + moveY + ScrollSpace;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + ScrollSpace;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect.top + ScrollSpace);
        }
        if (rect.left < bounding.left) {
          moveX = -(bounding.left - rect.left + ScrollSpace);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + moveX + ScrollSpace;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + ScrollSpace;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect.left + ScrollSpace);
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            if (moveY) {
              let start2 = cur.scrollTop;
              cur.scrollTop += moveY;
              moveY = cur.scrollTop - start2;
            }
            if (moveX) {
              let start2 = cur.scrollLeft;
              cur.scrollLeft += moveX;
              moveX = cur.scrollLeft - start2;
            }
            rect = {
              left: rect.left - moveX,
              top: rect.top - moveY,
              right: rect.right - moveX,
              bottom: rect.bottom - moveY
            };
          }
        }
        if (top2)
          break;
        cur = cur.assignedSlot || cur.parentNode;
      } else if (cur.nodeType == 11) {
        cur = cur.host;
      } else {
        break;
      }
    }
  }
  var DOMSelection = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    set(domSel) {
      this.anchorNode = domSel.anchorNode;
      this.anchorOffset = domSel.anchorOffset;
      this.focusNode = domSel.focusNode;
      this.focusOffset = domSel.focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
      stack.push(cur, cur.scrollTop, cur.scrollLeft);
      if (cur == cur.ownerDocument)
        break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i = 0; i < stack.length; ) {
        let elt = stack[i++], top2 = stack[i++], left = stack[i++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name2, code) {
    let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  var _plainTextSupported = null;
  function contentEditablePlainTextSupported() {
    if (_plainTextSupported == null) {
      _plainTextSupported = false;
      let dummy = document.createElement("div");
      try {
        dummy.contentEditable = "plaintext-only";
        _plainTextSupported = dummy.contentEditable == "plaintext-only";
      } catch (_14) {
      }
    }
    return _plainTextSupported;
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  };
  var none$3 = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get editorView() {
      if (!this.parent)
        throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      var _a3;
      if (this.dirty & 2) {
        let parent = this.dom, pos = null;
        for (let child of this.children) {
          if (child.dirty) {
            let next2 = pos ? pos.nextSibling : parent.firstChild;
            if (!child.dom && next2 && !((_a3 = ContentView.get(next2)) === null || _a3 === void 0 ? void 0 : _a3.parent))
              child.reuseDOM(next2);
            child.sync(track);
            child.dirty = 0;
          }
          if (track && track.node == parent && pos != child.dom)
            track.written = true;
          syncNodeInto(parent, pos, child.dom);
          pos = child.dom;
        }
        let next = pos ? pos.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
      return false;
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i = 0, pos = 0; ; i++) {
        let child = this.children[i];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children = none$3) {
      this.markDirty();
      for (let i = from; i < to; i++) {
        let child = this.children[i];
        if (child.parent == this)
          child.parent = null;
      }
      this.children.splice(from, to - from, ...children);
      for (let i = 0; i < children.length; i++)
        children[i].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  function syncNodeInto(parent, after, dom) {
    let next = after ? after.nextSibling : parent.firstChild;
    if (dom.parentNode == parent)
      while (next != dom)
        next = rm(next);
    else
      parent.insertBefore(dom, next);
  }
  var ChildCursor = class {
    constructor(children, pos, i) {
      this.children = children;
      this.pos = pos;
      this.i = i;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  var [nav, doc] = typeof navigator != "undefined" ? [navigator, document] : [{ userAgent: "", vendor: "", platform: "" }, { documentElement: { style: {} } }];
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari2 = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var browser = {
    mac: /* @__PURE__ */ /Mac/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios: safari2 && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari: safari2,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var none$2 = [];
  var InlineView = class extends ContentView {
    become(_other) {
      return false;
    }
    getSide() {
      return 0;
    }
  };
  InlineView.prototype.children = none$2;
  var MaxJoinLen = 256;
  var TextView = class extends InlineView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType != 3)
        return false;
      this.createDOM(dom);
      return true;
    }
    merge(from, to, source) {
      if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    slice(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends InlineView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch2 of children)
        ch2.setParent(this);
    }
    createDOM() {
      let dom = document.createElement(this.mark.tagName);
      if (this.mark.class)
        dom.className = this.mark.class;
      if (this.mark.attrs)
        for (let name2 in this.mark.attrs)
          dom.setAttribute(name2, this.mark.attrs[name2]);
      this.setDOM(dom);
    }
    sync(track) {
      if (!this.dom || this.dirty & 4)
        this.createDOM();
      super.sync(track);
    }
    merge(from, to, source, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    slice(from) {
      let result = [], off = 0, detachFrom = -1, i = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.slice(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i;
        off = end;
        i++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1)
        this.replaceChildren(detachFrom, this.children.length);
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this.dom, this.children, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else
        to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r6) => r6.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect;
  }
  var WidgetView = class extends InlineView {
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
    }
    static create(widget, length, side) {
      return new (widget.customView || WidgetView)(widget, length, side);
    }
    slice(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let view = top2.editorView, text = view && view.state.doc, start2 = this.posAtStart;
      return text ? text.slice(start2, start2 + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
        rect = rects[i];
        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      return new DOMPos(this.widget.text, pos);
    }
    sync() {
      if (!this.dom)
        this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      return textCoords(this.widget.text, pos, side);
    }
  };
  function mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of elts)
      dLen += view.length;
    parent.length += dLen;
    let { children } = parent;
    if (fromI == toI && fromOff) {
      let start2 = children[fromI];
      if (elts.length == 1 && start2.merge(fromOff, toOff, elts[0], openStart, openEnd))
        return;
      if (elts.length == 0) {
        start2.merge(fromOff, toOff, null, openStart, openEnd);
        return;
      }
      let after = start2.slice(toOff);
      if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))
        elts[elts.length - 1] = after;
      else
        elts.push(after);
      toI++;
      openEnd = toOff = 0;
    }
    if (toOff) {
      let end = children[toI];
      if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {
        elts.pop();
        openEnd = elts.length ? 0 : openStart;
      } else {
        end.merge(0, toOff, null, 0, 0);
      }
    } else if (toI < children.length && elts.length && children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {
      elts.pop();
      openEnd = elts.length ? 0 : openStart;
    }
    if (fromOff) {
      let start2 = children[fromI];
      if (elts.length && start2.merge(fromOff, start2.length, elts[0], openStart, 0)) {
        elts.shift();
        openStart = elts.length ? 0 : openEnd;
      } else {
        start2.merge(fromOff, start2.length, null, 0, 0);
      }
      fromI++;
    } else if (fromI && elts.length) {
      let end = children[fromI - 1];
      if (end.merge(end.length, end.length, elts[0], openStart, 0)) {
        elts.shift();
        openStart = elts.length ? 0 : openEnd;
      }
    }
    while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {
      elts.pop();
      toI--;
      openEnd = elts.length ? 0 : openStart;
    }
    while (fromI < toI && elts.length && children[fromI].become(elts[0])) {
      elts.shift();
      fromI++;
      openStart = elts.length ? 0 : openEnd;
    }
    if (!elts.length && fromI && toI < children.length && children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))
      fromI--;
    if (elts.length || fromI != toI)
      parent.replaceChildren(fromI, toI, elts);
  }
  function inlineDOMAtPos(dom, children, pos) {
    let i = 0;
    for (let off = 0; i < children.length; i++) {
      let child = children[i], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (; i > 0; i--) {
      let before = children[i - 1].dom;
      if (before.parentNode == dom)
        return DOMPos.after(before);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    for (let off = 0, i = 0; i < view.children.length; i++) {
      let child = view.children[i], end = off + child.length, next;
      if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {
        let flatten2 = 0;
        if (end == off) {
          if (child.getSide() <= 0)
            continue;
          flatten2 = side = -child.getSide();
        }
        let rect = child.coordsAt(pos - off, side);
        return flatten2 && rect ? flattenRect(rect, side < 0) : rect;
      }
      off = end;
    }
    let last = view.dom.lastChild;
    if (!last)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1];
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class)
        target.class += " " + source.class;
      else if (name2 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name2] = source[name2];
    }
    return target;
  }
  function attrsEq(a, b) {
    if (a == b)
      return true;
    if (!a || !b)
      return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
      return false;
    for (let key of keysA) {
      if (keysB.indexOf(key) == -1 || a[key] !== b[key])
        return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    if (prev) {
      for (let name2 in prev)
        if (!(attrs && name2 in attrs))
          dom.removeAttribute(name2);
    }
    if (attrs) {
      for (let name2 in attrs)
        if (!(prev && prev[name2] == attrs[name2]))
          dom.setAttribute(name2, attrs[name2]);
    }
  }
  var WidgetType = class {
    eq(_widget) {
      return false;
    }
    updateDOM(_dom) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(_event) {
      return true;
    }
    get customView() {
      return null;
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0;
      if (spec.block)
        side += (2e8 + 1) * (side > 0 ? 1 : -1);
      return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block;
      let { start: start2, end } = getInclusive(spec);
      let startSide = block ? -2e8 * (start2 ? 2 : 1) : 1e8 * (start2 ? -1 : 1);
      let endSide = block ? 2e8 * (end ? 2 : 1) : 1e8 * (end ? 1 : -1);
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort2 = false) {
      return RangeSet.of(of, sort2);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start: start2, end } = getInclusive(spec);
      super(1e8 * (start2 ? -1 : 1), 1e8 * (end ? 1 : -1), null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-1e8, -1e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide < 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec) {
    let { inclusiveStart: start2, inclusiveEnd: end } = spec;
    if (start2 == null)
      start2 = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start2 || false, end: end || false };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin > from)
      ranges[last] = Math.max(ranges[last], to);
    else
      ranges.push(from, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source, takeDeco, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (takeDeco)
        this.setDeco(source ? source.attrs : null);
      mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i].slice(off), 0);
        this.children[i].merge(off, this.children[i].length, null, 0, 0);
        i++;
      }
      for (let j = i; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i > 0 && this.children[i - 1].length == 0) {
        this.children[i - 1].parent = null;
        i--;
      }
      this.children.length = i;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this.dom, this.children, pos);
    }
    sync(track) {
      if (!this.dom || this.dirty & 4) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView)
        last = last.lastChild;
      if (!last || last.nodeName != "BR" && ContentView.get(last) instanceof WidgetView && (!browser.ios || !this.children.some((ch2) => ch2 instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0;
      for (let child of this.children) {
        if (!(child instanceof TextView))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
      }
      return {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length
      };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    match(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i = 0, off = 0; ; i++) {
        let block = docView.children[i], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (block.length)
            return null;
        }
        off = end + block.breakAfter;
      }
    }
  };
  var none$1 = [];
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length, type) {
      super();
      this.widget = widget;
      this.length = length;
      this.type = type;
      this.breakAfter = 0;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      return new BlockWidgetView(this.widget, len, this.type);
    }
    get children() {
      return none$1;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    match(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine)
        this.content.push(this.curLine = new LineView());
      return this.curLine;
    }
    addWidget(view) {
      this.curLine = null;
      this.content.push(view);
    }
    finish() {
      if (!this.posCovered())
        this.getLine();
    }
    wrapMarks(view, active) {
      for (let mark of active)
        view = new MarkView(mark, [view], view.length);
      return view;
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.curLine = null;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart) {
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let { type } = deco;
          if (type == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
        } else {
          let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide), active);
          this.getLine().append(widget, openStart);
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from, to, decorations2) {
      let builder = new ContentBuilder(text, from, to);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish();
      return builder;
    }
  };
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
  };
  var none2 = [];
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var scrollTo = /* @__PURE__ */ StateEffect.define({
    map: (range, changes) => range.map(changes)
  });
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context)
      console.error(context + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
  var PluginFieldProvider = class {
    constructor(field, get4) {
      this.field = field;
      this.get = get4;
    }
  };
  var PluginField = class {
    from(get4) {
      return new PluginFieldProvider(this, get4);
    }
    static define() {
      return new PluginField();
    }
  };
  PluginField.decorations = /* @__PURE__ */ PluginField.define();
  PluginField.atomicRanges = /* @__PURE__ */ PluginField.define();
  PluginField.scrollMargins = /* @__PURE__ */ PluginField.define();
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id, create, fields) {
      this.id = id;
      this.create = create;
      this.fields = fields;
      this.extension = viewPlugin.of(this);
    }
    static define(create, spec) {
      let { eventHandlers, provide, decorations: decorations2 } = spec || {};
      let fields = [];
      if (provide)
        for (let provider of Array.isArray(provide) ? provide : [provide])
          fields.push(provider);
      if (eventHandlers)
        fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));
      if (decorations2)
        fields.push(PluginField.decorations.from(decorations2));
      return new ViewPlugin(nextPluginID++, create, fields);
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var domEventHandlers = /* @__PURE__ */ PluginField.define();
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    takeField(type, target) {
      for (let { field, get: get4 } of this.spec.fields)
        if (field == type)
          target.push(get4(this.value));
    }
    update(view) {
      if (!this.value) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          return PluginInstance.dummy;
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (!this.value.update)
          return this;
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_14) {
            }
          return PluginInstance.dummy;
        }
      }
      return this;
    }
    destroy(view) {
      var _a3;
      if ((_a3 = this.value) === null || _a3 === void 0 ? void 0 : _a3.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
        }
      }
    }
  };
  PluginInstance.dummy = /* @__PURE__ */ new PluginInstance(/* @__PURE__ */ ViewPlugin.define(() => ({})));
  var editorAttributes = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.reduce((a, b) => combineAttrs(b, a), {})
  });
  var contentAttributes = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.reduce((a, b) => combineAttrs(b, a), {})
  });
  var decorations = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set5) {
      let i = set5.length, me = this;
      for (; i > 0; i--) {
        let range = set5[i - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set5.splice(i - 1, 1);
      }
      set5.splice(i, 0, me);
      return set5;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view, state, transactions = none2) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        view.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
      if (this.docChanged)
        this.flags |= 2;
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return this.transactions.some((tr) => tr.docChanged);
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var DocView = class extends ContentView {
    constructor(view) {
      super();
      this.view = view;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);
    }
    get root() {
      return this.view.root;
    }
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update) {
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update.transactions.length)
        this.compositionDeco = computeCompositionDeco(this.view, update.changes);
      let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      let pointerSel = update.transactions.some((tr) => tr.isUserEvent("select.pointer"));
      if (this.dirty == 0 && changedRanges.length == 0 && !(update.flags & 4) && update.state.selection.main.from >= this.view.viewport.from && update.state.selection.main.to <= this.view.viewport.to) {
        this.updateSelection(forceSelection, pointerSel);
        return false;
      } else {
        this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);
        return true;
      }
    }
    updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {
      this.updateChildren(changes, deco, oldLength);
      let { observer: observer3 } = this.view;
      observer3.ignore(() => {
        this.dom.style.height = this.view.viewState.domHeight + "px";
        this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer3.selectionRange.focusNode, written: false } : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer3.selectionRange.focusNode != track.node))
          forceSelection = true;
        this.updateSelection(forceSelection, pointerSel);
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer3.updateGaps(gaps);
    }
    updateChildren(changes, deco, oldLength) {
      let cursor = this.childCursor(oldLength);
      for (let i = changes.length - 1; ; i--) {
        let next = i >= 0 ? changes[i] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next;
        let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        this.replaceRange(fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    replaceRange(fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd) {
      let before = this.children[fromI], last = content2.length ? content2[content2.length - 1] : null;
      let breakAtEnd = last ? last.breakAfter : breakAtStart;
      if (fromI == toI && !breakAtStart && !breakAtEnd && content2.length < 2 && before.merge(fromOff, toOff, content2.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
      let after = this.children[toI];
      if (toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          content2[content2.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          content2.push(after);
        }
      } else if (after.breakAfter) {
        if (last)
          last.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && content2.length && before.merge(fromOff, before.length, content2[0], false, openStart, 0)) {
          before.breakAfter = content2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
      while (fromI < toI && content2.length) {
        if (this.children[toI - 1].match(content2[content2.length - 1]))
          toI--, content2.pop();
        else if (this.children[fromI].match(content2[0]))
          fromI++, content2.shift();
        else
          break;
      }
      if (fromI < toI || content2.length)
        this.replaceChildren(fromI, toI, content2);
    }
    updateSelection(force = false, fromPointer = false) {
      if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart)
        return;
      let main = this.view.state.selection.main;
      let anchor = this.domAtPos(main.anchor);
      let head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          let rawSel = getSelection(this.root);
          if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text)
                  anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            rawSel.extend(head.node, head.offset);
          } else {
            let range = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.view.composing)
        return;
      let cursor = this.view.state.selection.main;
      let sel = getSelection(this.root);
      if (!cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    }
    mayControlSelection() {
      return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
    }
    nearest(dom) {
      for (let cur = dom; cur; ) {
        let domView = ContentView.get(cur);
        if (domView && domView.rootView == this)
          return domView;
        cur = cur.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i, off } = this.childCursor().findPos(pos, -1);
      for (; i < this.children.length - 1; ) {
        let child = this.children[i];
        if (off < child.length || child instanceof LineView)
          break;
        i++;
        off = 0;
      }
      return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i = this.children.length - 1; ; i--) {
        let child = this.children[i], start2 = off - child.breakAfter - child.length;
        if (pos > start2 || pos == start2 && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start2, side);
        off = start2;
      }
    }
    measureVisibleLineHeights() {
      let result = [], { from, to } = this.view.viewState.viewport;
      let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      for (let pos = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          result.push(child.dom.getBoundingClientRect().height);
          let width = child.dom.scrollWidth;
          if (width > minWidth) {
            this.minWidth = minWidth = width;
            this.minWidthFrom = pos;
            this.minWidthTo = end;
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth;
      dummy.className = "cm-line";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return { lineHeight, charWidth };
    }
    childCursor(pos = this.length) {
      let i = this.children.length;
      if (i)
        pos -= this.children[--i].length;
      return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i = 0; ; i++) {
        let next = i == vs.viewports.length ? null : vs.viewports[i];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;
          deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      return this.decorations = [
        ...this.view.pluginField(PluginField.decorations),
        ...this.view.state.facet(decorations),
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollRangeIntoView(range) {
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.pluginField(PluginField.scrollMargins))
        if (margins) {
          let { left, right, top: top2, bottom } = margins;
          if (left != null)
            mLeft = Math.max(mLeft, left);
          if (right != null)
            mRight = Math.max(mRight, right);
          if (top2 != null)
            mTop = Math.max(mTop, top2);
          if (bottom != null)
            mBottom = Math.max(mBottom, bottom);
        }
      scrollRectIntoView(this.dom, {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      }, range.head < range.anchor ? -1 : 1);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function computeCompositionDeco(view, changes) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return Decoration.none;
    let cView = view.docView.nearest(textNode);
    let from, to, topNode = textNode;
    if (cView instanceof InlineView) {
      while (cView.parent instanceof InlineView)
        cView = cView.parent;
      from = cView.posAtStart;
      to = from + cView.length;
      topNode = cView.dom;
    } else if (cView instanceof LineView) {
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
    } else {
      return Decoration.none;
    }
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let text = textNode.nodeValue, { state } = view;
    if (newTo - newFrom < text.length) {
      if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)
        newTo = newFrom + text.length;
      else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)
        newFrom = newTo - text.length;
      else
        return Decoration.none;
    } else if (state.sliceDoc(newFrom, newTo) != text) {
      return Decoration.none;
    }
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(topNode, textNode) }).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top2, text) {
      super();
      this.top = top2;
      this.text = text;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(node, offset, side) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
      result.push(1 << +str[i]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r6 = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r6;
    Brackets[r6] = -l;
  }
  function charType(ch2) {
    return ch2 <= 247 ? LowTypes[ch2] : 1424 <= ch2 && ch2 <= 1524 ? 2 : 1536 <= ch2 && ch2 <= 1785 ? ArabicTypes[ch2 - 1536] : 1774 <= ch2 && ch2 <= 2220 ? 4 : 8192 <= ch2 && ch2 <= 8203 ? 256 : ch2 == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  var BidiSpan = class {
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i = 0; i < order.length; i++) {
        let span = order[i];
        if (span.from <= index && span.to >= index) {
          if (span.level == level)
            return i;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
            maybe = i;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < len - 1 && prev == types[i + 1] && prev & 24)
          type = types[i] = prev;
        else
          types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace2 = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++)
          types[j] = replace2;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
    for (let i = 0, sI = 0, context = 0, ch2, br, type; i < len; i++) {
      if (br = Brackets[ch2 = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch2;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur = BracketStack[sJ + 2];
          if (cur & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i = 0; i < len; i++) {
      if (types[i] == 256) {
        let end = i + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i ? types[i - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i; j < end; j++)
          types[j] = replace2;
        i = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i = 0; i < len; ) {
        let start2 = i, rtl = types[i++] != 1;
        while (i < len && rtl == (types[i] != 1))
          i++;
        if (rtl) {
          for (let j = i; j > start2; ) {
            let end = j, l = types[--j] != 2;
            while (j > start2 && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start2, i, 0));
        }
      }
    } else {
      for (let i = 0; i < len; ) {
        let start2 = i, rtl = types[i++] == 2;
        while (i < len && rtl == (types[i] == 2))
          i++;
        order.push(new BidiSpan(start2, i, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start2, forward) {
    var _a3;
    let startIndex = start2.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a3 = start2.bidiLevel) !== null && _a3 !== void 0 ? _a3 : -1, start2.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y);
    if (!closestX && closest.contentEditable == "true")
      return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
      let rects = textRange(node, i, i + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x - rect.left;
        let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i + (after ? 1 : 0) };
          closestOffset = i + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view, { x, y }, precise, bias = -1) {
    let content2 = view.contentDOM.getBoundingClientRect(), block;
    let halfLine = view.defaultLineHeight / 2;
    for (let bounced = false; ; ) {
      block = view.blockAtHeight(y, content2.top);
      if (block.top > y || block.bottom < y) {
        bias = block.top > y ? -1 : 1;
        y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));
        if (bounced)
          return precise ? null : 0;
        else
          bounced = true;
      }
      if (block.type == BlockType.Text)
        break;
      y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
    }
    let lineStart = block.from;
    x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : posAtCoordsImprecise(view, content2, block, x, y);
    let doc2 = view.dom.ownerDocument;
    let element = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(x, y);
    let node, offset = -1;
    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x, y);
        if (range) {
          ({ startContainer: node, startOffset: offset } = range);
          if (browser.safari && isSuspiciousCaretResult(node, offset, x))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let line = Math.floor((y - block.top) / view.defaultLineHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function moveToLineBoundary(view, start2, forward, includeWrap) {
    let line = view.state.doc.lineAt(start2.head);
    let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start2.assoc < 0 && start2.head > line.from ? start2.head - 1 : start2.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let pos = view.posAtCoords({
        x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start2.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view, start2, forward, by) {
    let line = view.state.doc.lineAt(start2.head), spans = view.bidiSpans(line);
    for (let cur = start2, check = null; ; ) {
      let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur;
      }
      cur = next;
    }
  }
  function byGroup(view, pos, start2) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start2);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start2, forward, distance) {
    let startPos = start2.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos);
    let goal = start2.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos);
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineAt(startPos, view.dom.getBoundingClientRect().top);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = dir < 0 ? line.top : line.bottom;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, void 0, void 0, goal);
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let atoms = view.pluginField(PluginField.atomicRanges);
    for (; ; ) {
      let moved = false;
      for (let set5 of atoms) {
        set5.between(pos.from - 1, pos.from + 1, (from, to, value) => {
          if (pos.from > from && pos.from < to) {
            pos = oldPos.from > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.pendingIOSKey = null;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.rapidCompositionStart = false;
      this.mouseSelection = null;
      for (let type in handlers) {
        let handler = handlers[type];
        view.contentDOM.addEventListener(type, (event) => {
          if (type == "keydown" && this.keydown(view, event))
            return;
          if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
            return;
          if (this.mustFlushObserver(event))
            view.observer.forceFlush();
          if (this.runCustomHandlers(type, view, event))
            event.preventDefault();
          else
            handler(view, event);
        });
        this.registeredEvents.push(type);
      }
      this.notifiedFocused = view.hasFocus;
      this.ensureHandlers(view);
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view) {
      let handlers2 = this.customHandlers = view.pluginField(domEventHandlers);
      for (let set5 of handlers2) {
        for (let type in set5.handlers)
          if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
            this.registeredEvents.push(type);
            view.contentDOM.addEventListener(type, (event) => {
              if (!eventBelongsToEditor(view, event))
                return;
              if (this.runCustomHandlers(type, view, event))
                event.preventDefault();
            });
          }
      }
    }
    runCustomHandlers(type, view, event) {
      for (let set5 of this.customHandlers) {
        let handler = set5.handlers[type], handled = false;
        if (handler) {
          try {
            handled = handler.call(set5.plugin, event, view);
          } catch (e) {
            logException(view.state, e);
          }
          if (handled || event.defaultPrevented) {
            if (browser.android && type == "keydown" && event.keyCode == 13)
              view.observer.flushSoon();
            return true;
          }
        }
      }
      return false;
    }
    runScrollHandlers(view, event) {
      for (let set5 of this.customHandlers) {
        let handler = set5.handlers.scroll;
        if (handler) {
          try {
            handler.call(set5.plugin, event, view);
          } catch (e) {
            logException(view.state, e);
          }
        }
      }
    }
    keydown(view, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (this.screenKeyEvent(view, event))
        return true;
      if (browser.ios && (event.keyCode == 13 || event.keyCode == 8) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
        this.pendingIOSKey = event.keyCode == 13 ? "enter" : "backspace";
        setTimeout(() => this.flushIOSKey(view), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view) {
      if (!this.pendingIOSKey)
        return false;
      let dom = view.contentDOM, key = this.pendingIOSKey;
      this.pendingIOSKey = null;
      return key == "enter" ? dispatchKey(dom, "Enter", 13) : dispatchKey(dom, "Backspace", 8);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && Date.now() - this.compositionEndedAt < 500) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    screenKeyEvent(view, event) {
      let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3;
      if (event.keyCode == 27)
        this.lastEscPress = Date.now();
      else if (modifierCodes.indexOf(event.keyCode) < 0)
        this.lastEscPress = 0;
      return protectedTab;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
    }
    startMouseSelection(view, event, style) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = new MouseSelection(this, view, event, style);
    }
    update(update) {
      if (this.mouseSelection)
        this.mouseSelection.update(update);
      if (update.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class {
    constructor(inputState, view, startEvent, style) {
      this.inputState = inputState;
      this.view = view;
      this.style = style;
      this.lastEvent = startEvent;
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragMove = dragMovesSelection(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.inputState.mouseSelection = null;
    }
    select(event) {
      let selection = this.style.get(event, this.extend, this.multiple);
      if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection,
          userEvent: "select.pointer",
          scrollIntoView: true
        });
    }
    update(update) {
      if (update.docChanged && this.dragging)
        this.dragging = this.dragging.map(update.changes);
      if (this.style.update(update))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    let { state } = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r6) => r6.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine)
          return { range };
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text.line(i++);
        return {
          changes: { from: range.from, to: range.to, insert: line.text },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
  };
  var lastTouch = 0;
  handlers.touchstart = (view, e) => {
    lastTouch = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (lastTouch > Date.now() - 2e3)
      return;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view, event);
    if (style) {
      if (view.root.activeElement != view.contentDOM)
        view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      view.inputState.startMouseSelection(view, event, style);
    }
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
  var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
      return 1;
    return before && insideY(y, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start2 = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    let last = start2, lastEvent = event;
    return {
      update(update) {
        if (update.changes) {
          if (start2)
            start2.pos = update.changes.mapPos(start2.pos);
          startSel = startSel.map(update.changes);
          lastEvent = null;
        }
      },
      get(event2, extend2, multiple) {
        let cur;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
          cur = last;
        else {
          cur = last = queryPos(view, event2);
          lastEvent = event2;
        }
        if (!cur || !start2)
          return startSel;
        let range = rangeForClick(view, cur.pos, cur.bias, type);
        if (start2.pos != cur.pos && !extend2) {
          let startRange = rangeForClick(view, start2.pos, start2.bias, type);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend2)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  handlers.dragstart = (view, event) => {
    let { selection: { main } } = view.state;
    let { mouseSelection } = view.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view, event, text, direct) {
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });
    if (dropPos == null || !text)
      return;
    event.preventDefault();
    let { mouseSelection } = view.inputState;
    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del ? "move.drop" : "input.drop"
    });
  }
  handlers.drop = (view, event) => {
    if (!event.dataTransfer)
      return;
    if (view.state.readOnly)
      return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
      event.preventDefault();
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i = 0; i < files.length; i++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i]);
      }
    } else {
      dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers.paste = (view, event) => {
    if (view.state.readOnly)
      return event.preventDefault();
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view);
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
      if (!range.empty) {
        content2.push(state.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
      return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/plain", text);
    } else {
      captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  handlers.focus = handlers.blur = (view) => {
    setTimeout(() => {
      if (view.hasFocus != view.inputState.notifiedFocused)
        view.update([]);
    }, 10);
  };
  handlers.beforeprint = (view) => {
    view.viewState.printing = true;
    view.requestMeasure();
    setTimeout(() => {
      view.viewState.printing = false;
      view.requestMeasure();
    }, 2e3);
  };
  function forceClearComposition(view, rapid) {
    if (view.docView.compositionDeco.size) {
      view.inputState.rapidCompositionStart = rapid;
      try {
        view.update([]);
      } finally {
        view.inputState.rapidCompositionStart = false;
      }
    }
  }
  handlers.compositionstart = handlers.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      if (view.docView.compositionDeco.size) {
        view.observer.flush();
        forceClearComposition(view, true);
      }
      view.inputState.composing = 0;
    }
  };
  handlers.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    setTimeout(() => {
      if (view.inputState.composing < 0)
        forceClearComposition(view, false);
    }, 50);
  };
  handlers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line"];
  var HeightOracle = class {
    constructor() {
      this.doc = Text.empty;
      this.lineWrapping = false;
      this.direction = Direction.LTR;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefresh(lineHeights, whiteSpace, direction) {
      let newHeight = false;
      for (let i = 0; i < lineHeights.length; i++) {
        let h = lineHeights[i];
        if (h < 0) {
          i++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight || wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;
    }
    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;
      this.lineWrapping = lineWrapping;
      this.direction = direction;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i = 0; i < knownHeights.length; i++) {
          let h = knownHeights[i];
          if (h < 0)
            i++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length, top2, height, type) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this.type = type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType2;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-4;
  var HeightMap = class {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this;
      for (let i = changes.length - 1; i >= 0; i--) {
        let { fromA, toA, fromB, toB } = changes[i];
        let start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        let end = start2.to >= toA ? start2 : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i > 0 && start2.from <= changes[i - 1].toA) {
          fromA = changes[i - 1].fromA;
          fromB = changes[i - 1].fromB;
          i--;
          if (fromA < start2.from)
            start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start2.from - fromA;
        fromA = start2.from;
        let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i == j) {
          if (before > after * 2) {
            let split = nodes[i - 1];
            if (split.break)
              nodes.splice(--i, 1, split.left, null, split.right);
            else
              nodes.splice(--i, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break)
              nodes.splice(j, 1, split.left, null, split.right);
            else
              nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i - 1] == null) {
        brk = 1;
        i--;
      } else if (nodes[i] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, type) {
      super(length, height);
      this.type = type;
    }
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc2, top2, offset) {
      return this.blockAt(0, doc2, top2, offset);
    }
    forEachLine(_from, _to, doc2, top2, offset, f) {
      f(this.blockAt(0, doc2, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    lines(doc2, offset) {
      let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
      return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
    }
    blockAt(height, doc2, top2, offset) {
      let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      let { from, length } = doc2.line(firstLine + line);
      return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc2, top2, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value, doc2, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        let { from: from2, to } = doc2.lineAt(value);
        return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
      }
      let { firstLine, lineHeight } = this.lines(doc2, offset);
      let { from, length, number: number2 } = doc2.lineAt(value);
      return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let { firstLine, lineHeight } = this.lines(doc2, offset);
      for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
        let line = doc2.lineAt(pos);
        if (pos == from)
          top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from);
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let line = new HeightMapText(len, measured.heights[measured.index++]);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        oracle.heightChanged = true;
        return HeightMap.of(nodes);
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc2, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc2, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, doc2, top2, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
        if (mid.to >= from && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText)
          last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText)
        return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent; ) {
      if (parent.nodeType == 1) {
        let style = window.getComputedStyle(parent);
        if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) && style.overflow != "visible") {
          let parentRect = parent.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? parent.offsetParent : parent.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: right - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size) {
      this.from = from;
      this.to = to;
      this.size = size;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        let gA2 = a[i], gB = b[i];
        if (gA2.from != gB.from || gA2.to != gB.to || gA2.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state) {
      this.state = state;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentWidth = 0;
      this.heightOracle = new HeightOracle();
      this.scaler = IdScaler;
      this.scrollTo = null;
      this.printing = false;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main } = this.state.selection;
      for (let i = 0; i <= 1; i++) {
        let pos = i ? main.head : main.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineAt(pos, 0);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    update(update, scrollTo2 = null) {
      let prev = this.state;
      this.state = update.state;
      let newDeco = this.state.facet(decorations);
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTo2 && (scrollTo2.head < viewport.from || scrollTo2.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTo2);
      this.viewport = viewport;
      this.updateForViewport();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15e3)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTo2)
        this.scrollTo = scrollTo2;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc)
        this.mustEnforceCursorAssoc = true;
    }
    measure(docView, repeated) {
      let dom = docView.dom, whiteSpace = "", direction = Direction.LTR;
      let result = 0;
      if (!repeated) {
        let style = window.getComputedStyle(dom);
        whiteSpace = style.whiteSpace, direction = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
          result |= 8;
          this.paddingTop = paddingTop;
          this.paddingBottom = paddingBottom;
        }
      }
      let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (!this.inView)
        return 0;
      let lineHeights = docView.measureVisibleLineHeights();
      let refresh = false, bias = 0, oracle = this.heightOracle;
      if (!repeated) {
        let contentWidth = docView.dom.clientWidth;
        if (oracle.mustRefresh(lineHeights, whiteSpace, direction) || oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {
          let { lineHeight, charWidth } = docView.measureTextSize();
          refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            docView.minWidth = 0;
            result |= 8;
          }
        }
        if (this.contentWidth != contentWidth) {
          this.contentWidth = contentWidth;
          result |= 8;
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
      }
      oracle.heightChanged = false;
      this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
      if (oracle.heightChanged)
        result |= 2;
      if (!this.viewportIsAppropriate(this.viewport, bias) || this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to))
        this.viewport = this.getViewport(bias, this.scrollTo);
      this.updateForViewport();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15e3)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top, 0);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom, 0);
    }
    getViewport(bias, scrollTo2) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map2 = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
      if (scrollTo2) {
        if (scrollTo2.head < viewport.from) {
          let { top: newTop } = map2.lineAt(scrollTo2.head, QueryType.ByPos, doc2, 0, 0);
          viewport = new Viewport(map2.lineAt(newTop - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map2.lineAt(newTop + (visibleBottom - visibleTop) + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        } else if (scrollTo2.head > viewport.to) {
          let { bottom: newBottom } = map2.lineAt(scrollTo2.head, QueryType.ByPos, doc2, 0, 0);
          viewport = new Viewport(map2.lineAt(newBottom - (visibleBottom - visibleTop) - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map2.lineAt(newBottom + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({ from, to }, bias = 0) {
      let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
      let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current) {
      let gaps = [];
      if (this.heightOracle.direction != Direction.LTR)
        return gaps;
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (line) => {
        if (line.length < 1e4)
          return;
        let structure = lineStructure(line.from, line.to, this.state);
        if (structure.total < 1e4)
          return;
        let viewFrom, viewTo;
        if (this.heightOracle.lineWrapping) {
          if (line.from != this.viewport.from)
            viewFrom = line.from;
          else
            viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);
          if (line.to != this.viewport.to)
            viewTo = line.to;
          else
            viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);
          viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);
        }
        let sel = this.state.selection.main;
        if (sel.from <= viewFrom && sel.to >= line.from)
          viewFrom = sel.from;
        if (sel.from <= line.to && sel.to >= viewTo)
          viewTo = sel.to;
        let gapTo = viewFrom - 1e4, gapFrom = viewTo + 1e4;
        if (gapTo > line.from + 5e3)
          gaps.push(find(current, (gap) => gap.from == line.from && gap.to > gapTo - 5e3 && gap.to < gapTo + 5e3) || new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));
        if (gapFrom < line.to - 5e3)
          gaps.push(find(current, (gap) => gap.to == line.to && gap.from > gapFrom - 5e3 && gap.from < gapFrom + 5e3) || new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));
      });
      return gaps;
    }
    gapSize(line, pos, start2, structure) {
      if (this.heightOracle.lineWrapping) {
        let height = line.height * findFraction(structure, pos);
        return start2 ? height : line.height - height;
      } else {
        let ratio = findFraction(structure, pos);
        return structure.total * this.heightOracle.charWidth * (start2 ? ratio : 1 - ratio);
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.state.facet(decorations);
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({ from, to });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r6, i) => r6.from != ranges[i].from || r6.to != ranges[i].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineAt(pos, editorTop) {
      editorTop += this.paddingTop;
      return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);
    }
    lineAtHeight(height, editorTop) {
      editorTop += this.paddingTop;
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);
    }
    blockAtHeight(height, editorTop) {
      editorTop += this.paddingTop;
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);
    }
    forEachLine(from, to, f, editorTop) {
      editorTop += this.paddingTop;
      return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : (b) => f(scaleBlock(b, this.scaler, editorTop)));
    }
    get contentHeight() {
      return this.domHeight + this.paddingTop + this.paddingBottom;
    }
    get domHeight() {
      return this.scaler.toDOM(this.heightMap.height, this.paddingTop);
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, state) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(state.facet(decorations), from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0; ; i++) {
      let { from, to } = ranges[i], size = to - from;
      if (dist <= size)
        return from + dist;
      dist -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find(array2, f) {
    for (let val of array2)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(doc2, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n, top2) {
      n -= top2;
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale + top2;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top) + top2;
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n, top2) {
      n -= top2;
      for (let i = 0, base2 = 0, domBase = 0; ; i++) {
        let vp = i < this.viewports.length ? this.viewports[i] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale + top2;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop) + top2;
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler, top2) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top, top2), bBottom = scaler.toDOM(block.bottom, top2);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler, top2)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      minHeight: "100%",
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none"
    },
    ".cm-lineWrapping": {
      whiteSpace: "pre-wrap",
      wordBreak: "break-word",
      overflowWrap: "anywhere"
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
      zIndex: -1,
      contain: "size style"
    },
    ".cm-selectionBackground": {
      position: "absolute"
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      zIndex: 100,
      contain: "size style",
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    ".cm-cursor": {
      position: "absolute",
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none",
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
    "&dark .cm-activeLine": { backgroundColor: "#223039" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "3px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view, onChange, onScrollChanged) {
      this.view = view;
      this.onChange = onChange;
      this.onScrollChanged = onScrollChanged;
      this.active = false;
      this.ignoreSelection = new DOMSelection();
      this.delayedFlush = -1;
      this.queue = [];
      this.lastFlush = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this._selectionRange = null;
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        this._selectionRange = null;
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.start();
      this.onScroll = this.onScroll.bind(this);
      window.addEventListener("scroll", this.onScroll);
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries2) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries2[entries2.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries2) => {
          if (entries2[entries2.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
    }
    onScroll(e) {
      if (this.intersecting)
        this.flush();
      this.onScrollChanged(e);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      if (this.lastFlush < Date.now() - 50)
        this._selectionRange = null;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event))
        return;
      if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush();
    }
    get selectionRange() {
      if (!this._selectionRange) {
        let { root } = this.view, sel = getSelection(root);
        if (browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM)
          sel = safariSelectionRangeHack(this.view) || sel;
        this._selectionRange = sel;
      }
      return this._selectionRange;
    }
    setSelectionRange(anchor, head) {
      var _a3;
      if (!((_a3 = this._selectionRange) === null || _a3 === void 0 ? void 0 : _a3.type))
        this._selectionRange = {
          anchorNode: anchor.node,
          anchorOffset: anchor.offset,
          focusNode: head.node,
          focusOffset: head.offset
        };
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
            i++;
          else if (!changed)
            changed = this.scrollTargets.slice(0, i);
          if (changed)
            changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i < this.scrollTargets.length && !changed)
        changed = this.scrollTargets.slice(0, i);
      if (changed) {
        for (let dom of this.scrollTargets)
          dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed)
          dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clearSelection() {
      this.ignoreSelection.set(this.selectionRange);
    }
    clear() {
      this.observer.takeRecords();
      this.queue.length = 0;
      this.clearSelection();
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = window.setTimeout(() => {
          this.delayedFlush = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        window.clearTimeout(this.delayedFlush);
        this.delayedFlush = -1;
        this.flush();
      }
    }
    flush() {
      if (this.delayedFlush >= 0)
        return;
      this.lastFlush = Date.now();
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let selection = this.selectionRange;
      let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);
      if (records.length == 0 && !newSel)
        return;
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to } = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      let startState = this.view.state;
      if (from > -1 || newSel)
        this.onChange(from, to, typeOver);
      if (this.view.state == startState) {
        if (this.view.docView.dirty) {
          this.ignore(() => this.view.docView.sync());
          this.view.docView.dirty = 0;
        }
        if (newSel)
          this.view.docView.updateSelection();
      }
      this.clearSelection();
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    destroy() {
      this.stop();
      if (this.intersection)
        this.intersection.disconnect();
      if (this.gapIntersection)
        this.gapIntersection.disconnect();
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      window.removeEventListener("scroll", this.onScroll);
      clearTimeout(this.parentCheck);
    }
  };
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view) {
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function applyDOMChange(view, start2, end, typeOver) {
    let change, newSel;
    let sel = view.state.selection.main, bounds;
    if (start2 > -1 && !view.state.readOnly && (bounds = view.docView.domBoundsAround(start2, end, 0))) {
      let { from, to } = bounds;
      let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view);
      reader.readRange(bounds.startDOM, bounds.endDOM);
      newSel = selectionFromPoints(selPoints, from);
      let preferredPos = sel.from, preferredSide = null;
      if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);
      if (diff)
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: view.state.toText(reader.text.slice(diff.from, diff.toB))
        };
    } else if (view.hasFocus || !view.state.facet(editable)) {
      let domSel = view.observer.selectionRange;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      if (head != sel.head || anchor != sel.anchor)
        newSel = EditorSelection.single(anchor, head);
    }
    if (!change && !newSel)
      return;
    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
      change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    if (change) {
      let startState = view.state;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)) || browser.ios && view.inputState.flushIOSKey(view))
        return;
      let text = change.insert.toString();
      if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
        return;
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change);
        tr = {
          changes,
          selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? startState.selection.replaceRange(newSel.main) : void 0
        };
      }
      let userEvent = "input.type";
      if (view.composing) {
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      view.dispatch(tr, { scrollIntoView: true, userEvent });
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({ selection: newSel, scrollIntoView, userEvent });
    }
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
      from++;
    if (from == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  var DOMReader = class {
    constructor(points, view) {
      this.points = points;
      this.view = view;
      this.text = "";
      this.lineBreak = view.state.lineBreak;
    }
    readRange(start2, end) {
      if (!start2)
        return;
      let parent = start2.parentNode;
      for (let cur = start2; ; ) {
        this.findPointBefore(parent, cur);
        this.readNode(cur);
        let next = cur.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore))
          this.text += this.lineBreak;
        cur = next;
      }
      this.findPointBefore(parent, end);
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      let text;
      if (fromView != null)
        text = fromView.sliceString(0, void 0, this.lineBreak);
      else if (node.nodeType == 3)
        text = node.nodeValue;
      else if (node.nodeName == "BR")
        text = node.nextSibling ? this.lineBreak : "";
      else if (node.nodeType == 1)
        this.readRange(node.firstChild, null);
      if (text != null) {
        this.findPointIn(node, text.length);
        this.text += text;
        if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\n\n$/.test(this.text))
          this.text = this.text.slice(0, -1);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointIn(node, maxLen) {
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, maxLen);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var EditorView = class {
    constructor(config = {}) {
      this.plugins = [];
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: absolute; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this.root = config.root || document;
      this.viewState = new ViewState(config.state || EditorState.create());
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec).update(this));
      this.observer = new DOMObserver(this, (from, to, typeOver) => {
        applyDOMChange(this, from, to, typeOver);
      }, (event) => {
        this.inputState.runScrollHandlers(this, event);
        if (this.observer.intersecting)
          this.measure();
      });
      this.inputState = new InputState(this);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      ensureGlobalHandler();
      this.requestMeasure();
      if (config.parent)
        config.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state);
      update = new ViewUpdate(this, state, transactions);
      let scrollPos = null;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollPos)
            scrollPos = scrollPos.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main } = tr.state.selection;
            scrollPos = main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1);
          }
          for (let e of tr.effects)
            if (e.is(scrollTo))
              scrollPos = e.value;
        }
        this.viewState.update(update, scrollPos);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        this.updateAttrs();
        this.showAnnouncements(transactions);
      } finally {
        this.updateState = 0;
      }
      if (redrawn || scrollPos || this.viewState.mustEnforceCursorAssoc)
        this.requestMeasure();
      if (!update.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update);
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      try {
        for (let plugin2 of this.plugins)
          plugin2.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec).update(this));
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin2 = this.plugins[found];
            plugin2.mustUpdate = update;
            newPlugins.push(plugin2);
          }
        }
        for (let plugin2 of this.plugins)
          if (plugin2.mustUpdate != update)
            plugin2.destroy(this);
        this.plugins = newPlugins;
        this.inputState.ensureHandlers(this);
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update;
      }
      for (let i = 0; i < this.plugins.length; i++)
        this.plugins[i] = this.plugins[i].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = -1;
      if (flush)
        this.observer.flush();
      let updated = null;
      try {
        for (let i = 0; ; i++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let changed = this.viewState.measure(this.docView, i > 0);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTo == null)
            break;
          if (i > 5) {
            console.warn("Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update = new ViewUpdate(this, this.state);
          update.flags |= changed;
          if (!updated)
            updated = update;
          else
            updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
          }
          this.updateAttrs();
          if (changed)
            this.docView.update(update);
          for (let i2 = 0; i2 < measuring.length; i2++)
            if (measured[i2] != BadMeasure) {
              try {
                measuring[i2].write(measured[i2], this);
              } catch (e) {
                logException(this.state, e);
              }
            }
          if (this.viewState.scrollTo) {
            this.docView.scrollRangeIntoView(this.viewState.scrollTo);
            this.viewState.scrollTo = null;
          }
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
      }
      this.measureScheduled = -1;
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      this.editorAttrs = editorAttrs;
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        contenteditable: !this.state.facet(editable) ? "false" : contentEditablePlainTextSupported() ? "plaintext-only" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      combineAttrs(this.state.facet(contentAttributes), contentAttrs);
      updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      this.contentAttrs = contentAttrs;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (let i = 0; i < this.measureRequests.length; i++) {
            if (this.measureRequests[i].key === request.key) {
              this.measureRequests[i] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    pluginField(field) {
      let result = [];
      for (let plugin2 of this.plugins)
        plugin2.update(this).takeField(field, result);
      return result;
    }
    plugin(plugin2) {
      for (let inst of this.plugins)
        if (inst.spec == plugin2)
          return inst.update(this).value;
      return null;
    }
    blockAtHeight(height, docTop) {
      this.readMeasured();
      return this.viewState.blockAtHeight(height, ensureTop(docTop, this.contentDOM));
    }
    visualLineAtHeight(height, docTop) {
      this.readMeasured();
      return this.viewState.lineAtHeight(height, ensureTop(docTop, this.contentDOM));
    }
    viewportLines(f, docTop) {
      let { from, to } = this.viewport;
      this.viewState.forEachLine(from, to, f, ensureTop(docTop, this.contentDOM));
    }
    visualLineAt(pos, docTop = 0) {
      return this.viewState.lineAt(pos, docTop);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start2, forward, by) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
    }
    moveByGroup(start2, forward) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
    }
    moveToLineBoundary(start2, forward, includeWrap = true) {
      return moveToLineBoundary(this, start2, forward, includeWrap);
    }
    moveVertically(start2, forward, distance) {
      return skipAtoms(this, start2, moveVertically(this, start2, forward, distance));
    }
    scrollPosIntoView(pos) {
      this.viewState.scrollTo = EditorSelection.cursor(pos);
      this.requestMeasure();
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.heightOracle.direction;
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirection;
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, this.textDirection);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a3;
      return (document.hasFocus() || browser.safari && ((_a3 = this.inputState) === null || _a3 === void 0 ? void 0 : _a3.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    destroy() {
      for (let plugin2 of this.plugins)
        plugin2.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
      if (options && options.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.fallback(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
  };
  EditorView.scrollTo = scrollTo;
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  function ensureTop(given, dom) {
    return given == null ? dom.getBoundingClientRect().top : given;
  }
  var resizeDebounce = -1;
  function ensureGlobalHandler() {
    window.addEventListener("resize", () => {
      if (resizeDebounce == -1)
        resizeDebounce = setTimeout(handleResize, 50);
    });
  }
  function handleResize() {
    resizeDebounce = -1;
    let found = document.querySelectorAll(".cm-content");
    for (let i = 0; i < found.length; i++) {
      let docView = ContentView.get(found[i]);
      if (docView)
        docView.editorView.requestMeasure();
    }
  }
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to, dir, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
    static update(cache2, changes) {
      if (changes.empty)
        return cache2;
      let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
      for (let i = Math.max(0, cache2.length - 10); i < cache2.length; i++) {
        let entry = cache2[i];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  var currentPlatform = typeof navigator == "undefined" ? "key" : /* @__PURE__ */ /Mac/.test(navigator.platform) ? "mac" : /* @__PURE__ */ /Win/.test(navigator.platform) ? "win" : /* @__PURE__ */ /Linux|X11/.test(navigator.platform) ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift3, meta2;
    for (let i = 0; i < parts.length - 1; ++i) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift3 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift3)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event, shift3) {
    if (event.altKey)
      name2 = "Alt-" + name2;
    if (event.ctrlKey)
      name2 = "Ctrl-" + name2;
    if (event.metaKey)
      name2 = "Meta-" + name2;
    if (shift3 !== false && event.shiftKey)
      name2 = "Shift-" + name2;
    return name2;
  }
  var handleKeyEvents = /* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  });
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map2 = Keymaps.get(bindings);
    if (!map2)
      Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map2;
  }
  function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name2, is3) => {
      let current = isPrefix[name2];
      if (current == null)
        isPrefix[name2] = is3;
      else if (current != is3)
        throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault) => {
      let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i = 1; i < parts.length; i++) {
        let prefix = parts.slice(0, i).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix])
          scopeObj[prefix] = {
            preventDefault: true,
            commands: [(view) => {
              let ourObj = storedPrefix = { view, prefix, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });
      binding.commands.push(command);
      if (preventDefault)
        binding.preventDefault = true;
    };
    for (let b of bindings) {
      let name2 = b[platform] || b.key;
      if (!name2)
        continue;
      for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
        add(scope, name2, b.run, b.preventDefault);
        if (b.shift)
          add(scope, "Shift-" + name2, b.shift, b.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map2, event, view, scope) {
    let name2 = keyName(event), isChar = name2.length == 1 && name2 != " ";
    let prefix = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
        storedPrefix = null;
    }
    let runFor = (binding) => {
      if (binding) {
        for (let cmd of binding.commands)
          if (cmd(view))
            return true;
        if (binding.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map2[scope], baseName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)]))
        return true;
      if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))
          return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix + modifiers(name2, event, true)]))
          return true;
      }
    }
    return fallthrough;
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      });
    }
  });
  function drawSelection(config = {}) {
    return [
      selectionConfig.of(config),
      drawSelectionPlugin,
      hideNativeSelection
    ];
  }
  var Piece = class {
    constructor(left, top2, width, height, className) {
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
      this.className = className;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width >= 0)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
  };
  var drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.rangePieces = [];
      this.cursors = [];
      this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
      this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.selectionLayer.className = "cm-selectionLayer";
      this.selectionLayer.setAttribute("aria-hidden", "true");
      this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.cursorLayer.className = "cm-cursorLayer";
      this.cursorLayer.setAttribute("aria-hidden", "true");
      view.requestMeasure(this.measureReq);
      this.setBlinkRate();
    }
    setBlinkRate() {
      this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update) {
      let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
      if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)
        this.view.requestMeasure(this.measureReq);
      if (update.transactions.some((tr) => tr.scrollIntoView))
        this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      if (confChanged)
        this.setBlinkRate();
    }
    readPos() {
      let { state } = this.view, conf = state.facet(selectionConfig);
      let rangePieces = state.selection.ranges.map((r6) => r6.empty ? [] : measureRange(this.view, r6)).reduce((a, b) => a.concat(b));
      let cursors = [];
      for (let r6 of state.selection.ranges) {
        let prim = r6 == state.selection.main;
        if (r6.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let piece = measureCursor(this.view, r6, prim);
          if (piece)
            cursors.push(piece);
        }
      }
      return { rangePieces, cursors };
    }
    drawSel({ rangePieces, cursors }) {
      if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {
        this.selectionLayer.textContent = "";
        for (let p of rangePieces)
          this.selectionLayer.appendChild(p.draw());
        this.rangePieces = rangePieces;
      }
      if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
        let oldCursors = this.cursorLayer.children;
        if (oldCursors.length !== cursors.length) {
          this.cursorLayer.textContent = "";
          for (const c of cursors)
            this.cursorLayer.appendChild(c.draw());
        } else {
          cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
        }
        this.cursors = cursors;
      }
    }
    destroy() {
      this.selectionLayer.remove();
      this.cursorLayer.remove();
    }
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": { backgroundColor: "transparent !important" },
      "&::selection": { backgroundColor: "transparent !important" }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.override(/* @__PURE__ */ EditorView.theme(themeSpec));
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
  }
  function wrappedLine(view, pos, inside2) {
    let range = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
      type: BlockType.Text
    };
  }
  function blockAt(view, pos) {
    let line = view.visualLineAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
      return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineStyle = window.getComputedStyle(content2.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
      if (visualStart)
        visualStart = wrappedLine(view, from, visualStart);
      if (visualEnd)
        visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && blockAt(view, (top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new Piece(left - base2.left, top2 - base2.top, right - left, bottom - top2, "cm-selectionBackground");
    }
    function pieces({ top: top2, bottom, horizontal }) {
      let pieces2 = [];
      for (let i = 0; i < horizontal.length; i += 2)
        pieces2.push(piece(horizontal[i], top2, horizontal[i + 1], bottom));
      return pieces2;
    }
    function drawForLine(from2, to2, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from3, fromOpen, to3, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start2 = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      for (let r6 of view.visibleRanges)
        if (r6.to > start2 && r6.from < end) {
          for (let pos = Math.max(r6.from, start2), endPos = Math.min(r6.to, end); ; ) {
            let docLine = view.state.doc.lineAt(pos);
            for (let span of view.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start2, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start2, from2 == null, end, to2 == null, view.textDirection);
      return { top: top2, bottom, horizontal };
    }
    function drawForWidget(block, top2) {
      let y = contentRect.top + (top2 ? block.top : block.bottom);
      return { top: y, bottom: y, horizontal: [] };
    }
  }
  function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
      return null;
    let base2 = getBase(view);
    return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
  }
  function iterMatches(doc2, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc2.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m = re.exec(cursor.value))
          f(pos + m.index, pos + m.index + m[0].length, m);
    }
  }
  var MatchDecorator = class {
    constructor(config) {
      let { regexp, decoration, boundary } = config;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
      this.boundary = boundary;
    }
    createDeco(view) {
      let build = new RangeSetBuilder();
      for (let { from, to } of view.visibleRanges)
        iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));
      return build.finish();
    }
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged)
        update.changes.iterChanges((_f3, _t, from, to) => {
          if (to > update.view.viewport.from && from < update.view.viewport.to) {
            changeFrom = Math.min(from, changeFrom);
            changeTo = Math.max(to, changeTo);
          }
        });
      if (update.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update.view);
      if (changeTo > -1)
        return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r6 of view.visibleRanges) {
        let from = Math.max(r6.from, updateFrom), to = Math.min(r6.to, updateTo);
        if (to > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
          let start2 = Math.max(r6.from, fromLine.from), end = Math.min(r6.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--)
              if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                start2 = from;
                break;
              }
            for (; to < toLine.to; to++)
              if (this.boundary.test(toLine.text[to - toLine.from])) {
                end = to;
                break;
              }
          }
          let ranges = [], m;
          if (fromLine == toLine) {
            this.regexp.lastIndex = start2 - fromLine.from;
            while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {
              let pos = m.index + fromLine.from;
              ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));
            }
          } else {
            iterMatches(view.state.doc, this.regexp, start2, end, (from2, to2, m2) => ranges.push(this.getDeco(m2, view, from2).range(from2, to2)));
          }
          deco = deco.update({ filterFrom: start2, filterTo: end, filter: (from2, to2) => from2 < start2 || to2 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a3;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a3 = styles.tabSize) !== null && _a3 !== void 0 ? _a3 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config.replaceTabs = !supportsTabSize())
        config.specialChars = new RegExp("	|" + config.specialChars.source, UnicodeRegexpSupport);
      if (config.addSpecialChars)
        config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
      return config;
    }
  });
  function highlightSpecialChars(config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m, view, pos) => {
            let { doc: doc2 } = view.state;
            let code = codePointAt(m[0], 0);
            if (code == 9) {
              let line = doc2.lineAt(pos);
              let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({ widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth) });
            }
            return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code) {
    if (code >= 32)
      return DefaultPlaceholder;
    if (code == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options, code) {
      super();
      this.options = options;
      this.code = code;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var plugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.height = -1;
      this.measure = {
        read: (view2) => Math.max(0, view2.scrollDOM.clientHeight - view2.defaultLineHeight),
        write: (value, view2) => {
          if (Math.abs(value - this.height) > 1) {
            this.height = value;
            view2.contentDOM.style.paddingBottom = value + "px";
          }
        }
      };
      view.requestMeasure(this.measure);
    }
    update(update) {
      if (update.geometryChanged)
        update.view.requestMeasure(this.measure);
    }
  });
  function scrollPastEnd() {
    return plugin;
  }
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({ attributes: { class: "cm-activeLine" } });
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet)
        this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r6 of view.state.selection.ranges) {
        if (!r6.empty)
          return Decoration.none;
        let line = view.visualLineAt(r6.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var Placeholder = class extends WidgetType {
    constructor(content2) {
      super();
      this.content = content2;
    }
    toDOM() {
      let wrap = document.createElement("span");
      wrap.className = "cm-placeholder";
      wrap.style.pointerEvents = "none";
      wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
      if (typeof this.content == "string")
        wrap.setAttribute("aria-label", "placeholder " + this.content);
      else
        wrap.setAttribute("aria-hidden", "true");
      return wrap;
    }
    ignoreEvent() {
      return false;
    }
  };
  function placeholder(content2) {
    return ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]);
      }
      get decorations() {
        return this.view.state.doc.length ? Decoration.none : this.placeholder;
      }
    }, { decorations: (v) => v.decorations });
  }
  var __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };

  // ../../node_modules/@codemirror/gutter/dist/index.js
  var dist_exports3 = {};
  __export(dist_exports3, {
    GutterMarker: () => GutterMarker,
    gutter: () => gutter,
    gutterLineClass: () => gutterLineClass,
    gutters: () => gutters,
    highlightActiveLineGutter: () => highlightActiveLineGutter,
    lineNumberMarkers: () => lineNumberMarkers,
    lineNumbers: () => lineNumbers
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
  }
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-gutters": {
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#999",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    }
  });
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values2) => values2.some((x) => x)
  });
  function gutters(config) {
    let result = [
      gutterView,
      baseTheme2
    ];
    if (config && config.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
      this.syncGutters();
    }
    update(update) {
      if (this.updateGutters(update))
        this.syncGutters();
    }
    syncGutters() {
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport));
      this.view.viewportLines((line) => {
        let text;
        if (Array.isArray(line.type)) {
          for (let b of line.type)
            if (b.type == BlockType.Text) {
              text = b;
              break;
            }
        } else {
          text = line.type == BlockType.Text ? line : void 0;
        }
        if (!text)
          return;
        if (classSet.length)
          classSet = [];
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, text, classSet);
      }, 0);
      for (let cx of contexts)
        cx.finish();
      this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters)
          g.dom.remove();
        for (let g of gutters2)
          this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      this.dom.remove();
    }
  }, {
    provide: /* @__PURE__ */ PluginField.scrollMargins.from((value) => {
      if (value.gutters.length == 0 || !value.fixed)
        return null;
      return value.view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport) {
      this.gutter = gutter2;
      this.localMarkers = [];
      this.i = 0;
      this.height = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
      if (this.localMarkers.length)
        this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      let above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        let elt = gutter2.elements[this.i];
        if (sameMarkers(localMarkers, elt.markers))
          localMarkers = elt.markers;
        elt.update(view, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i)
        gutter2.dom.removeChild(gutter2.elements.pop().dom);
    }
  };
  var SingleGutterView = class {
    constructor(view, config) {
      this.view = view;
      this.config = config;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);
          if (config.domEventHandlers[prop](view, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config.markers(view));
      if (config.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update.view, 0, 0, [updated]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to);
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.dom = document.createElement("div");
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height)
        this.dom.style.height = (this.height = height) + "px";
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (this.markers != markers) {
        this.markers = markers;
        for (let ch2; ch2 = this.dom.lastChild; )
          ch2.remove();
        let cls = "cm-gutterElement";
        for (let m of markers) {
          if (m.toDOM)
            this.dom.appendChild(m.toDOM(view));
          let c = m.elementClass;
          if (c)
            cls += " " + c;
        }
        this.dom.className = cls;
      }
    }
  };
  function sameMarkers(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].compare(b[i]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a, b) {
          let result = Object.assign({}, a);
          for (let event in b) {
            let exists = result[event], add = b[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add(view, line, event2) : add;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM(_view) {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config = {}) {
    return [
      lineNumberConfig.of(config),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
      last = last * 10 + 9;
    return last;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges)
      if (range.empty) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
          last = linePos;
          marks.push(activeLineGutterMarker.range(linePos));
        }
      }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // ../../node_modules/@codemirror/highlight/dist/index.js
  var dist_exports4 = {};
  __export(dist_exports4, {
    HighlightStyle: () => HighlightStyle,
    Tag: () => Tag,
    classHighlightStyle: () => classHighlightStyle,
    defaultHighlightStyle: () => defaultHighlightStyle,
    highlightTree: () => highlightTree,
    styleTags: () => styleTags,
    tags: () => tags
  });

  // ../../node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config = {}) {
      this.id = nextPropID++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var noProps = Object.create(null);
  var NodeType = class {
    constructor(name2, props, id, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map2) {
      let direct = Object.create(null);
      for (let prop in map2)
        for (let name2 of prop.split(" "))
          direct[name2] = map2[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", Object.create(null), 0, 8);
  var CachedNode = new WeakMap();
  var Tree = class {
    constructor(type, children, positions, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch2 of this.children) {
        let str = ch2.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(pos, side = 0) {
      let scope = pos != null && CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      if (pos != null) {
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
      }
      return cursor;
    }
    fullCursor() {
      return new TreeCursor(this.topNode, 1);
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      return this.cursor(pos, side).node;
    }
    resolveInner(pos, side = 0) {
      let result = this.topNode;
      for (; ; ) {
        let inner = result.enter(pos, side);
        if (!inner)
          return result;
        result = inner;
      }
    }
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      for (let c = this.cursor(), get4 = () => c.node; ; ) {
        let mustLeave = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get4) !== false)) {
          if (c.firstChild())
            continue;
          if (!c.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(c.type, c.from, c.to, get4);
          mustLeave = c.type.isAnonymous;
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          mustLeave = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id in this.props)
          result.push([+id, this.props[id]]);
      return result;
    }
    balance(config = {}) {
      return this.children.length <= 8 ? this : balanceRange(this.type, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length, set5) {
      this.buffer = buffer;
      this.length = length;
      this.set = set5;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id = this.buffer[index], endIndex = this.buffer[index + 3];
      let type = this.set.types[id], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from, to) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI);
      for (let i = startI, j = 0; i < endI; ) {
        copy[j++] = b[i++];
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - startI;
      }
      return new TreeBuffer(copy, to - from, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  var TreeNode = class {
    constructor(node, _from, index, _parent) {
      this.node = node;
      this._from = _from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this.node.type;
    }
    get name() {
      return this.node.type.name;
    }
    get from() {
      return this._from;
    }
    get to() {
      return this._from + this.node.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
          let next = children[i], start2 = positions[i] + parent._from;
          if (!checkSide(side, pos, start2, start2 + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & 2)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start2, side);
            if (index > -1)
              return new BufferNode(new BufferContext(parent, next, i, start2), null, index);
          } else if (mode & 1 || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start2, i, parent);
            let inner = new TreeNode(next, start2, i, parent);
            return mode & 1 || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & 1 || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent.node.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this.node.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this.node.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, overlays = true, buffers = true) {
      let mounted;
      if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, buffers ? 0 : 2);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get cursor() {
      return new TreeCursor(this);
    }
    get tree() {
      return this.node;
    }
    toTree() {
      return this.node;
    }
    resolve(pos, side = 0) {
      return this.cursor.moveTo(pos, side).node;
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r6 = getChildren(this, type, before, after);
      return r6.length ? r6[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    toString() {
      return this.node.toString();
    }
  };
  function getChildren(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
      return result;
    if (before != null) {
      while (!cur.type.is(before))
        if (!cur.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur.type.is(after))
        return result;
      if (cur.type.is(type))
        result.push(cur.node);
      if (!cur.nextSibling())
        return after == null ? result : [];
    }
  }
  var BufferContext = class {
    constructor(parent, buffer, index, start2) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start2;
    }
  };
  var BufferNode = class {
    constructor(context, _parent, index) {
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, overlays, buffers = true) {
      if (!buffers)
        return null;
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    get cursor() {
      return new TreeCursor(this);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
        children.push(buffer.slice(startI, endI, from, to));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return this.cursor.moveTo(pos, side).node;
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r6 = getChildren(this, type, before, after);
      return r6.length ? r6[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
  };
  var TreeCursor = class {
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      let { start: start2, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start2 + buffer.buffer[index + 1];
      this.to = start2 + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, overlays = true, buffers = true) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, overlays, buffers));
      return buffers ? this.enterChild(1, pos, side) : false;
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & 1 ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & 1 ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({ index, parent } = buffer);
      } else {
        ({ index, _parent: parent } = this._tree);
      }
      for (; parent; { index, _parent: parent } = parent) {
        if (index > -1)
          for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
            let child = parent.node.children[i];
            if (this.mode & 1 || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache2 = this.bufferNode, result = null, depth = 0;
      if (cache2 && cache2.context == this.buffer) {
        scan:
          for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache2; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree.node;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch2) => ch2 instanceof TreeBuffer || !ch2.type.isAnonymous || hasChild(ch2));
  }
  function buildTree(data) {
    var _a3;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let { id, start: start2, end, size } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          let node2 = reused[id];
          children2.push(node2);
          positions2.push(start2 - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id;
          return;
        } else if (size == -4) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id], node, buffer2;
      let startPos = start2 - parentStart;
      if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index = data2.length;
        while (cursor.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id >= minRepeatType ? id : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start2, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start2, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree(type, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize3 = fork.size;
          if (fork.id == inRepeat && nodeSize3 >= 0) {
            result.size = size;
            result.start = start2;
            result.skip = skip;
            skip += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize3;
          if (nodeSize3 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start2 = nodeStart;
          size += nodeSize3;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start2;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let { id, start: start2, end, size } = cursor;
      cursor.next();
      if (size >= 0 && id < minRepeatType) {
        let startIndex = index;
        if (size > 4) {
          let endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start2 - bufferStart;
        buffer2[--index] = id;
      } else if (size == -3) {
        contextHash = id;
      } else if (size == -4) {
        lookAhead = id;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a3 = data.length) !== null && _a3 !== void 0 ? _a3 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = node.children.reduce((s, ch2) => s + nodeSize(balanceType, ch2), 1);
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(type, children, positions, from, to, start2, length, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
      total += nodeSize(type, children[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i = from2; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(type, children2[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize(type, children2[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
          localChildren.push(balanceRange(type, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start2);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r6) => new Range2(r6.from, r6.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };

  // ../../node_modules/@codemirror/language/dist/index.js
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  function defineLanguageFacet(baseData) {
    return Facet.define({
      combine: baseData ? (values2) => values2.concat(baseData) : void 0
    });
  }
  var Language = class {
    constructor(data, parser2, topNode, extraExtensions = []) {
      this.data = data;
      this.topNode = topNode;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser2;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return languageDataFacetAt(state, pos, side) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r6 of mount.overlay)
                result.push({ from: r6.from + from, to: r6.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size)
              return;
          }
        }
        for (let i = 0; i < tree.children.length; i++) {
          let ch2 = tree.children[i];
          if (ch2 instanceof Tree)
            explore(ch2, tree.positions[i] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state, pos, side) {
    let topLang = state.facet(language);
    if (!topLang)
      return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
      for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, true, false))
        facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  var LRLanguage = class extends Language {
    constructor(data, parser2) {
      super(data, parser2, parser2.topNode);
      this.parser = parser2;
    }
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new LRLanguage(data, spec.parser.configure({
        props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
      }));
    }
    configure(options) {
      return new LRLanguage(this.data, this.parser.configure(options));
    }
    get allowsNesting() {
      return this.parser.wrappers.length > 0;
    }
  };
  function syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2, length = doc2.length) {
      this.doc = doc2;
      this.length = length;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser2;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(time, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a3;
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        let endTime = Date.now() + time;
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a3 = this.parse.stoppedAt) !== null && _a3 !== void 0 ? _a3 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (Date.now() > endTime)
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) > this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r6; r6 = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r6.from, r6.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r6 of this.skipped) {
            let from = changes.mapPos(r6.from, 1), to = changes.mapPos(r6.to, -1);
            if (from < to)
              skipped.push({ from, to });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i = 0; i < this.skipped.length; i++) {
        let { from, to } = this.skipped[i];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({ from, to });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser2 = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r6 of ranges)
                  cx.tempSkipped.push(r6);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser2;
        }
      }();
    }
    movedPast(pos) {
      return this.treeLen < pos && this.parse && this.parse.parsedPos >= pos;
    }
    isDone(upto) {
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
  }
  var LanguageState = class {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(25, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let parseState = new ParseContext(state.facet(language).parser, state, [], Tree.empty, 0, { from: 0, to: state.doc.length }, [], null);
      if (!parseState.work(25))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects)
        if (e.is(Language.setState))
          return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = typeof window != "undefined" && window.requestIdleCallback || ((callback, { timeout }) => setTimeout(callback, timeout));
  var cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = -1;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working > -1)
        return;
      let { state } = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
        this.working = requestIdle(this.work, { timeout: 500 });
    }
    work(deadline) {
      this.working = -1;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.treeLen >= vpTo + 1e6)
        return;
      let time = Math.min(this.chunkBudget, deadline ? Math.max(25, deadline.timeRemaining()) : 100);
      let done = field.context.work(time, vpTo + 1e6);
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (!done && this.chunkBudget > 0)
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        cx.scheduleOn.then(() => this.scheduleWork());
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working >= 0)
        cancelIdle(this.working);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: [Language.state, parseWorker]
  });
  var LanguageSupport = class {
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [language2, support];
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
      let matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  }
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
  }

  // ../../node_modules/@codemirror/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set5, base2, modified) {
      this.set = set5;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set5 = [], tag = new Tag(set5, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = permute(mods);
      for (let parent of base2.set)
        for (let config of configs)
          set5.push(Modifier.get(parent, config));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
  }
  function permute(array2) {
    let result = [array2];
    for (let i = 0; i < array2.length; i++) {
      for (let a of permute(array2.slice(0, i).concat(array2.slice(i + 1))))
        result.push(a);
    }
    return result;
  }
  function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last = pieces.length - 1, inner = pieces[last];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = /* @__PURE__ */ new NodeProp();
  var highlightStyle = /* @__PURE__ */ Facet.define({
    combine(stylings) {
      return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;
    }
  });
  var fallbackHighlightStyle = /* @__PURE__ */ Facet.define({
    combine(values2) {
      return values2.length ? values2[0].match : null;
    }
  });
  function getHighlightStyle(state) {
    return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);
  }
  var Rule = class {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  var HighlightStyle = class {
    constructor(spec, options) {
      this.map = Object.create(null);
      let modSpec;
      function def(spec2) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = Object.create(null)))["." + cls] = spec2;
        return cls;
      }
      this.all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : null;
      for (let style of spec) {
        let cls = (style.class || def(Object.assign({}, style, { tag: null }))) + (this.all ? " " + this.all : "");
        let tags2 = style.tag;
        if (!Array.isArray(tags2))
          this.map[tags2.id] = cls;
        else
          for (let tag of tags2)
            this.map[tag.id] = cls;
      }
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.scope = options.scope || null;
      this.match = this.match.bind(this);
      let ext = [treeHighlighter];
      if (this.module)
        ext.push(EditorView.styleModule.of(this.module));
      this.extension = ext.concat(highlightStyle.of(this));
      this.fallback = ext.concat(fallbackHighlightStyle.of(this));
    }
    match(tag, scope) {
      if (this.scope && scope != this.scope)
        return null;
      for (let t2 of tag.set) {
        let match = this.map[t2.id];
        if (match !== void 0) {
          if (t2 != tag)
            this.map[tag.id] = match;
          return match;
        }
      }
      return this.map[tag.id] = this.all;
    }
    static combinedMatch(styles) {
      if (styles.length == 1)
        return styles[0].match;
      let cache2 = styles.some((s) => s.scope) ? void 0 : Object.create(null);
      return (tag, scope) => {
        let cached = cache2 && cache2[tag.id];
        if (cached !== void 0)
          return cached;
        let result = null;
        for (let style of styles) {
          let value = style.match(tag, scope);
          if (value)
            result = result ? result + " " + value : value;
        }
        if (cache2)
          cache2[tag.id] = result;
        return result;
      };
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
    static get(state, tag, scope) {
      let style = getHighlightStyle(state);
      return style && style(tag, scope || NodeType.none);
    }
  };
  function highlightTree(tree, getStyle, putStyle, from = 0, to = tree.length) {
    highlightTreeRange(tree, from, to, getStyle, putStyle);
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
    }
    update(update) {
      let tree = syntaxTree(update.state), style = getHighlightStyle(update.state);
      let styleChange = style != update.startState.facet(highlightStyle);
      if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update.changes);
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, style);
      }
    }
    buildDeco(view, match) {
      if (!match || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from, to } of view.visibleRanges) {
        highlightTreeRange(this.tree, from, to, match, (from2, to2, style) => {
          builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
        });
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.extend(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var nodeStack = [""];
  var HighlightBuilder = class {
    constructor(at, style, span) {
      this.at = at;
      this.style = style;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, depth, scope) {
      let { type, from: start2, to: end } = cursor;
      if (start2 >= to || end <= from)
        return;
      nodeStack[depth] = type.name;
      if (type.isTop)
        scope = type;
      let cls = inheritedClass;
      let rule = type.prop(ruleNodeProp), opaque = false;
      while (rule) {
        if (!rule.context || matchContext(rule.context, nodeStack, depth)) {
          for (let tag of rule.tags) {
            let st = this.style(tag, scope);
            if (st) {
              if (cls)
                cls += " ";
              cls += st;
              if (rule.mode == 1)
                inheritedClass += (inheritedClass ? " " : "") + st;
              else if (rule.mode == 0)
                opaque = true;
            }
          }
          break;
        }
        rule = rule.next;
      }
      this.startSpan(cursor.from, cls);
      if (opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start2, 1);
        let hasChild3 = cursor.firstChild();
        for (let i = 0, pos = start2; ; i++) {
          let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
          let nextPos = next ? next.from + start2 : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild3) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, depth + 1, scope);
              this.startSpan(Math.min(to, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start2;
          if (pos > from) {
            this.highlightRange(inner.cursor, Math.max(from, next.from + start2), Math.min(to, pos), inheritedClass, depth, mounted.tree.type);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild3)
          cursor.parent();
      } else if (cursor.firstChild()) {
        do {
          if (cursor.to <= from)
            continue;
          if (cursor.from >= to)
            break;
          this.highlightRange(cursor, from, to, inheritedClass, depth + 1, scope);
          this.startSpan(Math.min(to, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  function highlightTreeRange(tree, from, to, style, span) {
    let builder = new HighlightBuilder(from, style, span);
    builder.highlightRange(tree.cursor(), from, to, "", 0, tree.type);
    builder.flush(to);
  }
  function matchContext(context, stack, depth) {
    if (context.length > depth - 1)
      return false;
    for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {
      let check = context[i];
      if (check && check != stack[d])
        return false;
    }
    return true;
  }
  var t = Tag.define;
  var comment = /* @__PURE__ */ t();
  var name = /* @__PURE__ */ t();
  var typeName = /* @__PURE__ */ t(name);
  var propertyName = /* @__PURE__ */ t(name);
  var literal = /* @__PURE__ */ t();
  var string = /* @__PURE__ */ t(literal);
  var number = /* @__PURE__ */ t(literal);
  var content = /* @__PURE__ */ t();
  var heading = /* @__PURE__ */ t(content);
  var keyword = /* @__PURE__ */ t();
  var operator = /* @__PURE__ */ t();
  var punctuation = /* @__PURE__ */ t();
  var bracket = /* @__PURE__ */ t(punctuation);
  var meta = /* @__PURE__ */ t();
  var tags = {
    comment,
    lineComment: /* @__PURE__ */ t(comment),
    blockComment: /* @__PURE__ */ t(comment),
    docComment: /* @__PURE__ */ t(comment),
    name,
    variableName: /* @__PURE__ */ t(name),
    typeName,
    tagName: /* @__PURE__ */ t(typeName),
    propertyName,
    attributeName: /* @__PURE__ */ t(propertyName),
    className: /* @__PURE__ */ t(name),
    labelName: /* @__PURE__ */ t(name),
    namespace: /* @__PURE__ */ t(name),
    macroName: /* @__PURE__ */ t(name),
    literal,
    string,
    docString: /* @__PURE__ */ t(string),
    character: /* @__PURE__ */ t(string),
    attributeValue: /* @__PURE__ */ t(string),
    number,
    integer: /* @__PURE__ */ t(number),
    float: /* @__PURE__ */ t(number),
    bool: /* @__PURE__ */ t(literal),
    regexp: /* @__PURE__ */ t(literal),
    escape: /* @__PURE__ */ t(literal),
    color: /* @__PURE__ */ t(literal),
    url: /* @__PURE__ */ t(literal),
    keyword,
    self: /* @__PURE__ */ t(keyword),
    null: /* @__PURE__ */ t(keyword),
    atom: /* @__PURE__ */ t(keyword),
    unit: /* @__PURE__ */ t(keyword),
    modifier: /* @__PURE__ */ t(keyword),
    operatorKeyword: /* @__PURE__ */ t(keyword),
    controlKeyword: /* @__PURE__ */ t(keyword),
    definitionKeyword: /* @__PURE__ */ t(keyword),
    operator,
    derefOperator: /* @__PURE__ */ t(operator),
    arithmeticOperator: /* @__PURE__ */ t(operator),
    logicOperator: /* @__PURE__ */ t(operator),
    bitwiseOperator: /* @__PURE__ */ t(operator),
    compareOperator: /* @__PURE__ */ t(operator),
    updateOperator: /* @__PURE__ */ t(operator),
    definitionOperator: /* @__PURE__ */ t(operator),
    typeOperator: /* @__PURE__ */ t(operator),
    controlOperator: /* @__PURE__ */ t(operator),
    punctuation,
    separator: /* @__PURE__ */ t(punctuation),
    bracket,
    angleBracket: /* @__PURE__ */ t(bracket),
    squareBracket: /* @__PURE__ */ t(bracket),
    paren: /* @__PURE__ */ t(bracket),
    brace: /* @__PURE__ */ t(bracket),
    content,
    heading,
    heading1: /* @__PURE__ */ t(heading),
    heading2: /* @__PURE__ */ t(heading),
    heading3: /* @__PURE__ */ t(heading),
    heading4: /* @__PURE__ */ t(heading),
    heading5: /* @__PURE__ */ t(heading),
    heading6: /* @__PURE__ */ t(heading),
    contentSeparator: /* @__PURE__ */ t(content),
    list: /* @__PURE__ */ t(content),
    quote: /* @__PURE__ */ t(content),
    emphasis: /* @__PURE__ */ t(content),
    strong: /* @__PURE__ */ t(content),
    link: /* @__PURE__ */ t(content),
    monospace: /* @__PURE__ */ t(content),
    strikethrough: /* @__PURE__ */ t(content),
    inserted: /* @__PURE__ */ t(),
    deleted: /* @__PURE__ */ t(),
    changed: /* @__PURE__ */ t(),
    invalid: /* @__PURE__ */ t(),
    meta,
    documentMeta: /* @__PURE__ */ t(meta),
    annotation: /* @__PURE__ */ t(meta),
    processingInstruction: /* @__PURE__ */ t(meta),
    definition: /* @__PURE__ */ Tag.defineModifier(),
    constant: /* @__PURE__ */ Tag.defineModifier(),
    function: /* @__PURE__ */ Tag.defineModifier(),
    standard: /* @__PURE__ */ Tag.defineModifier(),
    local: /* @__PURE__ */ Tag.defineModifier(),
    special: /* @__PURE__ */ Tag.defineModifier()
  };
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.meta,
      color: "#7a757a"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var classHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    { tag: tags.link, class: "cmt-link" },
    { tag: tags.heading, class: "cmt-heading" },
    { tag: tags.emphasis, class: "cmt-emphasis" },
    { tag: tags.strong, class: "cmt-strong" },
    { tag: tags.keyword, class: "cmt-keyword" },
    { tag: tags.atom, class: "cmt-atom" },
    { tag: tags.bool, class: "cmt-bool" },
    { tag: tags.url, class: "cmt-url" },
    { tag: tags.labelName, class: "cmt-labelName" },
    { tag: tags.inserted, class: "cmt-inserted" },
    { tag: tags.deleted, class: "cmt-deleted" },
    { tag: tags.literal, class: "cmt-literal" },
    { tag: tags.string, class: "cmt-string" },
    { tag: tags.number, class: "cmt-number" },
    { tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)], class: "cmt-string2" },
    { tag: tags.variableName, class: "cmt-variableName" },
    { tag: /* @__PURE__ */ tags.local(tags.variableName), class: "cmt-variableName cmt-local" },
    { tag: /* @__PURE__ */ tags.definition(tags.variableName), class: "cmt-variableName cmt-definition" },
    { tag: /* @__PURE__ */ tags.special(tags.variableName), class: "cmt-variableName2" },
    { tag: tags.typeName, class: "cmt-typeName" },
    { tag: tags.namespace, class: "cmt-namespace" },
    { tag: tags.macroName, class: "cmt-macroName" },
    { tag: tags.propertyName, class: "cmt-propertyName" },
    { tag: tags.operator, class: "cmt-operator" },
    { tag: tags.comment, class: "cmt-comment" },
    { tag: tags.meta, class: "cmt-meta" },
    { tag: tags.invalid, class: "cmt-invalid" },
    { tag: tags.punctuation, class: "cmt-punctuation" }
  ]);

  // ../../packages/nota/dist/nota.js
  var lv = Object.create;
  var Eo = Object.defineProperty;
  var p7 = Object.getOwnPropertyDescriptor;
  var uv = Object.getOwnPropertyNames;
  var cv = Object.getPrototypeOf;
  var fv = Object.prototype.hasOwnProperty;
  var hv = (t2) => Eo(t2, "__esModule", { value: true });
  var dv = (t2, r6) => () => (t2 && (r6 = t2(t2 = 0)), r6);
  var J = (t2, r6) => () => (r6 || t2((r6 = { exports: {} }).exports, r6), r6.exports);
  var Sn = (t2, r6) => {
    for (var s in r6)
      Eo(t2, s, { get: r6[s], enumerable: true });
  };
  var bt = (t2, r6, s) => {
    if (r6 && typeof r6 == "object" || typeof r6 == "function")
      for (let c of uv(r6))
        !fv.call(t2, c) && c !== "default" && Eo(t2, c, { get: () => r6[c], enumerable: !(s = p7(r6, c)) || s.enumerable });
    return t2;
  };
  var cr = (t2) => bt(hv(Eo(t2 != null ? lv(cv(t2)) : {}, "default", t2 && t2.__esModule && "default" in t2 ? { get: () => t2.default, enumerable: true } : { value: t2, enumerable: true })), t2);
  var T1 = (t2, r6, s, c) => {
    for (var p = c > 1 ? void 0 : c ? p7(r6, s) : r6, w = t2.length - 1, T; w >= 0; w--)
      (T = t2[w]) && (p = (c ? T(r6, s, p) : T(p)) || p);
    return c && p && Eo(r6, s, p), p;
  };
  var F = {};
  Sn(F, { default: () => N });
  var Ge = dv(() => {
    bt(F, VT);
  });
  var g7 = J((wl) => {
    (function(t2) {
      function r6() {
        this.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"], this.notKey = [",", "{", "}", " ", "="], this.pos = 0, this.input = "", this.entries = new Array(), this.currentEntry = "", this.setInput = function(s) {
          this.input = s;
        }, this.getEntries = function() {
          return this.entries;
        }, this.isWhitespace = function(s) {
          return s == " " || s == "\r" || s == "	" || s == `
`;
        }, this.match = function(s, c) {
          if ((c == null || c == null) && (c = true), this.skipWhitespace(c), this.input.substring(this.pos, this.pos + s.length) == s)
            this.pos += s.length;
          else
            throw TypeError("Token mismatch: match", "expected " + s + ", found " + this.input.substring(this.pos));
          this.skipWhitespace(c);
        }, this.tryMatch = function(s, c) {
          return (c == null || c == null) && (c = true), this.skipWhitespace(c), this.input.substring(this.pos, this.pos + s.length) == s;
        }, this.matchAt = function() {
          for (; this.input.length > this.pos && this.input[this.pos] != "@"; )
            this.pos++;
          return this.input[this.pos] == "@";
        }, this.skipWhitespace = function(s) {
          for (; this.isWhitespace(this.input[this.pos]); )
            this.pos++;
          if (this.input[this.pos] == "%" && s == true) {
            for (; this.input[this.pos] != `
`; )
              this.pos++;
            this.skipWhitespace(s);
          }
        }, this.value_braces = function() {
          var s = 0;
          this.match("{", false);
          for (var c = this.pos, p = false; ; ) {
            if (!p) {
              if (this.input[this.pos] == "}")
                if (s > 0)
                  s--;
                else {
                  var w = this.pos;
                  return this.match("}", false), this.input.substring(c, w);
                }
              else if (this.input[this.pos] == "{")
                s++;
              else if (this.pos >= this.input.length - 1)
                throw TypeError("Unterminated value: value_braces");
            }
            this.input[this.pos] == "\\" && p == false ? p = true : p = false, this.pos++;
          }
        }, this.value_comment = function() {
          for (var s = "", c = 0; !(this.tryMatch("}", false) && c == 0); ) {
            if (s = s + this.input[this.pos], this.input[this.pos] == "{" && c++, this.input[this.pos] == "}" && c--, this.pos >= this.input.length - 1)
              throw TypeError("Unterminated value: value_comment", +this.input.substring(start));
            this.pos++;
          }
          return s;
        }, this.value_quotes = function() {
          this.match('"', false);
          for (var s = this.pos, c = false; ; ) {
            if (!c) {
              if (this.input[this.pos] == '"') {
                var p = this.pos;
                return this.match('"', false), this.input.substring(s, p);
              } else if (this.pos >= this.input.length - 1)
                throw TypeError("Unterminated value: value_quotes", this.input.substring(s));
            }
            this.input[this.pos] == "\\" && c == false ? c = true : c = false, this.pos++;
          }
        }, this.single_value = function() {
          var s = this.pos;
          if (this.tryMatch("{"))
            return this.value_braces();
          if (this.tryMatch('"'))
            return this.value_quotes();
          var c = this.key();
          if (c.match("^[0-9]+$"))
            return c;
          if (this.months.indexOf(c.toLowerCase()) >= 0)
            return c.toLowerCase();
          throw "Value expected: single_value" + this.input.substring(s) + " for key: " + c;
        }, this.value = function() {
          var s = [];
          for (s.push(this.single_value()); this.tryMatch("#"); )
            this.match("#"), s.push(this.single_value());
          return s.join("");
        }, this.key = function(s) {
          for (var c = this.pos; ; ) {
            if (this.pos >= this.input.length)
              throw TypeError("Runaway key: key");
            if (this.notKey.indexOf(this.input[this.pos]) >= 0)
              return s && this.input[this.pos] != "," ? (this.pos = c, null) : this.input.substring(c, this.pos);
            this.pos++;
          }
        }, this.key_equals_value = function() {
          var s = this.key();
          if (this.tryMatch("=")) {
            this.match("=");
            var c = this.value();
            return s = s.trim(), [s, c];
          } else
            throw TypeError("Value expected, equals sign missing: key_equals_value", this.input.substring(this.pos));
        }, this.key_value_list = function() {
          var s = this.key_equals_value();
          for (this.currentEntry.entryTags = {}, this.currentEntry.entryTags[s[0]] = s[1]; this.tryMatch(",") && (this.match(","), !this.tryMatch("}")); )
            s = this.key_equals_value(), this.currentEntry.entryTags[s[0]] = s[1];
        }, this.entry_body = function(s) {
          this.currentEntry = {}, this.currentEntry.citationKey = this.key(true), this.currentEntry.entryType = s.substring(1), this.currentEntry.citationKey != null && this.match(","), this.key_value_list(), this.entries.push(this.currentEntry);
        }, this.directive = function() {
          return this.match("@"), "@" + this.key();
        }, this.preamble = function() {
          this.currentEntry = {}, this.currentEntry.entryType = "PREAMBLE", this.currentEntry.entry = this.value_comment(), this.entries.push(this.currentEntry);
        }, this.comment = function() {
          this.currentEntry = {}, this.currentEntry.entryType = "COMMENT", this.currentEntry.entry = this.value_comment(), this.entries.push(this.currentEntry);
        }, this.entry = function(s) {
          this.entry_body(s);
        }, this.alernativeCitationKey = function() {
          this.entries.forEach(function(s) {
            !s.citationKey && s.entryTags && (s.citationKey = "", s.entryTags.author && (s.citationKey += s.entryTags.author.split(",")[0] += ", "), s.citationKey += s.entryTags.year);
          });
        }, this.bibtex = function() {
          for (; this.matchAt(); ) {
            var s = this.directive();
            this.match("{"), s.toUpperCase() == "@STRING" ? this.string() : s.toUpperCase() == "@PREAMBLE" ? this.preamble() : s.toUpperCase() == "@COMMENT" ? this.comment() : this.entry(s), this.match("}");
          }
          this.alernativeCitationKey();
        };
      }
      t2.toJSON = function(s) {
        var c = new r6();
        return c.setInput(s), c.bibtex(), c.entries;
      }, t2.toBibtex = function(s, c) {
        c === void 0 && (c = true);
        var p = "", w = ",", T = "";
        c || (w = `,
`, T = "    ");
        for (var k in s) {
          if (p += "@" + s[k].entryType, p += "{", s[k].citationKey && (p += s[k].citationKey + w), s[k].entry && (p += s[k].entry), s[k].entryTags) {
            var P = T;
            for (var j in s[k].entryTags)
              P.trim().length != 0 && (P += w + T), P += j + (c ? "={" : " = {") + s[k].entryTags[j] + "}";
            p += P;
          }
          p += c ? `}
` : `
}

`;
        }
        return p;
      };
    })(typeof wl == "undefined" ? wl.bibtexParse = {} : wl);
  });
  var R0 = J((fa, ko) => {
    (function() {
      var t2, r6 = "4.17.21", s = 200, c = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", p = "Expected a function", w = "Invalid `variable` option passed into `_.template`", T = "__lodash_hash_undefined__", k = 500, P = "__lodash_placeholder__", j = 1, U = 2, ee = 4, G = 1, ae = 2, ie3 = 1, V = 2, de = 4, ve = 8, _e2 = 16, Me = 32, we = 64, ye = 128, xe = 256, Se = 512, Je = 30, Ae = "...", Ue = 800, Ye = 16, Dt = 1, mt = 2, m1 = 3, $t = 1 / 0, Bt = 9007199254740991, pe = 17976931348623157e292, Sr = 0 / 0, Pe = 4294967295, pt = Pe - 1, J1 = Pe >>> 1, ar = [["ary", ye], ["bind", ie3], ["bindKey", V], ["curry", ve], ["curryRight", _e2], ["flip", Se], ["partial", Me], ["partialRight", we], ["rearg", xe]], i1 = "[object Arguments]", Rr = "[object Array]", zr = "[object AsyncFunction]", p1 = "[object Boolean]", L1 = "[object Date]", Q1 = "[object DOMException]", e0 = "[object Error]", y0 = "[object Function]", zn = "[object GeneratorFunction]", or = "[object Map]", Fr = "[object Number]", g1 = "[object Null]", Hr = "[object Object]", t0 = "[object Promise]", Fn = "[object Proxy]", jr = "[object RegExp]", Zt = "[object Set]", Hn = "[object String]", Ti = "[object Symbol]", Ur = "[object Undefined]", Wr = "[object WeakMap]", b0 = "[object WeakSet]", x0 = "[object ArrayBuffer]", w0 = "[object DataView]", Da = "[object Float32Array]", Gr = "[object Float64Array]", tn = "[object Int8Array]", Ei = "[object Int16Array]", Ba = "[object Int32Array]", jn = "[object Uint8Array]", Un = "[object Uint8ClampedArray]", Na = "[object Uint16Array]", Oa = "[object Uint32Array]", Mu = /\b__p \+= '';/g, Ci = /\b(__p \+=) '' \+/g, xt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, h = /&(?:amp|lt|gt|quot|#39);/g, v = /[&<>"']/g, te = RegExp(h.source), x = RegExp(v.source), M = /<%-([\s\S]+?)%>/g, gt = /<%([\s\S]+?)%>/g, ue = /<%=([\s\S]+?)%>/g, sr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rn = /^\w*$/, Te = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Tt = /[\\^$.*+?()[\]{}|]/g, Ar = RegExp(Tt.source), nn = /^\s+/, B = /\s/, I1 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, L = /\{\n\/\* \[wrapped with (.+)\] \*/, os = /,? & /, ss = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, qa = /[()=,{}\[\]\/\s]/, ls = /\\(\\)?/g, us = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, ki = /\w*$/, cs = /^[-+]0x[0-9a-f]+$/i, Mi = /^0b[01]+$/i, Pa = /^\[object .+?Constructor\]$/, Di = /^0o[0-7]+$/i, De = /^(?:0|[1-9]\d*)$/, pr = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, wt = /($^)/, _0 = /['\n\r\u2028\u2029\\]/g, a1 = "\\ud800-\\udfff", La = "\\u0300-\\u036f", Ia = "\\ufe20-\\ufe2f", Bi = "\\u20d0-\\u20ff", Wn = La + Ia + Bi, Ra = "\\u2700-\\u27bf", fs = "a-z\\xdf-\\xf6\\xf8-\\xff", Du = "\\xac\\xb1\\xd7\\xf7", hs = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ds = "\\u2000-\\u206f", ms = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ps = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ni = "\\ufe0e\\ufe0f", gs = Du + hs + ds + ms, Oi = "['\u2019]", _t = "[" + a1 + "]", Gn = "[" + gs + "]", gr = "[" + Wn + "]", vs = "\\d+", Bu = "[" + Ra + "]", ys = "[" + fs + "]", bs = "[^" + a1 + gs + vs + Ra + fs + ps + "]", za = "\\ud83c[\\udffb-\\udfff]", Fa = "(?:" + gr + "|" + za + ")", lr = "[^" + a1 + "]", qi = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ha = "[\\ud800-\\udbff][\\udc00-\\udfff]", an = "[" + ps + "]", ja = "\\u200d", xs = "(?:" + ys + "|" + bs + ")", Nu = "(?:" + an + "|" + bs + ")", ws = "(?:" + Oi + "(?:d|ll|m|re|s|t|ve))?", _s = "(?:" + Oi + "(?:D|LL|M|RE|S|T|VE))?", Vn = Fa + "?", Ua = "[" + Ni + "]?", Ss = "(?:" + ja + "(?:" + [lr, qi, Ha].join("|") + ")" + Ua + Vn + ")*", Ou = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", H = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", vt = Ua + Vn + Ss, S0 = "(?:" + [Bu, qi, Ha].join("|") + ")" + vt, R1 = "(?:" + [lr + gr + "?", gr, qi, Ha, _t].join("|") + ")", qu = RegExp(Oi, "g"), Pu = RegExp(gr, "g"), Pi = RegExp(za + "(?=" + za + ")|" + R1 + vt, "g"), Li = RegExp([an + "?" + ys + "+" + ws + "(?=" + [Gn, an, "$"].join("|") + ")", Nu + "+" + _s + "(?=" + [Gn, an + xs, "$"].join("|") + ")", an + "?" + xs + "+" + ws, an + "+" + _s, H, Ou, vs, S0].join("|"), "g"), Ii = RegExp("[" + ja + a1 + Wn + Ni + "]"), ce = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, A0 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Ri = -1, Ne = {};
      Ne[Da] = Ne[Gr] = Ne[tn] = Ne[Ei] = Ne[Ba] = Ne[jn] = Ne[Un] = Ne[Na] = Ne[Oa] = true, Ne[i1] = Ne[Rr] = Ne[x0] = Ne[p1] = Ne[w0] = Ne[L1] = Ne[e0] = Ne[y0] = Ne[or] = Ne[Fr] = Ne[Hr] = Ne[jr] = Ne[Zt] = Ne[Hn] = Ne[Wr] = false;
      var Ke = {};
      Ke[i1] = Ke[Rr] = Ke[x0] = Ke[w0] = Ke[p1] = Ke[L1] = Ke[Da] = Ke[Gr] = Ke[tn] = Ke[Ei] = Ke[Ba] = Ke[or] = Ke[Fr] = Ke[Hr] = Ke[jr] = Ke[Zt] = Ke[Hn] = Ke[Ti] = Ke[jn] = Ke[Un] = Ke[Na] = Ke[Oa] = true, Ke[e0] = Ke[y0] = Ke[Wr] = false;
      var Lu = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, Iu = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Ru = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, zu = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Xt = parseFloat, As = parseInt, Wa = typeof global == "object" && global && global.Object === Object && global, Fu = typeof self == "object" && self && self.Object === Object && self, Nt = Wa || Fu || Function("return this")(), T0 = typeof fa == "object" && fa && !fa.nodeType && fa, Ie = T0 && typeof ko == "object" && ko && !ko.nodeType && ko, $n = Ie && Ie.exports === T0, Xn = $n && Wa.process, Tr = function() {
        try {
          var I = Ie && Ie.require && Ie.require("util").types;
          return I || Xn && Xn.binding && Xn.binding("util");
        } catch ($) {
        }
      }(), Er = Tr && Tr.isArrayBuffer, on = Tr && Tr.isDate, Ts = Tr && Tr.isMap, ne = Tr && Tr.isRegExp, Cr = Tr && Tr.isSet, zi = Tr && Tr.isTypedArray;
      function ur(I, $, W) {
        switch (W.length) {
          case 0:
            return I.call($);
          case 1:
            return I.call($, W[0]);
          case 2:
            return I.call($, W[0], W[1]);
          case 3:
            return I.call($, W[0], W[1], W[2]);
        }
        return I.apply($, W);
      }
      function kr(I, $, W, fe) {
        for (var Be = -1, nt = I == null ? 0 : I.length; ++Be < nt; ) {
          var Qe = I[Be];
          $(fe, Qe, W(Qe), I);
        }
        return fe;
      }
      function Lt(I, $) {
        for (var W = -1, fe = I == null ? 0 : I.length; ++W < fe && $(I[W], W, I) !== false; )
          ;
        return I;
      }
      function ct(I, $) {
        for (var W = I == null ? 0 : I.length; W-- && $(I[W], W, I) !== false; )
          ;
        return I;
      }
      function Ga(I, $) {
        for (var W = -1, fe = I == null ? 0 : I.length; ++W < fe; )
          if (!$(I[W], W, I))
            return false;
        return true;
      }
      function z1(I, $) {
        for (var W = -1, fe = I == null ? 0 : I.length, Be = 0, nt = []; ++W < fe; ) {
          var Qe = I[W];
          $(Qe, W, I) && (nt[Be++] = Qe);
        }
        return nt;
      }
      function Yn(I, $) {
        var W = I == null ? 0 : I.length;
        return !!W && r0(I, $, 0) > -1;
      }
      function Va(I, $, W) {
        for (var fe = -1, Be = I == null ? 0 : I.length; ++fe < Be; )
          if (W($, I[fe]))
            return true;
        return false;
      }
      function yt(I, $) {
        for (var W = -1, fe = I == null ? 0 : I.length, Be = Array(fe); ++W < fe; )
          Be[W] = $(I[W], W, I);
        return Be;
      }
      function E0(I, $) {
        for (var W = -1, fe = $.length, Be = I.length; ++W < fe; )
          I[Be + W] = $[W];
        return I;
      }
      function $a(I, $, W, fe) {
        var Be = -1, nt = I == null ? 0 : I.length;
        for (fe && nt && (W = I[++Be]); ++Be < nt; )
          W = $(W, I[Be], Be, I);
        return W;
      }
      function Hu(I, $, W, fe) {
        var Be = I == null ? 0 : I.length;
        for (fe && Be && (W = I[--Be]); Be--; )
          W = $(W, I[Be], Be, I);
        return W;
      }
      function Xa(I, $) {
        for (var W = -1, fe = I == null ? 0 : I.length; ++W < fe; )
          if ($(I[W], W, I))
            return true;
        return false;
      }
      var ju = Ka("length");
      function Uu(I) {
        return I.split("");
      }
      function Wu(I) {
        return I.match(ss) || [];
      }
      function v1(I, $, W) {
        var fe;
        return W(I, function(Be, nt, Qe) {
          if ($(Be, nt, Qe))
            return fe = nt, false;
        }), fe;
      }
      function Oe(I, $, W, fe) {
        for (var Be = I.length, nt = W + (fe ? 1 : -1); fe ? nt-- : ++nt < Be; )
          if ($(I[nt], nt, I))
            return nt;
        return -1;
      }
      function r0(I, $, W) {
        return $ === $ ? Os(I, $, W) : Oe(I, Hi, W);
      }
      function Fi(I, $, W, fe) {
        for (var Be = W - 1, nt = I.length; ++Be < nt; )
          if (fe(I[Be], $))
            return Be;
        return -1;
      }
      function Hi(I) {
        return I !== I;
      }
      function Ya(I, $) {
        var W = I == null ? 0 : I.length;
        return W ? ji(I, $) / W : Sr;
      }
      function Ka(I) {
        return function($) {
          return $ == null ? t2 : $[I];
        };
      }
      function sn(I) {
        return function($) {
          return I == null ? t2 : I[$];
        };
      }
      function Es(I, $, W, fe, Be) {
        return Be(I, function(nt, Qe, tt) {
          W = fe ? (fe = false, nt) : $(W, nt, Qe, tt);
        }), W;
      }
      function Cs(I, $) {
        var W = I.length;
        for (I.sort($); W--; )
          I[W] = I[W].value;
        return I;
      }
      function ji(I, $) {
        for (var W, fe = -1, Be = I.length; ++fe < Be; ) {
          var nt = $(I[fe]);
          nt !== t2 && (W = W === t2 ? nt : W + nt);
        }
        return W;
      }
      function Za(I, $) {
        for (var W = -1, fe = Array(I); ++W < I; )
          fe[W] = $(W);
        return fe;
      }
      function Gu(I, $) {
        return yt($, function(W) {
          return [W, I[W]];
        });
      }
      function ks(I) {
        return I && I.slice(0, qs(I) + 1).replace(nn, "");
      }
      function vr(I) {
        return function($) {
          return I($);
        };
      }
      function Ui(I, $) {
        return yt($, function(W) {
          return I[W];
        });
      }
      function C0(I, $) {
        return I.has($);
      }
      function Ja(I, $) {
        for (var W = -1, fe = I.length; ++W < fe && r0($, I[W], 0) > -1; )
          ;
        return W;
      }
      function Ms(I, $) {
        for (var W = I.length; W-- && r0($, I[W], 0) > -1; )
          ;
        return W;
      }
      function Ds(I, $) {
        for (var W = I.length, fe = 0; W--; )
          I[W] === $ && ++fe;
        return fe;
      }
      var Kn = sn(Lu), Qa = sn(Iu);
      function Bs(I) {
        return "\\" + zu[I];
      }
      function Vu(I, $) {
        return I == null ? t2 : I[$];
      }
      function ln(I) {
        return Ii.test(I);
      }
      function Ns(I) {
        return ce.test(I);
      }
      function eo(I) {
        for (var $, W = []; !($ = I.next()).done; )
          W.push($.value);
        return W;
      }
      function Zn(I) {
        var $ = -1, W = Array(I.size);
        return I.forEach(function(fe, Be) {
          W[++$] = [Be, fe];
        }), W;
      }
      function Wi(I, $) {
        return function(W) {
          return I($(W));
        };
      }
      function o1(I, $) {
        for (var W = -1, fe = I.length, Be = 0, nt = []; ++W < fe; ) {
          var Qe = I[W];
          (Qe === $ || Qe === P) && (I[W] = P, nt[Be++] = W);
        }
        return nt;
      }
      function Gi(I) {
        var $ = -1, W = Array(I.size);
        return I.forEach(function(fe) {
          W[++$] = fe;
        }), W;
      }
      function $u(I) {
        var $ = -1, W = Array(I.size);
        return I.forEach(function(fe) {
          W[++$] = [fe, fe];
        }), W;
      }
      function Os(I, $, W) {
        for (var fe = W - 1, Be = I.length; ++fe < Be; )
          if (I[fe] === $)
            return fe;
        return -1;
      }
      function to(I, $, W) {
        for (var fe = W + 1; fe--; )
          if (I[fe] === $)
            return fe;
        return fe;
      }
      function n0(I) {
        return ln(I) ? Xu(I) : ju(I);
      }
      function Mr(I) {
        return ln(I) ? Ls(I) : Uu(I);
      }
      function qs(I) {
        for (var $ = I.length; $-- && B.test(I.charAt($)); )
          ;
        return $;
      }
      var Ps = sn(Ru);
      function Xu(I) {
        for (var $ = Pi.lastIndex = 0; Pi.test(I); )
          ++$;
        return $;
      }
      function Ls(I) {
        return I.match(Pi) || [];
      }
      function Jn(I) {
        return I.match(Li) || [];
      }
      var Yu = function I($) {
        $ = $ == null ? Nt : i0.defaults(Nt.Object(), $, i0.pick(Nt, A0));
        var W = $.Array, fe = $.Date, Be = $.Error, nt = $.Function, Qe = $.Math, tt = $.Object, ro = $.RegExp, Vi = $.String, Dr = $.TypeError, un = W.prototype, no = nt.prototype, k0 = tt.prototype, Br = $["__core-js_shared__"], Qn = no.toString, rt = k0.hasOwnProperty, a0 = 0, $i = function() {
          var e = /[^.]+$/.exec(Br && Br.keys && Br.keys.IE_PROTO || "");
          return e ? "Symbol(src)_1." + e : "";
        }(), Nr = k0.toString, Ku = Qn.call(tt), y1 = Nt._, Is = ro("^" + Qn.call(rt).replace(Tt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Xi = $n ? $.Buffer : t2, F1 = $.Symbol, Yi = $.Uint8Array, io = Xi ? Xi.allocUnsafe : t2, ei = Wi(tt.getPrototypeOf, tt), Ki = tt.create, ao = k0.propertyIsEnumerable, ti = un.splice, oo = F1 ? F1.isConcatSpreadable : t2, cn = F1 ? F1.iterator : t2, H1 = F1 ? F1.toStringTag : t2, fn = function() {
          try {
            var e = li(tt, "defineProperty");
            return e({}, "", {}), e;
          } catch (n) {
          }
        }(), Rs = $.clearTimeout !== Nt.clearTimeout && $.clearTimeout, zs = fe && fe.now !== Nt.Date.now && fe.now, Fs = $.setTimeout !== Nt.setTimeout && $.setTimeout, Zi = Qe.ceil, hn = Qe.floor, Ji = tt.getOwnPropertySymbols, Hs = Xi ? Xi.isBuffer : t2, so = $.isFinite, dn = un.join, ri = Wi(tt.keys, tt), It = Qe.max, Jt = Qe.min, js = fe.now, A = $.parseInt, lo = Qe.random, Zu = un.reverse, Qi = li($, "DataView"), mn = li($, "Map"), uo = li($, "Promise"), M0 = li($, "Set"), ni = li($, "WeakMap"), pn = li(tt, "create"), gn = ni && new ni(), o0 = {}, Us = ui(Qi), Ws = ui(mn), Gs = ui(uo), Ju = ui(M0), Vs = ui(ni), ii = F1 ? F1.prototype : t2, ai = ii ? ii.valueOf : t2, j1 = ii ? ii.toString : t2;
        function _14(e) {
          if (Ot(e) && !Le(e) && !(e instanceof We)) {
            if (e instanceof $r)
              return e;
            if (rt.call(e, "__wrapped__"))
              return q6(e);
          }
          return new $r(e);
        }
        var Vr = function() {
          function e() {
          }
          return function(n) {
            if (!Mt(n))
              return {};
            if (Ki)
              return Ki(n);
            e.prototype = n;
            var u = new e();
            return e.prototype = t2, u;
          };
        }();
        function oi() {
        }
        function $r(e, n) {
          this.__wrapped__ = e, this.__actions__ = [], this.__chain__ = !!n, this.__index__ = 0, this.__values__ = t2;
        }
        _14.templateSettings = { escape: M, evaluate: gt, interpolate: ue, variable: "", imports: { _: _14 } }, _14.prototype = oi.prototype, _14.prototype.constructor = _14, $r.prototype = Vr(oi.prototype), $r.prototype.constructor = $r;
        function We(e) {
          this.__wrapped__ = e, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Pe, this.__views__ = [];
        }
        function Qu() {
          var e = new We(this.__wrapped__);
          return e.__actions__ = Yr(this.__actions__), e.__dir__ = this.__dir__, e.__filtered__ = this.__filtered__, e.__iteratees__ = Yr(this.__iteratees__), e.__takeCount__ = this.__takeCount__, e.__views__ = Yr(this.__views__), e;
        }
        function e2() {
          if (this.__filtered__) {
            var e = new We(this);
            e.__dir__ = -1, e.__filtered__ = true;
          } else
            e = this.clone(), e.__dir__ *= -1;
          return e;
        }
        function co() {
          var e = this.__wrapped__.value(), n = this.__dir__, u = Le(e), d = n < 0, b = u ? e.length : 0, E = Ph(0, b, this.__views__), D = E.start, q = E.end, R = q - D, Z = d ? q : D - 1, Q = this.__iteratees__, re = Q.length, le = 0, be = Jt(R, this.__takeCount__);
          if (!u || !d && b == R && be == R)
            return n6(e, this.__actions__);
          var Ce = [];
          e:
            for (; R-- && le < be; ) {
              Z += n;
              for (var Fe = -1, ke = e[Z]; ++Fe < re; ) {
                var Xe = Q[Fe], et = Xe.iteratee, u1 = Xe.type, Pr = et(ke);
                if (u1 == mt)
                  ke = Pr;
                else if (!Pr) {
                  if (u1 == Dt)
                    continue e;
                  break e;
                }
              }
              Ce[le++] = ke;
            }
          return Ce;
        }
        We.prototype = Vr(oi.prototype), We.prototype.constructor = We;
        function D0(e) {
          var n = -1, u = e == null ? 0 : e.length;
          for (this.clear(); ++n < u; ) {
            var d = e[n];
            this.set(d[0], d[1]);
          }
        }
        function t22() {
          this.__data__ = pn ? pn(null) : {}, this.size = 0;
        }
        function $s(e) {
          var n = this.has(e) && delete this.__data__[e];
          return this.size -= n ? 1 : 0, n;
        }
        function r22(e) {
          var n = this.__data__;
          if (pn) {
            var u = n[e];
            return u === T ? t2 : u;
          }
          return rt.call(n, e) ? n[e] : t2;
        }
        function n2(e) {
          var n = this.__data__;
          return pn ? n[e] !== t2 : rt.call(n, e);
        }
        function i2(e, n) {
          var u = this.__data__;
          return this.size += this.has(e) ? 0 : 1, u[e] = pn && n === t2 ? T : n, this;
        }
        D0.prototype.clear = t22, D0.prototype.delete = $s, D0.prototype.get = r22, D0.prototype.has = n2, D0.prototype.set = i2;
        function b1(e) {
          var n = -1, u = e == null ? 0 : e.length;
          for (this.clear(); ++n < u; ) {
            var d = e[n];
            this.set(d[0], d[1]);
          }
        }
        function fo() {
          this.__data__ = [], this.size = 0;
        }
        function Xs(e) {
          var n = this.__data__, u = y(n, e);
          if (u < 0)
            return false;
          var d = n.length - 1;
          return u == d ? n.pop() : ti.call(n, u, 1), --this.size, true;
        }
        function ho(e) {
          var n = this.__data__, u = y(n, e);
          return u < 0 ? t2 : n[u][1];
        }
        function Ys(e) {
          return y(this.__data__, e) > -1;
        }
        function Ks(e, n) {
          var u = this.__data__, d = y(u, e);
          return d < 0 ? (++this.size, u.push([e, n])) : u[d][1] = n, this;
        }
        b1.prototype.clear = fo, b1.prototype.delete = Xs, b1.prototype.get = ho, b1.prototype.has = Ys, b1.prototype.set = Ks;
        function U1(e) {
          var n = -1, u = e == null ? 0 : e.length;
          for (this.clear(); ++n < u; ) {
            var d = e[n];
            this.set(d[0], d[1]);
          }
        }
        function mo() {
          this.size = 0, this.__data__ = { hash: new D0(), map: new (mn || b1)(), string: new D0() };
        }
        function Zs(e) {
          var n = fl(this, e).delete(e);
          return this.size -= n ? 1 : 0, n;
        }
        function Js(e) {
          return fl(this, e).get(e);
        }
        function a2(e) {
          return fl(this, e).has(e);
        }
        function po(e, n) {
          var u = fl(this, e), d = u.size;
          return u.set(e, n), this.size += u.size == d ? 0 : 1, this;
        }
        U1.prototype.clear = mo, U1.prototype.delete = Zs, U1.prototype.get = Js, U1.prototype.has = a2, U1.prototype.set = po;
        function s0(e) {
          var n = -1, u = e == null ? 0 : e.length;
          for (this.__data__ = new U1(); ++n < u; )
            this.add(e[n]);
        }
        function o2(e) {
          return this.__data__.set(e, T), this;
        }
        function s2(e) {
          return this.__data__.has(e);
        }
        s0.prototype.add = s0.prototype.push = o2, s0.prototype.has = s2;
        function Xr(e) {
          var n = this.__data__ = new b1(e);
          this.size = n.size;
        }
        function go() {
          this.__data__ = new b1(), this.size = 0;
        }
        function l2(e) {
          var n = this.__data__, u = n.delete(e);
          return this.size = n.size, u;
        }
        function u2(e) {
          return this.__data__.get(e);
        }
        function c2(e) {
          return this.__data__.has(e);
        }
        function g(e, n) {
          var u = this.__data__;
          if (u instanceof b1) {
            var d = u.__data__;
            if (!mn || d.length < s - 1)
              return d.push([e, n]), this.size = ++u.size, this;
            u = this.__data__ = new U1(d);
          }
          return u.set(e, n), this.size = u.size, this;
        }
        Xr.prototype.clear = go, Xr.prototype.delete = l2, Xr.prototype.get = u2, Xr.prototype.has = c2, Xr.prototype.set = g;
        function i(e, n) {
          var u = Le(e), d = !u && ci(e), b = !u && !d && _n(e), E = !u && !d && !b && la(e), D = u || d || b || E, q = D ? Za(e.length, Vi) : [], R = q.length;
          for (var Z in e)
            (n || rt.call(e, Z)) && !(D && (Z == "length" || b && (Z == "offset" || Z == "parent") || E && (Z == "buffer" || Z == "byteLength" || Z == "byteOffset") || q0(Z, R))) && q.push(Z);
          return q;
        }
        function a(e) {
          var n = e.length;
          return n ? e[g2(0, n - 1)] : t2;
        }
        function o(e, n) {
          return hl(Yr(e), K(n, 0, e.length));
        }
        function l(e) {
          return hl(Yr(e));
        }
        function f(e, n, u) {
          (u !== t2 && !G1(e[n], u) || u === t2 && !(n in e)) && z(e, n, u);
        }
        function m(e, n, u) {
          var d = e[n];
          (!(rt.call(e, n) && G1(d, u)) || u === t2 && !(n in e)) && z(e, n, u);
        }
        function y(e, n) {
          for (var u = e.length; u--; )
            if (G1(e[u][0], n))
              return u;
          return -1;
        }
        function S(e, n, u, d) {
          return ge(e, function(b, E, D) {
            n(d, b, u(b), D);
          }), d;
        }
        function C2(e, n) {
          return e && u0(n, er(n), e);
        }
        function O(e, n) {
          return e && u0(n, Zr(n), e);
        }
        function z(e, n, u) {
          n == "__proto__" && fn ? fn(e, n, { configurable: true, enumerable: true, value: u, writable: true }) : e[n] = u;
        }
        function X(e, n) {
          for (var u = -1, d = n.length, b = W(d), E = e == null; ++u < d; )
            b[u] = E ? t2 : H2(e, n[u]);
          return b;
        }
        function K(e, n, u) {
          return e === e && (u !== t2 && (e = e <= u ? e : u), n !== t2 && (e = e >= n ? e : n)), e;
        }
        function Y(e, n, u, d, b, E) {
          var D, q = n & j, R = n & U, Z = n & ee;
          if (u && (D = b ? u(e, d, b, E) : u(e)), D !== t2)
            return D;
          if (!Mt(e))
            return e;
          var Q = Le(e);
          if (Q) {
            if (D = Ih(e), !q)
              return Yr(e, D);
          } else {
            var re = br(e), le = re == y0 || re == zn;
            if (_n(e))
              return o6(e, q);
            if (re == Hr || re == i1 || le && !b) {
              if (D = R || le ? {} : T6(e), !q)
                return R ? Eh(e, O(D, e)) : Th(e, C2(D, e));
            } else {
              if (!Ke[re])
                return b ? e : {};
              D = Rh(e, re, q);
            }
          }
          E || (E = new Xr());
          var be = E.get(e);
          if (be)
            return be;
          E.set(e, D), e7(e) ? e.forEach(function(ke) {
            D.add(Y(ke, n, u, ke, e, E));
          }) : J6(e) && e.forEach(function(ke, Xe) {
            D.set(Xe, Y(ke, n, u, Xe, e, E));
          });
          var Ce = Z ? R ? C22 : E2 : R ? Zr : er, Fe = Q ? t2 : Ce(e);
          return Lt(Fe || e, function(ke, Xe) {
            Fe && (Xe = ke, ke = e[Xe]), m(D, Xe, Y(ke, n, u, Xe, e, E));
          }), D;
        }
        function oe(e) {
          var n = er(e);
          return function(u) {
            return se(u, e, n);
          };
        }
        function se(e, n, u) {
          var d = u.length;
          if (e == null)
            return !d;
          for (e = tt(e); d--; ) {
            var b = u[d], E = n[b], D = e[b];
            if (D === t2 && !(b in e) || !E(D))
              return false;
          }
          return true;
        }
        function he(e, n, u) {
          if (typeof e != "function")
            throw new Dr(p);
          return Ao(function() {
            e.apply(t2, u);
          }, n);
        }
        function me(e, n, u, d) {
          var b = -1, E = Yn, D = true, q = e.length, R = [], Z = n.length;
          if (!q)
            return R;
          u && (n = yt(n, vr(u))), d ? (E = Va, D = false) : n.length >= s && (E = C0, D = false, n = new s0(n));
          e:
            for (; ++b < q; ) {
              var Q = e[b], re = u == null ? Q : u(Q);
              if (Q = d || Q !== 0 ? Q : 0, D && re === re) {
                for (var le = Z; le--; )
                  if (n[le] === re)
                    continue e;
                R.push(Q);
              } else
                E(n, re, d) || R.push(Q);
            }
          return R;
        }
        var ge = f6(Et), Ze = f6(x1, true);
        function st(e, n) {
          var u = true;
          return ge(e, function(d, b, E) {
            return u = !!n(d, b, E), u;
          }), u;
        }
        function ft(e, n, u) {
          for (var d = -1, b = e.length; ++d < b; ) {
            var E = e[d], D = n(E);
            if (D != null && (q === t2 ? D === D && !l1(D) : u(D, q)))
              var q = D, R = E;
          }
          return R;
        }
        function at(e, n, u, d) {
          var b = e.length;
          for (u = Re(u), u < 0 && (u = -u > b ? 0 : b + u), d = d === t2 || d > b ? b : Re(d), d < 0 && (d += b), d = u > d ? 0 : r7(d); u < d; )
            e[u++] = n;
          return e;
        }
        function ot(e, n) {
          var u = [];
          return ge(e, function(d, b, E) {
            n(d, b, E) && u.push(d);
          }), u;
        }
        function He(e, n, u, d, b) {
          var E = -1, D = e.length;
          for (u || (u = Fh), b || (b = []); ++E < D; ) {
            var q = e[E];
            n > 0 && u(q) ? n > 1 ? He(q, n - 1, u, d, b) : E0(b, q) : d || (b[b.length] = q);
          }
          return b;
        }
        var lt = h6(), yr = h6(true);
        function Et(e, n) {
          return e && lt(e, n, er);
        }
        function x1(e, n) {
          return e && yr(e, n, er);
        }
        function Or(e, n) {
          return z1(n, function(u) {
            return P0(e[u]);
          });
        }
        function Rt(e, n) {
          n = xn(n, e);
          for (var u = 0, d = n.length; e != null && u < d; )
            e = e[c0(n[u++])];
          return u && u == d ? e : t2;
        }
        function B0(e, n, u) {
          var d = n(e);
          return Le(e) ? d : E0(d, u(e));
        }
        function Qt(e) {
          return e == null ? e === t2 ? Ur : g1 : H1 && H1 in tt(e) ? qh(e) : $h(e);
        }
        function si(e, n) {
          return e > n;
        }
        function f2(e, n) {
          return e != null && rt.call(e, n);
        }
        function vo(e, n) {
          return e != null && n in tt(e);
        }
        function W1(e, n, u) {
          return e >= Jt(n, u) && e < It(n, u);
        }
        function ea(e, n, u) {
          for (var d = u ? Va : Yn, b = e[0].length, E = e.length, D = E, q = W(E), R = Infinity, Z = []; D--; ) {
            var Q = e[D];
            D && n && (Q = yt(Q, vr(n))), R = Jt(Q.length, R), q[D] = !u && (n || b >= 120 && Q.length >= 120) ? new s0(D && Q) : t2;
          }
          Q = e[0];
          var re = -1, le = q[0];
          e:
            for (; ++re < b && Z.length < R; ) {
              var be = Q[re], Ce = n ? n(be) : be;
              if (be = u || be !== 0 ? be : 0, !(le ? C0(le, Ce) : d(Z, Ce, u))) {
                for (D = E; --D; ) {
                  var Fe = q[D];
                  if (!(Fe ? C0(Fe, Ce) : d(e[D], Ce, u)))
                    continue e;
                }
                le && le.push(Ce), Z.push(be);
              }
            }
          return Z;
        }
        function h2(e, n, u, d) {
          return Et(e, function(b, E, D) {
            n(d, u(b), E, D);
          }), d;
        }
        function w1(e, n, u) {
          n = xn(n, e), e = M6(e, n);
          var d = e == null ? e : e[c0(S1(n))];
          return d == null ? t2 : ur(d, e, u);
        }
        function yo(e) {
          return Ot(e) && Qt(e) == i1;
        }
        function vn(e) {
          return Ot(e) && Qt(e) == x0;
        }
        function yn(e) {
          return Ot(e) && Qt(e) == L1;
        }
        function l0(e, n, u, d, b) {
          return e === n ? true : e == null || n == null || !Ot(e) && !Ot(n) ? e !== e && n !== n : ta(e, n, u, d, l0, b);
        }
        function ta(e, n, u, d, b, E) {
          var D = Le(e), q = Le(n), R = D ? Rr : br(e), Z = q ? Rr : br(n);
          R = R == i1 ? Hr : R, Z = Z == i1 ? Hr : Z;
          var Q = R == Hr, re = Z == Hr, le = R == Z;
          if (le && _n(e)) {
            if (!_n(n))
              return false;
            D = true, Q = false;
          }
          if (le && !Q)
            return E || (E = new Xr()), D || la(e) ? _62(e, n, u, d, b, E) : Nh(e, n, R, u, d, b, E);
          if (!(u & G)) {
            var be = Q && rt.call(e, "__wrapped__"), Ce = re && rt.call(n, "__wrapped__");
            if (be || Ce) {
              var Fe = be ? e.value() : e, ke = Ce ? n.value() : n;
              return E || (E = new Xr()), b(Fe, ke, u, d, E);
            }
          }
          return le ? (E || (E = new Xr()), Oh(e, n, u, d, b, E)) : false;
        }
        function d2(e) {
          return Ot(e) && br(e) == or;
        }
        function bo(e, n, u, d) {
          var b = u.length, E = b, D = !d;
          if (e == null)
            return !E;
          for (e = tt(e); b--; ) {
            var q = u[b];
            if (D && q[2] ? q[1] !== e[q[0]] : !(q[0] in e))
              return false;
          }
          for (; ++b < E; ) {
            q = u[b];
            var R = q[0], Z = e[R], Q = q[1];
            if (D && q[2]) {
              if (Z === t2 && !(R in e))
                return false;
            } else {
              var re = new Xr();
              if (d)
                var le = d(Z, Q, R, e, n, re);
              if (!(le === t2 ? l0(Q, Z, G | ae, d, re) : le))
                return false;
            }
          }
          return true;
        }
        function Qs(e) {
          if (!Mt(e) || jh(e))
            return false;
          var n = P0(e) ? Is : Pa;
          return n.test(ui(e));
        }
        function xo(e) {
          return Ot(e) && Qt(e) == jr;
        }
        function el(e) {
          return Ot(e) && br(e) == Zt;
        }
        function tl(e) {
          return Ot(e) && yl(e.length) && !!Ne[Qt(e)];
        }
        function ra(e) {
          return typeof e == "function" ? e : e == null ? Jr : typeof e == "object" ? Le(e) ? X8(e[0], e[1]) : $8(e) : d7(e);
        }
        function na(e) {
          if (!So(e))
            return ri(e);
          var n = [];
          for (var u in tt(e))
            rt.call(e, u) && u != "constructor" && n.push(u);
          return n;
        }
        function ia(e) {
          if (!Mt(e))
            return Vh(e);
          var n = So(e), u = [];
          for (var d in e)
            d == "constructor" && (n || !rt.call(e, d)) || u.push(d);
          return u;
        }
        function m2(e, n) {
          return e < n;
        }
        function V8(e, n) {
          var u = -1, d = Kr(e) ? W(e.length) : [];
          return ge(e, function(b, E, D) {
            d[++u] = n(b, E, D);
          }), d;
        }
        function $8(e) {
          var n = M2(e);
          return n.length == 1 && n[0][2] ? C6(n[0][0], n[0][1]) : function(u) {
            return u === e || bo(u, e, n);
          };
        }
        function X8(e, n) {
          return B2(e) && E6(n) ? C6(c0(e), n) : function(u) {
            var d = H2(u, e);
            return d === t2 && d === n ? j2(u, e) : l0(n, d, G | ae);
          };
        }
        function rl(e, n, u, d, b) {
          e !== n && lt(n, function(E, D) {
            if (b || (b = new Xr()), Mt(E))
              fh(e, n, D, u, rl, d, b);
            else {
              var q = d ? d(O2(e, D), E, D + "", e, n, b) : t2;
              q === t2 && (q = E), f(e, D, q);
            }
          }, Zr);
        }
        function fh(e, n, u, d, b, E, D) {
          var q = O2(e, u), R = O2(n, u), Z = D.get(R);
          if (Z) {
            f(e, u, Z);
            return;
          }
          var Q = E ? E(q, R, u + "", e, n, D) : t2, re = Q === t2;
          if (re) {
            var le = Le(R), be = !le && _n(R), Ce = !le && !be && la(R);
            Q = R, le || be || Ce ? Le(q) ? Q = q : zt(q) ? Q = Yr(q) : be ? (re = false, Q = o6(R, true)) : Ce ? (re = false, Q = s6(R, true)) : Q = [] : To(R) || ci(R) ? (Q = q, ci(q) ? Q = n7(q) : (!Mt(q) || P0(q)) && (Q = T6(R))) : re = false;
          }
          re && (D.set(R, Q), b(Q, R, d, E, D), D.delete(R)), f(e, u, Q);
        }
        function Y8(e, n) {
          var u = e.length;
          if (!!u)
            return n += n < 0 ? u : 0, q0(n, u) ? e[n] : t2;
        }
        function K8(e, n, u) {
          n.length ? n = yt(n, function(E) {
            return Le(E) ? function(D) {
              return Rt(D, E.length === 1 ? E[0] : E);
            } : E;
          }) : n = [Jr];
          var d = -1;
          n = yt(n, vr(Ee()));
          var b = V8(e, function(E, D, q) {
            var R = yt(n, function(Z) {
              return Z(E);
            });
            return { criteria: R, index: ++d, value: E };
          });
          return Cs(b, function(E, D) {
            return Ah(E, D, u);
          });
        }
        function hh(e, n) {
          return Z8(e, n, function(u, d) {
            return j2(e, d);
          });
        }
        function Z8(e, n, u) {
          for (var d = -1, b = n.length, E = {}; ++d < b; ) {
            var D = n[d], q = Rt(e, D);
            u(q, D) && wo(E, xn(D, e), q);
          }
          return E;
        }
        function dh(e) {
          return function(n) {
            return Rt(n, e);
          };
        }
        function p2(e, n, u, d) {
          var b = d ? Fi : r0, E = -1, D = n.length, q = e;
          for (e === n && (n = Yr(n)), u && (q = yt(e, vr(u))); ++E < D; )
            for (var R = 0, Z = n[E], Q = u ? u(Z) : Z; (R = b(q, Q, R, d)) > -1; )
              q !== e && ti.call(q, R, 1), ti.call(e, R, 1);
          return e;
        }
        function J8(e, n) {
          for (var u = e ? n.length : 0, d = u - 1; u--; ) {
            var b = n[u];
            if (u == d || b !== E) {
              var E = b;
              q0(b) ? ti.call(e, b, 1) : b2(e, b);
            }
          }
          return e;
        }
        function g2(e, n) {
          return e + hn(lo() * (n - e + 1));
        }
        function mh(e, n, u, d) {
          for (var b = -1, E = It(Zi((n - e) / (u || 1)), 0), D = W(E); E--; )
            D[d ? E : ++b] = e, e += u;
          return D;
        }
        function v2(e, n) {
          var u = "";
          if (!e || n < 1 || n > Bt)
            return u;
          do
            n % 2 && (u += e), n = hn(n / 2), n && (e += e);
          while (n);
          return u;
        }
        function je(e, n) {
          return q2(k6(e, n, Jr), e + "");
        }
        function ph(e) {
          return a(ua(e));
        }
        function gh(e, n) {
          var u = ua(e);
          return hl(u, K(n, 0, u.length));
        }
        function wo(e, n, u, d) {
          if (!Mt(e))
            return e;
          n = xn(n, e);
          for (var b = -1, E = n.length, D = E - 1, q = e; q != null && ++b < E; ) {
            var R = c0(n[b]), Z = u;
            if (R === "__proto__" || R === "constructor" || R === "prototype")
              return e;
            if (b != D) {
              var Q = q[R];
              Z = d ? d(Q, R, q) : t2, Z === t2 && (Z = Mt(Q) ? Q : q0(n[b + 1]) ? [] : {});
            }
            m(q, R, Z), q = q[R];
          }
          return e;
        }
        var Q8 = gn ? function(e, n) {
          return gn.set(e, n), e;
        } : Jr, vh = fn ? function(e, n) {
          return fn(e, "toString", { configurable: true, enumerable: false, value: W2(n), writable: true });
        } : Jr;
        function yh(e) {
          return hl(ua(e));
        }
        function _1(e, n, u) {
          var d = -1, b = e.length;
          n < 0 && (n = -n > b ? 0 : b + n), u = u > b ? b : u, u < 0 && (u += b), b = n > u ? 0 : u - n >>> 0, n >>>= 0;
          for (var E = W(b); ++d < b; )
            E[d] = e[d + n];
          return E;
        }
        function bh(e, n) {
          var u;
          return ge(e, function(d, b, E) {
            return u = n(d, b, E), !u;
          }), !!u;
        }
        function nl(e, n, u) {
          var d = 0, b = e == null ? d : e.length;
          if (typeof n == "number" && n === n && b <= J1) {
            for (; d < b; ) {
              var E = d + b >>> 1, D = e[E];
              D !== null && !l1(D) && (u ? D <= n : D < n) ? d = E + 1 : b = E;
            }
            return b;
          }
          return y2(e, n, Jr, u);
        }
        function y2(e, n, u, d) {
          var b = 0, E = e == null ? 0 : e.length;
          if (E === 0)
            return 0;
          n = u(n);
          for (var D = n !== n, q = n === null, R = l1(n), Z = n === t2; b < E; ) {
            var Q = hn((b + E) / 2), re = u(e[Q]), le = re !== t2, be = re === null, Ce = re === re, Fe = l1(re);
            if (D)
              var ke = d || Ce;
            else
              Z ? ke = Ce && (d || le) : q ? ke = Ce && le && (d || !be) : R ? ke = Ce && le && !be && (d || !Fe) : be || Fe ? ke = false : ke = d ? re <= n : re < n;
            ke ? b = Q + 1 : E = Q;
          }
          return Jt(E, pt);
        }
        function e6(e, n) {
          for (var u = -1, d = e.length, b = 0, E = []; ++u < d; ) {
            var D = e[u], q = n ? n(D) : D;
            if (!u || !G1(q, R)) {
              var R = q;
              E[b++] = D === 0 ? 0 : D;
            }
          }
          return E;
        }
        function t6(e) {
          return typeof e == "number" ? e : l1(e) ? Sr : +e;
        }
        function s1(e) {
          if (typeof e == "string")
            return e;
          if (Le(e))
            return yt(e, s1) + "";
          if (l1(e))
            return j1 ? j1.call(e) : "";
          var n = e + "";
          return n == "0" && 1 / e == -$t ? "-0" : n;
        }
        function bn(e, n, u) {
          var d = -1, b = Yn, E = e.length, D = true, q = [], R = q;
          if (u)
            D = false, b = Va;
          else if (E >= s) {
            var Z = n ? null : Dh(e);
            if (Z)
              return Gi(Z);
            D = false, b = C0, R = new s0();
          } else
            R = n ? [] : q;
          e:
            for (; ++d < E; ) {
              var Q = e[d], re = n ? n(Q) : Q;
              if (Q = u || Q !== 0 ? Q : 0, D && re === re) {
                for (var le = R.length; le--; )
                  if (R[le] === re)
                    continue e;
                n && R.push(re), q.push(Q);
              } else
                b(R, re, u) || (R !== q && R.push(re), q.push(Q));
            }
          return q;
        }
        function b2(e, n) {
          return n = xn(n, e), e = M6(e, n), e == null || delete e[c0(S1(n))];
        }
        function r62(e, n, u, d) {
          return wo(e, n, u(Rt(e, n)), d);
        }
        function il(e, n, u, d) {
          for (var b = e.length, E = d ? b : -1; (d ? E-- : ++E < b) && n(e[E], E, e); )
            ;
          return u ? _1(e, d ? 0 : E, d ? E + 1 : b) : _1(e, d ? E + 1 : 0, d ? b : E);
        }
        function n6(e, n) {
          var u = e;
          return u instanceof We && (u = u.value()), $a(n, function(d, b) {
            return b.func.apply(b.thisArg, E0([d], b.args));
          }, u);
        }
        function x2(e, n, u) {
          var d = e.length;
          if (d < 2)
            return d ? bn(e[0]) : [];
          for (var b = -1, E = W(d); ++b < d; )
            for (var D = e[b], q = -1; ++q < d; )
              q != b && (E[b] = me(E[b] || D, e[q], n, u));
          return bn(He(E, 1), n, u);
        }
        function i6(e, n, u) {
          for (var d = -1, b = e.length, E = n.length, D = {}; ++d < b; ) {
            var q = d < E ? n[d] : t2;
            u(D, e[d], q);
          }
          return D;
        }
        function w2(e) {
          return zt(e) ? e : [];
        }
        function _22(e) {
          return typeof e == "function" ? e : Jr;
        }
        function xn(e, n) {
          return Le(e) ? e : B2(e, n) ? [e] : O6(ut(e));
        }
        var xh = je;
        function wn(e, n, u) {
          var d = e.length;
          return u = u === t2 ? d : u, !n && u >= d ? e : _1(e, n, u);
        }
        var a6 = Rs || function(e) {
          return Nt.clearTimeout(e);
        };
        function o6(e, n) {
          if (n)
            return e.slice();
          var u = e.length, d = io ? io(u) : new e.constructor(u);
          return e.copy(d), d;
        }
        function S2(e) {
          var n = new e.constructor(e.byteLength);
          return new Yi(n).set(new Yi(e)), n;
        }
        function wh(e, n) {
          var u = n ? S2(e.buffer) : e.buffer;
          return new e.constructor(u, e.byteOffset, e.byteLength);
        }
        function _h(e) {
          var n = new e.constructor(e.source, ki.exec(e));
          return n.lastIndex = e.lastIndex, n;
        }
        function Sh(e) {
          return ai ? tt(ai.call(e)) : {};
        }
        function s6(e, n) {
          var u = n ? S2(e.buffer) : e.buffer;
          return new e.constructor(u, e.byteOffset, e.length);
        }
        function l6(e, n) {
          if (e !== n) {
            var u = e !== t2, d = e === null, b = e === e, E = l1(e), D = n !== t2, q = n === null, R = n === n, Z = l1(n);
            if (!q && !Z && !E && e > n || E && D && R && !q && !Z || d && D && R || !u && R || !b)
              return 1;
            if (!d && !E && !Z && e < n || Z && u && b && !d && !E || q && u && b || !D && b || !R)
              return -1;
          }
          return 0;
        }
        function Ah(e, n, u) {
          for (var d = -1, b = e.criteria, E = n.criteria, D = b.length, q = u.length; ++d < D; ) {
            var R = l6(b[d], E[d]);
            if (R) {
              if (d >= q)
                return R;
              var Z = u[d];
              return R * (Z == "desc" ? -1 : 1);
            }
          }
          return e.index - n.index;
        }
        function u6(e, n, u, d) {
          for (var b = -1, E = e.length, D = u.length, q = -1, R = n.length, Z = It(E - D, 0), Q = W(R + Z), re = !d; ++q < R; )
            Q[q] = n[q];
          for (; ++b < D; )
            (re || b < E) && (Q[u[b]] = e[b]);
          for (; Z--; )
            Q[q++] = e[b++];
          return Q;
        }
        function c6(e, n, u, d) {
          for (var b = -1, E = e.length, D = -1, q = u.length, R = -1, Z = n.length, Q = It(E - q, 0), re = W(Q + Z), le = !d; ++b < Q; )
            re[b] = e[b];
          for (var be = b; ++R < Z; )
            re[be + R] = n[R];
          for (; ++D < q; )
            (le || b < E) && (re[be + u[D]] = e[b++]);
          return re;
        }
        function Yr(e, n) {
          var u = -1, d = e.length;
          for (n || (n = W(d)); ++u < d; )
            n[u] = e[u];
          return n;
        }
        function u0(e, n, u, d) {
          var b = !u;
          u || (u = {});
          for (var E = -1, D = n.length; ++E < D; ) {
            var q = n[E], R = d ? d(u[q], e[q], q, u, e) : t2;
            R === t2 && (R = e[q]), b ? z(u, q, R) : m(u, q, R);
          }
          return u;
        }
        function Th(e, n) {
          return u0(e, D2(e), n);
        }
        function Eh(e, n) {
          return u0(e, S6(e), n);
        }
        function al(e, n) {
          return function(u, d) {
            var b = Le(u) ? kr : S, E = n ? n() : {};
            return b(u, e, Ee(d, 2), E);
          };
        }
        function aa(e) {
          return je(function(n, u) {
            var d = -1, b = u.length, E = b > 1 ? u[b - 1] : t2, D = b > 2 ? u[2] : t2;
            for (E = e.length > 3 && typeof E == "function" ? (b--, E) : t2, D && qr(u[0], u[1], D) && (E = b < 3 ? t2 : E, b = 1), n = tt(n); ++d < b; ) {
              var q = u[d];
              q && e(n, q, d, E);
            }
            return n;
          });
        }
        function f6(e, n) {
          return function(u, d) {
            if (u == null)
              return u;
            if (!Kr(u))
              return e(u, d);
            for (var b = u.length, E = n ? b : -1, D = tt(u); (n ? E-- : ++E < b) && d(D[E], E, D) !== false; )
              ;
            return u;
          };
        }
        function h6(e) {
          return function(n, u, d) {
            for (var b = -1, E = tt(n), D = d(n), q = D.length; q--; ) {
              var R = D[e ? q : ++b];
              if (u(E[R], R, E) === false)
                break;
            }
            return n;
          };
        }
        function Ch(e, n, u) {
          var d = n & ie3, b = _o(e);
          function E() {
            var D = this && this !== Nt && this instanceof E ? b : e;
            return D.apply(d ? u : this, arguments);
          }
          return E;
        }
        function d6(e) {
          return function(n) {
            n = ut(n);
            var u = ln(n) ? Mr(n) : t2, d = u ? u[0] : n.charAt(0), b = u ? wn(u, 1).join("") : n.slice(1);
            return d[e]() + b;
          };
        }
        function oa(e) {
          return function(n) {
            return $a(f7(c7(n).replace(qu, "")), e, "");
          };
        }
        function _o(e) {
          return function() {
            var n = arguments;
            switch (n.length) {
              case 0:
                return new e();
              case 1:
                return new e(n[0]);
              case 2:
                return new e(n[0], n[1]);
              case 3:
                return new e(n[0], n[1], n[2]);
              case 4:
                return new e(n[0], n[1], n[2], n[3]);
              case 5:
                return new e(n[0], n[1], n[2], n[3], n[4]);
              case 6:
                return new e(n[0], n[1], n[2], n[3], n[4], n[5]);
              case 7:
                return new e(n[0], n[1], n[2], n[3], n[4], n[5], n[6]);
            }
            var u = Vr(e.prototype), d = e.apply(u, n);
            return Mt(d) ? d : u;
          };
        }
        function kh(e, n, u) {
          var d = _o(e);
          function b() {
            for (var E = arguments.length, D = W(E), q = E, R = sa(b); q--; )
              D[q] = arguments[q];
            var Z = E < 3 && D[0] !== R && D[E - 1] !== R ? [] : o1(D, R);
            if (E -= Z.length, E < u)
              return y6(e, n, ol, b.placeholder, t2, D, Z, t2, t2, u - E);
            var Q = this && this !== Nt && this instanceof b ? d : e;
            return ur(Q, this, D);
          }
          return b;
        }
        function m6(e) {
          return function(n, u, d) {
            var b = tt(n);
            if (!Kr(n)) {
              var E = Ee(u, 3);
              n = er(n), u = function(q) {
                return E(b[q], q, b);
              };
            }
            var D = e(n, u, d);
            return D > -1 ? b[E ? n[D] : D] : t2;
          };
        }
        function p6(e) {
          return O0(function(n) {
            var u = n.length, d = u, b = $r.prototype.thru;
            for (e && n.reverse(); d--; ) {
              var E = n[d];
              if (typeof E != "function")
                throw new Dr(p);
              if (b && !D && cl(E) == "wrapper")
                var D = new $r([], true);
            }
            for (d = D ? d : u; ++d < u; ) {
              E = n[d];
              var q = cl(E), R = q == "wrapper" ? k2(E) : t2;
              R && N2(R[0]) && R[1] == (ye | ve | Me | xe) && !R[4].length && R[9] == 1 ? D = D[cl(R[0])].apply(D, R[3]) : D = E.length == 1 && N2(E) ? D[q]() : D.thru(E);
            }
            return function() {
              var Z = arguments, Q = Z[0];
              if (D && Z.length == 1 && Le(Q))
                return D.plant(Q).value();
              for (var re = 0, le = u ? n[re].apply(this, Z) : Q; ++re < u; )
                le = n[re].call(this, le);
              return le;
            };
          });
        }
        function ol(e, n, u, d, b, E, D, q, R, Z) {
          var Q = n & ye, re = n & ie3, le = n & V, be = n & (ve | _e2), Ce = n & Se, Fe = le ? t2 : _o(e);
          function ke() {
            for (var Xe = arguments.length, et = W(Xe), u1 = Xe; u1--; )
              et[u1] = arguments[u1];
            if (be)
              var Pr = sa(ke), c1 = Ds(et, Pr);
            if (d && (et = u6(et, d, b, be)), E && (et = c6(et, E, D, be)), Xe -= c1, be && Xe < Z) {
              var Ft = o1(et, Pr);
              return y6(e, n, ol, ke.placeholder, u, et, Ft, q, R, Z - Xe);
            }
            var V1 = re ? u : this, I0 = le ? V1[e] : e;
            return Xe = et.length, q ? et = Xh(et, q) : Ce && Xe > 1 && et.reverse(), Q && R < Xe && (et.length = R), this && this !== Nt && this instanceof ke && (I0 = Fe || _o(I0)), I0.apply(V1, et);
          }
          return ke;
        }
        function g6(e, n) {
          return function(u, d) {
            return h2(u, e, n(d), {});
          };
        }
        function sl(e, n) {
          return function(u, d) {
            var b;
            if (u === t2 && d === t2)
              return n;
            if (u !== t2 && (b = u), d !== t2) {
              if (b === t2)
                return d;
              typeof u == "string" || typeof d == "string" ? (u = s1(u), d = s1(d)) : (u = t6(u), d = t6(d)), b = e(u, d);
            }
            return b;
          };
        }
        function A2(e) {
          return O0(function(n) {
            return n = yt(n, vr(Ee())), je(function(u) {
              var d = this;
              return e(n, function(b) {
                return ur(b, d, u);
              });
            });
          });
        }
        function ll(e, n) {
          n = n === t2 ? " " : s1(n);
          var u = n.length;
          if (u < 2)
            return u ? v2(n, e) : n;
          var d = v2(n, Zi(e / n0(n)));
          return ln(n) ? wn(Mr(d), 0, e).join("") : d.slice(0, e);
        }
        function Mh(e, n, u, d) {
          var b = n & ie3, E = _o(e);
          function D() {
            for (var q = -1, R = arguments.length, Z = -1, Q = d.length, re = W(Q + R), le = this && this !== Nt && this instanceof D ? E : e; ++Z < Q; )
              re[Z] = d[Z];
            for (; R--; )
              re[Z++] = arguments[++q];
            return ur(le, b ? u : this, re);
          }
          return D;
        }
        function v6(e) {
          return function(n, u, d) {
            return d && typeof d != "number" && qr(n, u, d) && (u = d = t2), n = L0(n), u === t2 ? (u = n, n = 0) : u = L0(u), d = d === t2 ? n < u ? 1 : -1 : L0(d), mh(n, u, d, e);
          };
        }
        function ul(e) {
          return function(n, u) {
            return typeof n == "string" && typeof u == "string" || (n = A1(n), u = A1(u)), e(n, u);
          };
        }
        function y6(e, n, u, d, b, E, D, q, R, Z) {
          var Q = n & ve, re = Q ? D : t2, le = Q ? t2 : D, be = Q ? E : t2, Ce = Q ? t2 : E;
          n |= Q ? Me : we, n &= ~(Q ? we : Me), n & de || (n &= ~(ie3 | V));
          var Fe = [e, n, b, be, re, Ce, le, q, R, Z], ke = u.apply(t2, Fe);
          return N2(e) && D6(ke, Fe), ke.placeholder = d, B6(ke, e, n);
        }
        function T2(e) {
          var n = Qe[e];
          return function(u, d) {
            if (u = A1(u), d = d == null ? 0 : Jt(Re(d), 292), d && so(u)) {
              var b = (ut(u) + "e").split("e"), E = n(b[0] + "e" + (+b[1] + d));
              return b = (ut(E) + "e").split("e"), +(b[0] + "e" + (+b[1] - d));
            }
            return n(u);
          };
        }
        var Dh = M0 && 1 / Gi(new M0([, -0]))[1] == $t ? function(e) {
          return new M0(e);
        } : $2;
        function b6(e) {
          return function(n) {
            var u = br(n);
            return u == or ? Zn(n) : u == Zt ? $u(n) : Gu(n, e(n));
          };
        }
        function N0(e, n, u, d, b, E, D, q) {
          var R = n & V;
          if (!R && typeof e != "function")
            throw new Dr(p);
          var Z = d ? d.length : 0;
          if (Z || (n &= ~(Me | we), d = b = t2), D = D === t2 ? D : It(Re(D), 0), q = q === t2 ? q : Re(q), Z -= b ? b.length : 0, n & we) {
            var Q = d, re = b;
            d = b = t2;
          }
          var le = R ? t2 : k2(e), be = [e, n, u, d, b, Q, re, E, D, q];
          if (le && Gh(be, le), e = be[0], n = be[1], u = be[2], d = be[3], b = be[4], q = be[9] = be[9] === t2 ? R ? 0 : e.length : It(be[9] - Z, 0), !q && n & (ve | _e2) && (n &= ~(ve | _e2)), !n || n == ie3)
            var Ce = Ch(e, n, u);
          else
            n == ve || n == _e2 ? Ce = kh(e, n, q) : (n == Me || n == (ie3 | Me)) && !b.length ? Ce = Mh(e, n, u, d) : Ce = ol.apply(t2, be);
          var Fe = le ? Q8 : D6;
          return B6(Fe(Ce, be), e, n);
        }
        function x6(e, n, u, d) {
          return e === t2 || G1(e, k0[u]) && !rt.call(d, u) ? n : e;
        }
        function w6(e, n, u, d, b, E) {
          return Mt(e) && Mt(n) && (E.set(n, e), rl(e, n, t2, w6, E), E.delete(n)), e;
        }
        function Bh(e) {
          return To(e) ? t2 : e;
        }
        function _62(e, n, u, d, b, E) {
          var D = u & G, q = e.length, R = n.length;
          if (q != R && !(D && R > q))
            return false;
          var Z = E.get(e), Q = E.get(n);
          if (Z && Q)
            return Z == n && Q == e;
          var re = -1, le = true, be = u & ae ? new s0() : t2;
          for (E.set(e, n), E.set(n, e); ++re < q; ) {
            var Ce = e[re], Fe = n[re];
            if (d)
              var ke = D ? d(Fe, Ce, re, n, e, E) : d(Ce, Fe, re, e, n, E);
            if (ke !== t2) {
              if (ke)
                continue;
              le = false;
              break;
            }
            if (be) {
              if (!Xa(n, function(Xe, et) {
                if (!C0(be, et) && (Ce === Xe || b(Ce, Xe, u, d, E)))
                  return be.push(et);
              })) {
                le = false;
                break;
              }
            } else if (!(Ce === Fe || b(Ce, Fe, u, d, E))) {
              le = false;
              break;
            }
          }
          return E.delete(e), E.delete(n), le;
        }
        function Nh(e, n, u, d, b, E, D) {
          switch (u) {
            case w0:
              if (e.byteLength != n.byteLength || e.byteOffset != n.byteOffset)
                return false;
              e = e.buffer, n = n.buffer;
            case x0:
              return !(e.byteLength != n.byteLength || !E(new Yi(e), new Yi(n)));
            case p1:
            case L1:
            case Fr:
              return G1(+e, +n);
            case e0:
              return e.name == n.name && e.message == n.message;
            case jr:
            case Hn:
              return e == n + "";
            case or:
              var q = Zn;
            case Zt:
              var R = d & G;
              if (q || (q = Gi), e.size != n.size && !R)
                return false;
              var Z = D.get(e);
              if (Z)
                return Z == n;
              d |= ae, D.set(e, n);
              var Q = _62(q(e), q(n), d, b, E, D);
              return D.delete(e), Q;
            case Ti:
              if (ai)
                return ai.call(e) == ai.call(n);
          }
          return false;
        }
        function Oh(e, n, u, d, b, E) {
          var D = u & G, q = E2(e), R = q.length, Z = E2(n), Q = Z.length;
          if (R != Q && !D)
            return false;
          for (var re = R; re--; ) {
            var le = q[re];
            if (!(D ? le in n : rt.call(n, le)))
              return false;
          }
          var be = E.get(e), Ce = E.get(n);
          if (be && Ce)
            return be == n && Ce == e;
          var Fe = true;
          E.set(e, n), E.set(n, e);
          for (var ke = D; ++re < R; ) {
            le = q[re];
            var Xe = e[le], et = n[le];
            if (d)
              var u1 = D ? d(et, Xe, le, n, e, E) : d(Xe, et, le, e, n, E);
            if (!(u1 === t2 ? Xe === et || b(Xe, et, u, d, E) : u1)) {
              Fe = false;
              break;
            }
            ke || (ke = le == "constructor");
          }
          if (Fe && !ke) {
            var Pr = e.constructor, c1 = n.constructor;
            Pr != c1 && "constructor" in e && "constructor" in n && !(typeof Pr == "function" && Pr instanceof Pr && typeof c1 == "function" && c1 instanceof c1) && (Fe = false);
          }
          return E.delete(e), E.delete(n), Fe;
        }
        function O0(e) {
          return q2(k6(e, t2, I6), e + "");
        }
        function E2(e) {
          return B0(e, er, D2);
        }
        function C22(e) {
          return B0(e, Zr, S6);
        }
        var k2 = gn ? function(e) {
          return gn.get(e);
        } : $2;
        function cl(e) {
          for (var n = e.name + "", u = o0[n], d = rt.call(o0, n) ? u.length : 0; d--; ) {
            var b = u[d], E = b.func;
            if (E == null || E == e)
              return b.name;
          }
          return n;
        }
        function sa(e) {
          var n = rt.call(_14, "placeholder") ? _14 : e;
          return n.placeholder;
        }
        function Ee() {
          var e = _14.iteratee || G2;
          return e = e === G2 ? ra : e, arguments.length ? e(arguments[0], arguments[1]) : e;
        }
        function fl(e, n) {
          var u = e.__data__;
          return Hh(n) ? u[typeof n == "string" ? "string" : "hash"] : u.map;
        }
        function M2(e) {
          for (var n = er(e), u = n.length; u--; ) {
            var d = n[u], b = e[d];
            n[u] = [d, b, E6(b)];
          }
          return n;
        }
        function li(e, n) {
          var u = Vu(e, n);
          return Qs(u) ? u : t2;
        }
        function qh(e) {
          var n = rt.call(e, H1), u = e[H1];
          try {
            e[H1] = t2;
            var d = true;
          } catch (E) {
          }
          var b = Nr.call(e);
          return d && (n ? e[H1] = u : delete e[H1]), b;
        }
        var D2 = Ji ? function(e) {
          return e == null ? [] : (e = tt(e), z1(Ji(e), function(n) {
            return ao.call(e, n);
          }));
        } : X2, S6 = Ji ? function(e) {
          for (var n = []; e; )
            E0(n, D2(e)), e = ei(e);
          return n;
        } : X2, br = Qt;
        (Qi && br(new Qi(new ArrayBuffer(1))) != w0 || mn && br(new mn()) != or || uo && br(uo.resolve()) != t0 || M0 && br(new M0()) != Zt || ni && br(new ni()) != Wr) && (br = function(e) {
          var n = Qt(e), u = n == Hr ? e.constructor : t2, d = u ? ui(u) : "";
          if (d)
            switch (d) {
              case Us:
                return w0;
              case Ws:
                return or;
              case Gs:
                return t0;
              case Ju:
                return Zt;
              case Vs:
                return Wr;
            }
          return n;
        });
        function Ph(e, n, u) {
          for (var d = -1, b = u.length; ++d < b; ) {
            var E = u[d], D = E.size;
            switch (E.type) {
              case "drop":
                e += D;
                break;
              case "dropRight":
                n -= D;
                break;
              case "take":
                n = Jt(n, e + D);
                break;
              case "takeRight":
                e = It(e, n - D);
                break;
            }
          }
          return { start: e, end: n };
        }
        function Lh(e) {
          var n = e.match(L);
          return n ? n[1].split(os) : [];
        }
        function A6(e, n, u) {
          n = xn(n, e);
          for (var d = -1, b = n.length, E = false; ++d < b; ) {
            var D = c0(n[d]);
            if (!(E = e != null && u(e, D)))
              break;
            e = e[D];
          }
          return E || ++d != b ? E : (b = e == null ? 0 : e.length, !!b && yl(b) && q0(D, b) && (Le(e) || ci(e)));
        }
        function Ih(e) {
          var n = e.length, u = new e.constructor(n);
          return n && typeof e[0] == "string" && rt.call(e, "index") && (u.index = e.index, u.input = e.input), u;
        }
        function T6(e) {
          return typeof e.constructor == "function" && !So(e) ? Vr(ei(e)) : {};
        }
        function Rh(e, n, u) {
          var d = e.constructor;
          switch (n) {
            case x0:
              return S2(e);
            case p1:
            case L1:
              return new d(+e);
            case w0:
              return wh(e, u);
            case Da:
            case Gr:
            case tn:
            case Ei:
            case Ba:
            case jn:
            case Un:
            case Na:
            case Oa:
              return s6(e, u);
            case or:
              return new d();
            case Fr:
            case Hn:
              return new d(e);
            case jr:
              return _h(e);
            case Zt:
              return new d();
            case Ti:
              return Sh(e);
          }
        }
        function zh(e, n) {
          var u = n.length;
          if (!u)
            return e;
          var d = u - 1;
          return n[d] = (u > 1 ? "& " : "") + n[d], n = n.join(u > 2 ? ", " : " "), e.replace(I1, `{
/* [wrapped with ` + n + `] */
`);
        }
        function Fh(e) {
          return Le(e) || ci(e) || !!(oo && e && e[oo]);
        }
        function q0(e, n) {
          var u = typeof e;
          return n = n ?? Bt, !!n && (u == "number" || u != "symbol" && De.test(e)) && e > -1 && e % 1 == 0 && e < n;
        }
        function qr(e, n, u) {
          if (!Mt(u))
            return false;
          var d = typeof n;
          return (d == "number" ? Kr(u) && q0(n, u.length) : d == "string" && n in u) ? G1(u[n], e) : false;
        }
        function B2(e, n) {
          if (Le(e))
            return false;
          var u = typeof e;
          return u == "number" || u == "symbol" || u == "boolean" || e == null || l1(e) ? true : rn.test(e) || !sr.test(e) || n != null && e in tt(n);
        }
        function Hh(e) {
          var n = typeof e;
          return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? e !== "__proto__" : e === null;
        }
        function N2(e) {
          var n = cl(e), u = _14[n];
          if (typeof u != "function" || !(n in We.prototype))
            return false;
          if (e === u)
            return true;
          var d = k2(u);
          return !!d && e === d[0];
        }
        function jh(e) {
          return !!$i && $i in e;
        }
        var Uh = Br ? P0 : Y2;
        function So(e) {
          var n = e && e.constructor, u = typeof n == "function" && n.prototype || k0;
          return e === u;
        }
        function E6(e) {
          return e === e && !Mt(e);
        }
        function C6(e, n) {
          return function(u) {
            return u == null ? false : u[e] === n && (n !== t2 || e in tt(u));
          };
        }
        function Wh(e) {
          var n = gl(e, function(d) {
            return u.size === k && u.clear(), d;
          }), u = n.cache;
          return n;
        }
        function Gh(e, n) {
          var u = e[1], d = n[1], b = u | d, E = b < (ie3 | V | ye), D = d == ye && u == ve || d == ye && u == xe && e[7].length <= n[8] || d == (ye | xe) && n[7].length <= n[8] && u == ve;
          if (!(E || D))
            return e;
          d & ie3 && (e[2] = n[2], b |= u & ie3 ? 0 : de);
          var q = n[3];
          if (q) {
            var R = e[3];
            e[3] = R ? u6(R, q, n[4]) : q, e[4] = R ? o1(e[3], P) : n[4];
          }
          return q = n[5], q && (R = e[5], e[5] = R ? c6(R, q, n[6]) : q, e[6] = R ? o1(e[5], P) : n[6]), q = n[7], q && (e[7] = q), d & ye && (e[8] = e[8] == null ? n[8] : Jt(e[8], n[8])), e[9] == null && (e[9] = n[9]), e[0] = n[0], e[1] = b, e;
        }
        function Vh(e) {
          var n = [];
          if (e != null)
            for (var u in tt(e))
              n.push(u);
          return n;
        }
        function $h(e) {
          return Nr.call(e);
        }
        function k6(e, n, u) {
          return n = It(n === t2 ? e.length - 1 : n, 0), function() {
            for (var d = arguments, b = -1, E = It(d.length - n, 0), D = W(E); ++b < E; )
              D[b] = d[n + b];
            b = -1;
            for (var q = W(n + 1); ++b < n; )
              q[b] = d[b];
            return q[n] = u(D), ur(e, this, q);
          };
        }
        function M6(e, n) {
          return n.length < 2 ? e : Rt(e, _1(n, 0, -1));
        }
        function Xh(e, n) {
          for (var u = e.length, d = Jt(n.length, u), b = Yr(e); d--; ) {
            var E = n[d];
            e[d] = q0(E, u) ? b[E] : t2;
          }
          return e;
        }
        function O2(e, n) {
          if (!(n === "constructor" && typeof e[n] == "function") && n != "__proto__")
            return e[n];
        }
        var D6 = N6(Q8), Ao = Fs || function(e, n) {
          return Nt.setTimeout(e, n);
        }, q2 = N6(vh);
        function B6(e, n, u) {
          var d = n + "";
          return q2(e, zh(d, Yh(Lh(d), u)));
        }
        function N6(e) {
          var n = 0, u = 0;
          return function() {
            var d = js(), b = Ye - (d - u);
            if (u = d, b > 0) {
              if (++n >= Ue)
                return arguments[0];
            } else
              n = 0;
            return e.apply(t2, arguments);
          };
        }
        function hl(e, n) {
          var u = -1, d = e.length, b = d - 1;
          for (n = n === t2 ? d : n; ++u < n; ) {
            var E = g2(u, b), D = e[E];
            e[E] = e[u], e[u] = D;
          }
          return e.length = n, e;
        }
        var O6 = Wh(function(e) {
          var n = [];
          return e.charCodeAt(0) === 46 && n.push(""), e.replace(Te, function(u, d, b, E) {
            n.push(b ? E.replace(ls, "$1") : d || u);
          }), n;
        });
        function c0(e) {
          if (typeof e == "string" || l1(e))
            return e;
          var n = e + "";
          return n == "0" && 1 / e == -$t ? "-0" : n;
        }
        function ui(e) {
          if (e != null) {
            try {
              return Qn.call(e);
            } catch (n) {
            }
            try {
              return e + "";
            } catch (n) {
            }
          }
          return "";
        }
        function Yh(e, n) {
          return Lt(ar, function(u) {
            var d = "_." + u[0];
            n & u[1] && !Yn(e, d) && e.push(d);
          }), e.sort();
        }
        function q6(e) {
          if (e instanceof We)
            return e.clone();
          var n = new $r(e.__wrapped__, e.__chain__);
          return n.__actions__ = Yr(e.__actions__), n.__index__ = e.__index__, n.__values__ = e.__values__, n;
        }
        function Kh(e, n, u) {
          (u ? qr(e, n, u) : n === t2) ? n = 1 : n = It(Re(n), 0);
          var d = e == null ? 0 : e.length;
          if (!d || n < 1)
            return [];
          for (var b = 0, E = 0, D = W(Zi(d / n)); b < d; )
            D[E++] = _1(e, b, b += n);
          return D;
        }
        function Zh(e) {
          for (var n = -1, u = e == null ? 0 : e.length, d = 0, b = []; ++n < u; ) {
            var E = e[n];
            E && (b[d++] = E);
          }
          return b;
        }
        function Jh() {
          var e = arguments.length;
          if (!e)
            return [];
          for (var n = W(e - 1), u = arguments[0], d = e; d--; )
            n[d - 1] = arguments[d];
          return E0(Le(u) ? Yr(u) : [u], He(n, 1));
        }
        var Qh = je(function(e, n) {
          return zt(e) ? me(e, He(n, 1, zt, true)) : [];
        }), ed = je(function(e, n) {
          var u = S1(n);
          return zt(u) && (u = t2), zt(e) ? me(e, He(n, 1, zt, true), Ee(u, 2)) : [];
        }), td = je(function(e, n) {
          var u = S1(n);
          return zt(u) && (u = t2), zt(e) ? me(e, He(n, 1, zt, true), t2, u) : [];
        });
        function rd(e, n, u) {
          var d = e == null ? 0 : e.length;
          return d ? (n = u || n === t2 ? 1 : Re(n), _1(e, n < 0 ? 0 : n, d)) : [];
        }
        function nd(e, n, u) {
          var d = e == null ? 0 : e.length;
          return d ? (n = u || n === t2 ? 1 : Re(n), n = d - n, _1(e, 0, n < 0 ? 0 : n)) : [];
        }
        function id(e, n) {
          return e && e.length ? il(e, Ee(n, 3), true, true) : [];
        }
        function ad(e, n) {
          return e && e.length ? il(e, Ee(n, 3), true) : [];
        }
        function od(e, n, u, d) {
          var b = e == null ? 0 : e.length;
          return b ? (u && typeof u != "number" && qr(e, n, u) && (u = 0, d = b), at(e, n, u, d)) : [];
        }
        function P6(e, n, u) {
          var d = e == null ? 0 : e.length;
          if (!d)
            return -1;
          var b = u == null ? 0 : Re(u);
          return b < 0 && (b = It(d + b, 0)), Oe(e, Ee(n, 3), b);
        }
        function L6(e, n, u) {
          var d = e == null ? 0 : e.length;
          if (!d)
            return -1;
          var b = d - 1;
          return u !== t2 && (b = Re(u), b = u < 0 ? It(d + b, 0) : Jt(b, d - 1)), Oe(e, Ee(n, 3), b, true);
        }
        function I6(e) {
          var n = e == null ? 0 : e.length;
          return n ? He(e, 1) : [];
        }
        function sd(e) {
          var n = e == null ? 0 : e.length;
          return n ? He(e, $t) : [];
        }
        function ld(e, n) {
          var u = e == null ? 0 : e.length;
          return u ? (n = n === t2 ? 1 : Re(n), He(e, n)) : [];
        }
        function ud(e) {
          for (var n = -1, u = e == null ? 0 : e.length, d = {}; ++n < u; ) {
            var b = e[n];
            d[b[0]] = b[1];
          }
          return d;
        }
        function R6(e) {
          return e && e.length ? e[0] : t2;
        }
        function cd(e, n, u) {
          var d = e == null ? 0 : e.length;
          if (!d)
            return -1;
          var b = u == null ? 0 : Re(u);
          return b < 0 && (b = It(d + b, 0)), r0(e, n, b);
        }
        function fd(e) {
          var n = e == null ? 0 : e.length;
          return n ? _1(e, 0, -1) : [];
        }
        var hd = je(function(e) {
          var n = yt(e, w2);
          return n.length && n[0] === e[0] ? ea(n) : [];
        }), dd = je(function(e) {
          var n = S1(e), u = yt(e, w2);
          return n === S1(u) ? n = t2 : u.pop(), u.length && u[0] === e[0] ? ea(u, Ee(n, 2)) : [];
        }), md = je(function(e) {
          var n = S1(e), u = yt(e, w2);
          return n = typeof n == "function" ? n : t2, n && u.pop(), u.length && u[0] === e[0] ? ea(u, t2, n) : [];
        });
        function pd(e, n) {
          return e == null ? "" : dn.call(e, n);
        }
        function S1(e) {
          var n = e == null ? 0 : e.length;
          return n ? e[n - 1] : t2;
        }
        function gd(e, n, u) {
          var d = e == null ? 0 : e.length;
          if (!d)
            return -1;
          var b = d;
          return u !== t2 && (b = Re(u), b = b < 0 ? It(d + b, 0) : Jt(b, d - 1)), n === n ? to(e, n, b) : Oe(e, Hi, b, true);
        }
        function vd(e, n) {
          return e && e.length ? Y8(e, Re(n)) : t2;
        }
        var yd = je(z6);
        function z6(e, n) {
          return e && e.length && n && n.length ? p2(e, n) : e;
        }
        function bd(e, n, u) {
          return e && e.length && n && n.length ? p2(e, n, Ee(u, 2)) : e;
        }
        function xd(e, n, u) {
          return e && e.length && n && n.length ? p2(e, n, t2, u) : e;
        }
        var wd = O0(function(e, n) {
          var u = e == null ? 0 : e.length, d = X(e, n);
          return J8(e, yt(n, function(b) {
            return q0(b, u) ? +b : b;
          }).sort(l6)), d;
        });
        function _d(e, n) {
          var u = [];
          if (!(e && e.length))
            return u;
          var d = -1, b = [], E = e.length;
          for (n = Ee(n, 3); ++d < E; ) {
            var D = e[d];
            n(D, d, e) && (u.push(D), b.push(d));
          }
          return J8(e, b), u;
        }
        function P2(e) {
          return e == null ? e : Zu.call(e);
        }
        function Sd(e, n, u) {
          var d = e == null ? 0 : e.length;
          return d ? (u && typeof u != "number" && qr(e, n, u) ? (n = 0, u = d) : (n = n == null ? 0 : Re(n), u = u === t2 ? d : Re(u)), _1(e, n, u)) : [];
        }
        function Ad(e, n) {
          return nl(e, n);
        }
        function Td(e, n, u) {
          return y2(e, n, Ee(u, 2));
        }
        function Ed(e, n) {
          var u = e == null ? 0 : e.length;
          if (u) {
            var d = nl(e, n);
            if (d < u && G1(e[d], n))
              return d;
          }
          return -1;
        }
        function Cd(e, n) {
          return nl(e, n, true);
        }
        function kd(e, n, u) {
          return y2(e, n, Ee(u, 2), true);
        }
        function Md(e, n) {
          var u = e == null ? 0 : e.length;
          if (u) {
            var d = nl(e, n, true) - 1;
            if (G1(e[d], n))
              return d;
          }
          return -1;
        }
        function Dd(e) {
          return e && e.length ? e6(e) : [];
        }
        function Bd(e, n) {
          return e && e.length ? e6(e, Ee(n, 2)) : [];
        }
        function Nd(e) {
          var n = e == null ? 0 : e.length;
          return n ? _1(e, 1, n) : [];
        }
        function Od(e, n, u) {
          return e && e.length ? (n = u || n === t2 ? 1 : Re(n), _1(e, 0, n < 0 ? 0 : n)) : [];
        }
        function qd(e, n, u) {
          var d = e == null ? 0 : e.length;
          return d ? (n = u || n === t2 ? 1 : Re(n), n = d - n, _1(e, n < 0 ? 0 : n, d)) : [];
        }
        function Pd(e, n) {
          return e && e.length ? il(e, Ee(n, 3), false, true) : [];
        }
        function Ld(e, n) {
          return e && e.length ? il(e, Ee(n, 3)) : [];
        }
        var Id = je(function(e) {
          return bn(He(e, 1, zt, true));
        }), Rd = je(function(e) {
          var n = S1(e);
          return zt(n) && (n = t2), bn(He(e, 1, zt, true), Ee(n, 2));
        }), zd = je(function(e) {
          var n = S1(e);
          return n = typeof n == "function" ? n : t2, bn(He(e, 1, zt, true), t2, n);
        });
        function Fd(e) {
          return e && e.length ? bn(e) : [];
        }
        function Hd(e, n) {
          return e && e.length ? bn(e, Ee(n, 2)) : [];
        }
        function jd(e, n) {
          return n = typeof n == "function" ? n : t2, e && e.length ? bn(e, t2, n) : [];
        }
        function L2(e) {
          if (!(e && e.length))
            return [];
          var n = 0;
          return e = z1(e, function(u) {
            if (zt(u))
              return n = It(u.length, n), true;
          }), Za(n, function(u) {
            return yt(e, Ka(u));
          });
        }
        function F6(e, n) {
          if (!(e && e.length))
            return [];
          var u = L2(e);
          return n == null ? u : yt(u, function(d) {
            return ur(n, t2, d);
          });
        }
        var Ud = je(function(e, n) {
          return zt(e) ? me(e, n) : [];
        }), Wd = je(function(e) {
          return x2(z1(e, zt));
        }), Gd = je(function(e) {
          var n = S1(e);
          return zt(n) && (n = t2), x2(z1(e, zt), Ee(n, 2));
        }), Vd = je(function(e) {
          var n = S1(e);
          return n = typeof n == "function" ? n : t2, x2(z1(e, zt), t2, n);
        }), $d = je(L2);
        function Xd(e, n) {
          return i6(e || [], n || [], m);
        }
        function Yd(e, n) {
          return i6(e || [], n || [], wo);
        }
        var Kd = je(function(e) {
          var n = e.length, u = n > 1 ? e[n - 1] : t2;
          return u = typeof u == "function" ? (e.pop(), u) : t2, F6(e, u);
        });
        function H6(e) {
          var n = _14(e);
          return n.__chain__ = true, n;
        }
        function Zd(e, n) {
          return n(e), e;
        }
        function dl(e, n) {
          return n(e);
        }
        var Jd = O0(function(e) {
          var n = e.length, u = n ? e[0] : 0, d = this.__wrapped__, b = function(E) {
            return X(E, e);
          };
          return n > 1 || this.__actions__.length || !(d instanceof We) || !q0(u) ? this.thru(b) : (d = d.slice(u, +u + (n ? 1 : 0)), d.__actions__.push({ func: dl, args: [b], thisArg: t2 }), new $r(d, this.__chain__).thru(function(E) {
            return n && !E.length && E.push(t2), E;
          }));
        });
        function Qd() {
          return H6(this);
        }
        function em() {
          return new $r(this.value(), this.__chain__);
        }
        function tm() {
          this.__values__ === t2 && (this.__values__ = t7(this.value()));
          var e = this.__index__ >= this.__values__.length, n = e ? t2 : this.__values__[this.__index__++];
          return { done: e, value: n };
        }
        function rm2() {
          return this;
        }
        function nm(e) {
          for (var n, u = this; u instanceof oi; ) {
            var d = q6(u);
            d.__index__ = 0, d.__values__ = t2, n ? b.__wrapped__ = d : n = d;
            var b = d;
            u = u.__wrapped__;
          }
          return b.__wrapped__ = e, n;
        }
        function im() {
          var e = this.__wrapped__;
          if (e instanceof We) {
            var n = e;
            return this.__actions__.length && (n = new We(this)), n = n.reverse(), n.__actions__.push({ func: dl, args: [P2], thisArg: t2 }), new $r(n, this.__chain__);
          }
          return this.thru(P2);
        }
        function am() {
          return n6(this.__wrapped__, this.__actions__);
        }
        var om = al(function(e, n, u) {
          rt.call(e, u) ? ++e[u] : z(e, u, 1);
        });
        function sm(e, n, u) {
          var d = Le(e) ? Ga : st;
          return u && qr(e, n, u) && (n = t2), d(e, Ee(n, 3));
        }
        function lm(e, n) {
          var u = Le(e) ? z1 : ot;
          return u(e, Ee(n, 3));
        }
        var um = m6(P6), cm = m6(L6);
        function fm(e, n) {
          return He(ml(e, n), 1);
        }
        function hm(e, n) {
          return He(ml(e, n), $t);
        }
        function dm(e, n, u) {
          return u = u === t2 ? 1 : Re(u), He(ml(e, n), u);
        }
        function j6(e, n) {
          var u = Le(e) ? Lt : ge;
          return u(e, Ee(n, 3));
        }
        function U6(e, n) {
          var u = Le(e) ? ct : Ze;
          return u(e, Ee(n, 3));
        }
        var mm = al(function(e, n, u) {
          rt.call(e, u) ? e[u].push(n) : z(e, u, [n]);
        });
        function pm(e, n, u, d) {
          e = Kr(e) ? e : ua(e), u = u && !d ? Re(u) : 0;
          var b = e.length;
          return u < 0 && (u = It(b + u, 0)), bl(e) ? u <= b && e.indexOf(n, u) > -1 : !!b && r0(e, n, u) > -1;
        }
        var gm = je(function(e, n, u) {
          var d = -1, b = typeof n == "function", E = Kr(e) ? W(e.length) : [];
          return ge(e, function(D) {
            E[++d] = b ? ur(n, D, u) : w1(D, n, u);
          }), E;
        }), vm = al(function(e, n, u) {
          z(e, u, n);
        });
        function ml(e, n) {
          var u = Le(e) ? yt : V8;
          return u(e, Ee(n, 3));
        }
        function ym(e, n, u, d) {
          return e == null ? [] : (Le(n) || (n = n == null ? [] : [n]), u = d ? t2 : u, Le(u) || (u = u == null ? [] : [u]), K8(e, n, u));
        }
        var bm = al(function(e, n, u) {
          e[u ? 0 : 1].push(n);
        }, function() {
          return [[], []];
        });
        function xm(e, n, u) {
          var d = Le(e) ? $a : Es, b = arguments.length < 3;
          return d(e, Ee(n, 4), u, b, ge);
        }
        function wm(e, n, u) {
          var d = Le(e) ? Hu : Es, b = arguments.length < 3;
          return d(e, Ee(n, 4), u, b, Ze);
        }
        function _m(e, n) {
          var u = Le(e) ? z1 : ot;
          return u(e, vl(Ee(n, 3)));
        }
        function Sm(e) {
          var n = Le(e) ? a : ph;
          return n(e);
        }
        function Am(e, n, u) {
          (u ? qr(e, n, u) : n === t2) ? n = 1 : n = Re(n);
          var d = Le(e) ? o : gh;
          return d(e, n);
        }
        function Tm(e) {
          var n = Le(e) ? l : yh;
          return n(e);
        }
        function Em(e) {
          if (e == null)
            return 0;
          if (Kr(e))
            return bl(e) ? n0(e) : e.length;
          var n = br(e);
          return n == or || n == Zt ? e.size : na(e).length;
        }
        function Cm(e, n, u) {
          var d = Le(e) ? Xa : bh;
          return u && qr(e, n, u) && (n = t2), d(e, Ee(n, 3));
        }
        var km = je(function(e, n) {
          if (e == null)
            return [];
          var u = n.length;
          return u > 1 && qr(e, n[0], n[1]) ? n = [] : u > 2 && qr(n[0], n[1], n[2]) && (n = [n[0]]), K8(e, He(n, 1), []);
        }), pl = zs || function() {
          return Nt.Date.now();
        };
        function Mm(e, n) {
          if (typeof n != "function")
            throw new Dr(p);
          return e = Re(e), function() {
            if (--e < 1)
              return n.apply(this, arguments);
          };
        }
        function W6(e, n, u) {
          return n = u ? t2 : n, n = e && n == null ? e.length : n, N0(e, ye, t2, t2, t2, t2, n);
        }
        function G6(e, n) {
          var u;
          if (typeof n != "function")
            throw new Dr(p);
          return e = Re(e), function() {
            return --e > 0 && (u = n.apply(this, arguments)), e <= 1 && (n = t2), u;
          };
        }
        var I2 = je(function(e, n, u) {
          var d = ie3;
          if (u.length) {
            var b = o1(u, sa(I2));
            d |= Me;
          }
          return N0(e, d, n, u, b);
        }), V6 = je(function(e, n, u) {
          var d = ie3 | V;
          if (u.length) {
            var b = o1(u, sa(V6));
            d |= Me;
          }
          return N0(n, d, e, u, b);
        });
        function $6(e, n, u) {
          n = u ? t2 : n;
          var d = N0(e, ve, t2, t2, t2, t2, t2, n);
          return d.placeholder = $6.placeholder, d;
        }
        function X6(e, n, u) {
          n = u ? t2 : n;
          var d = N0(e, _e2, t2, t2, t2, t2, t2, n);
          return d.placeholder = X6.placeholder, d;
        }
        function Y6(e, n, u) {
          var d, b, E, D, q, R, Z = 0, Q = false, re = false, le = true;
          if (typeof e != "function")
            throw new Dr(p);
          n = A1(n) || 0, Mt(u) && (Q = !!u.leading, re = "maxWait" in u, E = re ? It(A1(u.maxWait) || 0, n) : E, le = "trailing" in u ? !!u.trailing : le);
          function be(Ft) {
            var V1 = d, I0 = b;
            return d = b = t2, Z = Ft, D = e.apply(I0, V1), D;
          }
          function Ce(Ft) {
            return Z = Ft, q = Ao(Xe, n), Q ? be(Ft) : D;
          }
          function Fe(Ft) {
            var V1 = Ft - R, I0 = Ft - Z, m7 = n - V1;
            return re ? Jt(m7, E - I0) : m7;
          }
          function ke(Ft) {
            var V1 = Ft - R, I0 = Ft - Z;
            return R === t2 || V1 >= n || V1 < 0 || re && I0 >= E;
          }
          function Xe() {
            var Ft = pl();
            if (ke(Ft))
              return et(Ft);
            q = Ao(Xe, Fe(Ft));
          }
          function et(Ft) {
            return q = t2, le && d ? be(Ft) : (d = b = t2, D);
          }
          function u1() {
            q !== t2 && a6(q), Z = 0, d = R = b = q = t2;
          }
          function Pr() {
            return q === t2 ? D : et(pl());
          }
          function c1() {
            var Ft = pl(), V1 = ke(Ft);
            if (d = arguments, b = this, R = Ft, V1) {
              if (q === t2)
                return Ce(R);
              if (re)
                return a6(q), q = Ao(Xe, n), be(R);
            }
            return q === t2 && (q = Ao(Xe, n)), D;
          }
          return c1.cancel = u1, c1.flush = Pr, c1;
        }
        var Dm = je(function(e, n) {
          return he(e, 1, n);
        }), Bm = je(function(e, n, u) {
          return he(e, A1(n) || 0, u);
        });
        function Nm(e) {
          return N0(e, Se);
        }
        function gl(e, n) {
          if (typeof e != "function" || n != null && typeof n != "function")
            throw new Dr(p);
          var u = function() {
            var d = arguments, b = n ? n.apply(this, d) : d[0], E = u.cache;
            if (E.has(b))
              return E.get(b);
            var D = e.apply(this, d);
            return u.cache = E.set(b, D) || E, D;
          };
          return u.cache = new (gl.Cache || U1)(), u;
        }
        gl.Cache = U1;
        function vl(e) {
          if (typeof e != "function")
            throw new Dr(p);
          return function() {
            var n = arguments;
            switch (n.length) {
              case 0:
                return !e.call(this);
              case 1:
                return !e.call(this, n[0]);
              case 2:
                return !e.call(this, n[0], n[1]);
              case 3:
                return !e.call(this, n[0], n[1], n[2]);
            }
            return !e.apply(this, n);
          };
        }
        function Om(e) {
          return G6(2, e);
        }
        var qm = xh(function(e, n) {
          n = n.length == 1 && Le(n[0]) ? yt(n[0], vr(Ee())) : yt(He(n, 1), vr(Ee()));
          var u = n.length;
          return je(function(d) {
            for (var b = -1, E = Jt(d.length, u); ++b < E; )
              d[b] = n[b].call(this, d[b]);
            return ur(e, this, d);
          });
        }), R2 = je(function(e, n) {
          var u = o1(n, sa(R2));
          return N0(e, Me, t2, n, u);
        }), K6 = je(function(e, n) {
          var u = o1(n, sa(K6));
          return N0(e, we, t2, n, u);
        }), Pm = O0(function(e, n) {
          return N0(e, xe, t2, t2, t2, n);
        });
        function Lm(e, n) {
          if (typeof e != "function")
            throw new Dr(p);
          return n = n === t2 ? n : Re(n), je(e, n);
        }
        function Im(e, n) {
          if (typeof e != "function")
            throw new Dr(p);
          return n = n == null ? 0 : It(Re(n), 0), je(function(u) {
            var d = u[n], b = wn(u, 0, n);
            return d && E0(b, d), ur(e, this, b);
          });
        }
        function Rm(e, n, u) {
          var d = true, b = true;
          if (typeof e != "function")
            throw new Dr(p);
          return Mt(u) && (d = "leading" in u ? !!u.leading : d, b = "trailing" in u ? !!u.trailing : b), Y6(e, n, { leading: d, maxWait: n, trailing: b });
        }
        function zm(e) {
          return W6(e, 1);
        }
        function Fm(e, n) {
          return R2(_22(n), e);
        }
        function Hm() {
          if (!arguments.length)
            return [];
          var e = arguments[0];
          return Le(e) ? e : [e];
        }
        function jm(e) {
          return Y(e, ee);
        }
        function Um(e, n) {
          return n = typeof n == "function" ? n : t2, Y(e, ee, n);
        }
        function Wm(e) {
          return Y(e, j | ee);
        }
        function Gm(e, n) {
          return n = typeof n == "function" ? n : t2, Y(e, j | ee, n);
        }
        function Vm(e, n) {
          return n == null || se(e, n, er(n));
        }
        function G1(e, n) {
          return e === n || e !== e && n !== n;
        }
        var $m = ul(si), Xm = ul(function(e, n) {
          return e >= n;
        }), ci = yo(function() {
          return arguments;
        }()) ? yo : function(e) {
          return Ot(e) && rt.call(e, "callee") && !ao.call(e, "callee");
        }, Le = W.isArray, Ym = Er ? vr(Er) : vn;
        function Kr(e) {
          return e != null && yl(e.length) && !P0(e);
        }
        function zt(e) {
          return Ot(e) && Kr(e);
        }
        function Km(e) {
          return e === true || e === false || Ot(e) && Qt(e) == p1;
        }
        var _n = Hs || Y2, Zm = on ? vr(on) : yn;
        function Jm(e) {
          return Ot(e) && e.nodeType === 1 && !To(e);
        }
        function Qm(e) {
          if (e == null)
            return true;
          if (Kr(e) && (Le(e) || typeof e == "string" || typeof e.splice == "function" || _n(e) || la(e) || ci(e)))
            return !e.length;
          var n = br(e);
          if (n == or || n == Zt)
            return !e.size;
          if (So(e))
            return !na(e).length;
          for (var u in e)
            if (rt.call(e, u))
              return false;
          return true;
        }
        function ep(e, n) {
          return l0(e, n);
        }
        function tp(e, n, u) {
          u = typeof u == "function" ? u : t2;
          var d = u ? u(e, n) : t2;
          return d === t2 ? l0(e, n, t2, u) : !!d;
        }
        function z2(e) {
          if (!Ot(e))
            return false;
          var n = Qt(e);
          return n == e0 || n == Q1 || typeof e.message == "string" && typeof e.name == "string" && !To(e);
        }
        function rp(e) {
          return typeof e == "number" && so(e);
        }
        function P0(e) {
          if (!Mt(e))
            return false;
          var n = Qt(e);
          return n == y0 || n == zn || n == zr || n == Fn;
        }
        function Z6(e) {
          return typeof e == "number" && e == Re(e);
        }
        function yl(e) {
          return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Bt;
        }
        function Mt(e) {
          var n = typeof e;
          return e != null && (n == "object" || n == "function");
        }
        function Ot(e) {
          return e != null && typeof e == "object";
        }
        var J6 = Ts ? vr(Ts) : d2;
        function np(e, n) {
          return e === n || bo(e, n, M2(n));
        }
        function ip(e, n, u) {
          return u = typeof u == "function" ? u : t2, bo(e, n, M2(n), u);
        }
        function ap(e) {
          return Q6(e) && e != +e;
        }
        function op(e) {
          if (Uh(e))
            throw new Be(c);
          return Qs(e);
        }
        function sp(e) {
          return e === null;
        }
        function lp(e) {
          return e == null;
        }
        function Q6(e) {
          return typeof e == "number" || Ot(e) && Qt(e) == Fr;
        }
        function To(e) {
          if (!Ot(e) || Qt(e) != Hr)
            return false;
          var n = ei(e);
          if (n === null)
            return true;
          var u = rt.call(n, "constructor") && n.constructor;
          return typeof u == "function" && u instanceof u && Qn.call(u) == Ku;
        }
        var F2 = ne ? vr(ne) : xo;
        function up(e) {
          return Z6(e) && e >= -Bt && e <= Bt;
        }
        var e7 = Cr ? vr(Cr) : el;
        function bl(e) {
          return typeof e == "string" || !Le(e) && Ot(e) && Qt(e) == Hn;
        }
        function l1(e) {
          return typeof e == "symbol" || Ot(e) && Qt(e) == Ti;
        }
        var la = zi ? vr(zi) : tl;
        function cp(e) {
          return e === t2;
        }
        function fp(e) {
          return Ot(e) && br(e) == Wr;
        }
        function hp(e) {
          return Ot(e) && Qt(e) == b0;
        }
        var dp = ul(m2), mp = ul(function(e, n) {
          return e <= n;
        });
        function t7(e) {
          if (!e)
            return [];
          if (Kr(e))
            return bl(e) ? Mr(e) : Yr(e);
          if (cn && e[cn])
            return eo(e[cn]());
          var n = br(e), u = n == or ? Zn : n == Zt ? Gi : ua;
          return u(e);
        }
        function L0(e) {
          if (!e)
            return e === 0 ? e : 0;
          if (e = A1(e), e === $t || e === -$t) {
            var n = e < 0 ? -1 : 1;
            return n * pe;
          }
          return e === e ? e : 0;
        }
        function Re(e) {
          var n = L0(e), u = n % 1;
          return n === n ? u ? n - u : n : 0;
        }
        function r7(e) {
          return e ? K(Re(e), 0, Pe) : 0;
        }
        function A1(e) {
          if (typeof e == "number")
            return e;
          if (l1(e))
            return Sr;
          if (Mt(e)) {
            var n = typeof e.valueOf == "function" ? e.valueOf() : e;
            e = Mt(n) ? n + "" : n;
          }
          if (typeof e != "string")
            return e === 0 ? e : +e;
          e = ks(e);
          var u = Mi.test(e);
          return u || Di.test(e) ? As(e.slice(2), u ? 2 : 8) : cs.test(e) ? Sr : +e;
        }
        function n7(e) {
          return u0(e, Zr(e));
        }
        function pp(e) {
          return e ? K(Re(e), -Bt, Bt) : e === 0 ? e : 0;
        }
        function ut(e) {
          return e == null ? "" : s1(e);
        }
        var gp = aa(function(e, n) {
          if (So(n) || Kr(n)) {
            u0(n, er(n), e);
            return;
          }
          for (var u in n)
            rt.call(n, u) && m(e, u, n[u]);
        }), i7 = aa(function(e, n) {
          u0(n, Zr(n), e);
        }), xl = aa(function(e, n, u, d) {
          u0(n, Zr(n), e, d);
        }), vp = aa(function(e, n, u, d) {
          u0(n, er(n), e, d);
        }), yp = O0(X);
        function bp(e, n) {
          var u = Vr(e);
          return n == null ? u : C2(u, n);
        }
        var xp = je(function(e, n) {
          e = tt(e);
          var u = -1, d = n.length, b = d > 2 ? n[2] : t2;
          for (b && qr(n[0], n[1], b) && (d = 1); ++u < d; )
            for (var E = n[u], D = Zr(E), q = -1, R = D.length; ++q < R; ) {
              var Z = D[q], Q = e[Z];
              (Q === t2 || G1(Q, k0[Z]) && !rt.call(e, Z)) && (e[Z] = E[Z]);
            }
          return e;
        }), wp = je(function(e) {
          return e.push(t2, w6), ur(a7, t2, e);
        });
        function _p(e, n) {
          return v1(e, Ee(n, 3), Et);
        }
        function Sp(e, n) {
          return v1(e, Ee(n, 3), x1);
        }
        function Ap(e, n) {
          return e == null ? e : lt(e, Ee(n, 3), Zr);
        }
        function Tp(e, n) {
          return e == null ? e : yr(e, Ee(n, 3), Zr);
        }
        function Ep(e, n) {
          return e && Et(e, Ee(n, 3));
        }
        function Cp(e, n) {
          return e && x1(e, Ee(n, 3));
        }
        function kp(e) {
          return e == null ? [] : Or(e, er(e));
        }
        function Mp(e) {
          return e == null ? [] : Or(e, Zr(e));
        }
        function H2(e, n, u) {
          var d = e == null ? t2 : Rt(e, n);
          return d === t2 ? u : d;
        }
        function Dp(e, n) {
          return e != null && A6(e, n, f2);
        }
        function j2(e, n) {
          return e != null && A6(e, n, vo);
        }
        var Bp = g6(function(e, n, u) {
          n != null && typeof n.toString != "function" && (n = Nr.call(n)), e[n] = u;
        }, W2(Jr)), Np = g6(function(e, n, u) {
          n != null && typeof n.toString != "function" && (n = Nr.call(n)), rt.call(e, n) ? e[n].push(u) : e[n] = [u];
        }, Ee), Op = je(w1);
        function er(e) {
          return Kr(e) ? i(e) : na(e);
        }
        function Zr(e) {
          return Kr(e) ? i(e, true) : ia(e);
        }
        function qp(e, n) {
          var u = {};
          return n = Ee(n, 3), Et(e, function(d, b, E) {
            z(u, n(d, b, E), d);
          }), u;
        }
        function Pp(e, n) {
          var u = {};
          return n = Ee(n, 3), Et(e, function(d, b, E) {
            z(u, b, n(d, b, E));
          }), u;
        }
        var Lp = aa(function(e, n, u) {
          rl(e, n, u);
        }), a7 = aa(function(e, n, u, d) {
          rl(e, n, u, d);
        }), Ip = O0(function(e, n) {
          var u = {};
          if (e == null)
            return u;
          var d = false;
          n = yt(n, function(E) {
            return E = xn(E, e), d || (d = E.length > 1), E;
          }), u0(e, C22(e), u), d && (u = Y(u, j | U | ee, Bh));
          for (var b = n.length; b--; )
            b2(u, n[b]);
          return u;
        });
        function Rp(e, n) {
          return o7(e, vl(Ee(n)));
        }
        var zp = O0(function(e, n) {
          return e == null ? {} : hh(e, n);
        });
        function o7(e, n) {
          if (e == null)
            return {};
          var u = yt(C22(e), function(d) {
            return [d];
          });
          return n = Ee(n), Z8(e, u, function(d, b) {
            return n(d, b[0]);
          });
        }
        function Fp(e, n, u) {
          n = xn(n, e);
          var d = -1, b = n.length;
          for (b || (b = 1, e = t2); ++d < b; ) {
            var E = e == null ? t2 : e[c0(n[d])];
            E === t2 && (d = b, E = u), e = P0(E) ? E.call(e) : E;
          }
          return e;
        }
        function Hp(e, n, u) {
          return e == null ? e : wo(e, n, u);
        }
        function jp(e, n, u, d) {
          return d = typeof d == "function" ? d : t2, e == null ? e : wo(e, n, u, d);
        }
        var s7 = b6(er), l7 = b6(Zr);
        function Up(e, n, u) {
          var d = Le(e), b = d || _n(e) || la(e);
          if (n = Ee(n, 4), u == null) {
            var E = e && e.constructor;
            b ? u = d ? new E() : [] : Mt(e) ? u = P0(E) ? Vr(ei(e)) : {} : u = {};
          }
          return (b ? Lt : Et)(e, function(D, q, R) {
            return n(u, D, q, R);
          }), u;
        }
        function Wp(e, n) {
          return e == null ? true : b2(e, n);
        }
        function Gp(e, n, u) {
          return e == null ? e : r62(e, n, _22(u));
        }
        function Vp(e, n, u, d) {
          return d = typeof d == "function" ? d : t2, e == null ? e : r62(e, n, _22(u), d);
        }
        function ua(e) {
          return e == null ? [] : Ui(e, er(e));
        }
        function $p(e) {
          return e == null ? [] : Ui(e, Zr(e));
        }
        function Xp(e, n, u) {
          return u === t2 && (u = n, n = t2), u !== t2 && (u = A1(u), u = u === u ? u : 0), n !== t2 && (n = A1(n), n = n === n ? n : 0), K(A1(e), n, u);
        }
        function Yp(e, n, u) {
          return n = L0(n), u === t2 ? (u = n, n = 0) : u = L0(u), e = A1(e), W1(e, n, u);
        }
        function Kp(e, n, u) {
          if (u && typeof u != "boolean" && qr(e, n, u) && (n = u = t2), u === t2 && (typeof n == "boolean" ? (u = n, n = t2) : typeof e == "boolean" && (u = e, e = t2)), e === t2 && n === t2 ? (e = 0, n = 1) : (e = L0(e), n === t2 ? (n = e, e = 0) : n = L0(n)), e > n) {
            var d = e;
            e = n, n = d;
          }
          if (u || e % 1 || n % 1) {
            var b = lo();
            return Jt(e + b * (n - e + Xt("1e-" + ((b + "").length - 1))), n);
          }
          return g2(e, n);
        }
        var Zp = oa(function(e, n, u) {
          return n = n.toLowerCase(), e + (u ? u7(n) : n);
        });
        function u7(e) {
          return U2(ut(e).toLowerCase());
        }
        function c7(e) {
          return e = ut(e), e && e.replace(pr, Kn).replace(Pu, "");
        }
        function Jp(e, n, u) {
          e = ut(e), n = s1(n);
          var d = e.length;
          u = u === t2 ? d : K(Re(u), 0, d);
          var b = u;
          return u -= n.length, u >= 0 && e.slice(u, b) == n;
        }
        function Qp(e) {
          return e = ut(e), e && x.test(e) ? e.replace(v, Qa) : e;
        }
        function eg(e) {
          return e = ut(e), e && Ar.test(e) ? e.replace(Tt, "\\$&") : e;
        }
        var tg = oa(function(e, n, u) {
          return e + (u ? "-" : "") + n.toLowerCase();
        }), rg = oa(function(e, n, u) {
          return e + (u ? " " : "") + n.toLowerCase();
        }), ng = d6("toLowerCase");
        function ig(e, n, u) {
          e = ut(e), n = Re(n);
          var d = n ? n0(e) : 0;
          if (!n || d >= n)
            return e;
          var b = (n - d) / 2;
          return ll(hn(b), u) + e + ll(Zi(b), u);
        }
        function ag(e, n, u) {
          e = ut(e), n = Re(n);
          var d = n ? n0(e) : 0;
          return n && d < n ? e + ll(n - d, u) : e;
        }
        function og(e, n, u) {
          e = ut(e), n = Re(n);
          var d = n ? n0(e) : 0;
          return n && d < n ? ll(n - d, u) + e : e;
        }
        function sg(e, n, u) {
          return u || n == null ? n = 0 : n && (n = +n), A(ut(e).replace(nn, ""), n || 0);
        }
        function lg(e, n, u) {
          return (u ? qr(e, n, u) : n === t2) ? n = 1 : n = Re(n), v2(ut(e), n);
        }
        function ug() {
          var e = arguments, n = ut(e[0]);
          return e.length < 3 ? n : n.replace(e[1], e[2]);
        }
        var cg = oa(function(e, n, u) {
          return e + (u ? "_" : "") + n.toLowerCase();
        });
        function fg(e, n, u) {
          return u && typeof u != "number" && qr(e, n, u) && (n = u = t2), u = u === t2 ? Pe : u >>> 0, u ? (e = ut(e), e && (typeof n == "string" || n != null && !F2(n)) && (n = s1(n), !n && ln(e)) ? wn(Mr(e), 0, u) : e.split(n, u)) : [];
        }
        var hg = oa(function(e, n, u) {
          return e + (u ? " " : "") + U2(n);
        });
        function dg(e, n, u) {
          return e = ut(e), u = u == null ? 0 : K(Re(u), 0, e.length), n = s1(n), e.slice(u, u + n.length) == n;
        }
        function mg(e, n, u) {
          var d = _14.templateSettings;
          u && qr(e, n, u) && (n = t2), e = ut(e), n = xl({}, n, d, x6);
          var b = xl({}, n.imports, d.imports, x6), E = er(b), D = Ui(b, E), q, R, Z = 0, Q = n.interpolate || wt, re = "__p += '", le = ro((n.escape || wt).source + "|" + Q.source + "|" + (Q === ue ? us : wt).source + "|" + (n.evaluate || wt).source + "|$", "g"), be = "//# sourceURL=" + (rt.call(n, "sourceURL") ? (n.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Ri + "]") + `
`;
          e.replace(le, function(ke, Xe, et, u1, Pr, c1) {
            return et || (et = u1), re += e.slice(Z, c1).replace(_0, Bs), Xe && (q = true, re += `' +
__e(` + Xe + `) +
'`), Pr && (R = true, re += `';
` + Pr + `;
__p += '`), et && (re += `' +
((__t = (` + et + `)) == null ? '' : __t) +
'`), Z = c1 + ke.length, ke;
          }), re += `';
`;
          var Ce = rt.call(n, "variable") && n.variable;
          if (!Ce)
            re = `with (obj) {
` + re + `
}
`;
          else if (qa.test(Ce))
            throw new Be(w);
          re = (R ? re.replace(Mu, "") : re).replace(Ci, "$1").replace(xt, "$1;"), re = "function(" + (Ce || "obj") + `) {
` + (Ce ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (q ? ", __e = _.escape" : "") + (R ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + re + `return __p
}`;
          var Fe = h7(function() {
            return nt(E, be + "return " + re).apply(t2, D);
          });
          if (Fe.source = re, z2(Fe))
            throw Fe;
          return Fe;
        }
        function pg(e) {
          return ut(e).toLowerCase();
        }
        function gg(e) {
          return ut(e).toUpperCase();
        }
        function vg(e, n, u) {
          if (e = ut(e), e && (u || n === t2))
            return ks(e);
          if (!e || !(n = s1(n)))
            return e;
          var d = Mr(e), b = Mr(n), E = Ja(d, b), D = Ms(d, b) + 1;
          return wn(d, E, D).join("");
        }
        function yg(e, n, u) {
          if (e = ut(e), e && (u || n === t2))
            return e.slice(0, qs(e) + 1);
          if (!e || !(n = s1(n)))
            return e;
          var d = Mr(e), b = Ms(d, Mr(n)) + 1;
          return wn(d, 0, b).join("");
        }
        function bg(e, n, u) {
          if (e = ut(e), e && (u || n === t2))
            return e.replace(nn, "");
          if (!e || !(n = s1(n)))
            return e;
          var d = Mr(e), b = Ja(d, Mr(n));
          return wn(d, b).join("");
        }
        function xg(e, n) {
          var u = Je, d = Ae;
          if (Mt(n)) {
            var b = "separator" in n ? n.separator : b;
            u = "length" in n ? Re(n.length) : u, d = "omission" in n ? s1(n.omission) : d;
          }
          e = ut(e);
          var E = e.length;
          if (ln(e)) {
            var D = Mr(e);
            E = D.length;
          }
          if (u >= E)
            return e;
          var q = u - n0(d);
          if (q < 1)
            return d;
          var R = D ? wn(D, 0, q).join("") : e.slice(0, q);
          if (b === t2)
            return R + d;
          if (D && (q += R.length - q), F2(b)) {
            if (e.slice(q).search(b)) {
              var Z, Q = R;
              for (b.global || (b = ro(b.source, ut(ki.exec(b)) + "g")), b.lastIndex = 0; Z = b.exec(Q); )
                var re = Z.index;
              R = R.slice(0, re === t2 ? q : re);
            }
          } else if (e.indexOf(s1(b), q) != q) {
            var le = R.lastIndexOf(b);
            le > -1 && (R = R.slice(0, le));
          }
          return R + d;
        }
        function wg(e) {
          return e = ut(e), e && te.test(e) ? e.replace(h, Ps) : e;
        }
        var _g = oa(function(e, n, u) {
          return e + (u ? " " : "") + n.toUpperCase();
        }), U2 = d6("toUpperCase");
        function f7(e, n, u) {
          return e = ut(e), n = u ? t2 : n, n === t2 ? Ns(e) ? Jn(e) : Wu(e) : e.match(n) || [];
        }
        var h7 = je(function(e, n) {
          try {
            return ur(e, t2, n);
          } catch (u) {
            return z2(u) ? u : new Be(u);
          }
        }), Sg = O0(function(e, n) {
          return Lt(n, function(u) {
            u = c0(u), z(e, u, I2(e[u], e));
          }), e;
        });
        function Ag(e) {
          var n = e == null ? 0 : e.length, u = Ee();
          return e = n ? yt(e, function(d) {
            if (typeof d[1] != "function")
              throw new Dr(p);
            return [u(d[0]), d[1]];
          }) : [], je(function(d) {
            for (var b = -1; ++b < n; ) {
              var E = e[b];
              if (ur(E[0], this, d))
                return ur(E[1], this, d);
            }
          });
        }
        function Tg(e) {
          return oe(Y(e, j));
        }
        function W2(e) {
          return function() {
            return e;
          };
        }
        function Eg(e, n) {
          return e == null || e !== e ? n : e;
        }
        var Cg = p6(), kg = p6(true);
        function Jr(e) {
          return e;
        }
        function G2(e) {
          return ra(typeof e == "function" ? e : Y(e, j));
        }
        function Mg(e) {
          return $8(Y(e, j));
        }
        function Dg(e, n) {
          return X8(e, Y(n, j));
        }
        var Bg = je(function(e, n) {
          return function(u) {
            return w1(u, e, n);
          };
        }), Ng = je(function(e, n) {
          return function(u) {
            return w1(e, u, n);
          };
        });
        function V2(e, n, u) {
          var d = er(n), b = Or(n, d);
          u == null && !(Mt(n) && (b.length || !d.length)) && (u = n, n = e, e = this, b = Or(n, er(n)));
          var E = !(Mt(u) && "chain" in u) || !!u.chain, D = P0(e);
          return Lt(b, function(q) {
            var R = n[q];
            e[q] = R, D && (e.prototype[q] = function() {
              var Z = this.__chain__;
              if (E || Z) {
                var Q = e(this.__wrapped__), re = Q.__actions__ = Yr(this.__actions__);
                return re.push({ func: R, args: arguments, thisArg: e }), Q.__chain__ = Z, Q;
              }
              return R.apply(e, E0([this.value()], arguments));
            });
          }), e;
        }
        function Og() {
          return Nt._ === this && (Nt._ = y1), this;
        }
        function $2() {
        }
        function qg(e) {
          return e = Re(e), je(function(n) {
            return Y8(n, e);
          });
        }
        var Pg = A2(yt), Lg = A2(Ga), Ig = A2(Xa);
        function d7(e) {
          return B2(e) ? Ka(c0(e)) : dh(e);
        }
        function Rg(e) {
          return function(n) {
            return e == null ? t2 : Rt(e, n);
          };
        }
        var zg = v6(), Fg = v6(true);
        function X2() {
          return [];
        }
        function Y2() {
          return false;
        }
        function Hg() {
          return {};
        }
        function jg() {
          return "";
        }
        function Ug() {
          return true;
        }
        function Wg(e, n) {
          if (e = Re(e), e < 1 || e > Bt)
            return [];
          var u = Pe, d = Jt(e, Pe);
          n = Ee(n), e -= Pe;
          for (var b = Za(d, n); ++u < e; )
            n(u);
          return b;
        }
        function Gg(e) {
          return Le(e) ? yt(e, c0) : l1(e) ? [e] : Yr(O6(ut(e)));
        }
        function Vg(e) {
          var n = ++a0;
          return ut(e) + n;
        }
        var $g = sl(function(e, n) {
          return e + n;
        }, 0), Xg = T2("ceil"), Yg = sl(function(e, n) {
          return e / n;
        }, 1), Kg = T2("floor");
        function Zg(e) {
          return e && e.length ? ft(e, Jr, si) : t2;
        }
        function Jg(e, n) {
          return e && e.length ? ft(e, Ee(n, 2), si) : t2;
        }
        function Qg(e) {
          return Ya(e, Jr);
        }
        function ev(e, n) {
          return Ya(e, Ee(n, 2));
        }
        function tv(e) {
          return e && e.length ? ft(e, Jr, m2) : t2;
        }
        function rv(e, n) {
          return e && e.length ? ft(e, Ee(n, 2), m2) : t2;
        }
        var nv = sl(function(e, n) {
          return e * n;
        }, 1), iv = T2("round"), av = sl(function(e, n) {
          return e - n;
        }, 0);
        function ov(e) {
          return e && e.length ? ji(e, Jr) : 0;
        }
        function sv(e, n) {
          return e && e.length ? ji(e, Ee(n, 2)) : 0;
        }
        return _14.after = Mm, _14.ary = W6, _14.assign = gp, _14.assignIn = i7, _14.assignInWith = xl, _14.assignWith = vp, _14.at = yp, _14.before = G6, _14.bind = I2, _14.bindAll = Sg, _14.bindKey = V6, _14.castArray = Hm, _14.chain = H6, _14.chunk = Kh, _14.compact = Zh, _14.concat = Jh, _14.cond = Ag, _14.conforms = Tg, _14.constant = W2, _14.countBy = om, _14.create = bp, _14.curry = $6, _14.curryRight = X6, _14.debounce = Y6, _14.defaults = xp, _14.defaultsDeep = wp, _14.defer = Dm, _14.delay = Bm, _14.difference = Qh, _14.differenceBy = ed, _14.differenceWith = td, _14.drop = rd, _14.dropRight = nd, _14.dropRightWhile = id, _14.dropWhile = ad, _14.fill = od, _14.filter = lm, _14.flatMap = fm, _14.flatMapDeep = hm, _14.flatMapDepth = dm, _14.flatten = I6, _14.flattenDeep = sd, _14.flattenDepth = ld, _14.flip = Nm, _14.flow = Cg, _14.flowRight = kg, _14.fromPairs = ud, _14.functions = kp, _14.functionsIn = Mp, _14.groupBy = mm, _14.initial = fd, _14.intersection = hd, _14.intersectionBy = dd, _14.intersectionWith = md, _14.invert = Bp, _14.invertBy = Np, _14.invokeMap = gm, _14.iteratee = G2, _14.keyBy = vm, _14.keys = er, _14.keysIn = Zr, _14.map = ml, _14.mapKeys = qp, _14.mapValues = Pp, _14.matches = Mg, _14.matchesProperty = Dg, _14.memoize = gl, _14.merge = Lp, _14.mergeWith = a7, _14.method = Bg, _14.methodOf = Ng, _14.mixin = V2, _14.negate = vl, _14.nthArg = qg, _14.omit = Ip, _14.omitBy = Rp, _14.once = Om, _14.orderBy = ym, _14.over = Pg, _14.overArgs = qm, _14.overEvery = Lg, _14.overSome = Ig, _14.partial = R2, _14.partialRight = K6, _14.partition = bm, _14.pick = zp, _14.pickBy = o7, _14.property = d7, _14.propertyOf = Rg, _14.pull = yd, _14.pullAll = z6, _14.pullAllBy = bd, _14.pullAllWith = xd, _14.pullAt = wd, _14.range = zg, _14.rangeRight = Fg, _14.rearg = Pm, _14.reject = _m, _14.remove = _d, _14.rest = Lm, _14.reverse = P2, _14.sampleSize = Am, _14.set = Hp, _14.setWith = jp, _14.shuffle = Tm, _14.slice = Sd, _14.sortBy = km, _14.sortedUniq = Dd, _14.sortedUniqBy = Bd, _14.split = fg, _14.spread = Im, _14.tail = Nd, _14.take = Od, _14.takeRight = qd, _14.takeRightWhile = Pd, _14.takeWhile = Ld, _14.tap = Zd, _14.throttle = Rm, _14.thru = dl, _14.toArray = t7, _14.toPairs = s7, _14.toPairsIn = l7, _14.toPath = Gg, _14.toPlainObject = n7, _14.transform = Up, _14.unary = zm, _14.union = Id, _14.unionBy = Rd, _14.unionWith = zd, _14.uniq = Fd, _14.uniqBy = Hd, _14.uniqWith = jd, _14.unset = Wp, _14.unzip = L2, _14.unzipWith = F6, _14.update = Gp, _14.updateWith = Vp, _14.values = ua, _14.valuesIn = $p, _14.without = Ud, _14.words = f7, _14.wrap = Fm, _14.xor = Wd, _14.xorBy = Gd, _14.xorWith = Vd, _14.zip = $d, _14.zipObject = Xd, _14.zipObjectDeep = Yd, _14.zipWith = Kd, _14.entries = s7, _14.entriesIn = l7, _14.extend = i7, _14.extendWith = xl, V2(_14, _14), _14.add = $g, _14.attempt = h7, _14.camelCase = Zp, _14.capitalize = u7, _14.ceil = Xg, _14.clamp = Xp, _14.clone = jm, _14.cloneDeep = Wm, _14.cloneDeepWith = Gm, _14.cloneWith = Um, _14.conformsTo = Vm, _14.deburr = c7, _14.defaultTo = Eg, _14.divide = Yg, _14.endsWith = Jp, _14.eq = G1, _14.escape = Qp, _14.escapeRegExp = eg, _14.every = sm, _14.find = um, _14.findIndex = P6, _14.findKey = _p, _14.findLast = cm, _14.findLastIndex = L6, _14.findLastKey = Sp, _14.floor = Kg, _14.forEach = j6, _14.forEachRight = U6, _14.forIn = Ap, _14.forInRight = Tp, _14.forOwn = Ep, _14.forOwnRight = Cp, _14.get = H2, _14.gt = $m, _14.gte = Xm, _14.has = Dp, _14.hasIn = j2, _14.head = R6, _14.identity = Jr, _14.includes = pm, _14.indexOf = cd, _14.inRange = Yp, _14.invoke = Op, _14.isArguments = ci, _14.isArray = Le, _14.isArrayBuffer = Ym, _14.isArrayLike = Kr, _14.isArrayLikeObject = zt, _14.isBoolean = Km, _14.isBuffer = _n, _14.isDate = Zm, _14.isElement = Jm, _14.isEmpty = Qm, _14.isEqual = ep, _14.isEqualWith = tp, _14.isError = z2, _14.isFinite = rp, _14.isFunction = P0, _14.isInteger = Z6, _14.isLength = yl, _14.isMap = J6, _14.isMatch = np, _14.isMatchWith = ip, _14.isNaN = ap, _14.isNative = op, _14.isNil = lp, _14.isNull = sp, _14.isNumber = Q6, _14.isObject = Mt, _14.isObjectLike = Ot, _14.isPlainObject = To, _14.isRegExp = F2, _14.isSafeInteger = up, _14.isSet = e7, _14.isString = bl, _14.isSymbol = l1, _14.isTypedArray = la, _14.isUndefined = cp, _14.isWeakMap = fp, _14.isWeakSet = hp, _14.join = pd, _14.kebabCase = tg, _14.last = S1, _14.lastIndexOf = gd, _14.lowerCase = rg, _14.lowerFirst = ng, _14.lt = dp, _14.lte = mp, _14.max = Zg, _14.maxBy = Jg, _14.mean = Qg, _14.meanBy = ev, _14.min = tv, _14.minBy = rv, _14.stubArray = X2, _14.stubFalse = Y2, _14.stubObject = Hg, _14.stubString = jg, _14.stubTrue = Ug, _14.multiply = nv, _14.nth = vd, _14.noConflict = Og, _14.noop = $2, _14.now = pl, _14.pad = ig, _14.padEnd = ag, _14.padStart = og, _14.parseInt = sg, _14.random = Kp, _14.reduce = xm, _14.reduceRight = wm, _14.repeat = lg, _14.replace = ug, _14.result = Fp, _14.round = iv, _14.runInContext = I, _14.sample = Sm, _14.size = Em, _14.snakeCase = cg, _14.some = Cm, _14.sortedIndex = Ad, _14.sortedIndexBy = Td, _14.sortedIndexOf = Ed, _14.sortedLastIndex = Cd, _14.sortedLastIndexBy = kd, _14.sortedLastIndexOf = Md, _14.startCase = hg, _14.startsWith = dg, _14.subtract = av, _14.sum = ov, _14.sumBy = sv, _14.template = mg, _14.times = Wg, _14.toFinite = L0, _14.toInteger = Re, _14.toLength = r7, _14.toLower = pg, _14.toNumber = A1, _14.toSafeInteger = pp, _14.toString = ut, _14.toUpper = gg, _14.trim = vg, _14.trimEnd = yg, _14.trimStart = bg, _14.truncate = xg, _14.unescape = wg, _14.uniqueId = Vg, _14.upperCase = _g, _14.upperFirst = U2, _14.each = j6, _14.eachRight = U6, _14.first = R6, V2(_14, function() {
          var e = {};
          return Et(_14, function(n, u) {
            rt.call(_14.prototype, u) || (e[u] = n);
          }), e;
        }(), { chain: false }), _14.VERSION = r6, Lt(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(e) {
          _14[e].placeholder = _14;
        }), Lt(["drop", "take"], function(e, n) {
          We.prototype[e] = function(u) {
            u = u === t2 ? 1 : It(Re(u), 0);
            var d = this.__filtered__ && !n ? new We(this) : this.clone();
            return d.__filtered__ ? d.__takeCount__ = Jt(u, d.__takeCount__) : d.__views__.push({ size: Jt(u, Pe), type: e + (d.__dir__ < 0 ? "Right" : "") }), d;
          }, We.prototype[e + "Right"] = function(u) {
            return this.reverse()[e](u).reverse();
          };
        }), Lt(["filter", "map", "takeWhile"], function(e, n) {
          var u = n + 1, d = u == Dt || u == m1;
          We.prototype[e] = function(b) {
            var E = this.clone();
            return E.__iteratees__.push({ iteratee: Ee(b, 3), type: u }), E.__filtered__ = E.__filtered__ || d, E;
          };
        }), Lt(["head", "last"], function(e, n) {
          var u = "take" + (n ? "Right" : "");
          We.prototype[e] = function() {
            return this[u](1).value()[0];
          };
        }), Lt(["initial", "tail"], function(e, n) {
          var u = "drop" + (n ? "" : "Right");
          We.prototype[e] = function() {
            return this.__filtered__ ? new We(this) : this[u](1);
          };
        }), We.prototype.compact = function() {
          return this.filter(Jr);
        }, We.prototype.find = function(e) {
          return this.filter(e).head();
        }, We.prototype.findLast = function(e) {
          return this.reverse().find(e);
        }, We.prototype.invokeMap = je(function(e, n) {
          return typeof e == "function" ? new We(this) : this.map(function(u) {
            return w1(u, e, n);
          });
        }), We.prototype.reject = function(e) {
          return this.filter(vl(Ee(e)));
        }, We.prototype.slice = function(e, n) {
          e = Re(e);
          var u = this;
          return u.__filtered__ && (e > 0 || n < 0) ? new We(u) : (e < 0 ? u = u.takeRight(-e) : e && (u = u.drop(e)), n !== t2 && (n = Re(n), u = n < 0 ? u.dropRight(-n) : u.take(n - e)), u);
        }, We.prototype.takeRightWhile = function(e) {
          return this.reverse().takeWhile(e).reverse();
        }, We.prototype.toArray = function() {
          return this.take(Pe);
        }, Et(We.prototype, function(e, n) {
          var u = /^(?:filter|find|map|reject)|While$/.test(n), d = /^(?:head|last)$/.test(n), b = _14[d ? "take" + (n == "last" ? "Right" : "") : n], E = d || /^find/.test(n);
          !b || (_14.prototype[n] = function() {
            var D = this.__wrapped__, q = d ? [1] : arguments, R = D instanceof We, Z = q[0], Q = R || Le(D), re = function(Xe) {
              var et = b.apply(_14, E0([Xe], q));
              return d && le ? et[0] : et;
            };
            Q && u && typeof Z == "function" && Z.length != 1 && (R = Q = false);
            var le = this.__chain__, be = !!this.__actions__.length, Ce = E && !le, Fe = R && !be;
            if (!E && Q) {
              D = Fe ? D : new We(this);
              var ke = e.apply(D, q);
              return ke.__actions__.push({ func: dl, args: [re], thisArg: t2 }), new $r(ke, le);
            }
            return Ce && Fe ? e.apply(this, q) : (ke = this.thru(re), Ce ? d ? ke.value()[0] : ke.value() : ke);
          });
        }), Lt(["pop", "push", "shift", "sort", "splice", "unshift"], function(e) {
          var n = un[e], u = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru", d = /^(?:pop|shift)$/.test(e);
          _14.prototype[e] = function() {
            var b = arguments;
            if (d && !this.__chain__) {
              var E = this.value();
              return n.apply(Le(E) ? E : [], b);
            }
            return this[u](function(D) {
              return n.apply(Le(D) ? D : [], b);
            });
          };
        }), Et(We.prototype, function(e, n) {
          var u = _14[n];
          if (u) {
            var d = u.name + "";
            rt.call(o0, d) || (o0[d] = []), o0[d].push({ name: n, func: u });
          }
        }), o0[ol(t2, V).name] = [{ name: "wrapper", func: t2 }], We.prototype.clone = Qu, We.prototype.reverse = e2, We.prototype.value = co, _14.prototype.at = Jd, _14.prototype.chain = Qd, _14.prototype.commit = em, _14.prototype.next = tm, _14.prototype.plant = nm, _14.prototype.reverse = im, _14.prototype.toJSON = _14.prototype.valueOf = _14.prototype.value = am, _14.prototype.first = _14.prototype.head, cn && (_14.prototype[cn] = rm2), _14;
      }, i0 = Yu();
      typeof define == "function" && typeof define.amd == "object" && define.amd ? (Nt._ = i0, define(function() {
        return i0;
      })) : Ie ? ((Ie.exports = i0)._ = i0, T0._ = i0) : Nt._ = i0;
    }).call(fa);
  });
  var ha = J((KT, _l) => {
    (function() {
      "use strict";
      var t2 = {}.hasOwnProperty;
      function r6() {
        for (var s = [], c = 0; c < arguments.length; c++) {
          var p = arguments[c];
          if (!!p) {
            var w = typeof p;
            if (w === "string" || w === "number")
              s.push(p);
            else if (Array.isArray(p)) {
              if (p.length) {
                var T = r6.apply(null, p);
                T && s.push(T);
              }
            } else if (w === "object")
              if (p.toString === Object.prototype.toString)
                for (var k in p)
                  t2.call(p, k) && p[k] && s.push(k);
              else
                s.push(p.toString());
          }
        }
        return s.join(" ");
      }
      typeof _l != "undefined" && _l.exports ? (r6.default = r6, _l.exports = r6) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function() {
        return r6;
      }) : window.classNames = r6;
    })();
  });
  var v7 = J((Mo, K2) => {
    (function(r6, s) {
      typeof Mo == "object" && typeof K2 == "object" ? K2.exports = s() : typeof define == "function" && define.amd ? define([], s) : typeof Mo == "object" ? Mo.katex = s() : r6.katex = s();
    })(typeof self != "undefined" ? self : Mo, function() {
      return function() {
        "use strict";
        var t2 = {};
        (function() {
          t2.d = function(g, i) {
            for (var a in i)
              t2.o(i, a) && !t2.o(g, a) && Object.defineProperty(g, a, { enumerable: true, get: i[a] });
          };
        })(), function() {
          t2.o = function(g, i) {
            return Object.prototype.hasOwnProperty.call(g, i);
          };
        }();
        var r6 = {};
        t2.d(r6, { default: function() {
          return c2;
        } });
        var s = function g(i, a) {
          this.position = void 0;
          var o = "KaTeX parse error: " + i, l, f = a && a.loc;
          if (f && f.start <= f.end) {
            var m = f.lexer.input;
            l = f.start;
            var y = f.end;
            l === m.length ? o += " at end of input: " : o += " at position " + (l + 1) + ": ";
            var S = m.slice(l, y).replace(/[^]/g, "$&\u0332"), C2;
            l > 15 ? C2 = "\u2026" + m.slice(l - 15, l) : C2 = m.slice(0, l);
            var O;
            y + 15 < m.length ? O = m.slice(y, y + 15) + "\u2026" : O = m.slice(y), o += C2 + S + O;
          }
          var z = new Error(o);
          return z.name = "ParseError", z.__proto__ = g.prototype, z.position = l, z;
        };
        s.prototype.__proto__ = Error.prototype;
        var c = s, p = function(i, a) {
          return i.indexOf(a) !== -1;
        }, w = function(i, a) {
          return i === void 0 ? a : i;
        }, T = /([A-Z])/g, k = function(i) {
          return i.replace(T, "-$1").toLowerCase();
        }, P = { "&": "&amp;", ">": "&gt;", "<": "&lt;", '"': "&quot;", "'": "&#x27;" }, j = /[&><"']/g;
        function U(g) {
          return String(g).replace(j, function(i) {
            return P[i];
          });
        }
        var ee = function g(i) {
          return i.type === "ordgroup" || i.type === "color" ? i.body.length === 1 ? g(i.body[0]) : i : i.type === "font" ? g(i.body) : i;
        }, G = function(i) {
          var a = ee(i);
          return a.type === "mathord" || a.type === "textord" || a.type === "atom";
        }, ae = function(i) {
          if (!i)
            throw new Error("Expected non-null, but got " + String(i));
          return i;
        }, ie3 = function(i) {
          var a = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(i);
          return a != null ? a[1] : "_relative";
        }, V = { contains: p, deflt: w, escape: U, hyphenate: k, getBaseElem: ee, isCharacterBox: G, protocolFromUrl: ie3 }, de = function() {
          function g(a) {
            this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, a = a || {}, this.displayMode = V.deflt(a.displayMode, false), this.output = V.deflt(a.output, "htmlAndMathml"), this.leqno = V.deflt(a.leqno, false), this.fleqn = V.deflt(a.fleqn, false), this.throwOnError = V.deflt(a.throwOnError, true), this.errorColor = V.deflt(a.errorColor, "#cc0000"), this.macros = a.macros || {}, this.minRuleThickness = Math.max(0, V.deflt(a.minRuleThickness, 0)), this.colorIsTextColor = V.deflt(a.colorIsTextColor, false), this.strict = V.deflt(a.strict, "warn"), this.trust = V.deflt(a.trust, false), this.maxSize = Math.max(0, V.deflt(a.maxSize, Infinity)), this.maxExpand = Math.max(0, V.deflt(a.maxExpand, 1e3)), this.globalGroup = V.deflt(a.globalGroup, false);
          }
          var i = g.prototype;
          return i.reportNonstrict = function(o, l, f) {
            var m = this.strict;
            if (typeof m == "function" && (m = m(o, l, f)), !(!m || m === "ignore")) {
              if (m === true || m === "error")
                throw new c("LaTeX-incompatible input and strict mode is set to 'error': " + (l + " [" + o + "]"), f);
              m === "warn" ? typeof console != "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (l + " [" + o + "]")) : typeof console != "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + m + "': " + l + " [" + o + "]"));
            }
          }, i.useStrictBehavior = function(o, l, f) {
            var m = this.strict;
            if (typeof m == "function")
              try {
                m = m(o, l, f);
              } catch (y) {
                m = "error";
              }
            return !m || m === "ignore" ? false : m === true || m === "error" ? true : m === "warn" ? (typeof console != "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (l + " [" + o + "]")), false) : (typeof console != "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + m + "': " + l + " [" + o + "]")), false);
          }, i.isTrusted = function(o) {
            o.url && !o.protocol && (o.protocol = V.protocolFromUrl(o.url));
            var l = typeof this.trust == "function" ? this.trust(o) : this.trust;
            return Boolean(l);
          }, g;
        }(), ve = function() {
          function g(a, o, l) {
            this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = a, this.size = o, this.cramped = l;
          }
          var i = g.prototype;
          return i.sup = function() {
            return Ue[Ye[this.id]];
          }, i.sub = function() {
            return Ue[Dt[this.id]];
          }, i.fracNum = function() {
            return Ue[mt[this.id]];
          }, i.fracDen = function() {
            return Ue[m1[this.id]];
          }, i.cramp = function() {
            return Ue[$t[this.id]];
          }, i.text = function() {
            return Ue[Bt[this.id]];
          }, i.isTight = function() {
            return this.size >= 2;
          }, g;
        }(), _e2 = 0, Me = 1, we = 2, ye = 3, xe = 4, Se = 5, Je = 6, Ae = 7, Ue = [new ve(_e2, 0, false), new ve(Me, 0, true), new ve(we, 1, false), new ve(ye, 1, true), new ve(xe, 2, false), new ve(Se, 2, true), new ve(Je, 3, false), new ve(Ae, 3, true)], Ye = [xe, Se, xe, Se, Je, Ae, Je, Ae], Dt = [Se, Se, Se, Se, Ae, Ae, Ae, Ae], mt = [we, ye, xe, Se, Je, Ae, Je, Ae], m1 = [ye, ye, Se, Se, Ae, Ae, Ae, Ae], $t = [Me, Me, ye, ye, Se, Se, Ae, Ae], Bt = [_e2, Me, we, ye, we, ye, we, ye], pe = { DISPLAY: Ue[_e2], TEXT: Ue[we], SCRIPT: Ue[xe], SCRIPTSCRIPT: Ue[Je] }, Sr = [{ name: "latin", blocks: [[256, 591], [768, 879]] }, { name: "cyrillic", blocks: [[1024, 1279]] }, { name: "armenian", blocks: [[1328, 1423]] }, { name: "brahmic", blocks: [[2304, 4255]] }, { name: "georgian", blocks: [[4256, 4351]] }, { name: "cjk", blocks: [[12288, 12543], [19968, 40879], [65280, 65376]] }, { name: "hangul", blocks: [[44032, 55215]] }];
        function Pe(g) {
          for (var i = 0; i < Sr.length; i++)
            for (var a = Sr[i], o = 0; o < a.blocks.length; o++) {
              var l = a.blocks[o];
              if (g >= l[0] && g <= l[1])
                return a.name;
            }
          return null;
        }
        var pt = [];
        Sr.forEach(function(g) {
          return g.blocks.forEach(function(i) {
            return pt.push.apply(pt, i);
          });
        });
        function J1(g) {
          for (var i = 0; i < pt.length; i += 2)
            if (g >= pt[i] && g <= pt[i + 1])
              return true;
          return false;
        }
        var ar = 80, i1 = function(i, a) {
          return "M95," + (622 + i + a) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + i / 2.075 + " -" + i + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + i) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + i) + " " + a + "h400000v" + (40 + i) + "h-400000z";
        }, Rr = function(i, a) {
          return "M263," + (601 + i + a) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + i / 2.084 + " -" + i + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + i) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + i) + " " + a + "h400000v" + (40 + i) + "h-400000z";
        }, zr = function(i, a) {
          return "M983 " + (10 + i + a) + `
l` + i / 3.13 + " -" + i + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + i) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + i) + " " + a + "h400000v" + (40 + i) + "h-400000z";
        }, p1 = function(i, a) {
          return "M424," + (2398 + i + a) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + i / 4.223 + " -" + i + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + i) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + i) + " " + a + `
h400000v` + (40 + i) + "h-400000z";
        }, L1 = function(i, a) {
          return "M473," + (2713 + i + a) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + i / 5.298 + " -" + i + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + i) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + i) + " " + a + "h400000v" + (40 + i) + "H1017.7z";
        }, Q1 = function(i) {
          var a = i / 2;
          return "M400000 " + i + " H0 L" + a + " 0 l65 45 L145 " + (i - 80) + " H400000z";
        }, e0 = function(i, a, o) {
          var l = o - 54 - a - i;
          return "M702 " + (i + a) + "H400000" + (40 + i) + `
H742v` + l + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + a + "H400000v" + (40 + i) + "H742z";
        }, y0 = function(i, a, o) {
          a = 1e3 * a;
          var l = "";
          switch (i) {
            case "sqrtMain":
              l = i1(a, ar);
              break;
            case "sqrtSize1":
              l = Rr(a, ar);
              break;
            case "sqrtSize2":
              l = zr(a, ar);
              break;
            case "sqrtSize3":
              l = p1(a, ar);
              break;
            case "sqrtSize4":
              l = L1(a, ar);
              break;
            case "sqrtTall":
              l = e0(a, ar, o);
          }
          return l;
        }, zn = function(i, a) {
          switch (i) {
            case "\u239C":
              return "M291 0 H417 V" + a + " H291z M291 0 H417 V" + a + " H291z";
            case "\u2223":
              return "M145 0 H188 V" + a + " H145z M145 0 H188 V" + a + " H145z";
            case "\u2225":
              return "M145 0 H188 V" + a + " H145z M145 0 H188 V" + a + " H145z" + ("M367 0 H410 V" + a + " H367z M367 0 H410 V" + a + " H367z");
            case "\u239F":
              return "M457 0 H583 V" + a + " H457z M457 0 H583 V" + a + " H457z";
            case "\u23A2":
              return "M319 0 H403 V" + a + " H319z M319 0 H403 V" + a + " H319z";
            case "\u23A5":
              return "M263 0 H347 V" + a + " H263z M263 0 H347 V" + a + " H263z";
            case "\u23AA":
              return "M384 0 H504 V" + a + " H384z M384 0 H504 V" + a + " H384z";
            case "\u23D0":
              return "M312 0 H355 V" + a + " H312z M312 0 H355 V" + a + " H312z";
            case "\u2016":
              return "M257 0 H300 V" + a + " H257z M257 0 H300 V" + a + " H257z" + ("M478 0 H521 V" + a + " H478z M478 0 H521 V" + a + " H478z");
            default:
              return "";
          }
        }, or = { doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`, doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`, leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`, leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`, leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`, leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`, leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`, leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`, leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`, leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`, leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`, lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`, leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`, leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`, leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`, longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`, midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`, midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`, oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`, oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`, oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`, oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`, rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`, rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`, rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`, rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`, rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`, rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`, rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`, rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`, rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`, righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`, rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`, rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`, twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`, twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`, tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`, tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`, tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`, tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`, vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`, widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`, widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`, widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`, widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`, widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`, widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`, widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`, widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`, baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`, rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`, baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`, rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`, shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`, shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z` }, Fr = function() {
          function g(a) {
            this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = a, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
          }
          var i = g.prototype;
          return i.hasClass = function(o) {
            return V.contains(this.classes, o);
          }, i.toNode = function() {
            for (var o = document.createDocumentFragment(), l = 0; l < this.children.length; l++)
              o.appendChild(this.children[l].toNode());
            return o;
          }, i.toMarkup = function() {
            for (var o = "", l = 0; l < this.children.length; l++)
              o += this.children[l].toMarkup();
            return o;
          }, i.toText = function() {
            var o = function(f) {
              return f.toText();
            };
            return this.children.map(o).join("");
          }, g;
        }(), g1 = function(i) {
          return i.filter(function(a) {
            return a;
          }).join(" ");
        }, Hr = function(i, a, o) {
          if (this.classes = i || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = o || {}, a) {
            a.style.isTight() && this.classes.push("mtight");
            var l = a.getColor();
            l && (this.style.color = l);
          }
        }, t0 = function(i) {
          var a = document.createElement(i);
          a.className = g1(this.classes);
          for (var o in this.style)
            this.style.hasOwnProperty(o) && (a.style[o] = this.style[o]);
          for (var l in this.attributes)
            this.attributes.hasOwnProperty(l) && a.setAttribute(l, this.attributes[l]);
          for (var f = 0; f < this.children.length; f++)
            a.appendChild(this.children[f].toNode());
          return a;
        }, Fn = function(i) {
          var a = "<" + i;
          this.classes.length && (a += ' class="' + V.escape(g1(this.classes)) + '"');
          var o = "";
          for (var l in this.style)
            this.style.hasOwnProperty(l) && (o += V.hyphenate(l) + ":" + this.style[l] + ";");
          o && (a += ' style="' + V.escape(o) + '"');
          for (var f in this.attributes)
            this.attributes.hasOwnProperty(f) && (a += " " + f + '="' + V.escape(this.attributes[f]) + '"');
          a += ">";
          for (var m = 0; m < this.children.length; m++)
            a += this.children[m].toMarkup();
          return a += "</" + i + ">", a;
        }, jr = function() {
          function g(a, o, l, f) {
            this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Hr.call(this, a, l, f), this.children = o || [];
          }
          var i = g.prototype;
          return i.setAttribute = function(o, l) {
            this.attributes[o] = l;
          }, i.hasClass = function(o) {
            return V.contains(this.classes, o);
          }, i.toNode = function() {
            return t0.call(this, "span");
          }, i.toMarkup = function() {
            return Fn.call(this, "span");
          }, g;
        }(), Zt = function() {
          function g(a, o, l, f) {
            this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Hr.call(this, o, f), this.children = l || [], this.setAttribute("href", a);
          }
          var i = g.prototype;
          return i.setAttribute = function(o, l) {
            this.attributes[o] = l;
          }, i.hasClass = function(o) {
            return V.contains(this.classes, o);
          }, i.toNode = function() {
            return t0.call(this, "a");
          }, i.toMarkup = function() {
            return Fn.call(this, "a");
          }, g;
        }(), Hn = function() {
          function g(a, o, l) {
            this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = o, this.src = a, this.classes = ["mord"], this.style = l;
          }
          var i = g.prototype;
          return i.hasClass = function(o) {
            return V.contains(this.classes, o);
          }, i.toNode = function() {
            var o = document.createElement("img");
            o.src = this.src, o.alt = this.alt, o.className = "mord";
            for (var l in this.style)
              this.style.hasOwnProperty(l) && (o.style[l] = this.style[l]);
            return o;
          }, i.toMarkup = function() {
            var o = "<img  src='" + this.src + " 'alt='" + this.alt + "' ", l = "";
            for (var f in this.style)
              this.style.hasOwnProperty(f) && (l += V.hyphenate(f) + ":" + this.style[f] + ";");
            return l && (o += ' style="' + V.escape(l) + '"'), o += "'/>", o;
          }, g;
        }(), Ti = { \u00EE: "\u0131\u0302", \u00EF: "\u0131\u0308", \u00ED: "\u0131\u0301", \u00EC: "\u0131\u0300" }, Ur = function() {
          function g(a, o, l, f, m, y, S, C2) {
            this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = a, this.height = o || 0, this.depth = l || 0, this.italic = f || 0, this.skew = m || 0, this.width = y || 0, this.classes = S || [], this.style = C2 || {}, this.maxFontSize = 0;
            var O = Pe(this.text.charCodeAt(0));
            O && this.classes.push(O + "_fallback"), /[îïíì]/.test(this.text) && (this.text = Ti[this.text]);
          }
          var i = g.prototype;
          return i.hasClass = function(o) {
            return V.contains(this.classes, o);
          }, i.toNode = function() {
            var o = document.createTextNode(this.text), l = null;
            this.italic > 0 && (l = document.createElement("span"), l.style.marginRight = this.italic + "em"), this.classes.length > 0 && (l = l || document.createElement("span"), l.className = g1(this.classes));
            for (var f in this.style)
              this.style.hasOwnProperty(f) && (l = l || document.createElement("span"), l.style[f] = this.style[f]);
            return l ? (l.appendChild(o), l) : o;
          }, i.toMarkup = function() {
            var o = false, l = "<span";
            this.classes.length && (o = true, l += ' class="', l += V.escape(g1(this.classes)), l += '"');
            var f = "";
            this.italic > 0 && (f += "margin-right:" + this.italic + "em;");
            for (var m in this.style)
              this.style.hasOwnProperty(m) && (f += V.hyphenate(m) + ":" + this.style[m] + ";");
            f && (o = true, l += ' style="' + V.escape(f) + '"');
            var y = V.escape(this.text);
            return o ? (l += ">", l += y, l += "</span>", l) : y;
          }, g;
        }(), Wr = function() {
          function g(a, o) {
            this.children = void 0, this.attributes = void 0, this.children = a || [], this.attributes = o || {};
          }
          var i = g.prototype;
          return i.toNode = function() {
            var o = "http://www.w3.org/2000/svg", l = document.createElementNS(o, "svg");
            for (var f in this.attributes)
              Object.prototype.hasOwnProperty.call(this.attributes, f) && l.setAttribute(f, this.attributes[f]);
            for (var m = 0; m < this.children.length; m++)
              l.appendChild(this.children[m].toNode());
            return l;
          }, i.toMarkup = function() {
            var o = '<svg xmlns="http://www.w3.org/2000/svg"';
            for (var l in this.attributes)
              Object.prototype.hasOwnProperty.call(this.attributes, l) && (o += " " + l + "='" + this.attributes[l] + "'");
            o += ">";
            for (var f = 0; f < this.children.length; f++)
              o += this.children[f].toMarkup();
            return o += "</svg>", o;
          }, g;
        }(), b0 = function() {
          function g(a, o) {
            this.pathName = void 0, this.alternate = void 0, this.pathName = a, this.alternate = o;
          }
          var i = g.prototype;
          return i.toNode = function() {
            var o = "http://www.w3.org/2000/svg", l = document.createElementNS(o, "path");
            return this.alternate ? l.setAttribute("d", this.alternate) : l.setAttribute("d", or[this.pathName]), l;
          }, i.toMarkup = function() {
            return this.alternate ? "<path d='" + this.alternate + "'/>" : "<path d='" + or[this.pathName] + "'/>";
          }, g;
        }(), x0 = function() {
          function g(a) {
            this.attributes = void 0, this.attributes = a || {};
          }
          var i = g.prototype;
          return i.toNode = function() {
            var o = "http://www.w3.org/2000/svg", l = document.createElementNS(o, "line");
            for (var f in this.attributes)
              Object.prototype.hasOwnProperty.call(this.attributes, f) && l.setAttribute(f, this.attributes[f]);
            return l;
          }, i.toMarkup = function() {
            var o = "<line";
            for (var l in this.attributes)
              Object.prototype.hasOwnProperty.call(this.attributes, l) && (o += " " + l + "='" + this.attributes[l] + "'");
            return o += "/>", o;
          }, g;
        }();
        function w0(g) {
          if (g instanceof Ur)
            return g;
          throw new Error("Expected symbolNode but got " + String(g) + ".");
        }
        function Da(g) {
          if (g instanceof jr)
            return g;
          throw new Error("Expected span<HtmlDomNode> but got " + String(g) + ".");
        }
        var Gr = { "AMS-Regular": { "32": [0, 0, 0, 0, 0.25], "65": [0, 0.68889, 0, 0, 0.72222], "66": [0, 0.68889, 0, 0, 0.66667], "67": [0, 0.68889, 0, 0, 0.72222], "68": [0, 0.68889, 0, 0, 0.72222], "69": [0, 0.68889, 0, 0, 0.66667], "70": [0, 0.68889, 0, 0, 0.61111], "71": [0, 0.68889, 0, 0, 0.77778], "72": [0, 0.68889, 0, 0, 0.77778], "73": [0, 0.68889, 0, 0, 0.38889], "74": [0.16667, 0.68889, 0, 0, 0.5], "75": [0, 0.68889, 0, 0, 0.77778], "76": [0, 0.68889, 0, 0, 0.66667], "77": [0, 0.68889, 0, 0, 0.94445], "78": [0, 0.68889, 0, 0, 0.72222], "79": [0.16667, 0.68889, 0, 0, 0.77778], "80": [0, 0.68889, 0, 0, 0.61111], "81": [0.16667, 0.68889, 0, 0, 0.77778], "82": [0, 0.68889, 0, 0, 0.72222], "83": [0, 0.68889, 0, 0, 0.55556], "84": [0, 0.68889, 0, 0, 0.66667], "85": [0, 0.68889, 0, 0, 0.72222], "86": [0, 0.68889, 0, 0, 0.72222], "87": [0, 0.68889, 0, 0, 1], "88": [0, 0.68889, 0, 0, 0.72222], "89": [0, 0.68889, 0, 0, 0.72222], "90": [0, 0.68889, 0, 0, 0.66667], "107": [0, 0.68889, 0, 0, 0.55556], "160": [0, 0, 0, 0, 0.25], "165": [0, 0.675, 0.025, 0, 0.75], "174": [0.15559, 0.69224, 0, 0, 0.94666], "240": [0, 0.68889, 0, 0, 0.55556], "295": [0, 0.68889, 0, 0, 0.54028], "710": [0, 0.825, 0, 0, 2.33334], "732": [0, 0.9, 0, 0, 2.33334], "770": [0, 0.825, 0, 0, 2.33334], "771": [0, 0.9, 0, 0, 2.33334], "989": [0.08167, 0.58167, 0, 0, 0.77778], "1008": [0, 0.43056, 0.04028, 0, 0.66667], "8245": [0, 0.54986, 0, 0, 0.275], "8463": [0, 0.68889, 0, 0, 0.54028], "8487": [0, 0.68889, 0, 0, 0.72222], "8498": [0, 0.68889, 0, 0, 0.55556], "8502": [0, 0.68889, 0, 0, 0.66667], "8503": [0, 0.68889, 0, 0, 0.44445], "8504": [0, 0.68889, 0, 0, 0.66667], "8513": [0, 0.68889, 0, 0, 0.63889], "8592": [-0.03598, 0.46402, 0, 0, 0.5], "8594": [-0.03598, 0.46402, 0, 0, 0.5], "8602": [-0.13313, 0.36687, 0, 0, 1], "8603": [-0.13313, 0.36687, 0, 0, 1], "8606": [0.01354, 0.52239, 0, 0, 1], "8608": [0.01354, 0.52239, 0, 0, 1], "8610": [0.01354, 0.52239, 0, 0, 1.11111], "8611": [0.01354, 0.52239, 0, 0, 1.11111], "8619": [0, 0.54986, 0, 0, 1], "8620": [0, 0.54986, 0, 0, 1], "8621": [-0.13313, 0.37788, 0, 0, 1.38889], "8622": [-0.13313, 0.36687, 0, 0, 1], "8624": [0, 0.69224, 0, 0, 0.5], "8625": [0, 0.69224, 0, 0, 0.5], "8630": [0, 0.43056, 0, 0, 1], "8631": [0, 0.43056, 0, 0, 1], "8634": [0.08198, 0.58198, 0, 0, 0.77778], "8635": [0.08198, 0.58198, 0, 0, 0.77778], "8638": [0.19444, 0.69224, 0, 0, 0.41667], "8639": [0.19444, 0.69224, 0, 0, 0.41667], "8642": [0.19444, 0.69224, 0, 0, 0.41667], "8643": [0.19444, 0.69224, 0, 0, 0.41667], "8644": [0.1808, 0.675, 0, 0, 1], "8646": [0.1808, 0.675, 0, 0, 1], "8647": [0.1808, 0.675, 0, 0, 1], "8648": [0.19444, 0.69224, 0, 0, 0.83334], "8649": [0.1808, 0.675, 0, 0, 1], "8650": [0.19444, 0.69224, 0, 0, 0.83334], "8651": [0.01354, 0.52239, 0, 0, 1], "8652": [0.01354, 0.52239, 0, 0, 1], "8653": [-0.13313, 0.36687, 0, 0, 1], "8654": [-0.13313, 0.36687, 0, 0, 1], "8655": [-0.13313, 0.36687, 0, 0, 1], "8666": [0.13667, 0.63667, 0, 0, 1], "8667": [0.13667, 0.63667, 0, 0, 1], "8669": [-0.13313, 0.37788, 0, 0, 1], "8672": [-0.064, 0.437, 0, 0, 1.334], "8674": [-0.064, 0.437, 0, 0, 1.334], "8705": [0, 0.825, 0, 0, 0.5], "8708": [0, 0.68889, 0, 0, 0.55556], "8709": [0.08167, 0.58167, 0, 0, 0.77778], "8717": [0, 0.43056, 0, 0, 0.42917], "8722": [-0.03598, 0.46402, 0, 0, 0.5], "8724": [0.08198, 0.69224, 0, 0, 0.77778], "8726": [0.08167, 0.58167, 0, 0, 0.77778], "8733": [0, 0.69224, 0, 0, 0.77778], "8736": [0, 0.69224, 0, 0, 0.72222], "8737": [0, 0.69224, 0, 0, 0.72222], "8738": [0.03517, 0.52239, 0, 0, 0.72222], "8739": [0.08167, 0.58167, 0, 0, 0.22222], "8740": [0.25142, 0.74111, 0, 0, 0.27778], "8741": [0.08167, 0.58167, 0, 0, 0.38889], "8742": [0.25142, 0.74111, 0, 0, 0.5], "8756": [0, 0.69224, 0, 0, 0.66667], "8757": [0, 0.69224, 0, 0, 0.66667], "8764": [-0.13313, 0.36687, 0, 0, 0.77778], "8765": [-0.13313, 0.37788, 0, 0, 0.77778], "8769": [-0.13313, 0.36687, 0, 0, 0.77778], "8770": [-0.03625, 0.46375, 0, 0, 0.77778], "8774": [0.30274, 0.79383, 0, 0, 0.77778], "8776": [-0.01688, 0.48312, 0, 0, 0.77778], "8778": [0.08167, 0.58167, 0, 0, 0.77778], "8782": [0.06062, 0.54986, 0, 0, 0.77778], "8783": [0.06062, 0.54986, 0, 0, 0.77778], "8785": [0.08198, 0.58198, 0, 0, 0.77778], "8786": [0.08198, 0.58198, 0, 0, 0.77778], "8787": [0.08198, 0.58198, 0, 0, 0.77778], "8790": [0, 0.69224, 0, 0, 0.77778], "8791": [0.22958, 0.72958, 0, 0, 0.77778], "8796": [0.08198, 0.91667, 0, 0, 0.77778], "8806": [0.25583, 0.75583, 0, 0, 0.77778], "8807": [0.25583, 0.75583, 0, 0, 0.77778], "8808": [0.25142, 0.75726, 0, 0, 0.77778], "8809": [0.25142, 0.75726, 0, 0, 0.77778], "8812": [0.25583, 0.75583, 0, 0, 0.5], "8814": [0.20576, 0.70576, 0, 0, 0.77778], "8815": [0.20576, 0.70576, 0, 0, 0.77778], "8816": [0.30274, 0.79383, 0, 0, 0.77778], "8817": [0.30274, 0.79383, 0, 0, 0.77778], "8818": [0.22958, 0.72958, 0, 0, 0.77778], "8819": [0.22958, 0.72958, 0, 0, 0.77778], "8822": [0.1808, 0.675, 0, 0, 0.77778], "8823": [0.1808, 0.675, 0, 0, 0.77778], "8828": [0.13667, 0.63667, 0, 0, 0.77778], "8829": [0.13667, 0.63667, 0, 0, 0.77778], "8830": [0.22958, 0.72958, 0, 0, 0.77778], "8831": [0.22958, 0.72958, 0, 0, 0.77778], "8832": [0.20576, 0.70576, 0, 0, 0.77778], "8833": [0.20576, 0.70576, 0, 0, 0.77778], "8840": [0.30274, 0.79383, 0, 0, 0.77778], "8841": [0.30274, 0.79383, 0, 0, 0.77778], "8842": [0.13597, 0.63597, 0, 0, 0.77778], "8843": [0.13597, 0.63597, 0, 0, 0.77778], "8847": [0.03517, 0.54986, 0, 0, 0.77778], "8848": [0.03517, 0.54986, 0, 0, 0.77778], "8858": [0.08198, 0.58198, 0, 0, 0.77778], "8859": [0.08198, 0.58198, 0, 0, 0.77778], "8861": [0.08198, 0.58198, 0, 0, 0.77778], "8862": [0, 0.675, 0, 0, 0.77778], "8863": [0, 0.675, 0, 0, 0.77778], "8864": [0, 0.675, 0, 0, 0.77778], "8865": [0, 0.675, 0, 0, 0.77778], "8872": [0, 0.69224, 0, 0, 0.61111], "8873": [0, 0.69224, 0, 0, 0.72222], "8874": [0, 0.69224, 0, 0, 0.88889], "8876": [0, 0.68889, 0, 0, 0.61111], "8877": [0, 0.68889, 0, 0, 0.61111], "8878": [0, 0.68889, 0, 0, 0.72222], "8879": [0, 0.68889, 0, 0, 0.72222], "8882": [0.03517, 0.54986, 0, 0, 0.77778], "8883": [0.03517, 0.54986, 0, 0, 0.77778], "8884": [0.13667, 0.63667, 0, 0, 0.77778], "8885": [0.13667, 0.63667, 0, 0, 0.77778], "8888": [0, 0.54986, 0, 0, 1.11111], "8890": [0.19444, 0.43056, 0, 0, 0.55556], "8891": [0.19444, 0.69224, 0, 0, 0.61111], "8892": [0.19444, 0.69224, 0, 0, 0.61111], "8901": [0, 0.54986, 0, 0, 0.27778], "8903": [0.08167, 0.58167, 0, 0, 0.77778], "8905": [0.08167, 0.58167, 0, 0, 0.77778], "8906": [0.08167, 0.58167, 0, 0, 0.77778], "8907": [0, 0.69224, 0, 0, 0.77778], "8908": [0, 0.69224, 0, 0, 0.77778], "8909": [-0.03598, 0.46402, 0, 0, 0.77778], "8910": [0, 0.54986, 0, 0, 0.76042], "8911": [0, 0.54986, 0, 0, 0.76042], "8912": [0.03517, 0.54986, 0, 0, 0.77778], "8913": [0.03517, 0.54986, 0, 0, 0.77778], "8914": [0, 0.54986, 0, 0, 0.66667], "8915": [0, 0.54986, 0, 0, 0.66667], "8916": [0, 0.69224, 0, 0, 0.66667], "8918": [0.0391, 0.5391, 0, 0, 0.77778], "8919": [0.0391, 0.5391, 0, 0, 0.77778], "8920": [0.03517, 0.54986, 0, 0, 1.33334], "8921": [0.03517, 0.54986, 0, 0, 1.33334], "8922": [0.38569, 0.88569, 0, 0, 0.77778], "8923": [0.38569, 0.88569, 0, 0, 0.77778], "8926": [0.13667, 0.63667, 0, 0, 0.77778], "8927": [0.13667, 0.63667, 0, 0, 0.77778], "8928": [0.30274, 0.79383, 0, 0, 0.77778], "8929": [0.30274, 0.79383, 0, 0, 0.77778], "8934": [0.23222, 0.74111, 0, 0, 0.77778], "8935": [0.23222, 0.74111, 0, 0, 0.77778], "8936": [0.23222, 0.74111, 0, 0, 0.77778], "8937": [0.23222, 0.74111, 0, 0, 0.77778], "8938": [0.20576, 0.70576, 0, 0, 0.77778], "8939": [0.20576, 0.70576, 0, 0, 0.77778], "8940": [0.30274, 0.79383, 0, 0, 0.77778], "8941": [0.30274, 0.79383, 0, 0, 0.77778], "8994": [0.19444, 0.69224, 0, 0, 0.77778], "8995": [0.19444, 0.69224, 0, 0, 0.77778], "9416": [0.15559, 0.69224, 0, 0, 0.90222], "9484": [0, 0.69224, 0, 0, 0.5], "9488": [0, 0.69224, 0, 0, 0.5], "9492": [0, 0.37788, 0, 0, 0.5], "9496": [0, 0.37788, 0, 0, 0.5], "9585": [0.19444, 0.68889, 0, 0, 0.88889], "9586": [0.19444, 0.74111, 0, 0, 0.88889], "9632": [0, 0.675, 0, 0, 0.77778], "9633": [0, 0.675, 0, 0, 0.77778], "9650": [0, 0.54986, 0, 0, 0.72222], "9651": [0, 0.54986, 0, 0, 0.72222], "9654": [0.03517, 0.54986, 0, 0, 0.77778], "9660": [0, 0.54986, 0, 0, 0.72222], "9661": [0, 0.54986, 0, 0, 0.72222], "9664": [0.03517, 0.54986, 0, 0, 0.77778], "9674": [0.11111, 0.69224, 0, 0, 0.66667], "9733": [0.19444, 0.69224, 0, 0, 0.94445], "10003": [0, 0.69224, 0, 0, 0.83334], "10016": [0, 0.69224, 0, 0, 0.83334], "10731": [0.11111, 0.69224, 0, 0, 0.66667], "10846": [0.19444, 0.75583, 0, 0, 0.61111], "10877": [0.13667, 0.63667, 0, 0, 0.77778], "10878": [0.13667, 0.63667, 0, 0, 0.77778], "10885": [0.25583, 0.75583, 0, 0, 0.77778], "10886": [0.25583, 0.75583, 0, 0, 0.77778], "10887": [0.13597, 0.63597, 0, 0, 0.77778], "10888": [0.13597, 0.63597, 0, 0, 0.77778], "10889": [0.26167, 0.75726, 0, 0, 0.77778], "10890": [0.26167, 0.75726, 0, 0, 0.77778], "10891": [0.48256, 0.98256, 0, 0, 0.77778], "10892": [0.48256, 0.98256, 0, 0, 0.77778], "10901": [0.13667, 0.63667, 0, 0, 0.77778], "10902": [0.13667, 0.63667, 0, 0, 0.77778], "10933": [0.25142, 0.75726, 0, 0, 0.77778], "10934": [0.25142, 0.75726, 0, 0, 0.77778], "10935": [0.26167, 0.75726, 0, 0, 0.77778], "10936": [0.26167, 0.75726, 0, 0, 0.77778], "10937": [0.26167, 0.75726, 0, 0, 0.77778], "10938": [0.26167, 0.75726, 0, 0, 0.77778], "10949": [0.25583, 0.75583, 0, 0, 0.77778], "10950": [0.25583, 0.75583, 0, 0, 0.77778], "10955": [0.28481, 0.79383, 0, 0, 0.77778], "10956": [0.28481, 0.79383, 0, 0, 0.77778], "57350": [0.08167, 0.58167, 0, 0, 0.22222], "57351": [0.08167, 0.58167, 0, 0, 0.38889], "57352": [0.08167, 0.58167, 0, 0, 0.77778], "57353": [0, 0.43056, 0.04028, 0, 0.66667], "57356": [0.25142, 0.75726, 0, 0, 0.77778], "57357": [0.25142, 0.75726, 0, 0, 0.77778], "57358": [0.41951, 0.91951, 0, 0, 0.77778], "57359": [0.30274, 0.79383, 0, 0, 0.77778], "57360": [0.30274, 0.79383, 0, 0, 0.77778], "57361": [0.41951, 0.91951, 0, 0, 0.77778], "57366": [0.25142, 0.75726, 0, 0, 0.77778], "57367": [0.25142, 0.75726, 0, 0, 0.77778], "57368": [0.25142, 0.75726, 0, 0, 0.77778], "57369": [0.25142, 0.75726, 0, 0, 0.77778], "57370": [0.13597, 0.63597, 0, 0, 0.77778], "57371": [0.13597, 0.63597, 0, 0, 0.77778] }, "Caligraphic-Regular": { "32": [0, 0, 0, 0, 0.25], "65": [0, 0.68333, 0, 0.19445, 0.79847], "66": [0, 0.68333, 0.03041, 0.13889, 0.65681], "67": [0, 0.68333, 0.05834, 0.13889, 0.52653], "68": [0, 0.68333, 0.02778, 0.08334, 0.77139], "69": [0, 0.68333, 0.08944, 0.11111, 0.52778], "70": [0, 0.68333, 0.09931, 0.11111, 0.71875], "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487], "72": [0, 0.68333, 965e-5, 0.11111, 0.84452], "73": [0, 0.68333, 0.07382, 0, 0.54452], "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778], "75": [0, 0.68333, 0.01445, 0.05556, 0.76195], "76": [0, 0.68333, 0, 0.13889, 0.68972], "77": [0, 0.68333, 0, 0.13889, 1.2009], "78": [0, 0.68333, 0.14736, 0.08334, 0.82049], "79": [0, 0.68333, 0.02778, 0.11111, 0.79611], "80": [0, 0.68333, 0.08222, 0.08334, 0.69556], "81": [0.09722, 0.68333, 0, 0.11111, 0.81667], "82": [0, 0.68333, 0, 0.08334, 0.8475], "83": [0, 0.68333, 0.075, 0.13889, 0.60556], "84": [0, 0.68333, 0.25417, 0, 0.54464], "85": [0, 0.68333, 0.09931, 0.08334, 0.62583], "86": [0, 0.68333, 0.08222, 0, 0.61278], "87": [0, 0.68333, 0.08222, 0.08334, 0.98778], "88": [0, 0.68333, 0.14643, 0.13889, 0.7133], "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834], "90": [0, 0.68333, 0.07944, 0.13889, 0.72473], "160": [0, 0, 0, 0, 0.25] }, "Fraktur-Regular": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69141, 0, 0, 0.29574], "34": [0, 0.69141, 0, 0, 0.21471], "38": [0, 0.69141, 0, 0, 0.73786], "39": [0, 0.69141, 0, 0, 0.21201], "40": [0.24982, 0.74947, 0, 0, 0.38865], "41": [0.24982, 0.74947, 0, 0, 0.38865], "42": [0, 0.62119, 0, 0, 0.27764], "43": [0.08319, 0.58283, 0, 0, 0.75623], "44": [0, 0.10803, 0, 0, 0.27764], "45": [0.08319, 0.58283, 0, 0, 0.75623], "46": [0, 0.10803, 0, 0, 0.27764], "47": [0.24982, 0.74947, 0, 0, 0.50181], "48": [0, 0.47534, 0, 0, 0.50181], "49": [0, 0.47534, 0, 0, 0.50181], "50": [0, 0.47534, 0, 0, 0.50181], "51": [0.18906, 0.47534, 0, 0, 0.50181], "52": [0.18906, 0.47534, 0, 0, 0.50181], "53": [0.18906, 0.47534, 0, 0, 0.50181], "54": [0, 0.69141, 0, 0, 0.50181], "55": [0.18906, 0.47534, 0, 0, 0.50181], "56": [0, 0.69141, 0, 0, 0.50181], "57": [0.18906, 0.47534, 0, 0, 0.50181], "58": [0, 0.47534, 0, 0, 0.21606], "59": [0.12604, 0.47534, 0, 0, 0.21606], "61": [-0.13099, 0.36866, 0, 0, 0.75623], "63": [0, 0.69141, 0, 0, 0.36245], "65": [0, 0.69141, 0, 0, 0.7176], "66": [0, 0.69141, 0, 0, 0.88397], "67": [0, 0.69141, 0, 0, 0.61254], "68": [0, 0.69141, 0, 0, 0.83158], "69": [0, 0.69141, 0, 0, 0.66278], "70": [0.12604, 0.69141, 0, 0, 0.61119], "71": [0, 0.69141, 0, 0, 0.78539], "72": [0.06302, 0.69141, 0, 0, 0.7203], "73": [0, 0.69141, 0, 0, 0.55448], "74": [0.12604, 0.69141, 0, 0, 0.55231], "75": [0, 0.69141, 0, 0, 0.66845], "76": [0, 0.69141, 0, 0, 0.66602], "77": [0, 0.69141, 0, 0, 1.04953], "78": [0, 0.69141, 0, 0, 0.83212], "79": [0, 0.69141, 0, 0, 0.82699], "80": [0.18906, 0.69141, 0, 0, 0.82753], "81": [0.03781, 0.69141, 0, 0, 0.82699], "82": [0, 0.69141, 0, 0, 0.82807], "83": [0, 0.69141, 0, 0, 0.82861], "84": [0, 0.69141, 0, 0, 0.66899], "85": [0, 0.69141, 0, 0, 0.64576], "86": [0, 0.69141, 0, 0, 0.83131], "87": [0, 0.69141, 0, 0, 1.04602], "88": [0, 0.69141, 0, 0, 0.71922], "89": [0.18906, 0.69141, 0, 0, 0.83293], "90": [0.12604, 0.69141, 0, 0, 0.60201], "91": [0.24982, 0.74947, 0, 0, 0.27764], "93": [0.24982, 0.74947, 0, 0, 0.27764], "94": [0, 0.69141, 0, 0, 0.49965], "97": [0, 0.47534, 0, 0, 0.50046], "98": [0, 0.69141, 0, 0, 0.51315], "99": [0, 0.47534, 0, 0, 0.38946], "100": [0, 0.62119, 0, 0, 0.49857], "101": [0, 0.47534, 0, 0, 0.40053], "102": [0.18906, 0.69141, 0, 0, 0.32626], "103": [0.18906, 0.47534, 0, 0, 0.5037], "104": [0.18906, 0.69141, 0, 0, 0.52126], "105": [0, 0.69141, 0, 0, 0.27899], "106": [0, 0.69141, 0, 0, 0.28088], "107": [0, 0.69141, 0, 0, 0.38946], "108": [0, 0.69141, 0, 0, 0.27953], "109": [0, 0.47534, 0, 0, 0.76676], "110": [0, 0.47534, 0, 0, 0.52666], "111": [0, 0.47534, 0, 0, 0.48885], "112": [0.18906, 0.52396, 0, 0, 0.50046], "113": [0.18906, 0.47534, 0, 0, 0.48912], "114": [0, 0.47534, 0, 0, 0.38919], "115": [0, 0.47534, 0, 0, 0.44266], "116": [0, 0.62119, 0, 0, 0.33301], "117": [0, 0.47534, 0, 0, 0.5172], "118": [0, 0.52396, 0, 0, 0.5118], "119": [0, 0.52396, 0, 0, 0.77351], "120": [0.18906, 0.47534, 0, 0, 0.38865], "121": [0.18906, 0.47534, 0, 0, 0.49884], "122": [0.18906, 0.47534, 0, 0, 0.39054], "160": [0, 0, 0, 0, 0.25], "8216": [0, 0.69141, 0, 0, 0.21471], "8217": [0, 0.69141, 0, 0, 0.21471], "58112": [0, 0.62119, 0, 0, 0.49749], "58113": [0, 0.62119, 0, 0, 0.4983], "58114": [0.18906, 0.69141, 0, 0, 0.33328], "58115": [0.18906, 0.69141, 0, 0, 0.32923], "58116": [0.18906, 0.47534, 0, 0, 0.50343], "58117": [0, 0.69141, 0, 0, 0.33301], "58118": [0, 0.62119, 0, 0, 0.33409], "58119": [0, 0.47534, 0, 0, 0.50073] }, "Main-Bold": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0, 0, 0.35], "34": [0, 0.69444, 0, 0, 0.60278], "35": [0.19444, 0.69444, 0, 0, 0.95833], "36": [0.05556, 0.75, 0, 0, 0.575], "37": [0.05556, 0.75, 0, 0, 0.95833], "38": [0, 0.69444, 0, 0, 0.89444], "39": [0, 0.69444, 0, 0, 0.31944], "40": [0.25, 0.75, 0, 0, 0.44722], "41": [0.25, 0.75, 0, 0, 0.44722], "42": [0, 0.75, 0, 0, 0.575], "43": [0.13333, 0.63333, 0, 0, 0.89444], "44": [0.19444, 0.15556, 0, 0, 0.31944], "45": [0, 0.44444, 0, 0, 0.38333], "46": [0, 0.15556, 0, 0, 0.31944], "47": [0.25, 0.75, 0, 0, 0.575], "48": [0, 0.64444, 0, 0, 0.575], "49": [0, 0.64444, 0, 0, 0.575], "50": [0, 0.64444, 0, 0, 0.575], "51": [0, 0.64444, 0, 0, 0.575], "52": [0, 0.64444, 0, 0, 0.575], "53": [0, 0.64444, 0, 0, 0.575], "54": [0, 0.64444, 0, 0, 0.575], "55": [0, 0.64444, 0, 0, 0.575], "56": [0, 0.64444, 0, 0, 0.575], "57": [0, 0.64444, 0, 0, 0.575], "58": [0, 0.44444, 0, 0, 0.31944], "59": [0.19444, 0.44444, 0, 0, 0.31944], "60": [0.08556, 0.58556, 0, 0, 0.89444], "61": [-0.10889, 0.39111, 0, 0, 0.89444], "62": [0.08556, 0.58556, 0, 0, 0.89444], "63": [0, 0.69444, 0, 0, 0.54305], "64": [0, 0.69444, 0, 0, 0.89444], "65": [0, 0.68611, 0, 0, 0.86944], "66": [0, 0.68611, 0, 0, 0.81805], "67": [0, 0.68611, 0, 0, 0.83055], "68": [0, 0.68611, 0, 0, 0.88194], "69": [0, 0.68611, 0, 0, 0.75555], "70": [0, 0.68611, 0, 0, 0.72361], "71": [0, 0.68611, 0, 0, 0.90416], "72": [0, 0.68611, 0, 0, 0.9], "73": [0, 0.68611, 0, 0, 0.43611], "74": [0, 0.68611, 0, 0, 0.59444], "75": [0, 0.68611, 0, 0, 0.90138], "76": [0, 0.68611, 0, 0, 0.69166], "77": [0, 0.68611, 0, 0, 1.09166], "78": [0, 0.68611, 0, 0, 0.9], "79": [0, 0.68611, 0, 0, 0.86388], "80": [0, 0.68611, 0, 0, 0.78611], "81": [0.19444, 0.68611, 0, 0, 0.86388], "82": [0, 0.68611, 0, 0, 0.8625], "83": [0, 0.68611, 0, 0, 0.63889], "84": [0, 0.68611, 0, 0, 0.8], "85": [0, 0.68611, 0, 0, 0.88472], "86": [0, 0.68611, 0.01597, 0, 0.86944], "87": [0, 0.68611, 0.01597, 0, 1.18888], "88": [0, 0.68611, 0, 0, 0.86944], "89": [0, 0.68611, 0.02875, 0, 0.86944], "90": [0, 0.68611, 0, 0, 0.70277], "91": [0.25, 0.75, 0, 0, 0.31944], "92": [0.25, 0.75, 0, 0, 0.575], "93": [0.25, 0.75, 0, 0, 0.31944], "94": [0, 0.69444, 0, 0, 0.575], "95": [0.31, 0.13444, 0.03194, 0, 0.575], "97": [0, 0.44444, 0, 0, 0.55902], "98": [0, 0.69444, 0, 0, 0.63889], "99": [0, 0.44444, 0, 0, 0.51111], "100": [0, 0.69444, 0, 0, 0.63889], "101": [0, 0.44444, 0, 0, 0.52708], "102": [0, 0.69444, 0.10903, 0, 0.35139], "103": [0.19444, 0.44444, 0.01597, 0, 0.575], "104": [0, 0.69444, 0, 0, 0.63889], "105": [0, 0.69444, 0, 0, 0.31944], "106": [0.19444, 0.69444, 0, 0, 0.35139], "107": [0, 0.69444, 0, 0, 0.60694], "108": [0, 0.69444, 0, 0, 0.31944], "109": [0, 0.44444, 0, 0, 0.95833], "110": [0, 0.44444, 0, 0, 0.63889], "111": [0, 0.44444, 0, 0, 0.575], "112": [0.19444, 0.44444, 0, 0, 0.63889], "113": [0.19444, 0.44444, 0, 0, 0.60694], "114": [0, 0.44444, 0, 0, 0.47361], "115": [0, 0.44444, 0, 0, 0.45361], "116": [0, 0.63492, 0, 0, 0.44722], "117": [0, 0.44444, 0, 0, 0.63889], "118": [0, 0.44444, 0.01597, 0, 0.60694], "119": [0, 0.44444, 0.01597, 0, 0.83055], "120": [0, 0.44444, 0, 0, 0.60694], "121": [0.19444, 0.44444, 0.01597, 0, 0.60694], "122": [0, 0.44444, 0, 0, 0.51111], "123": [0.25, 0.75, 0, 0, 0.575], "124": [0.25, 0.75, 0, 0, 0.31944], "125": [0.25, 0.75, 0, 0, 0.575], "126": [0.35, 0.34444, 0, 0, 0.575], "160": [0, 0, 0, 0, 0.25], "163": [0, 0.69444, 0, 0, 0.86853], "168": [0, 0.69444, 0, 0, 0.575], "172": [0, 0.44444, 0, 0, 0.76666], "176": [0, 0.69444, 0, 0, 0.86944], "177": [0.13333, 0.63333, 0, 0, 0.89444], "184": [0.17014, 0, 0, 0, 0.51111], "198": [0, 0.68611, 0, 0, 1.04166], "215": [0.13333, 0.63333, 0, 0, 0.89444], "216": [0.04861, 0.73472, 0, 0, 0.89444], "223": [0, 0.69444, 0, 0, 0.59722], "230": [0, 0.44444, 0, 0, 0.83055], "247": [0.13333, 0.63333, 0, 0, 0.89444], "248": [0.09722, 0.54167, 0, 0, 0.575], "305": [0, 0.44444, 0, 0, 0.31944], "338": [0, 0.68611, 0, 0, 1.16944], "339": [0, 0.44444, 0, 0, 0.89444], "567": [0.19444, 0.44444, 0, 0, 0.35139], "710": [0, 0.69444, 0, 0, 0.575], "711": [0, 0.63194, 0, 0, 0.575], "713": [0, 0.59611, 0, 0, 0.575], "714": [0, 0.69444, 0, 0, 0.575], "715": [0, 0.69444, 0, 0, 0.575], "728": [0, 0.69444, 0, 0, 0.575], "729": [0, 0.69444, 0, 0, 0.31944], "730": [0, 0.69444, 0, 0, 0.86944], "732": [0, 0.69444, 0, 0, 0.575], "733": [0, 0.69444, 0, 0, 0.575], "915": [0, 0.68611, 0, 0, 0.69166], "916": [0, 0.68611, 0, 0, 0.95833], "920": [0, 0.68611, 0, 0, 0.89444], "923": [0, 0.68611, 0, 0, 0.80555], "926": [0, 0.68611, 0, 0, 0.76666], "928": [0, 0.68611, 0, 0, 0.9], "931": [0, 0.68611, 0, 0, 0.83055], "933": [0, 0.68611, 0, 0, 0.89444], "934": [0, 0.68611, 0, 0, 0.83055], "936": [0, 0.68611, 0, 0, 0.89444], "937": [0, 0.68611, 0, 0, 0.83055], "8211": [0, 0.44444, 0.03194, 0, 0.575], "8212": [0, 0.44444, 0.03194, 0, 1.14999], "8216": [0, 0.69444, 0, 0, 0.31944], "8217": [0, 0.69444, 0, 0, 0.31944], "8220": [0, 0.69444, 0, 0, 0.60278], "8221": [0, 0.69444, 0, 0, 0.60278], "8224": [0.19444, 0.69444, 0, 0, 0.51111], "8225": [0.19444, 0.69444, 0, 0, 0.51111], "8242": [0, 0.55556, 0, 0, 0.34444], "8407": [0, 0.72444, 0.15486, 0, 0.575], "8463": [0, 0.69444, 0, 0, 0.66759], "8465": [0, 0.69444, 0, 0, 0.83055], "8467": [0, 0.69444, 0, 0, 0.47361], "8472": [0.19444, 0.44444, 0, 0, 0.74027], "8476": [0, 0.69444, 0, 0, 0.83055], "8501": [0, 0.69444, 0, 0, 0.70277], "8592": [-0.10889, 0.39111, 0, 0, 1.14999], "8593": [0.19444, 0.69444, 0, 0, 0.575], "8594": [-0.10889, 0.39111, 0, 0, 1.14999], "8595": [0.19444, 0.69444, 0, 0, 0.575], "8596": [-0.10889, 0.39111, 0, 0, 1.14999], "8597": [0.25, 0.75, 0, 0, 0.575], "8598": [0.19444, 0.69444, 0, 0, 1.14999], "8599": [0.19444, 0.69444, 0, 0, 1.14999], "8600": [0.19444, 0.69444, 0, 0, 1.14999], "8601": [0.19444, 0.69444, 0, 0, 1.14999], "8636": [-0.10889, 0.39111, 0, 0, 1.14999], "8637": [-0.10889, 0.39111, 0, 0, 1.14999], "8640": [-0.10889, 0.39111, 0, 0, 1.14999], "8641": [-0.10889, 0.39111, 0, 0, 1.14999], "8656": [-0.10889, 0.39111, 0, 0, 1.14999], "8657": [0.19444, 0.69444, 0, 0, 0.70277], "8658": [-0.10889, 0.39111, 0, 0, 1.14999], "8659": [0.19444, 0.69444, 0, 0, 0.70277], "8660": [-0.10889, 0.39111, 0, 0, 1.14999], "8661": [0.25, 0.75, 0, 0, 0.70277], "8704": [0, 0.69444, 0, 0, 0.63889], "8706": [0, 0.69444, 0.06389, 0, 0.62847], "8707": [0, 0.69444, 0, 0, 0.63889], "8709": [0.05556, 0.75, 0, 0, 0.575], "8711": [0, 0.68611, 0, 0, 0.95833], "8712": [0.08556, 0.58556, 0, 0, 0.76666], "8715": [0.08556, 0.58556, 0, 0, 0.76666], "8722": [0.13333, 0.63333, 0, 0, 0.89444], "8723": [0.13333, 0.63333, 0, 0, 0.89444], "8725": [0.25, 0.75, 0, 0, 0.575], "8726": [0.25, 0.75, 0, 0, 0.575], "8727": [-0.02778, 0.47222, 0, 0, 0.575], "8728": [-0.02639, 0.47361, 0, 0, 0.575], "8729": [-0.02639, 0.47361, 0, 0, 0.575], "8730": [0.18, 0.82, 0, 0, 0.95833], "8733": [0, 0.44444, 0, 0, 0.89444], "8734": [0, 0.44444, 0, 0, 1.14999], "8736": [0, 0.69224, 0, 0, 0.72222], "8739": [0.25, 0.75, 0, 0, 0.31944], "8741": [0.25, 0.75, 0, 0, 0.575], "8743": [0, 0.55556, 0, 0, 0.76666], "8744": [0, 0.55556, 0, 0, 0.76666], "8745": [0, 0.55556, 0, 0, 0.76666], "8746": [0, 0.55556, 0, 0, 0.76666], "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875], "8764": [-0.10889, 0.39111, 0, 0, 0.89444], "8768": [0.19444, 0.69444, 0, 0, 0.31944], "8771": [222e-5, 0.50222, 0, 0, 0.89444], "8776": [0.02444, 0.52444, 0, 0, 0.89444], "8781": [222e-5, 0.50222, 0, 0, 0.89444], "8801": [222e-5, 0.50222, 0, 0, 0.89444], "8804": [0.19667, 0.69667, 0, 0, 0.89444], "8805": [0.19667, 0.69667, 0, 0, 0.89444], "8810": [0.08556, 0.58556, 0, 0, 1.14999], "8811": [0.08556, 0.58556, 0, 0, 1.14999], "8826": [0.08556, 0.58556, 0, 0, 0.89444], "8827": [0.08556, 0.58556, 0, 0, 0.89444], "8834": [0.08556, 0.58556, 0, 0, 0.89444], "8835": [0.08556, 0.58556, 0, 0, 0.89444], "8838": [0.19667, 0.69667, 0, 0, 0.89444], "8839": [0.19667, 0.69667, 0, 0, 0.89444], "8846": [0, 0.55556, 0, 0, 0.76666], "8849": [0.19667, 0.69667, 0, 0, 0.89444], "8850": [0.19667, 0.69667, 0, 0, 0.89444], "8851": [0, 0.55556, 0, 0, 0.76666], "8852": [0, 0.55556, 0, 0, 0.76666], "8853": [0.13333, 0.63333, 0, 0, 0.89444], "8854": [0.13333, 0.63333, 0, 0, 0.89444], "8855": [0.13333, 0.63333, 0, 0, 0.89444], "8856": [0.13333, 0.63333, 0, 0, 0.89444], "8857": [0.13333, 0.63333, 0, 0, 0.89444], "8866": [0, 0.69444, 0, 0, 0.70277], "8867": [0, 0.69444, 0, 0, 0.70277], "8868": [0, 0.69444, 0, 0, 0.89444], "8869": [0, 0.69444, 0, 0, 0.89444], "8900": [-0.02639, 0.47361, 0, 0, 0.575], "8901": [-0.02639, 0.47361, 0, 0, 0.31944], "8902": [-0.02778, 0.47222, 0, 0, 0.575], "8968": [0.25, 0.75, 0, 0, 0.51111], "8969": [0.25, 0.75, 0, 0, 0.51111], "8970": [0.25, 0.75, 0, 0, 0.51111], "8971": [0.25, 0.75, 0, 0, 0.51111], "8994": [-0.13889, 0.36111, 0, 0, 1.14999], "8995": [-0.13889, 0.36111, 0, 0, 1.14999], "9651": [0.19444, 0.69444, 0, 0, 1.02222], "9657": [-0.02778, 0.47222, 0, 0, 0.575], "9661": [0.19444, 0.69444, 0, 0, 1.02222], "9667": [-0.02778, 0.47222, 0, 0, 0.575], "9711": [0.19444, 0.69444, 0, 0, 1.14999], "9824": [0.12963, 0.69444, 0, 0, 0.89444], "9825": [0.12963, 0.69444, 0, 0, 0.89444], "9826": [0.12963, 0.69444, 0, 0, 0.89444], "9827": [0.12963, 0.69444, 0, 0, 0.89444], "9837": [0, 0.75, 0, 0, 0.44722], "9838": [0.19444, 0.69444, 0, 0, 0.44722], "9839": [0.19444, 0.69444, 0, 0, 0.44722], "10216": [0.25, 0.75, 0, 0, 0.44722], "10217": [0.25, 0.75, 0, 0, 0.44722], "10815": [0, 0.68611, 0, 0, 0.9], "10927": [0.19667, 0.69667, 0, 0, 0.89444], "10928": [0.19667, 0.69667, 0, 0, 0.89444], "57376": [0.19444, 0.69444, 0, 0, 0] }, "Main-BoldItalic": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0.11417, 0, 0.38611], "34": [0, 0.69444, 0.07939, 0, 0.62055], "35": [0.19444, 0.69444, 0.06833, 0, 0.94444], "37": [0.05556, 0.75, 0.12861, 0, 0.94444], "38": [0, 0.69444, 0.08528, 0, 0.88555], "39": [0, 0.69444, 0.12945, 0, 0.35555], "40": [0.25, 0.75, 0.15806, 0, 0.47333], "41": [0.25, 0.75, 0.03306, 0, 0.47333], "42": [0, 0.75, 0.14333, 0, 0.59111], "43": [0.10333, 0.60333, 0.03306, 0, 0.88555], "44": [0.19444, 0.14722, 0, 0, 0.35555], "45": [0, 0.44444, 0.02611, 0, 0.41444], "46": [0, 0.14722, 0, 0, 0.35555], "47": [0.25, 0.75, 0.15806, 0, 0.59111], "48": [0, 0.64444, 0.13167, 0, 0.59111], "49": [0, 0.64444, 0.13167, 0, 0.59111], "50": [0, 0.64444, 0.13167, 0, 0.59111], "51": [0, 0.64444, 0.13167, 0, 0.59111], "52": [0.19444, 0.64444, 0.13167, 0, 0.59111], "53": [0, 0.64444, 0.13167, 0, 0.59111], "54": [0, 0.64444, 0.13167, 0, 0.59111], "55": [0.19444, 0.64444, 0.13167, 0, 0.59111], "56": [0, 0.64444, 0.13167, 0, 0.59111], "57": [0, 0.64444, 0.13167, 0, 0.59111], "58": [0, 0.44444, 0.06695, 0, 0.35555], "59": [0.19444, 0.44444, 0.06695, 0, 0.35555], "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555], "63": [0, 0.69444, 0.11472, 0, 0.59111], "64": [0, 0.69444, 0.09208, 0, 0.88555], "65": [0, 0.68611, 0, 0, 0.86555], "66": [0, 0.68611, 0.0992, 0, 0.81666], "67": [0, 0.68611, 0.14208, 0, 0.82666], "68": [0, 0.68611, 0.09062, 0, 0.87555], "69": [0, 0.68611, 0.11431, 0, 0.75666], "70": [0, 0.68611, 0.12903, 0, 0.72722], "71": [0, 0.68611, 0.07347, 0, 0.89527], "72": [0, 0.68611, 0.17208, 0, 0.8961], "73": [0, 0.68611, 0.15681, 0, 0.47166], "74": [0, 0.68611, 0.145, 0, 0.61055], "75": [0, 0.68611, 0.14208, 0, 0.89499], "76": [0, 0.68611, 0, 0, 0.69777], "77": [0, 0.68611, 0.17208, 0, 1.07277], "78": [0, 0.68611, 0.17208, 0, 0.8961], "79": [0, 0.68611, 0.09062, 0, 0.85499], "80": [0, 0.68611, 0.0992, 0, 0.78721], "81": [0.19444, 0.68611, 0.09062, 0, 0.85499], "82": [0, 0.68611, 0.02559, 0, 0.85944], "83": [0, 0.68611, 0.11264, 0, 0.64999], "84": [0, 0.68611, 0.12903, 0, 0.7961], "85": [0, 0.68611, 0.17208, 0, 0.88083], "86": [0, 0.68611, 0.18625, 0, 0.86555], "87": [0, 0.68611, 0.18625, 0, 1.15999], "88": [0, 0.68611, 0.15681, 0, 0.86555], "89": [0, 0.68611, 0.19803, 0, 0.86555], "90": [0, 0.68611, 0.14208, 0, 0.70888], "91": [0.25, 0.75, 0.1875, 0, 0.35611], "93": [0.25, 0.75, 0.09972, 0, 0.35611], "94": [0, 0.69444, 0.06709, 0, 0.59111], "95": [0.31, 0.13444, 0.09811, 0, 0.59111], "97": [0, 0.44444, 0.09426, 0, 0.59111], "98": [0, 0.69444, 0.07861, 0, 0.53222], "99": [0, 0.44444, 0.05222, 0, 0.53222], "100": [0, 0.69444, 0.10861, 0, 0.59111], "101": [0, 0.44444, 0.085, 0, 0.53222], "102": [0.19444, 0.69444, 0.21778, 0, 0.4], "103": [0.19444, 0.44444, 0.105, 0, 0.53222], "104": [0, 0.69444, 0.09426, 0, 0.59111], "105": [0, 0.69326, 0.11387, 0, 0.35555], "106": [0.19444, 0.69326, 0.1672, 0, 0.35555], "107": [0, 0.69444, 0.11111, 0, 0.53222], "108": [0, 0.69444, 0.10861, 0, 0.29666], "109": [0, 0.44444, 0.09426, 0, 0.94444], "110": [0, 0.44444, 0.09426, 0, 0.64999], "111": [0, 0.44444, 0.07861, 0, 0.59111], "112": [0.19444, 0.44444, 0.07861, 0, 0.59111], "113": [0.19444, 0.44444, 0.105, 0, 0.53222], "114": [0, 0.44444, 0.11111, 0, 0.50167], "115": [0, 0.44444, 0.08167, 0, 0.48694], "116": [0, 0.63492, 0.09639, 0, 0.385], "117": [0, 0.44444, 0.09426, 0, 0.62055], "118": [0, 0.44444, 0.11111, 0, 0.53222], "119": [0, 0.44444, 0.11111, 0, 0.76777], "120": [0, 0.44444, 0.12583, 0, 0.56055], "121": [0.19444, 0.44444, 0.105, 0, 0.56166], "122": [0, 0.44444, 0.13889, 0, 0.49055], "126": [0.35, 0.34444, 0.11472, 0, 0.59111], "160": [0, 0, 0, 0, 0.25], "168": [0, 0.69444, 0.11473, 0, 0.59111], "176": [0, 0.69444, 0, 0, 0.94888], "184": [0.17014, 0, 0, 0, 0.53222], "198": [0, 0.68611, 0.11431, 0, 1.02277], "216": [0.04861, 0.73472, 0.09062, 0, 0.88555], "223": [0.19444, 0.69444, 0.09736, 0, 0.665], "230": [0, 0.44444, 0.085, 0, 0.82666], "248": [0.09722, 0.54167, 0.09458, 0, 0.59111], "305": [0, 0.44444, 0.09426, 0, 0.35555], "338": [0, 0.68611, 0.11431, 0, 1.14054], "339": [0, 0.44444, 0.085, 0, 0.82666], "567": [0.19444, 0.44444, 0.04611, 0, 0.385], "710": [0, 0.69444, 0.06709, 0, 0.59111], "711": [0, 0.63194, 0.08271, 0, 0.59111], "713": [0, 0.59444, 0.10444, 0, 0.59111], "714": [0, 0.69444, 0.08528, 0, 0.59111], "715": [0, 0.69444, 0, 0, 0.59111], "728": [0, 0.69444, 0.10333, 0, 0.59111], "729": [0, 0.69444, 0.12945, 0, 0.35555], "730": [0, 0.69444, 0, 0, 0.94888], "732": [0, 0.69444, 0.11472, 0, 0.59111], "733": [0, 0.69444, 0.11472, 0, 0.59111], "915": [0, 0.68611, 0.12903, 0, 0.69777], "916": [0, 0.68611, 0, 0, 0.94444], "920": [0, 0.68611, 0.09062, 0, 0.88555], "923": [0, 0.68611, 0, 0, 0.80666], "926": [0, 0.68611, 0.15092, 0, 0.76777], "928": [0, 0.68611, 0.17208, 0, 0.8961], "931": [0, 0.68611, 0.11431, 0, 0.82666], "933": [0, 0.68611, 0.10778, 0, 0.88555], "934": [0, 0.68611, 0.05632, 0, 0.82666], "936": [0, 0.68611, 0.10778, 0, 0.88555], "937": [0, 0.68611, 0.0992, 0, 0.82666], "8211": [0, 0.44444, 0.09811, 0, 0.59111], "8212": [0, 0.44444, 0.09811, 0, 1.18221], "8216": [0, 0.69444, 0.12945, 0, 0.35555], "8217": [0, 0.69444, 0.12945, 0, 0.35555], "8220": [0, 0.69444, 0.16772, 0, 0.62055], "8221": [0, 0.69444, 0.07939, 0, 0.62055] }, "Main-Italic": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0.12417, 0, 0.30667], "34": [0, 0.69444, 0.06961, 0, 0.51444], "35": [0.19444, 0.69444, 0.06616, 0, 0.81777], "37": [0.05556, 0.75, 0.13639, 0, 0.81777], "38": [0, 0.69444, 0.09694, 0, 0.76666], "39": [0, 0.69444, 0.12417, 0, 0.30667], "40": [0.25, 0.75, 0.16194, 0, 0.40889], "41": [0.25, 0.75, 0.03694, 0, 0.40889], "42": [0, 0.75, 0.14917, 0, 0.51111], "43": [0.05667, 0.56167, 0.03694, 0, 0.76666], "44": [0.19444, 0.10556, 0, 0, 0.30667], "45": [0, 0.43056, 0.02826, 0, 0.35778], "46": [0, 0.10556, 0, 0, 0.30667], "47": [0.25, 0.75, 0.16194, 0, 0.51111], "48": [0, 0.64444, 0.13556, 0, 0.51111], "49": [0, 0.64444, 0.13556, 0, 0.51111], "50": [0, 0.64444, 0.13556, 0, 0.51111], "51": [0, 0.64444, 0.13556, 0, 0.51111], "52": [0.19444, 0.64444, 0.13556, 0, 0.51111], "53": [0, 0.64444, 0.13556, 0, 0.51111], "54": [0, 0.64444, 0.13556, 0, 0.51111], "55": [0.19444, 0.64444, 0.13556, 0, 0.51111], "56": [0, 0.64444, 0.13556, 0, 0.51111], "57": [0, 0.64444, 0.13556, 0, 0.51111], "58": [0, 0.43056, 0.0582, 0, 0.30667], "59": [0.19444, 0.43056, 0.0582, 0, 0.30667], "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666], "63": [0, 0.69444, 0.1225, 0, 0.51111], "64": [0, 0.69444, 0.09597, 0, 0.76666], "65": [0, 0.68333, 0, 0, 0.74333], "66": [0, 0.68333, 0.10257, 0, 0.70389], "67": [0, 0.68333, 0.14528, 0, 0.71555], "68": [0, 0.68333, 0.09403, 0, 0.755], "69": [0, 0.68333, 0.12028, 0, 0.67833], "70": [0, 0.68333, 0.13305, 0, 0.65277], "71": [0, 0.68333, 0.08722, 0, 0.77361], "72": [0, 0.68333, 0.16389, 0, 0.74333], "73": [0, 0.68333, 0.15806, 0, 0.38555], "74": [0, 0.68333, 0.14028, 0, 0.525], "75": [0, 0.68333, 0.14528, 0, 0.76888], "76": [0, 0.68333, 0, 0, 0.62722], "77": [0, 0.68333, 0.16389, 0, 0.89666], "78": [0, 0.68333, 0.16389, 0, 0.74333], "79": [0, 0.68333, 0.09403, 0, 0.76666], "80": [0, 0.68333, 0.10257, 0, 0.67833], "81": [0.19444, 0.68333, 0.09403, 0, 0.76666], "82": [0, 0.68333, 0.03868, 0, 0.72944], "83": [0, 0.68333, 0.11972, 0, 0.56222], "84": [0, 0.68333, 0.13305, 0, 0.71555], "85": [0, 0.68333, 0.16389, 0, 0.74333], "86": [0, 0.68333, 0.18361, 0, 0.74333], "87": [0, 0.68333, 0.18361, 0, 0.99888], "88": [0, 0.68333, 0.15806, 0, 0.74333], "89": [0, 0.68333, 0.19383, 0, 0.74333], "90": [0, 0.68333, 0.14528, 0, 0.61333], "91": [0.25, 0.75, 0.1875, 0, 0.30667], "93": [0.25, 0.75, 0.10528, 0, 0.30667], "94": [0, 0.69444, 0.06646, 0, 0.51111], "95": [0.31, 0.12056, 0.09208, 0, 0.51111], "97": [0, 0.43056, 0.07671, 0, 0.51111], "98": [0, 0.69444, 0.06312, 0, 0.46], "99": [0, 0.43056, 0.05653, 0, 0.46], "100": [0, 0.69444, 0.10333, 0, 0.51111], "101": [0, 0.43056, 0.07514, 0, 0.46], "102": [0.19444, 0.69444, 0.21194, 0, 0.30667], "103": [0.19444, 0.43056, 0.08847, 0, 0.46], "104": [0, 0.69444, 0.07671, 0, 0.51111], "105": [0, 0.65536, 0.1019, 0, 0.30667], "106": [0.19444, 0.65536, 0.14467, 0, 0.30667], "107": [0, 0.69444, 0.10764, 0, 0.46], "108": [0, 0.69444, 0.10333, 0, 0.25555], "109": [0, 0.43056, 0.07671, 0, 0.81777], "110": [0, 0.43056, 0.07671, 0, 0.56222], "111": [0, 0.43056, 0.06312, 0, 0.51111], "112": [0.19444, 0.43056, 0.06312, 0, 0.51111], "113": [0.19444, 0.43056, 0.08847, 0, 0.46], "114": [0, 0.43056, 0.10764, 0, 0.42166], "115": [0, 0.43056, 0.08208, 0, 0.40889], "116": [0, 0.61508, 0.09486, 0, 0.33222], "117": [0, 0.43056, 0.07671, 0, 0.53666], "118": [0, 0.43056, 0.10764, 0, 0.46], "119": [0, 0.43056, 0.10764, 0, 0.66444], "120": [0, 0.43056, 0.12042, 0, 0.46389], "121": [0.19444, 0.43056, 0.08847, 0, 0.48555], "122": [0, 0.43056, 0.12292, 0, 0.40889], "126": [0.35, 0.31786, 0.11585, 0, 0.51111], "160": [0, 0, 0, 0, 0.25], "168": [0, 0.66786, 0.10474, 0, 0.51111], "176": [0, 0.69444, 0, 0, 0.83129], "184": [0.17014, 0, 0, 0, 0.46], "198": [0, 0.68333, 0.12028, 0, 0.88277], "216": [0.04861, 0.73194, 0.09403, 0, 0.76666], "223": [0.19444, 0.69444, 0.10514, 0, 0.53666], "230": [0, 0.43056, 0.07514, 0, 0.71555], "248": [0.09722, 0.52778, 0.09194, 0, 0.51111], "338": [0, 0.68333, 0.12028, 0, 0.98499], "339": [0, 0.43056, 0.07514, 0, 0.71555], "710": [0, 0.69444, 0.06646, 0, 0.51111], "711": [0, 0.62847, 0.08295, 0, 0.51111], "713": [0, 0.56167, 0.10333, 0, 0.51111], "714": [0, 0.69444, 0.09694, 0, 0.51111], "715": [0, 0.69444, 0, 0, 0.51111], "728": [0, 0.69444, 0.10806, 0, 0.51111], "729": [0, 0.66786, 0.11752, 0, 0.30667], "730": [0, 0.69444, 0, 0, 0.83129], "732": [0, 0.66786, 0.11585, 0, 0.51111], "733": [0, 0.69444, 0.1225, 0, 0.51111], "915": [0, 0.68333, 0.13305, 0, 0.62722], "916": [0, 0.68333, 0, 0, 0.81777], "920": [0, 0.68333, 0.09403, 0, 0.76666], "923": [0, 0.68333, 0, 0, 0.69222], "926": [0, 0.68333, 0.15294, 0, 0.66444], "928": [0, 0.68333, 0.16389, 0, 0.74333], "931": [0, 0.68333, 0.12028, 0, 0.71555], "933": [0, 0.68333, 0.11111, 0, 0.76666], "934": [0, 0.68333, 0.05986, 0, 0.71555], "936": [0, 0.68333, 0.11111, 0, 0.76666], "937": [0, 0.68333, 0.10257, 0, 0.71555], "8211": [0, 0.43056, 0.09208, 0, 0.51111], "8212": [0, 0.43056, 0.09208, 0, 1.02222], "8216": [0, 0.69444, 0.12417, 0, 0.30667], "8217": [0, 0.69444, 0.12417, 0, 0.30667], "8220": [0, 0.69444, 0.1685, 0, 0.51444], "8221": [0, 0.69444, 0.06961, 0, 0.51444], "8463": [0, 0.68889, 0, 0, 0.54028] }, "Main-Regular": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0, 0, 0.27778], "34": [0, 0.69444, 0, 0, 0.5], "35": [0.19444, 0.69444, 0, 0, 0.83334], "36": [0.05556, 0.75, 0, 0, 0.5], "37": [0.05556, 0.75, 0, 0, 0.83334], "38": [0, 0.69444, 0, 0, 0.77778], "39": [0, 0.69444, 0, 0, 0.27778], "40": [0.25, 0.75, 0, 0, 0.38889], "41": [0.25, 0.75, 0, 0, 0.38889], "42": [0, 0.75, 0, 0, 0.5], "43": [0.08333, 0.58333, 0, 0, 0.77778], "44": [0.19444, 0.10556, 0, 0, 0.27778], "45": [0, 0.43056, 0, 0, 0.33333], "46": [0, 0.10556, 0, 0, 0.27778], "47": [0.25, 0.75, 0, 0, 0.5], "48": [0, 0.64444, 0, 0, 0.5], "49": [0, 0.64444, 0, 0, 0.5], "50": [0, 0.64444, 0, 0, 0.5], "51": [0, 0.64444, 0, 0, 0.5], "52": [0, 0.64444, 0, 0, 0.5], "53": [0, 0.64444, 0, 0, 0.5], "54": [0, 0.64444, 0, 0, 0.5], "55": [0, 0.64444, 0, 0, 0.5], "56": [0, 0.64444, 0, 0, 0.5], "57": [0, 0.64444, 0, 0, 0.5], "58": [0, 0.43056, 0, 0, 0.27778], "59": [0.19444, 0.43056, 0, 0, 0.27778], "60": [0.0391, 0.5391, 0, 0, 0.77778], "61": [-0.13313, 0.36687, 0, 0, 0.77778], "62": [0.0391, 0.5391, 0, 0, 0.77778], "63": [0, 0.69444, 0, 0, 0.47222], "64": [0, 0.69444, 0, 0, 0.77778], "65": [0, 0.68333, 0, 0, 0.75], "66": [0, 0.68333, 0, 0, 0.70834], "67": [0, 0.68333, 0, 0, 0.72222], "68": [0, 0.68333, 0, 0, 0.76389], "69": [0, 0.68333, 0, 0, 0.68056], "70": [0, 0.68333, 0, 0, 0.65278], "71": [0, 0.68333, 0, 0, 0.78472], "72": [0, 0.68333, 0, 0, 0.75], "73": [0, 0.68333, 0, 0, 0.36111], "74": [0, 0.68333, 0, 0, 0.51389], "75": [0, 0.68333, 0, 0, 0.77778], "76": [0, 0.68333, 0, 0, 0.625], "77": [0, 0.68333, 0, 0, 0.91667], "78": [0, 0.68333, 0, 0, 0.75], "79": [0, 0.68333, 0, 0, 0.77778], "80": [0, 0.68333, 0, 0, 0.68056], "81": [0.19444, 0.68333, 0, 0, 0.77778], "82": [0, 0.68333, 0, 0, 0.73611], "83": [0, 0.68333, 0, 0, 0.55556], "84": [0, 0.68333, 0, 0, 0.72222], "85": [0, 0.68333, 0, 0, 0.75], "86": [0, 0.68333, 0.01389, 0, 0.75], "87": [0, 0.68333, 0.01389, 0, 1.02778], "88": [0, 0.68333, 0, 0, 0.75], "89": [0, 0.68333, 0.025, 0, 0.75], "90": [0, 0.68333, 0, 0, 0.61111], "91": [0.25, 0.75, 0, 0, 0.27778], "92": [0.25, 0.75, 0, 0, 0.5], "93": [0.25, 0.75, 0, 0, 0.27778], "94": [0, 0.69444, 0, 0, 0.5], "95": [0.31, 0.12056, 0.02778, 0, 0.5], "97": [0, 0.43056, 0, 0, 0.5], "98": [0, 0.69444, 0, 0, 0.55556], "99": [0, 0.43056, 0, 0, 0.44445], "100": [0, 0.69444, 0, 0, 0.55556], "101": [0, 0.43056, 0, 0, 0.44445], "102": [0, 0.69444, 0.07778, 0, 0.30556], "103": [0.19444, 0.43056, 0.01389, 0, 0.5], "104": [0, 0.69444, 0, 0, 0.55556], "105": [0, 0.66786, 0, 0, 0.27778], "106": [0.19444, 0.66786, 0, 0, 0.30556], "107": [0, 0.69444, 0, 0, 0.52778], "108": [0, 0.69444, 0, 0, 0.27778], "109": [0, 0.43056, 0, 0, 0.83334], "110": [0, 0.43056, 0, 0, 0.55556], "111": [0, 0.43056, 0, 0, 0.5], "112": [0.19444, 0.43056, 0, 0, 0.55556], "113": [0.19444, 0.43056, 0, 0, 0.52778], "114": [0, 0.43056, 0, 0, 0.39167], "115": [0, 0.43056, 0, 0, 0.39445], "116": [0, 0.61508, 0, 0, 0.38889], "117": [0, 0.43056, 0, 0, 0.55556], "118": [0, 0.43056, 0.01389, 0, 0.52778], "119": [0, 0.43056, 0.01389, 0, 0.72222], "120": [0, 0.43056, 0, 0, 0.52778], "121": [0.19444, 0.43056, 0.01389, 0, 0.52778], "122": [0, 0.43056, 0, 0, 0.44445], "123": [0.25, 0.75, 0, 0, 0.5], "124": [0.25, 0.75, 0, 0, 0.27778], "125": [0.25, 0.75, 0, 0, 0.5], "126": [0.35, 0.31786, 0, 0, 0.5], "160": [0, 0, 0, 0, 0.25], "163": [0, 0.69444, 0, 0, 0.76909], "167": [0.19444, 0.69444, 0, 0, 0.44445], "168": [0, 0.66786, 0, 0, 0.5], "172": [0, 0.43056, 0, 0, 0.66667], "176": [0, 0.69444, 0, 0, 0.75], "177": [0.08333, 0.58333, 0, 0, 0.77778], "182": [0.19444, 0.69444, 0, 0, 0.61111], "184": [0.17014, 0, 0, 0, 0.44445], "198": [0, 0.68333, 0, 0, 0.90278], "215": [0.08333, 0.58333, 0, 0, 0.77778], "216": [0.04861, 0.73194, 0, 0, 0.77778], "223": [0, 0.69444, 0, 0, 0.5], "230": [0, 0.43056, 0, 0, 0.72222], "247": [0.08333, 0.58333, 0, 0, 0.77778], "248": [0.09722, 0.52778, 0, 0, 0.5], "305": [0, 0.43056, 0, 0, 0.27778], "338": [0, 0.68333, 0, 0, 1.01389], "339": [0, 0.43056, 0, 0, 0.77778], "567": [0.19444, 0.43056, 0, 0, 0.30556], "710": [0, 0.69444, 0, 0, 0.5], "711": [0, 0.62847, 0, 0, 0.5], "713": [0, 0.56778, 0, 0, 0.5], "714": [0, 0.69444, 0, 0, 0.5], "715": [0, 0.69444, 0, 0, 0.5], "728": [0, 0.69444, 0, 0, 0.5], "729": [0, 0.66786, 0, 0, 0.27778], "730": [0, 0.69444, 0, 0, 0.75], "732": [0, 0.66786, 0, 0, 0.5], "733": [0, 0.69444, 0, 0, 0.5], "915": [0, 0.68333, 0, 0, 0.625], "916": [0, 0.68333, 0, 0, 0.83334], "920": [0, 0.68333, 0, 0, 0.77778], "923": [0, 0.68333, 0, 0, 0.69445], "926": [0, 0.68333, 0, 0, 0.66667], "928": [0, 0.68333, 0, 0, 0.75], "931": [0, 0.68333, 0, 0, 0.72222], "933": [0, 0.68333, 0, 0, 0.77778], "934": [0, 0.68333, 0, 0, 0.72222], "936": [0, 0.68333, 0, 0, 0.77778], "937": [0, 0.68333, 0, 0, 0.72222], "8211": [0, 0.43056, 0.02778, 0, 0.5], "8212": [0, 0.43056, 0.02778, 0, 1], "8216": [0, 0.69444, 0, 0, 0.27778], "8217": [0, 0.69444, 0, 0, 0.27778], "8220": [0, 0.69444, 0, 0, 0.5], "8221": [0, 0.69444, 0, 0, 0.5], "8224": [0.19444, 0.69444, 0, 0, 0.44445], "8225": [0.19444, 0.69444, 0, 0, 0.44445], "8230": [0, 0.123, 0, 0, 1.172], "8242": [0, 0.55556, 0, 0, 0.275], "8407": [0, 0.71444, 0.15382, 0, 0.5], "8463": [0, 0.68889, 0, 0, 0.54028], "8465": [0, 0.69444, 0, 0, 0.72222], "8467": [0, 0.69444, 0, 0.11111, 0.41667], "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646], "8476": [0, 0.69444, 0, 0, 0.72222], "8501": [0, 0.69444, 0, 0, 0.61111], "8592": [-0.13313, 0.36687, 0, 0, 1], "8593": [0.19444, 0.69444, 0, 0, 0.5], "8594": [-0.13313, 0.36687, 0, 0, 1], "8595": [0.19444, 0.69444, 0, 0, 0.5], "8596": [-0.13313, 0.36687, 0, 0, 1], "8597": [0.25, 0.75, 0, 0, 0.5], "8598": [0.19444, 0.69444, 0, 0, 1], "8599": [0.19444, 0.69444, 0, 0, 1], "8600": [0.19444, 0.69444, 0, 0, 1], "8601": [0.19444, 0.69444, 0, 0, 1], "8614": [0.011, 0.511, 0, 0, 1], "8617": [0.011, 0.511, 0, 0, 1.126], "8618": [0.011, 0.511, 0, 0, 1.126], "8636": [-0.13313, 0.36687, 0, 0, 1], "8637": [-0.13313, 0.36687, 0, 0, 1], "8640": [-0.13313, 0.36687, 0, 0, 1], "8641": [-0.13313, 0.36687, 0, 0, 1], "8652": [0.011, 0.671, 0, 0, 1], "8656": [-0.13313, 0.36687, 0, 0, 1], "8657": [0.19444, 0.69444, 0, 0, 0.61111], "8658": [-0.13313, 0.36687, 0, 0, 1], "8659": [0.19444, 0.69444, 0, 0, 0.61111], "8660": [-0.13313, 0.36687, 0, 0, 1], "8661": [0.25, 0.75, 0, 0, 0.61111], "8704": [0, 0.69444, 0, 0, 0.55556], "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309], "8707": [0, 0.69444, 0, 0, 0.55556], "8709": [0.05556, 0.75, 0, 0, 0.5], "8711": [0, 0.68333, 0, 0, 0.83334], "8712": [0.0391, 0.5391, 0, 0, 0.66667], "8715": [0.0391, 0.5391, 0, 0, 0.66667], "8722": [0.08333, 0.58333, 0, 0, 0.77778], "8723": [0.08333, 0.58333, 0, 0, 0.77778], "8725": [0.25, 0.75, 0, 0, 0.5], "8726": [0.25, 0.75, 0, 0, 0.5], "8727": [-0.03472, 0.46528, 0, 0, 0.5], "8728": [-0.05555, 0.44445, 0, 0, 0.5], "8729": [-0.05555, 0.44445, 0, 0, 0.5], "8730": [0.2, 0.8, 0, 0, 0.83334], "8733": [0, 0.43056, 0, 0, 0.77778], "8734": [0, 0.43056, 0, 0, 1], "8736": [0, 0.69224, 0, 0, 0.72222], "8739": [0.25, 0.75, 0, 0, 0.27778], "8741": [0.25, 0.75, 0, 0, 0.5], "8743": [0, 0.55556, 0, 0, 0.66667], "8744": [0, 0.55556, 0, 0, 0.66667], "8745": [0, 0.55556, 0, 0, 0.66667], "8746": [0, 0.55556, 0, 0, 0.66667], "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667], "8764": [-0.13313, 0.36687, 0, 0, 0.77778], "8768": [0.19444, 0.69444, 0, 0, 0.27778], "8771": [-0.03625, 0.46375, 0, 0, 0.77778], "8773": [-0.022, 0.589, 0, 0, 1], "8776": [-0.01688, 0.48312, 0, 0, 0.77778], "8781": [-0.03625, 0.46375, 0, 0, 0.77778], "8784": [-0.133, 0.673, 0, 0, 0.778], "8801": [-0.03625, 0.46375, 0, 0, 0.77778], "8804": [0.13597, 0.63597, 0, 0, 0.77778], "8805": [0.13597, 0.63597, 0, 0, 0.77778], "8810": [0.0391, 0.5391, 0, 0, 1], "8811": [0.0391, 0.5391, 0, 0, 1], "8826": [0.0391, 0.5391, 0, 0, 0.77778], "8827": [0.0391, 0.5391, 0, 0, 0.77778], "8834": [0.0391, 0.5391, 0, 0, 0.77778], "8835": [0.0391, 0.5391, 0, 0, 0.77778], "8838": [0.13597, 0.63597, 0, 0, 0.77778], "8839": [0.13597, 0.63597, 0, 0, 0.77778], "8846": [0, 0.55556, 0, 0, 0.66667], "8849": [0.13597, 0.63597, 0, 0, 0.77778], "8850": [0.13597, 0.63597, 0, 0, 0.77778], "8851": [0, 0.55556, 0, 0, 0.66667], "8852": [0, 0.55556, 0, 0, 0.66667], "8853": [0.08333, 0.58333, 0, 0, 0.77778], "8854": [0.08333, 0.58333, 0, 0, 0.77778], "8855": [0.08333, 0.58333, 0, 0, 0.77778], "8856": [0.08333, 0.58333, 0, 0, 0.77778], "8857": [0.08333, 0.58333, 0, 0, 0.77778], "8866": [0, 0.69444, 0, 0, 0.61111], "8867": [0, 0.69444, 0, 0, 0.61111], "8868": [0, 0.69444, 0, 0, 0.77778], "8869": [0, 0.69444, 0, 0, 0.77778], "8872": [0.249, 0.75, 0, 0, 0.867], "8900": [-0.05555, 0.44445, 0, 0, 0.5], "8901": [-0.05555, 0.44445, 0, 0, 0.27778], "8902": [-0.03472, 0.46528, 0, 0, 0.5], "8904": [5e-3, 0.505, 0, 0, 0.9], "8942": [0.03, 0.903, 0, 0, 0.278], "8943": [-0.19, 0.313, 0, 0, 1.172], "8945": [-0.1, 0.823, 0, 0, 1.282], "8968": [0.25, 0.75, 0, 0, 0.44445], "8969": [0.25, 0.75, 0, 0, 0.44445], "8970": [0.25, 0.75, 0, 0, 0.44445], "8971": [0.25, 0.75, 0, 0, 0.44445], "8994": [-0.14236, 0.35764, 0, 0, 1], "8995": [-0.14236, 0.35764, 0, 0, 1], "9136": [0.244, 0.744, 0, 0, 0.412], "9137": [0.244, 0.745, 0, 0, 0.412], "9651": [0.19444, 0.69444, 0, 0, 0.88889], "9657": [-0.03472, 0.46528, 0, 0, 0.5], "9661": [0.19444, 0.69444, 0, 0, 0.88889], "9667": [-0.03472, 0.46528, 0, 0, 0.5], "9711": [0.19444, 0.69444, 0, 0, 1], "9824": [0.12963, 0.69444, 0, 0, 0.77778], "9825": [0.12963, 0.69444, 0, 0, 0.77778], "9826": [0.12963, 0.69444, 0, 0, 0.77778], "9827": [0.12963, 0.69444, 0, 0, 0.77778], "9837": [0, 0.75, 0, 0, 0.38889], "9838": [0.19444, 0.69444, 0, 0, 0.38889], "9839": [0.19444, 0.69444, 0, 0, 0.38889], "10216": [0.25, 0.75, 0, 0, 0.38889], "10217": [0.25, 0.75, 0, 0, 0.38889], "10222": [0.244, 0.744, 0, 0, 0.412], "10223": [0.244, 0.745, 0, 0, 0.412], "10229": [0.011, 0.511, 0, 0, 1.609], "10230": [0.011, 0.511, 0, 0, 1.638], "10231": [0.011, 0.511, 0, 0, 1.859], "10232": [0.024, 0.525, 0, 0, 1.609], "10233": [0.024, 0.525, 0, 0, 1.638], "10234": [0.024, 0.525, 0, 0, 1.858], "10236": [0.011, 0.511, 0, 0, 1.638], "10815": [0, 0.68333, 0, 0, 0.75], "10927": [0.13597, 0.63597, 0, 0, 0.77778], "10928": [0.13597, 0.63597, 0, 0, 0.77778], "57376": [0.19444, 0.69444, 0, 0, 0] }, "Math-BoldItalic": { "32": [0, 0, 0, 0, 0.25], "48": [0, 0.44444, 0, 0, 0.575], "49": [0, 0.44444, 0, 0, 0.575], "50": [0, 0.44444, 0, 0, 0.575], "51": [0.19444, 0.44444, 0, 0, 0.575], "52": [0.19444, 0.44444, 0, 0, 0.575], "53": [0.19444, 0.44444, 0, 0, 0.575], "54": [0, 0.64444, 0, 0, 0.575], "55": [0.19444, 0.44444, 0, 0, 0.575], "56": [0, 0.64444, 0, 0, 0.575], "57": [0.19444, 0.44444, 0, 0, 0.575], "65": [0, 0.68611, 0, 0, 0.86944], "66": [0, 0.68611, 0.04835, 0, 0.8664], "67": [0, 0.68611, 0.06979, 0, 0.81694], "68": [0, 0.68611, 0.03194, 0, 0.93812], "69": [0, 0.68611, 0.05451, 0, 0.81007], "70": [0, 0.68611, 0.15972, 0, 0.68889], "71": [0, 0.68611, 0, 0, 0.88673], "72": [0, 0.68611, 0.08229, 0, 0.98229], "73": [0, 0.68611, 0.07778, 0, 0.51111], "74": [0, 0.68611, 0.10069, 0, 0.63125], "75": [0, 0.68611, 0.06979, 0, 0.97118], "76": [0, 0.68611, 0, 0, 0.75555], "77": [0, 0.68611, 0.11424, 0, 1.14201], "78": [0, 0.68611, 0.11424, 0, 0.95034], "79": [0, 0.68611, 0.03194, 0, 0.83666], "80": [0, 0.68611, 0.15972, 0, 0.72309], "81": [0.19444, 0.68611, 0, 0, 0.86861], "82": [0, 0.68611, 421e-5, 0, 0.87235], "83": [0, 0.68611, 0.05382, 0, 0.69271], "84": [0, 0.68611, 0.15972, 0, 0.63663], "85": [0, 0.68611, 0.11424, 0, 0.80027], "86": [0, 0.68611, 0.25555, 0, 0.67778], "87": [0, 0.68611, 0.15972, 0, 1.09305], "88": [0, 0.68611, 0.07778, 0, 0.94722], "89": [0, 0.68611, 0.25555, 0, 0.67458], "90": [0, 0.68611, 0.06979, 0, 0.77257], "97": [0, 0.44444, 0, 0, 0.63287], "98": [0, 0.69444, 0, 0, 0.52083], "99": [0, 0.44444, 0, 0, 0.51342], "100": [0, 0.69444, 0, 0, 0.60972], "101": [0, 0.44444, 0, 0, 0.55361], "102": [0.19444, 0.69444, 0.11042, 0, 0.56806], "103": [0.19444, 0.44444, 0.03704, 0, 0.5449], "104": [0, 0.69444, 0, 0, 0.66759], "105": [0, 0.69326, 0, 0, 0.4048], "106": [0.19444, 0.69326, 0.0622, 0, 0.47083], "107": [0, 0.69444, 0.01852, 0, 0.6037], "108": [0, 0.69444, 88e-4, 0, 0.34815], "109": [0, 0.44444, 0, 0, 1.0324], "110": [0, 0.44444, 0, 0, 0.71296], "111": [0, 0.44444, 0, 0, 0.58472], "112": [0.19444, 0.44444, 0, 0, 0.60092], "113": [0.19444, 0.44444, 0.03704, 0, 0.54213], "114": [0, 0.44444, 0.03194, 0, 0.5287], "115": [0, 0.44444, 0, 0, 0.53125], "116": [0, 0.63492, 0, 0, 0.41528], "117": [0, 0.44444, 0, 0, 0.68102], "118": [0, 0.44444, 0.03704, 0, 0.56666], "119": [0, 0.44444, 0.02778, 0, 0.83148], "120": [0, 0.44444, 0, 0, 0.65903], "121": [0.19444, 0.44444, 0.03704, 0, 0.59028], "122": [0, 0.44444, 0.04213, 0, 0.55509], "160": [0, 0, 0, 0, 0.25], "915": [0, 0.68611, 0.15972, 0, 0.65694], "916": [0, 0.68611, 0, 0, 0.95833], "920": [0, 0.68611, 0.03194, 0, 0.86722], "923": [0, 0.68611, 0, 0, 0.80555], "926": [0, 0.68611, 0.07458, 0, 0.84125], "928": [0, 0.68611, 0.08229, 0, 0.98229], "931": [0, 0.68611, 0.05451, 0, 0.88507], "933": [0, 0.68611, 0.15972, 0, 0.67083], "934": [0, 0.68611, 0, 0, 0.76666], "936": [0, 0.68611, 0.11653, 0, 0.71402], "937": [0, 0.68611, 0.04835, 0, 0.8789], "945": [0, 0.44444, 0, 0, 0.76064], "946": [0.19444, 0.69444, 0.03403, 0, 0.65972], "947": [0.19444, 0.44444, 0.06389, 0, 0.59003], "948": [0, 0.69444, 0.03819, 0, 0.52222], "949": [0, 0.44444, 0, 0, 0.52882], "950": [0.19444, 0.69444, 0.06215, 0, 0.50833], "951": [0.19444, 0.44444, 0.03704, 0, 0.6], "952": [0, 0.69444, 0.03194, 0, 0.5618], "953": [0, 0.44444, 0, 0, 0.41204], "954": [0, 0.44444, 0, 0, 0.66759], "955": [0, 0.69444, 0, 0, 0.67083], "956": [0.19444, 0.44444, 0, 0, 0.70787], "957": [0, 0.44444, 0.06898, 0, 0.57685], "958": [0.19444, 0.69444, 0.03021, 0, 0.50833], "959": [0, 0.44444, 0, 0, 0.58472], "960": [0, 0.44444, 0.03704, 0, 0.68241], "961": [0.19444, 0.44444, 0, 0, 0.6118], "962": [0.09722, 0.44444, 0.07917, 0, 0.42361], "963": [0, 0.44444, 0.03704, 0, 0.68588], "964": [0, 0.44444, 0.13472, 0, 0.52083], "965": [0, 0.44444, 0.03704, 0, 0.63055], "966": [0.19444, 0.44444, 0, 0, 0.74722], "967": [0.19444, 0.44444, 0, 0, 0.71805], "968": [0.19444, 0.69444, 0.03704, 0, 0.75833], "969": [0, 0.44444, 0.03704, 0, 0.71782], "977": [0, 0.69444, 0, 0, 0.69155], "981": [0.19444, 0.69444, 0, 0, 0.7125], "982": [0, 0.44444, 0.03194, 0, 0.975], "1009": [0.19444, 0.44444, 0, 0, 0.6118], "1013": [0, 0.44444, 0, 0, 0.48333], "57649": [0, 0.44444, 0, 0, 0.39352], "57911": [0.19444, 0.44444, 0, 0, 0.43889] }, "Math-Italic": { "32": [0, 0, 0, 0, 0.25], "48": [0, 0.43056, 0, 0, 0.5], "49": [0, 0.43056, 0, 0, 0.5], "50": [0, 0.43056, 0, 0, 0.5], "51": [0.19444, 0.43056, 0, 0, 0.5], "52": [0.19444, 0.43056, 0, 0, 0.5], "53": [0.19444, 0.43056, 0, 0, 0.5], "54": [0, 0.64444, 0, 0, 0.5], "55": [0.19444, 0.43056, 0, 0, 0.5], "56": [0, 0.64444, 0, 0, 0.5], "57": [0.19444, 0.43056, 0, 0, 0.5], "65": [0, 0.68333, 0, 0.13889, 0.75], "66": [0, 0.68333, 0.05017, 0.08334, 0.75851], "67": [0, 0.68333, 0.07153, 0.08334, 0.71472], "68": [0, 0.68333, 0.02778, 0.05556, 0.82792], "69": [0, 0.68333, 0.05764, 0.08334, 0.7382], "70": [0, 0.68333, 0.13889, 0.08334, 0.64306], "71": [0, 0.68333, 0, 0.08334, 0.78625], "72": [0, 0.68333, 0.08125, 0.05556, 0.83125], "73": [0, 0.68333, 0.07847, 0.11111, 0.43958], "74": [0, 0.68333, 0.09618, 0.16667, 0.55451], "75": [0, 0.68333, 0.07153, 0.05556, 0.84931], "76": [0, 0.68333, 0, 0.02778, 0.68056], "77": [0, 0.68333, 0.10903, 0.08334, 0.97014], "78": [0, 0.68333, 0.10903, 0.08334, 0.80347], "79": [0, 0.68333, 0.02778, 0.08334, 0.76278], "80": [0, 0.68333, 0.13889, 0.08334, 0.64201], "81": [0.19444, 0.68333, 0, 0.08334, 0.79056], "82": [0, 0.68333, 773e-5, 0.08334, 0.75929], "83": [0, 0.68333, 0.05764, 0.08334, 0.6132], "84": [0, 0.68333, 0.13889, 0.08334, 0.58438], "85": [0, 0.68333, 0.10903, 0.02778, 0.68278], "86": [0, 0.68333, 0.22222, 0, 0.58333], "87": [0, 0.68333, 0.13889, 0, 0.94445], "88": [0, 0.68333, 0.07847, 0.08334, 0.82847], "89": [0, 0.68333, 0.22222, 0, 0.58056], "90": [0, 0.68333, 0.07153, 0.08334, 0.68264], "97": [0, 0.43056, 0, 0, 0.52859], "98": [0, 0.69444, 0, 0, 0.42917], "99": [0, 0.43056, 0, 0.05556, 0.43276], "100": [0, 0.69444, 0, 0.16667, 0.52049], "101": [0, 0.43056, 0, 0.05556, 0.46563], "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959], "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697], "104": [0, 0.69444, 0, 0, 0.57616], "105": [0, 0.65952, 0, 0, 0.34451], "106": [0.19444, 0.65952, 0.05724, 0, 0.41181], "107": [0, 0.69444, 0.03148, 0, 0.5206], "108": [0, 0.69444, 0.01968, 0.08334, 0.29838], "109": [0, 0.43056, 0, 0, 0.87801], "110": [0, 0.43056, 0, 0, 0.60023], "111": [0, 0.43056, 0, 0.05556, 0.48472], "112": [0.19444, 0.43056, 0, 0.08334, 0.50313], "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641], "114": [0, 0.43056, 0.02778, 0.05556, 0.45116], "115": [0, 0.43056, 0, 0.05556, 0.46875], "116": [0, 0.61508, 0, 0.08334, 0.36111], "117": [0, 0.43056, 0, 0.02778, 0.57246], "118": [0, 0.43056, 0.03588, 0.02778, 0.48472], "119": [0, 0.43056, 0.02691, 0.08334, 0.71592], "120": [0, 0.43056, 0, 0.02778, 0.57153], "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028], "122": [0, 0.43056, 0.04398, 0.05556, 0.46505], "160": [0, 0, 0, 0, 0.25], "915": [0, 0.68333, 0.13889, 0.08334, 0.61528], "916": [0, 0.68333, 0, 0.16667, 0.83334], "920": [0, 0.68333, 0.02778, 0.08334, 0.76278], "923": [0, 0.68333, 0, 0.16667, 0.69445], "926": [0, 0.68333, 0.07569, 0.08334, 0.74236], "928": [0, 0.68333, 0.08125, 0.05556, 0.83125], "931": [0, 0.68333, 0.05764, 0.08334, 0.77986], "933": [0, 0.68333, 0.13889, 0.05556, 0.58333], "934": [0, 0.68333, 0, 0.08334, 0.66667], "936": [0, 0.68333, 0.11, 0.05556, 0.61222], "937": [0, 0.68333, 0.05017, 0.08334, 0.7724], "945": [0, 0.43056, 37e-4, 0.02778, 0.6397], "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563], "947": [0.19444, 0.43056, 0.05556, 0, 0.51773], "948": [0, 0.69444, 0.03785, 0.05556, 0.44444], "949": [0, 0.43056, 0, 0.08334, 0.46632], "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375], "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653], "952": [0, 0.69444, 0.02778, 0.08334, 0.46944], "953": [0, 0.43056, 0, 0.05556, 0.35394], "954": [0, 0.43056, 0, 0, 0.57616], "955": [0, 0.69444, 0, 0, 0.58334], "956": [0.19444, 0.43056, 0, 0.02778, 0.60255], "957": [0, 0.43056, 0.06366, 0.02778, 0.49398], "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375], "959": [0, 0.43056, 0, 0.05556, 0.48472], "960": [0, 0.43056, 0.03588, 0, 0.57003], "961": [0.19444, 0.43056, 0, 0.08334, 0.51702], "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285], "963": [0, 0.43056, 0.03588, 0, 0.57141], "964": [0, 0.43056, 0.1132, 0.02778, 0.43715], "965": [0, 0.43056, 0.03588, 0.02778, 0.54028], "966": [0.19444, 0.43056, 0, 0.08334, 0.65417], "967": [0.19444, 0.43056, 0, 0.05556, 0.62569], "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139], "969": [0, 0.43056, 0.03588, 0, 0.62245], "977": [0, 0.69444, 0, 0.08334, 0.59144], "981": [0.19444, 0.69444, 0, 0.08334, 0.59583], "982": [0, 0.43056, 0.02778, 0, 0.82813], "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702], "1013": [0, 0.43056, 0, 0.05556, 0.4059], "57649": [0, 0.43056, 0, 0.02778, 0.32246], "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403] }, "SansSerif-Bold": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0, 0, 0.36667], "34": [0, 0.69444, 0, 0, 0.55834], "35": [0.19444, 0.69444, 0, 0, 0.91667], "36": [0.05556, 0.75, 0, 0, 0.55], "37": [0.05556, 0.75, 0, 0, 1.02912], "38": [0, 0.69444, 0, 0, 0.83056], "39": [0, 0.69444, 0, 0, 0.30556], "40": [0.25, 0.75, 0, 0, 0.42778], "41": [0.25, 0.75, 0, 0, 0.42778], "42": [0, 0.75, 0, 0, 0.55], "43": [0.11667, 0.61667, 0, 0, 0.85556], "44": [0.10556, 0.13056, 0, 0, 0.30556], "45": [0, 0.45833, 0, 0, 0.36667], "46": [0, 0.13056, 0, 0, 0.30556], "47": [0.25, 0.75, 0, 0, 0.55], "48": [0, 0.69444, 0, 0, 0.55], "49": [0, 0.69444, 0, 0, 0.55], "50": [0, 0.69444, 0, 0, 0.55], "51": [0, 0.69444, 0, 0, 0.55], "52": [0, 0.69444, 0, 0, 0.55], "53": [0, 0.69444, 0, 0, 0.55], "54": [0, 0.69444, 0, 0, 0.55], "55": [0, 0.69444, 0, 0, 0.55], "56": [0, 0.69444, 0, 0, 0.55], "57": [0, 0.69444, 0, 0, 0.55], "58": [0, 0.45833, 0, 0, 0.30556], "59": [0.10556, 0.45833, 0, 0, 0.30556], "61": [-0.09375, 0.40625, 0, 0, 0.85556], "63": [0, 0.69444, 0, 0, 0.51945], "64": [0, 0.69444, 0, 0, 0.73334], "65": [0, 0.69444, 0, 0, 0.73334], "66": [0, 0.69444, 0, 0, 0.73334], "67": [0, 0.69444, 0, 0, 0.70278], "68": [0, 0.69444, 0, 0, 0.79445], "69": [0, 0.69444, 0, 0, 0.64167], "70": [0, 0.69444, 0, 0, 0.61111], "71": [0, 0.69444, 0, 0, 0.73334], "72": [0, 0.69444, 0, 0, 0.79445], "73": [0, 0.69444, 0, 0, 0.33056], "74": [0, 0.69444, 0, 0, 0.51945], "75": [0, 0.69444, 0, 0, 0.76389], "76": [0, 0.69444, 0, 0, 0.58056], "77": [0, 0.69444, 0, 0, 0.97778], "78": [0, 0.69444, 0, 0, 0.79445], "79": [0, 0.69444, 0, 0, 0.79445], "80": [0, 0.69444, 0, 0, 0.70278], "81": [0.10556, 0.69444, 0, 0, 0.79445], "82": [0, 0.69444, 0, 0, 0.70278], "83": [0, 0.69444, 0, 0, 0.61111], "84": [0, 0.69444, 0, 0, 0.73334], "85": [0, 0.69444, 0, 0, 0.76389], "86": [0, 0.69444, 0.01528, 0, 0.73334], "87": [0, 0.69444, 0.01528, 0, 1.03889], "88": [0, 0.69444, 0, 0, 0.73334], "89": [0, 0.69444, 0.0275, 0, 0.73334], "90": [0, 0.69444, 0, 0, 0.67223], "91": [0.25, 0.75, 0, 0, 0.34306], "93": [0.25, 0.75, 0, 0, 0.34306], "94": [0, 0.69444, 0, 0, 0.55], "95": [0.35, 0.10833, 0.03056, 0, 0.55], "97": [0, 0.45833, 0, 0, 0.525], "98": [0, 0.69444, 0, 0, 0.56111], "99": [0, 0.45833, 0, 0, 0.48889], "100": [0, 0.69444, 0, 0, 0.56111], "101": [0, 0.45833, 0, 0, 0.51111], "102": [0, 0.69444, 0.07639, 0, 0.33611], "103": [0.19444, 0.45833, 0.01528, 0, 0.55], "104": [0, 0.69444, 0, 0, 0.56111], "105": [0, 0.69444, 0, 0, 0.25556], "106": [0.19444, 0.69444, 0, 0, 0.28611], "107": [0, 0.69444, 0, 0, 0.53056], "108": [0, 0.69444, 0, 0, 0.25556], "109": [0, 0.45833, 0, 0, 0.86667], "110": [0, 0.45833, 0, 0, 0.56111], "111": [0, 0.45833, 0, 0, 0.55], "112": [0.19444, 0.45833, 0, 0, 0.56111], "113": [0.19444, 0.45833, 0, 0, 0.56111], "114": [0, 0.45833, 0.01528, 0, 0.37222], "115": [0, 0.45833, 0, 0, 0.42167], "116": [0, 0.58929, 0, 0, 0.40417], "117": [0, 0.45833, 0, 0, 0.56111], "118": [0, 0.45833, 0.01528, 0, 0.5], "119": [0, 0.45833, 0.01528, 0, 0.74445], "120": [0, 0.45833, 0, 0, 0.5], "121": [0.19444, 0.45833, 0.01528, 0, 0.5], "122": [0, 0.45833, 0, 0, 0.47639], "126": [0.35, 0.34444, 0, 0, 0.55], "160": [0, 0, 0, 0, 0.25], "168": [0, 0.69444, 0, 0, 0.55], "176": [0, 0.69444, 0, 0, 0.73334], "180": [0, 0.69444, 0, 0, 0.55], "184": [0.17014, 0, 0, 0, 0.48889], "305": [0, 0.45833, 0, 0, 0.25556], "567": [0.19444, 0.45833, 0, 0, 0.28611], "710": [0, 0.69444, 0, 0, 0.55], "711": [0, 0.63542, 0, 0, 0.55], "713": [0, 0.63778, 0, 0, 0.55], "728": [0, 0.69444, 0, 0, 0.55], "729": [0, 0.69444, 0, 0, 0.30556], "730": [0, 0.69444, 0, 0, 0.73334], "732": [0, 0.69444, 0, 0, 0.55], "733": [0, 0.69444, 0, 0, 0.55], "915": [0, 0.69444, 0, 0, 0.58056], "916": [0, 0.69444, 0, 0, 0.91667], "920": [0, 0.69444, 0, 0, 0.85556], "923": [0, 0.69444, 0, 0, 0.67223], "926": [0, 0.69444, 0, 0, 0.73334], "928": [0, 0.69444, 0, 0, 0.79445], "931": [0, 0.69444, 0, 0, 0.79445], "933": [0, 0.69444, 0, 0, 0.85556], "934": [0, 0.69444, 0, 0, 0.79445], "936": [0, 0.69444, 0, 0, 0.85556], "937": [0, 0.69444, 0, 0, 0.79445], "8211": [0, 0.45833, 0.03056, 0, 0.55], "8212": [0, 0.45833, 0.03056, 0, 1.10001], "8216": [0, 0.69444, 0, 0, 0.30556], "8217": [0, 0.69444, 0, 0, 0.30556], "8220": [0, 0.69444, 0, 0, 0.55834], "8221": [0, 0.69444, 0, 0, 0.55834] }, "SansSerif-Italic": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0.05733, 0, 0.31945], "34": [0, 0.69444, 316e-5, 0, 0.5], "35": [0.19444, 0.69444, 0.05087, 0, 0.83334], "36": [0.05556, 0.75, 0.11156, 0, 0.5], "37": [0.05556, 0.75, 0.03126, 0, 0.83334], "38": [0, 0.69444, 0.03058, 0, 0.75834], "39": [0, 0.69444, 0.07816, 0, 0.27778], "40": [0.25, 0.75, 0.13164, 0, 0.38889], "41": [0.25, 0.75, 0.02536, 0, 0.38889], "42": [0, 0.75, 0.11775, 0, 0.5], "43": [0.08333, 0.58333, 0.02536, 0, 0.77778], "44": [0.125, 0.08333, 0, 0, 0.27778], "45": [0, 0.44444, 0.01946, 0, 0.33333], "46": [0, 0.08333, 0, 0, 0.27778], "47": [0.25, 0.75, 0.13164, 0, 0.5], "48": [0, 0.65556, 0.11156, 0, 0.5], "49": [0, 0.65556, 0.11156, 0, 0.5], "50": [0, 0.65556, 0.11156, 0, 0.5], "51": [0, 0.65556, 0.11156, 0, 0.5], "52": [0, 0.65556, 0.11156, 0, 0.5], "53": [0, 0.65556, 0.11156, 0, 0.5], "54": [0, 0.65556, 0.11156, 0, 0.5], "55": [0, 0.65556, 0.11156, 0, 0.5], "56": [0, 0.65556, 0.11156, 0, 0.5], "57": [0, 0.65556, 0.11156, 0, 0.5], "58": [0, 0.44444, 0.02502, 0, 0.27778], "59": [0.125, 0.44444, 0.02502, 0, 0.27778], "61": [-0.13, 0.37, 0.05087, 0, 0.77778], "63": [0, 0.69444, 0.11809, 0, 0.47222], "64": [0, 0.69444, 0.07555, 0, 0.66667], "65": [0, 0.69444, 0, 0, 0.66667], "66": [0, 0.69444, 0.08293, 0, 0.66667], "67": [0, 0.69444, 0.11983, 0, 0.63889], "68": [0, 0.69444, 0.07555, 0, 0.72223], "69": [0, 0.69444, 0.11983, 0, 0.59722], "70": [0, 0.69444, 0.13372, 0, 0.56945], "71": [0, 0.69444, 0.11983, 0, 0.66667], "72": [0, 0.69444, 0.08094, 0, 0.70834], "73": [0, 0.69444, 0.13372, 0, 0.27778], "74": [0, 0.69444, 0.08094, 0, 0.47222], "75": [0, 0.69444, 0.11983, 0, 0.69445], "76": [0, 0.69444, 0, 0, 0.54167], "77": [0, 0.69444, 0.08094, 0, 0.875], "78": [0, 0.69444, 0.08094, 0, 0.70834], "79": [0, 0.69444, 0.07555, 0, 0.73611], "80": [0, 0.69444, 0.08293, 0, 0.63889], "81": [0.125, 0.69444, 0.07555, 0, 0.73611], "82": [0, 0.69444, 0.08293, 0, 0.64584], "83": [0, 0.69444, 0.09205, 0, 0.55556], "84": [0, 0.69444, 0.13372, 0, 0.68056], "85": [0, 0.69444, 0.08094, 0, 0.6875], "86": [0, 0.69444, 0.1615, 0, 0.66667], "87": [0, 0.69444, 0.1615, 0, 0.94445], "88": [0, 0.69444, 0.13372, 0, 0.66667], "89": [0, 0.69444, 0.17261, 0, 0.66667], "90": [0, 0.69444, 0.11983, 0, 0.61111], "91": [0.25, 0.75, 0.15942, 0, 0.28889], "93": [0.25, 0.75, 0.08719, 0, 0.28889], "94": [0, 0.69444, 0.0799, 0, 0.5], "95": [0.35, 0.09444, 0.08616, 0, 0.5], "97": [0, 0.44444, 981e-5, 0, 0.48056], "98": [0, 0.69444, 0.03057, 0, 0.51667], "99": [0, 0.44444, 0.08336, 0, 0.44445], "100": [0, 0.69444, 0.09483, 0, 0.51667], "101": [0, 0.44444, 0.06778, 0, 0.44445], "102": [0, 0.69444, 0.21705, 0, 0.30556], "103": [0.19444, 0.44444, 0.10836, 0, 0.5], "104": [0, 0.69444, 0.01778, 0, 0.51667], "105": [0, 0.67937, 0.09718, 0, 0.23889], "106": [0.19444, 0.67937, 0.09162, 0, 0.26667], "107": [0, 0.69444, 0.08336, 0, 0.48889], "108": [0, 0.69444, 0.09483, 0, 0.23889], "109": [0, 0.44444, 0.01778, 0, 0.79445], "110": [0, 0.44444, 0.01778, 0, 0.51667], "111": [0, 0.44444, 0.06613, 0, 0.5], "112": [0.19444, 0.44444, 0.0389, 0, 0.51667], "113": [0.19444, 0.44444, 0.04169, 0, 0.51667], "114": [0, 0.44444, 0.10836, 0, 0.34167], "115": [0, 0.44444, 0.0778, 0, 0.38333], "116": [0, 0.57143, 0.07225, 0, 0.36111], "117": [0, 0.44444, 0.04169, 0, 0.51667], "118": [0, 0.44444, 0.10836, 0, 0.46111], "119": [0, 0.44444, 0.10836, 0, 0.68334], "120": [0, 0.44444, 0.09169, 0, 0.46111], "121": [0.19444, 0.44444, 0.10836, 0, 0.46111], "122": [0, 0.44444, 0.08752, 0, 0.43472], "126": [0.35, 0.32659, 0.08826, 0, 0.5], "160": [0, 0, 0, 0, 0.25], "168": [0, 0.67937, 0.06385, 0, 0.5], "176": [0, 0.69444, 0, 0, 0.73752], "184": [0.17014, 0, 0, 0, 0.44445], "305": [0, 0.44444, 0.04169, 0, 0.23889], "567": [0.19444, 0.44444, 0.04169, 0, 0.26667], "710": [0, 0.69444, 0.0799, 0, 0.5], "711": [0, 0.63194, 0.08432, 0, 0.5], "713": [0, 0.60889, 0.08776, 0, 0.5], "714": [0, 0.69444, 0.09205, 0, 0.5], "715": [0, 0.69444, 0, 0, 0.5], "728": [0, 0.69444, 0.09483, 0, 0.5], "729": [0, 0.67937, 0.07774, 0, 0.27778], "730": [0, 0.69444, 0, 0, 0.73752], "732": [0, 0.67659, 0.08826, 0, 0.5], "733": [0, 0.69444, 0.09205, 0, 0.5], "915": [0, 0.69444, 0.13372, 0, 0.54167], "916": [0, 0.69444, 0, 0, 0.83334], "920": [0, 0.69444, 0.07555, 0, 0.77778], "923": [0, 0.69444, 0, 0, 0.61111], "926": [0, 0.69444, 0.12816, 0, 0.66667], "928": [0, 0.69444, 0.08094, 0, 0.70834], "931": [0, 0.69444, 0.11983, 0, 0.72222], "933": [0, 0.69444, 0.09031, 0, 0.77778], "934": [0, 0.69444, 0.04603, 0, 0.72222], "936": [0, 0.69444, 0.09031, 0, 0.77778], "937": [0, 0.69444, 0.08293, 0, 0.72222], "8211": [0, 0.44444, 0.08616, 0, 0.5], "8212": [0, 0.44444, 0.08616, 0, 1], "8216": [0, 0.69444, 0.07816, 0, 0.27778], "8217": [0, 0.69444, 0.07816, 0, 0.27778], "8220": [0, 0.69444, 0.14205, 0, 0.5], "8221": [0, 0.69444, 316e-5, 0, 0.5] }, "SansSerif-Regular": { "32": [0, 0, 0, 0, 0.25], "33": [0, 0.69444, 0, 0, 0.31945], "34": [0, 0.69444, 0, 0, 0.5], "35": [0.19444, 0.69444, 0, 0, 0.83334], "36": [0.05556, 0.75, 0, 0, 0.5], "37": [0.05556, 0.75, 0, 0, 0.83334], "38": [0, 0.69444, 0, 0, 0.75834], "39": [0, 0.69444, 0, 0, 0.27778], "40": [0.25, 0.75, 0, 0, 0.38889], "41": [0.25, 0.75, 0, 0, 0.38889], "42": [0, 0.75, 0, 0, 0.5], "43": [0.08333, 0.58333, 0, 0, 0.77778], "44": [0.125, 0.08333, 0, 0, 0.27778], "45": [0, 0.44444, 0, 0, 0.33333], "46": [0, 0.08333, 0, 0, 0.27778], "47": [0.25, 0.75, 0, 0, 0.5], "48": [0, 0.65556, 0, 0, 0.5], "49": [0, 0.65556, 0, 0, 0.5], "50": [0, 0.65556, 0, 0, 0.5], "51": [0, 0.65556, 0, 0, 0.5], "52": [0, 0.65556, 0, 0, 0.5], "53": [0, 0.65556, 0, 0, 0.5], "54": [0, 0.65556, 0, 0, 0.5], "55": [0, 0.65556, 0, 0, 0.5], "56": [0, 0.65556, 0, 0, 0.5], "57": [0, 0.65556, 0, 0, 0.5], "58": [0, 0.44444, 0, 0, 0.27778], "59": [0.125, 0.44444, 0, 0, 0.27778], "61": [-0.13, 0.37, 0, 0, 0.77778], "63": [0, 0.69444, 0, 0, 0.47222], "64": [0, 0.69444, 0, 0, 0.66667], "65": [0, 0.69444, 0, 0, 0.66667], "66": [0, 0.69444, 0, 0, 0.66667], "67": [0, 0.69444, 0, 0, 0.63889], "68": [0, 0.69444, 0, 0, 0.72223], "69": [0, 0.69444, 0, 0, 0.59722], "70": [0, 0.69444, 0, 0, 0.56945], "71": [0, 0.69444, 0, 0, 0.66667], "72": [0, 0.69444, 0, 0, 0.70834], "73": [0, 0.69444, 0, 0, 0.27778], "74": [0, 0.69444, 0, 0, 0.47222], "75": [0, 0.69444, 0, 0, 0.69445], "76": [0, 0.69444, 0, 0, 0.54167], "77": [0, 0.69444, 0, 0, 0.875], "78": [0, 0.69444, 0, 0, 0.70834], "79": [0, 0.69444, 0, 0, 0.73611], "80": [0, 0.69444, 0, 0, 0.63889], "81": [0.125, 0.69444, 0, 0, 0.73611], "82": [0, 0.69444, 0, 0, 0.64584], "83": [0, 0.69444, 0, 0, 0.55556], "84": [0, 0.69444, 0, 0, 0.68056], "85": [0, 0.69444, 0, 0, 0.6875], "86": [0, 0.69444, 0.01389, 0, 0.66667], "87": [0, 0.69444, 0.01389, 0, 0.94445], "88": [0, 0.69444, 0, 0, 0.66667], "89": [0, 0.69444, 0.025, 0, 0.66667], "90": [0, 0.69444, 0, 0, 0.61111], "91": [0.25, 0.75, 0, 0, 0.28889], "93": [0.25, 0.75, 0, 0, 0.28889], "94": [0, 0.69444, 0, 0, 0.5], "95": [0.35, 0.09444, 0.02778, 0, 0.5], "97": [0, 0.44444, 0, 0, 0.48056], "98": [0, 0.69444, 0, 0, 0.51667], "99": [0, 0.44444, 0, 0, 0.44445], "100": [0, 0.69444, 0, 0, 0.51667], "101": [0, 0.44444, 0, 0, 0.44445], "102": [0, 0.69444, 0.06944, 0, 0.30556], "103": [0.19444, 0.44444, 0.01389, 0, 0.5], "104": [0, 0.69444, 0, 0, 0.51667], "105": [0, 0.67937, 0, 0, 0.23889], "106": [0.19444, 0.67937, 0, 0, 0.26667], "107": [0, 0.69444, 0, 0, 0.48889], "108": [0, 0.69444, 0, 0, 0.23889], "109": [0, 0.44444, 0, 0, 0.79445], "110": [0, 0.44444, 0, 0, 0.51667], "111": [0, 0.44444, 0, 0, 0.5], "112": [0.19444, 0.44444, 0, 0, 0.51667], "113": [0.19444, 0.44444, 0, 0, 0.51667], "114": [0, 0.44444, 0.01389, 0, 0.34167], "115": [0, 0.44444, 0, 0, 0.38333], "116": [0, 0.57143, 0, 0, 0.36111], "117": [0, 0.44444, 0, 0, 0.51667], "118": [0, 0.44444, 0.01389, 0, 0.46111], "119": [0, 0.44444, 0.01389, 0, 0.68334], "120": [0, 0.44444, 0, 0, 0.46111], "121": [0.19444, 0.44444, 0.01389, 0, 0.46111], "122": [0, 0.44444, 0, 0, 0.43472], "126": [0.35, 0.32659, 0, 0, 0.5], "160": [0, 0, 0, 0, 0.25], "168": [0, 0.67937, 0, 0, 0.5], "176": [0, 0.69444, 0, 0, 0.66667], "184": [0.17014, 0, 0, 0, 0.44445], "305": [0, 0.44444, 0, 0, 0.23889], "567": [0.19444, 0.44444, 0, 0, 0.26667], "710": [0, 0.69444, 0, 0, 0.5], "711": [0, 0.63194, 0, 0, 0.5], "713": [0, 0.60889, 0, 0, 0.5], "714": [0, 0.69444, 0, 0, 0.5], "715": [0, 0.69444, 0, 0, 0.5], "728": [0, 0.69444, 0, 0, 0.5], "729": [0, 0.67937, 0, 0, 0.27778], "730": [0, 0.69444, 0, 0, 0.66667], "732": [0, 0.67659, 0, 0, 0.5], "733": [0, 0.69444, 0, 0, 0.5], "915": [0, 0.69444, 0, 0, 0.54167], "916": [0, 0.69444, 0, 0, 0.83334], "920": [0, 0.69444, 0, 0, 0.77778], "923": [0, 0.69444, 0, 0, 0.61111], "926": [0, 0.69444, 0, 0, 0.66667], "928": [0, 0.69444, 0, 0, 0.70834], "931": [0, 0.69444, 0, 0, 0.72222], "933": [0, 0.69444, 0, 0, 0.77778], "934": [0, 0.69444, 0, 0, 0.72222], "936": [0, 0.69444, 0, 0, 0.77778], "937": [0, 0.69444, 0, 0, 0.72222], "8211": [0, 0.44444, 0.02778, 0, 0.5], "8212": [0, 0.44444, 0.02778, 0, 1], "8216": [0, 0.69444, 0, 0, 0.27778], "8217": [0, 0.69444, 0, 0, 0.27778], "8220": [0, 0.69444, 0, 0, 0.5], "8221": [0, 0.69444, 0, 0, 0.5] }, "Script-Regular": { "32": [0, 0, 0, 0, 0.25], "65": [0, 0.7, 0.22925, 0, 0.80253], "66": [0, 0.7, 0.04087, 0, 0.90757], "67": [0, 0.7, 0.1689, 0, 0.66619], "68": [0, 0.7, 0.09371, 0, 0.77443], "69": [0, 0.7, 0.18583, 0, 0.56162], "70": [0, 0.7, 0.13634, 0, 0.89544], "71": [0, 0.7, 0.17322, 0, 0.60961], "72": [0, 0.7, 0.29694, 0, 0.96919], "73": [0, 0.7, 0.19189, 0, 0.80907], "74": [0.27778, 0.7, 0.19189, 0, 1.05159], "75": [0, 0.7, 0.31259, 0, 0.91364], "76": [0, 0.7, 0.19189, 0, 0.87373], "77": [0, 0.7, 0.15981, 0, 1.08031], "78": [0, 0.7, 0.3525, 0, 0.9015], "79": [0, 0.7, 0.08078, 0, 0.73787], "80": [0, 0.7, 0.08078, 0, 1.01262], "81": [0, 0.7, 0.03305, 0, 0.88282], "82": [0, 0.7, 0.06259, 0, 0.85], "83": [0, 0.7, 0.19189, 0, 0.86767], "84": [0, 0.7, 0.29087, 0, 0.74697], "85": [0, 0.7, 0.25815, 0, 0.79996], "86": [0, 0.7, 0.27523, 0, 0.62204], "87": [0, 0.7, 0.27523, 0, 0.80532], "88": [0, 0.7, 0.26006, 0, 0.94445], "89": [0, 0.7, 0.2939, 0, 0.70961], "90": [0, 0.7, 0.24037, 0, 0.8212], "160": [0, 0, 0, 0, 0.25] }, "Size1-Regular": { "32": [0, 0, 0, 0, 0.25], "40": [0.35001, 0.85, 0, 0, 0.45834], "41": [0.35001, 0.85, 0, 0, 0.45834], "47": [0.35001, 0.85, 0, 0, 0.57778], "91": [0.35001, 0.85, 0, 0, 0.41667], "92": [0.35001, 0.85, 0, 0, 0.57778], "93": [0.35001, 0.85, 0, 0, 0.41667], "123": [0.35001, 0.85, 0, 0, 0.58334], "125": [0.35001, 0.85, 0, 0, 0.58334], "160": [0, 0, 0, 0, 0.25], "710": [0, 0.72222, 0, 0, 0.55556], "732": [0, 0.72222, 0, 0, 0.55556], "770": [0, 0.72222, 0, 0, 0.55556], "771": [0, 0.72222, 0, 0, 0.55556], "8214": [-99e-5, 0.601, 0, 0, 0.77778], "8593": [1e-5, 0.6, 0, 0, 0.66667], "8595": [1e-5, 0.6, 0, 0, 0.66667], "8657": [1e-5, 0.6, 0, 0, 0.77778], "8659": [1e-5, 0.6, 0, 0, 0.77778], "8719": [0.25001, 0.75, 0, 0, 0.94445], "8720": [0.25001, 0.75, 0, 0, 0.94445], "8721": [0.25001, 0.75, 0, 0, 1.05556], "8730": [0.35001, 0.85, 0, 0, 1], "8739": [-599e-5, 0.606, 0, 0, 0.33333], "8741": [-599e-5, 0.606, 0, 0, 0.55556], "8747": [0.30612, 0.805, 0.19445, 0, 0.47222], "8748": [0.306, 0.805, 0.19445, 0, 0.47222], "8749": [0.306, 0.805, 0.19445, 0, 0.47222], "8750": [0.30612, 0.805, 0.19445, 0, 0.47222], "8896": [0.25001, 0.75, 0, 0, 0.83334], "8897": [0.25001, 0.75, 0, 0, 0.83334], "8898": [0.25001, 0.75, 0, 0, 0.83334], "8899": [0.25001, 0.75, 0, 0, 0.83334], "8968": [0.35001, 0.85, 0, 0, 0.47222], "8969": [0.35001, 0.85, 0, 0, 0.47222], "8970": [0.35001, 0.85, 0, 0, 0.47222], "8971": [0.35001, 0.85, 0, 0, 0.47222], "9168": [-99e-5, 0.601, 0, 0, 0.66667], "10216": [0.35001, 0.85, 0, 0, 0.47222], "10217": [0.35001, 0.85, 0, 0, 0.47222], "10752": [0.25001, 0.75, 0, 0, 1.11111], "10753": [0.25001, 0.75, 0, 0, 1.11111], "10754": [0.25001, 0.75, 0, 0, 1.11111], "10756": [0.25001, 0.75, 0, 0, 0.83334], "10758": [0.25001, 0.75, 0, 0, 0.83334] }, "Size2-Regular": { "32": [0, 0, 0, 0, 0.25], "40": [0.65002, 1.15, 0, 0, 0.59722], "41": [0.65002, 1.15, 0, 0, 0.59722], "47": [0.65002, 1.15, 0, 0, 0.81111], "91": [0.65002, 1.15, 0, 0, 0.47222], "92": [0.65002, 1.15, 0, 0, 0.81111], "93": [0.65002, 1.15, 0, 0, 0.47222], "123": [0.65002, 1.15, 0, 0, 0.66667], "125": [0.65002, 1.15, 0, 0, 0.66667], "160": [0, 0, 0, 0, 0.25], "710": [0, 0.75, 0, 0, 1], "732": [0, 0.75, 0, 0, 1], "770": [0, 0.75, 0, 0, 1], "771": [0, 0.75, 0, 0, 1], "8719": [0.55001, 1.05, 0, 0, 1.27778], "8720": [0.55001, 1.05, 0, 0, 1.27778], "8721": [0.55001, 1.05, 0, 0, 1.44445], "8730": [0.65002, 1.15, 0, 0, 1], "8747": [0.86225, 1.36, 0.44445, 0, 0.55556], "8748": [0.862, 1.36, 0.44445, 0, 0.55556], "8749": [0.862, 1.36, 0.44445, 0, 0.55556], "8750": [0.86225, 1.36, 0.44445, 0, 0.55556], "8896": [0.55001, 1.05, 0, 0, 1.11111], "8897": [0.55001, 1.05, 0, 0, 1.11111], "8898": [0.55001, 1.05, 0, 0, 1.11111], "8899": [0.55001, 1.05, 0, 0, 1.11111], "8968": [0.65002, 1.15, 0, 0, 0.52778], "8969": [0.65002, 1.15, 0, 0, 0.52778], "8970": [0.65002, 1.15, 0, 0, 0.52778], "8971": [0.65002, 1.15, 0, 0, 0.52778], "10216": [0.65002, 1.15, 0, 0, 0.61111], "10217": [0.65002, 1.15, 0, 0, 0.61111], "10752": [0.55001, 1.05, 0, 0, 1.51112], "10753": [0.55001, 1.05, 0, 0, 1.51112], "10754": [0.55001, 1.05, 0, 0, 1.51112], "10756": [0.55001, 1.05, 0, 0, 1.11111], "10758": [0.55001, 1.05, 0, 0, 1.11111] }, "Size3-Regular": { "32": [0, 0, 0, 0, 0.25], "40": [0.95003, 1.45, 0, 0, 0.73611], "41": [0.95003, 1.45, 0, 0, 0.73611], "47": [0.95003, 1.45, 0, 0, 1.04445], "91": [0.95003, 1.45, 0, 0, 0.52778], "92": [0.95003, 1.45, 0, 0, 1.04445], "93": [0.95003, 1.45, 0, 0, 0.52778], "123": [0.95003, 1.45, 0, 0, 0.75], "125": [0.95003, 1.45, 0, 0, 0.75], "160": [0, 0, 0, 0, 0.25], "710": [0, 0.75, 0, 0, 1.44445], "732": [0, 0.75, 0, 0, 1.44445], "770": [0, 0.75, 0, 0, 1.44445], "771": [0, 0.75, 0, 0, 1.44445], "8730": [0.95003, 1.45, 0, 0, 1], "8968": [0.95003, 1.45, 0, 0, 0.58334], "8969": [0.95003, 1.45, 0, 0, 0.58334], "8970": [0.95003, 1.45, 0, 0, 0.58334], "8971": [0.95003, 1.45, 0, 0, 0.58334], "10216": [0.95003, 1.45, 0, 0, 0.75], "10217": [0.95003, 1.45, 0, 0, 0.75] }, "Size4-Regular": { "32": [0, 0, 0, 0, 0.25], "40": [1.25003, 1.75, 0, 0, 0.79167], "41": [1.25003, 1.75, 0, 0, 0.79167], "47": [1.25003, 1.75, 0, 0, 1.27778], "91": [1.25003, 1.75, 0, 0, 0.58334], "92": [1.25003, 1.75, 0, 0, 1.27778], "93": [1.25003, 1.75, 0, 0, 0.58334], "123": [1.25003, 1.75, 0, 0, 0.80556], "125": [1.25003, 1.75, 0, 0, 0.80556], "160": [0, 0, 0, 0, 0.25], "710": [0, 0.825, 0, 0, 1.8889], "732": [0, 0.825, 0, 0, 1.8889], "770": [0, 0.825, 0, 0, 1.8889], "771": [0, 0.825, 0, 0, 1.8889], "8730": [1.25003, 1.75, 0, 0, 1], "8968": [1.25003, 1.75, 0, 0, 0.63889], "8969": [1.25003, 1.75, 0, 0, 0.63889], "8970": [1.25003, 1.75, 0, 0, 0.63889], "8971": [1.25003, 1.75, 0, 0, 0.63889], "9115": [0.64502, 1.155, 0, 0, 0.875], "9116": [1e-5, 0.6, 0, 0, 0.875], "9117": [0.64502, 1.155, 0, 0, 0.875], "9118": [0.64502, 1.155, 0, 0, 0.875], "9119": [1e-5, 0.6, 0, 0, 0.875], "9120": [0.64502, 1.155, 0, 0, 0.875], "9121": [0.64502, 1.155, 0, 0, 0.66667], "9122": [-99e-5, 0.601, 0, 0, 0.66667], "9123": [0.64502, 1.155, 0, 0, 0.66667], "9124": [0.64502, 1.155, 0, 0, 0.66667], "9125": [-99e-5, 0.601, 0, 0, 0.66667], "9126": [0.64502, 1.155, 0, 0, 0.66667], "9127": [1e-5, 0.9, 0, 0, 0.88889], "9128": [0.65002, 1.15, 0, 0, 0.88889], "9129": [0.90001, 0, 0, 0, 0.88889], "9130": [0, 0.3, 0, 0, 0.88889], "9131": [1e-5, 0.9, 0, 0, 0.88889], "9132": [0.65002, 1.15, 0, 0, 0.88889], "9133": [0.90001, 0, 0, 0, 0.88889], "9143": [0.88502, 0.915, 0, 0, 1.05556], "10216": [1.25003, 1.75, 0, 0, 0.80556], "10217": [1.25003, 1.75, 0, 0, 0.80556], "57344": [-499e-5, 0.605, 0, 0, 1.05556], "57345": [-499e-5, 0.605, 0, 0, 1.05556], "57680": [0, 0.12, 0, 0, 0.45], "57681": [0, 0.12, 0, 0, 0.45], "57682": [0, 0.12, 0, 0, 0.45], "57683": [0, 0.12, 0, 0, 0.45] }, "Typewriter-Regular": { "32": [0, 0, 0, 0, 0.525], "33": [0, 0.61111, 0, 0, 0.525], "34": [0, 0.61111, 0, 0, 0.525], "35": [0, 0.61111, 0, 0, 0.525], "36": [0.08333, 0.69444, 0, 0, 0.525], "37": [0.08333, 0.69444, 0, 0, 0.525], "38": [0, 0.61111, 0, 0, 0.525], "39": [0, 0.61111, 0, 0, 0.525], "40": [0.08333, 0.69444, 0, 0, 0.525], "41": [0.08333, 0.69444, 0, 0, 0.525], "42": [0, 0.52083, 0, 0, 0.525], "43": [-0.08056, 0.53055, 0, 0, 0.525], "44": [0.13889, 0.125, 0, 0, 0.525], "45": [-0.08056, 0.53055, 0, 0, 0.525], "46": [0, 0.125, 0, 0, 0.525], "47": [0.08333, 0.69444, 0, 0, 0.525], "48": [0, 0.61111, 0, 0, 0.525], "49": [0, 0.61111, 0, 0, 0.525], "50": [0, 0.61111, 0, 0, 0.525], "51": [0, 0.61111, 0, 0, 0.525], "52": [0, 0.61111, 0, 0, 0.525], "53": [0, 0.61111, 0, 0, 0.525], "54": [0, 0.61111, 0, 0, 0.525], "55": [0, 0.61111, 0, 0, 0.525], "56": [0, 0.61111, 0, 0, 0.525], "57": [0, 0.61111, 0, 0, 0.525], "58": [0, 0.43056, 0, 0, 0.525], "59": [0.13889, 0.43056, 0, 0, 0.525], "60": [-0.05556, 0.55556, 0, 0, 0.525], "61": [-0.19549, 0.41562, 0, 0, 0.525], "62": [-0.05556, 0.55556, 0, 0, 0.525], "63": [0, 0.61111, 0, 0, 0.525], "64": [0, 0.61111, 0, 0, 0.525], "65": [0, 0.61111, 0, 0, 0.525], "66": [0, 0.61111, 0, 0, 0.525], "67": [0, 0.61111, 0, 0, 0.525], "68": [0, 0.61111, 0, 0, 0.525], "69": [0, 0.61111, 0, 0, 0.525], "70": [0, 0.61111, 0, 0, 0.525], "71": [0, 0.61111, 0, 0, 0.525], "72": [0, 0.61111, 0, 0, 0.525], "73": [0, 0.61111, 0, 0, 0.525], "74": [0, 0.61111, 0, 0, 0.525], "75": [0, 0.61111, 0, 0, 0.525], "76": [0, 0.61111, 0, 0, 0.525], "77": [0, 0.61111, 0, 0, 0.525], "78": [0, 0.61111, 0, 0, 0.525], "79": [0, 0.61111, 0, 0, 0.525], "80": [0, 0.61111, 0, 0, 0.525], "81": [0.13889, 0.61111, 0, 0, 0.525], "82": [0, 0.61111, 0, 0, 0.525], "83": [0, 0.61111, 0, 0, 0.525], "84": [0, 0.61111, 0, 0, 0.525], "85": [0, 0.61111, 0, 0, 0.525], "86": [0, 0.61111, 0, 0, 0.525], "87": [0, 0.61111, 0, 0, 0.525], "88": [0, 0.61111, 0, 0, 0.525], "89": [0, 0.61111, 0, 0, 0.525], "90": [0, 0.61111, 0, 0, 0.525], "91": [0.08333, 0.69444, 0, 0, 0.525], "92": [0.08333, 0.69444, 0, 0, 0.525], "93": [0.08333, 0.69444, 0, 0, 0.525], "94": [0, 0.61111, 0, 0, 0.525], "95": [0.09514, 0, 0, 0, 0.525], "96": [0, 0.61111, 0, 0, 0.525], "97": [0, 0.43056, 0, 0, 0.525], "98": [0, 0.61111, 0, 0, 0.525], "99": [0, 0.43056, 0, 0, 0.525], "100": [0, 0.61111, 0, 0, 0.525], "101": [0, 0.43056, 0, 0, 0.525], "102": [0, 0.61111, 0, 0, 0.525], "103": [0.22222, 0.43056, 0, 0, 0.525], "104": [0, 0.61111, 0, 0, 0.525], "105": [0, 0.61111, 0, 0, 0.525], "106": [0.22222, 0.61111, 0, 0, 0.525], "107": [0, 0.61111, 0, 0, 0.525], "108": [0, 0.61111, 0, 0, 0.525], "109": [0, 0.43056, 0, 0, 0.525], "110": [0, 0.43056, 0, 0, 0.525], "111": [0, 0.43056, 0, 0, 0.525], "112": [0.22222, 0.43056, 0, 0, 0.525], "113": [0.22222, 0.43056, 0, 0, 0.525], "114": [0, 0.43056, 0, 0, 0.525], "115": [0, 0.43056, 0, 0, 0.525], "116": [0, 0.55358, 0, 0, 0.525], "117": [0, 0.43056, 0, 0, 0.525], "118": [0, 0.43056, 0, 0, 0.525], "119": [0, 0.43056, 0, 0, 0.525], "120": [0, 0.43056, 0, 0, 0.525], "121": [0.22222, 0.43056, 0, 0, 0.525], "122": [0, 0.43056, 0, 0, 0.525], "123": [0.08333, 0.69444, 0, 0, 0.525], "124": [0.08333, 0.69444, 0, 0, 0.525], "125": [0.08333, 0.69444, 0, 0, 0.525], "126": [0, 0.61111, 0, 0, 0.525], "127": [0, 0.61111, 0, 0, 0.525], "160": [0, 0, 0, 0, 0.525], "176": [0, 0.61111, 0, 0, 0.525], "184": [0.19445, 0, 0, 0, 0.525], "305": [0, 0.43056, 0, 0, 0.525], "567": [0.22222, 0.43056, 0, 0, 0.525], "711": [0, 0.56597, 0, 0, 0.525], "713": [0, 0.56555, 0, 0, 0.525], "714": [0, 0.61111, 0, 0, 0.525], "715": [0, 0.61111, 0, 0, 0.525], "728": [0, 0.61111, 0, 0, 0.525], "730": [0, 0.61111, 0, 0, 0.525], "770": [0, 0.61111, 0, 0, 0.525], "771": [0, 0.61111, 0, 0, 0.525], "776": [0, 0.61111, 0, 0, 0.525], "915": [0, 0.61111, 0, 0, 0.525], "916": [0, 0.61111, 0, 0, 0.525], "920": [0, 0.61111, 0, 0, 0.525], "923": [0, 0.61111, 0, 0, 0.525], "926": [0, 0.61111, 0, 0, 0.525], "928": [0, 0.61111, 0, 0, 0.525], "931": [0, 0.61111, 0, 0, 0.525], "933": [0, 0.61111, 0, 0, 0.525], "934": [0, 0.61111, 0, 0, 0.525], "936": [0, 0.61111, 0, 0, 0.525], "937": [0, 0.61111, 0, 0, 0.525], "8216": [0, 0.61111, 0, 0, 0.525], "8217": [0, 0.61111, 0, 0, 0.525], "8242": [0, 0.61111, 0, 0, 0.525], "9251": [0.11111, 0.21944, 0, 0, 0.525] } }, tn = { slant: [0.25, 0.25, 0.25], space: [0, 0, 0], stretch: [0, 0, 0], shrink: [0, 0, 0], xHeight: [0.431, 0.431, 0.431], quad: [1, 1.171, 1.472], extraSpace: [0, 0, 0], num1: [0.677, 0.732, 0.925], num2: [0.394, 0.384, 0.387], num3: [0.444, 0.471, 0.504], denom1: [0.686, 0.752, 1.025], denom2: [0.345, 0.344, 0.532], sup1: [0.413, 0.503, 0.504], sup2: [0.363, 0.431, 0.404], sup3: [0.289, 0.286, 0.294], sub1: [0.15, 0.143, 0.2], sub2: [0.247, 0.286, 0.4], supDrop: [0.386, 0.353, 0.494], subDrop: [0.05, 0.071, 0.1], delim1: [2.39, 1.7, 1.98], delim2: [1.01, 1.157, 1.42], axisHeight: [0.25, 0.25, 0.25], defaultRuleThickness: [0.04, 0.049, 0.049], bigOpSpacing1: [0.111, 0.111, 0.111], bigOpSpacing2: [0.166, 0.166, 0.166], bigOpSpacing3: [0.2, 0.2, 0.2], bigOpSpacing4: [0.6, 0.611, 0.611], bigOpSpacing5: [0.1, 0.143, 0.143], sqrtRuleThickness: [0.04, 0.04, 0.04], ptPerEm: [10, 10, 10], doubleRuleSep: [0.2, 0.2, 0.2], arrayRuleWidth: [0.04, 0.04, 0.04], fboxsep: [0.3, 0.3, 0.3], fboxrule: [0.04, 0.04, 0.04] }, Ei = { \u00C5: "A", \u00D0: "D", \u00DE: "o", \u00E5: "a", \u00F0: "d", \u00FE: "o", \u0410: "A", \u0411: "B", \u0412: "B", \u0413: "F", \u0414: "A", \u0415: "E", \u0416: "K", \u0417: "3", \u0418: "N", \u0419: "N", \u041A: "K", \u041B: "N", \u041C: "M", \u041D: "H", \u041E: "O", \u041F: "N", \u0420: "P", \u0421: "C", \u0422: "T", \u0423: "y", \u0424: "O", \u0425: "X", \u0426: "U", \u0427: "h", \u0428: "W", \u0429: "W", \u042A: "B", \u042B: "X", \u042C: "B", \u042D: "3", \u042E: "X", \u042F: "R", \u0430: "a", \u0431: "b", \u0432: "a", \u0433: "r", \u0434: "y", \u0435: "e", \u0436: "m", \u0437: "e", \u0438: "n", \u0439: "n", \u043A: "n", \u043B: "n", \u043C: "m", \u043D: "n", \u043E: "o", \u043F: "n", \u0440: "p", \u0441: "c", \u0442: "o", \u0443: "y", \u0444: "b", \u0445: "x", \u0446: "n", \u0447: "n", \u0448: "w", \u0449: "w", \u044A: "a", \u044B: "m", \u044C: "a", \u044D: "e", \u044E: "m", \u044F: "r" };
        function Ba(g, i) {
          Gr[g] = i;
        }
        function jn(g, i, a) {
          if (!Gr[i])
            throw new Error("Font metrics not found for font: " + i + ".");
          var o = g.charCodeAt(0), l = Gr[i][o];
          if (!l && g[0] in Ei && (o = Ei[g[0]].charCodeAt(0), l = Gr[i][o]), !l && a === "text" && J1(o) && (l = Gr[i][77]), l)
            return { depth: l[0], height: l[1], italic: l[2], skew: l[3], width: l[4] };
        }
        var Un = {};
        function Na(g) {
          var i;
          if (g >= 5 ? i = 0 : g >= 3 ? i = 1 : i = 2, !Un[i]) {
            var a = Un[i] = { cssEmPerMu: tn.quad[i] / 18 };
            for (var o in tn)
              tn.hasOwnProperty(o) && (a[o] = tn[o][i]);
          }
          return Un[i];
        }
        var Oa = { bin: 1, close: 1, inner: 1, open: 1, punct: 1, rel: 1 }, Mu = { "accent-token": 1, mathord: 1, "op-token": 1, spacing: 1, textord: 1 }, Ci = { math: {}, text: {} }, xt = Ci;
        function h(g, i, a, o, l, f) {
          Ci[g][l] = { font: i, group: a, replace: o }, f && o && (Ci[g][o] = Ci[g][l]);
        }
        var v = "math", te = "text", x = "main", M = "ams", gt = "accent-token", ue = "bin", sr = "close", rn = "inner", Te = "mathord", Tt = "op-token", Ar = "open", nn = "punct", B = "rel", I1 = "spacing", L = "textord";
        h(v, x, B, "\u2261", "\\equiv", true), h(v, x, B, "\u227A", "\\prec", true), h(v, x, B, "\u227B", "\\succ", true), h(v, x, B, "\u223C", "\\sim", true), h(v, x, B, "\u22A5", "\\perp"), h(v, x, B, "\u2AAF", "\\preceq", true), h(v, x, B, "\u2AB0", "\\succeq", true), h(v, x, B, "\u2243", "\\simeq", true), h(v, x, B, "\u2223", "\\mid", true), h(v, x, B, "\u226A", "\\ll", true), h(v, x, B, "\u226B", "\\gg", true), h(v, x, B, "\u224D", "\\asymp", true), h(v, x, B, "\u2225", "\\parallel"), h(v, x, B, "\u22C8", "\\bowtie", true), h(v, x, B, "\u2323", "\\smile", true), h(v, x, B, "\u2291", "\\sqsubseteq", true), h(v, x, B, "\u2292", "\\sqsupseteq", true), h(v, x, B, "\u2250", "\\doteq", true), h(v, x, B, "\u2322", "\\frown", true), h(v, x, B, "\u220B", "\\ni", true), h(v, x, B, "\u221D", "\\propto", true), h(v, x, B, "\u22A2", "\\vdash", true), h(v, x, B, "\u22A3", "\\dashv", true), h(v, x, B, "\u220B", "\\owns"), h(v, x, nn, ".", "\\ldotp"), h(v, x, nn, "\u22C5", "\\cdotp"), h(v, x, L, "#", "\\#"), h(te, x, L, "#", "\\#"), h(v, x, L, "&", "\\&"), h(te, x, L, "&", "\\&"), h(v, x, L, "\u2135", "\\aleph", true), h(v, x, L, "\u2200", "\\forall", true), h(v, x, L, "\u210F", "\\hbar", true), h(v, x, L, "\u2203", "\\exists", true), h(v, x, L, "\u2207", "\\nabla", true), h(v, x, L, "\u266D", "\\flat", true), h(v, x, L, "\u2113", "\\ell", true), h(v, x, L, "\u266E", "\\natural", true), h(v, x, L, "\u2663", "\\clubsuit", true), h(v, x, L, "\u2118", "\\wp", true), h(v, x, L, "\u266F", "\\sharp", true), h(v, x, L, "\u2662", "\\diamondsuit", true), h(v, x, L, "\u211C", "\\Re", true), h(v, x, L, "\u2661", "\\heartsuit", true), h(v, x, L, "\u2111", "\\Im", true), h(v, x, L, "\u2660", "\\spadesuit", true), h(v, x, L, "\xA7", "\\S", true), h(te, x, L, "\xA7", "\\S"), h(v, x, L, "\xB6", "\\P", true), h(te, x, L, "\xB6", "\\P"), h(v, x, L, "\u2020", "\\dag"), h(te, x, L, "\u2020", "\\dag"), h(te, x, L, "\u2020", "\\textdagger"), h(v, x, L, "\u2021", "\\ddag"), h(te, x, L, "\u2021", "\\ddag"), h(te, x, L, "\u2021", "\\textdaggerdbl"), h(v, x, sr, "\u23B1", "\\rmoustache", true), h(v, x, Ar, "\u23B0", "\\lmoustache", true), h(v, x, sr, "\u27EF", "\\rgroup", true), h(v, x, Ar, "\u27EE", "\\lgroup", true), h(v, x, ue, "\u2213", "\\mp", true), h(v, x, ue, "\u2296", "\\ominus", true), h(v, x, ue, "\u228E", "\\uplus", true), h(v, x, ue, "\u2293", "\\sqcap", true), h(v, x, ue, "\u2217", "\\ast"), h(v, x, ue, "\u2294", "\\sqcup", true), h(v, x, ue, "\u25EF", "\\bigcirc", true), h(v, x, ue, "\u2219", "\\bullet"), h(v, x, ue, "\u2021", "\\ddagger"), h(v, x, ue, "\u2240", "\\wr", true), h(v, x, ue, "\u2A3F", "\\amalg"), h(v, x, ue, "&", "\\And"), h(v, x, B, "\u27F5", "\\longleftarrow", true), h(v, x, B, "\u21D0", "\\Leftarrow", true), h(v, x, B, "\u27F8", "\\Longleftarrow", true), h(v, x, B, "\u27F6", "\\longrightarrow", true), h(v, x, B, "\u21D2", "\\Rightarrow", true), h(v, x, B, "\u27F9", "\\Longrightarrow", true), h(v, x, B, "\u2194", "\\leftrightarrow", true), h(v, x, B, "\u27F7", "\\longleftrightarrow", true), h(v, x, B, "\u21D4", "\\Leftrightarrow", true), h(v, x, B, "\u27FA", "\\Longleftrightarrow", true), h(v, x, B, "\u21A6", "\\mapsto", true), h(v, x, B, "\u27FC", "\\longmapsto", true), h(v, x, B, "\u2197", "\\nearrow", true), h(v, x, B, "\u21A9", "\\hookleftarrow", true), h(v, x, B, "\u21AA", "\\hookrightarrow", true), h(v, x, B, "\u2198", "\\searrow", true), h(v, x, B, "\u21BC", "\\leftharpoonup", true), h(v, x, B, "\u21C0", "\\rightharpoonup", true), h(v, x, B, "\u2199", "\\swarrow", true), h(v, x, B, "\u21BD", "\\leftharpoondown", true), h(v, x, B, "\u21C1", "\\rightharpoondown", true), h(v, x, B, "\u2196", "\\nwarrow", true), h(v, x, B, "\u21CC", "\\rightleftharpoons", true), h(v, M, B, "\u226E", "\\nless", true), h(v, M, B, "\uE010", "\\@nleqslant"), h(v, M, B, "\uE011", "\\@nleqq"), h(v, M, B, "\u2A87", "\\lneq", true), h(v, M, B, "\u2268", "\\lneqq", true), h(v, M, B, "\uE00C", "\\@lvertneqq"), h(v, M, B, "\u22E6", "\\lnsim", true), h(v, M, B, "\u2A89", "\\lnapprox", true), h(v, M, B, "\u2280", "\\nprec", true), h(v, M, B, "\u22E0", "\\npreceq", true), h(v, M, B, "\u22E8", "\\precnsim", true), h(v, M, B, "\u2AB9", "\\precnapprox", true), h(v, M, B, "\u2241", "\\nsim", true), h(v, M, B, "\uE006", "\\@nshortmid"), h(v, M, B, "\u2224", "\\nmid", true), h(v, M, B, "\u22AC", "\\nvdash", true), h(v, M, B, "\u22AD", "\\nvDash", true), h(v, M, B, "\u22EA", "\\ntriangleleft"), h(v, M, B, "\u22EC", "\\ntrianglelefteq", true), h(v, M, B, "\u228A", "\\subsetneq", true), h(v, M, B, "\uE01A", "\\@varsubsetneq"), h(v, M, B, "\u2ACB", "\\subsetneqq", true), h(v, M, B, "\uE017", "\\@varsubsetneqq"), h(v, M, B, "\u226F", "\\ngtr", true), h(v, M, B, "\uE00F", "\\@ngeqslant"), h(v, M, B, "\uE00E", "\\@ngeqq"), h(v, M, B, "\u2A88", "\\gneq", true), h(v, M, B, "\u2269", "\\gneqq", true), h(v, M, B, "\uE00D", "\\@gvertneqq"), h(v, M, B, "\u22E7", "\\gnsim", true), h(v, M, B, "\u2A8A", "\\gnapprox", true), h(v, M, B, "\u2281", "\\nsucc", true), h(v, M, B, "\u22E1", "\\nsucceq", true), h(v, M, B, "\u22E9", "\\succnsim", true), h(v, M, B, "\u2ABA", "\\succnapprox", true), h(v, M, B, "\u2246", "\\ncong", true), h(v, M, B, "\uE007", "\\@nshortparallel"), h(v, M, B, "\u2226", "\\nparallel", true), h(v, M, B, "\u22AF", "\\nVDash", true), h(v, M, B, "\u22EB", "\\ntriangleright"), h(v, M, B, "\u22ED", "\\ntrianglerighteq", true), h(v, M, B, "\uE018", "\\@nsupseteqq"), h(v, M, B, "\u228B", "\\supsetneq", true), h(v, M, B, "\uE01B", "\\@varsupsetneq"), h(v, M, B, "\u2ACC", "\\supsetneqq", true), h(v, M, B, "\uE019", "\\@varsupsetneqq"), h(v, M, B, "\u22AE", "\\nVdash", true), h(v, M, B, "\u2AB5", "\\precneqq", true), h(v, M, B, "\u2AB6", "\\succneqq", true), h(v, M, B, "\uE016", "\\@nsubseteqq"), h(v, M, ue, "\u22B4", "\\unlhd"), h(v, M, ue, "\u22B5", "\\unrhd"), h(v, M, B, "\u219A", "\\nleftarrow", true), h(v, M, B, "\u219B", "\\nrightarrow", true), h(v, M, B, "\u21CD", "\\nLeftarrow", true), h(v, M, B, "\u21CF", "\\nRightarrow", true), h(v, M, B, "\u21AE", "\\nleftrightarrow", true), h(v, M, B, "\u21CE", "\\nLeftrightarrow", true), h(v, M, B, "\u25B3", "\\vartriangle"), h(v, M, L, "\u210F", "\\hslash"), h(v, M, L, "\u25BD", "\\triangledown"), h(v, M, L, "\u25CA", "\\lozenge"), h(v, M, L, "\u24C8", "\\circledS"), h(v, M, L, "\xAE", "\\circledR"), h(te, M, L, "\xAE", "\\circledR"), h(v, M, L, "\u2221", "\\measuredangle", true), h(v, M, L, "\u2204", "\\nexists"), h(v, M, L, "\u2127", "\\mho"), h(v, M, L, "\u2132", "\\Finv", true), h(v, M, L, "\u2141", "\\Game", true), h(v, M, L, "\u2035", "\\backprime"), h(v, M, L, "\u25B2", "\\blacktriangle"), h(v, M, L, "\u25BC", "\\blacktriangledown"), h(v, M, L, "\u25A0", "\\blacksquare"), h(v, M, L, "\u29EB", "\\blacklozenge"), h(v, M, L, "\u2605", "\\bigstar"), h(v, M, L, "\u2222", "\\sphericalangle", true), h(v, M, L, "\u2201", "\\complement", true), h(v, M, L, "\xF0", "\\eth", true), h(te, x, L, "\xF0", "\xF0"), h(v, M, L, "\u2571", "\\diagup"), h(v, M, L, "\u2572", "\\diagdown"), h(v, M, L, "\u25A1", "\\square"), h(v, M, L, "\u25A1", "\\Box"), h(v, M, L, "\u25CA", "\\Diamond"), h(v, M, L, "\xA5", "\\yen", true), h(te, M, L, "\xA5", "\\yen", true), h(v, M, L, "\u2713", "\\checkmark", true), h(te, M, L, "\u2713", "\\checkmark"), h(v, M, L, "\u2136", "\\beth", true), h(v, M, L, "\u2138", "\\daleth", true), h(v, M, L, "\u2137", "\\gimel", true), h(v, M, L, "\u03DD", "\\digamma", true), h(v, M, L, "\u03F0", "\\varkappa"), h(v, M, Ar, "\u250C", "\\@ulcorner", true), h(v, M, sr, "\u2510", "\\@urcorner", true), h(v, M, Ar, "\u2514", "\\@llcorner", true), h(v, M, sr, "\u2518", "\\@lrcorner", true), h(v, M, B, "\u2266", "\\leqq", true), h(v, M, B, "\u2A7D", "\\leqslant", true), h(v, M, B, "\u2A95", "\\eqslantless", true), h(v, M, B, "\u2272", "\\lesssim", true), h(v, M, B, "\u2A85", "\\lessapprox", true), h(v, M, B, "\u224A", "\\approxeq", true), h(v, M, ue, "\u22D6", "\\lessdot"), h(v, M, B, "\u22D8", "\\lll", true), h(v, M, B, "\u2276", "\\lessgtr", true), h(v, M, B, "\u22DA", "\\lesseqgtr", true), h(v, M, B, "\u2A8B", "\\lesseqqgtr", true), h(v, M, B, "\u2251", "\\doteqdot"), h(v, M, B, "\u2253", "\\risingdotseq", true), h(v, M, B, "\u2252", "\\fallingdotseq", true), h(v, M, B, "\u223D", "\\backsim", true), h(v, M, B, "\u22CD", "\\backsimeq", true), h(v, M, B, "\u2AC5", "\\subseteqq", true), h(v, M, B, "\u22D0", "\\Subset", true), h(v, M, B, "\u228F", "\\sqsubset", true), h(v, M, B, "\u227C", "\\preccurlyeq", true), h(v, M, B, "\u22DE", "\\curlyeqprec", true), h(v, M, B, "\u227E", "\\precsim", true), h(v, M, B, "\u2AB7", "\\precapprox", true), h(v, M, B, "\u22B2", "\\vartriangleleft"), h(v, M, B, "\u22B4", "\\trianglelefteq"), h(v, M, B, "\u22A8", "\\vDash", true), h(v, M, B, "\u22AA", "\\Vvdash", true), h(v, M, B, "\u2323", "\\smallsmile"), h(v, M, B, "\u2322", "\\smallfrown"), h(v, M, B, "\u224F", "\\bumpeq", true), h(v, M, B, "\u224E", "\\Bumpeq", true), h(v, M, B, "\u2267", "\\geqq", true), h(v, M, B, "\u2A7E", "\\geqslant", true), h(v, M, B, "\u2A96", "\\eqslantgtr", true), h(v, M, B, "\u2273", "\\gtrsim", true), h(v, M, B, "\u2A86", "\\gtrapprox", true), h(v, M, ue, "\u22D7", "\\gtrdot"), h(v, M, B, "\u22D9", "\\ggg", true), h(v, M, B, "\u2277", "\\gtrless", true), h(v, M, B, "\u22DB", "\\gtreqless", true), h(v, M, B, "\u2A8C", "\\gtreqqless", true), h(v, M, B, "\u2256", "\\eqcirc", true), h(v, M, B, "\u2257", "\\circeq", true), h(v, M, B, "\u225C", "\\triangleq", true), h(v, M, B, "\u223C", "\\thicksim"), h(v, M, B, "\u2248", "\\thickapprox"), h(v, M, B, "\u2AC6", "\\supseteqq", true), h(v, M, B, "\u22D1", "\\Supset", true), h(v, M, B, "\u2290", "\\sqsupset", true), h(v, M, B, "\u227D", "\\succcurlyeq", true), h(v, M, B, "\u22DF", "\\curlyeqsucc", true), h(v, M, B, "\u227F", "\\succsim", true), h(v, M, B, "\u2AB8", "\\succapprox", true), h(v, M, B, "\u22B3", "\\vartriangleright"), h(v, M, B, "\u22B5", "\\trianglerighteq"), h(v, M, B, "\u22A9", "\\Vdash", true), h(v, M, B, "\u2223", "\\shortmid"), h(v, M, B, "\u2225", "\\shortparallel"), h(v, M, B, "\u226C", "\\between", true), h(v, M, B, "\u22D4", "\\pitchfork", true), h(v, M, B, "\u221D", "\\varpropto"), h(v, M, B, "\u25C0", "\\blacktriangleleft"), h(v, M, B, "\u2234", "\\therefore", true), h(v, M, B, "\u220D", "\\backepsilon"), h(v, M, B, "\u25B6", "\\blacktriangleright"), h(v, M, B, "\u2235", "\\because", true), h(v, M, B, "\u22D8", "\\llless"), h(v, M, B, "\u22D9", "\\gggtr"), h(v, M, ue, "\u22B2", "\\lhd"), h(v, M, ue, "\u22B3", "\\rhd"), h(v, M, B, "\u2242", "\\eqsim", true), h(v, x, B, "\u22C8", "\\Join"), h(v, M, B, "\u2251", "\\Doteq", true), h(v, M, ue, "\u2214", "\\dotplus", true), h(v, M, ue, "\u2216", "\\smallsetminus"), h(v, M, ue, "\u22D2", "\\Cap", true), h(v, M, ue, "\u22D3", "\\Cup", true), h(v, M, ue, "\u2A5E", "\\doublebarwedge", true), h(v, M, ue, "\u229F", "\\boxminus", true), h(v, M, ue, "\u229E", "\\boxplus", true), h(v, M, ue, "\u22C7", "\\divideontimes", true), h(v, M, ue, "\u22C9", "\\ltimes", true), h(v, M, ue, "\u22CA", "\\rtimes", true), h(v, M, ue, "\u22CB", "\\leftthreetimes", true), h(v, M, ue, "\u22CC", "\\rightthreetimes", true), h(v, M, ue, "\u22CF", "\\curlywedge", true), h(v, M, ue, "\u22CE", "\\curlyvee", true), h(v, M, ue, "\u229D", "\\circleddash", true), h(v, M, ue, "\u229B", "\\circledast", true), h(v, M, ue, "\u22C5", "\\centerdot"), h(v, M, ue, "\u22BA", "\\intercal", true), h(v, M, ue, "\u22D2", "\\doublecap"), h(v, M, ue, "\u22D3", "\\doublecup"), h(v, M, ue, "\u22A0", "\\boxtimes", true), h(v, M, B, "\u21E2", "\\dashrightarrow", true), h(v, M, B, "\u21E0", "\\dashleftarrow", true), h(v, M, B, "\u21C7", "\\leftleftarrows", true), h(v, M, B, "\u21C6", "\\leftrightarrows", true), h(v, M, B, "\u21DA", "\\Lleftarrow", true), h(v, M, B, "\u219E", "\\twoheadleftarrow", true), h(v, M, B, "\u21A2", "\\leftarrowtail", true), h(v, M, B, "\u21AB", "\\looparrowleft", true), h(v, M, B, "\u21CB", "\\leftrightharpoons", true), h(v, M, B, "\u21B6", "\\curvearrowleft", true), h(v, M, B, "\u21BA", "\\circlearrowleft", true), h(v, M, B, "\u21B0", "\\Lsh", true), h(v, M, B, "\u21C8", "\\upuparrows", true), h(v, M, B, "\u21BF", "\\upharpoonleft", true), h(v, M, B, "\u21C3", "\\downharpoonleft", true), h(v, x, B, "\u22B6", "\\origof", true), h(v, x, B, "\u22B7", "\\imageof", true), h(v, M, B, "\u22B8", "\\multimap", true), h(v, M, B, "\u21AD", "\\leftrightsquigarrow", true), h(v, M, B, "\u21C9", "\\rightrightarrows", true), h(v, M, B, "\u21C4", "\\rightleftarrows", true), h(v, M, B, "\u21A0", "\\twoheadrightarrow", true), h(v, M, B, "\u21A3", "\\rightarrowtail", true), h(v, M, B, "\u21AC", "\\looparrowright", true), h(v, M, B, "\u21B7", "\\curvearrowright", true), h(v, M, B, "\u21BB", "\\circlearrowright", true), h(v, M, B, "\u21B1", "\\Rsh", true), h(v, M, B, "\u21CA", "\\downdownarrows", true), h(v, M, B, "\u21BE", "\\upharpoonright", true), h(v, M, B, "\u21C2", "\\downharpoonright", true), h(v, M, B, "\u21DD", "\\rightsquigarrow", true), h(v, M, B, "\u21DD", "\\leadsto"), h(v, M, B, "\u21DB", "\\Rrightarrow", true), h(v, M, B, "\u21BE", "\\restriction"), h(v, x, L, "\u2018", "`"), h(v, x, L, "$", "\\$"), h(te, x, L, "$", "\\$"), h(te, x, L, "$", "\\textdollar"), h(v, x, L, "%", "\\%"), h(te, x, L, "%", "\\%"), h(v, x, L, "_", "\\_"), h(te, x, L, "_", "\\_"), h(te, x, L, "_", "\\textunderscore"), h(v, x, L, "\u2220", "\\angle", true), h(v, x, L, "\u221E", "\\infty", true), h(v, x, L, "\u2032", "\\prime"), h(v, x, L, "\u25B3", "\\triangle"), h(v, x, L, "\u0393", "\\Gamma", true), h(v, x, L, "\u0394", "\\Delta", true), h(v, x, L, "\u0398", "\\Theta", true), h(v, x, L, "\u039B", "\\Lambda", true), h(v, x, L, "\u039E", "\\Xi", true), h(v, x, L, "\u03A0", "\\Pi", true), h(v, x, L, "\u03A3", "\\Sigma", true), h(v, x, L, "\u03A5", "\\Upsilon", true), h(v, x, L, "\u03A6", "\\Phi", true), h(v, x, L, "\u03A8", "\\Psi", true), h(v, x, L, "\u03A9", "\\Omega", true), h(v, x, L, "A", "\u0391"), h(v, x, L, "B", "\u0392"), h(v, x, L, "E", "\u0395"), h(v, x, L, "Z", "\u0396"), h(v, x, L, "H", "\u0397"), h(v, x, L, "I", "\u0399"), h(v, x, L, "K", "\u039A"), h(v, x, L, "M", "\u039C"), h(v, x, L, "N", "\u039D"), h(v, x, L, "O", "\u039F"), h(v, x, L, "P", "\u03A1"), h(v, x, L, "T", "\u03A4"), h(v, x, L, "X", "\u03A7"), h(v, x, L, "\xAC", "\\neg", true), h(v, x, L, "\xAC", "\\lnot"), h(v, x, L, "\u22A4", "\\top"), h(v, x, L, "\u22A5", "\\bot"), h(v, x, L, "\u2205", "\\emptyset"), h(v, M, L, "\u2205", "\\varnothing"), h(v, x, Te, "\u03B1", "\\alpha", true), h(v, x, Te, "\u03B2", "\\beta", true), h(v, x, Te, "\u03B3", "\\gamma", true), h(v, x, Te, "\u03B4", "\\delta", true), h(v, x, Te, "\u03F5", "\\epsilon", true), h(v, x, Te, "\u03B6", "\\zeta", true), h(v, x, Te, "\u03B7", "\\eta", true), h(v, x, Te, "\u03B8", "\\theta", true), h(v, x, Te, "\u03B9", "\\iota", true), h(v, x, Te, "\u03BA", "\\kappa", true), h(v, x, Te, "\u03BB", "\\lambda", true), h(v, x, Te, "\u03BC", "\\mu", true), h(v, x, Te, "\u03BD", "\\nu", true), h(v, x, Te, "\u03BE", "\\xi", true), h(v, x, Te, "\u03BF", "\\omicron", true), h(v, x, Te, "\u03C0", "\\pi", true), h(v, x, Te, "\u03C1", "\\rho", true), h(v, x, Te, "\u03C3", "\\sigma", true), h(v, x, Te, "\u03C4", "\\tau", true), h(v, x, Te, "\u03C5", "\\upsilon", true), h(v, x, Te, "\u03D5", "\\phi", true), h(v, x, Te, "\u03C7", "\\chi", true), h(v, x, Te, "\u03C8", "\\psi", true), h(v, x, Te, "\u03C9", "\\omega", true), h(v, x, Te, "\u03B5", "\\varepsilon", true), h(v, x, Te, "\u03D1", "\\vartheta", true), h(v, x, Te, "\u03D6", "\\varpi", true), h(v, x, Te, "\u03F1", "\\varrho", true), h(v, x, Te, "\u03C2", "\\varsigma", true), h(v, x, Te, "\u03C6", "\\varphi", true), h(v, x, ue, "\u2217", "*", true), h(v, x, ue, "+", "+"), h(v, x, ue, "\u2212", "-", true), h(v, x, ue, "\u22C5", "\\cdot", true), h(v, x, ue, "\u2218", "\\circ"), h(v, x, ue, "\xF7", "\\div", true), h(v, x, ue, "\xB1", "\\pm", true), h(v, x, ue, "\xD7", "\\times", true), h(v, x, ue, "\u2229", "\\cap", true), h(v, x, ue, "\u222A", "\\cup", true), h(v, x, ue, "\u2216", "\\setminus"), h(v, x, ue, "\u2227", "\\land"), h(v, x, ue, "\u2228", "\\lor"), h(v, x, ue, "\u2227", "\\wedge", true), h(v, x, ue, "\u2228", "\\vee", true), h(v, x, L, "\u221A", "\\surd"), h(v, x, Ar, "\u27E8", "\\langle", true), h(v, x, Ar, "\u2223", "\\lvert"), h(v, x, Ar, "\u2225", "\\lVert"), h(v, x, sr, "?", "?"), h(v, x, sr, "!", "!"), h(v, x, sr, "\u27E9", "\\rangle", true), h(v, x, sr, "\u2223", "\\rvert"), h(v, x, sr, "\u2225", "\\rVert"), h(v, x, B, "=", "="), h(v, x, B, ":", ":"), h(v, x, B, "\u2248", "\\approx", true), h(v, x, B, "\u2245", "\\cong", true), h(v, x, B, "\u2265", "\\ge"), h(v, x, B, "\u2265", "\\geq", true), h(v, x, B, "\u2190", "\\gets"), h(v, x, B, ">", "\\gt", true), h(v, x, B, "\u2208", "\\in", true), h(v, x, B, "\uE020", "\\@not"), h(v, x, B, "\u2282", "\\subset", true), h(v, x, B, "\u2283", "\\supset", true), h(v, x, B, "\u2286", "\\subseteq", true), h(v, x, B, "\u2287", "\\supseteq", true), h(v, M, B, "\u2288", "\\nsubseteq", true), h(v, M, B, "\u2289", "\\nsupseteq", true), h(v, x, B, "\u22A8", "\\models"), h(v, x, B, "\u2190", "\\leftarrow", true), h(v, x, B, "\u2264", "\\le"), h(v, x, B, "\u2264", "\\leq", true), h(v, x, B, "<", "\\lt", true), h(v, x, B, "\u2192", "\\rightarrow", true), h(v, x, B, "\u2192", "\\to"), h(v, M, B, "\u2271", "\\ngeq", true), h(v, M, B, "\u2270", "\\nleq", true), h(v, x, I1, "\xA0", "\\ "), h(v, x, I1, "\xA0", "\\space"), h(v, x, I1, "\xA0", "\\nobreakspace"), h(te, x, I1, "\xA0", "\\ "), h(te, x, I1, "\xA0", " "), h(te, x, I1, "\xA0", "\\space"), h(te, x, I1, "\xA0", "\\nobreakspace"), h(v, x, I1, null, "\\nobreak"), h(v, x, I1, null, "\\allowbreak"), h(v, x, nn, ",", ","), h(v, x, nn, ";", ";"), h(v, M, ue, "\u22BC", "\\barwedge", true), h(v, M, ue, "\u22BB", "\\veebar", true), h(v, x, ue, "\u2299", "\\odot", true), h(v, x, ue, "\u2295", "\\oplus", true), h(v, x, ue, "\u2297", "\\otimes", true), h(v, x, L, "\u2202", "\\partial", true), h(v, x, ue, "\u2298", "\\oslash", true), h(v, M, ue, "\u229A", "\\circledcirc", true), h(v, M, ue, "\u22A1", "\\boxdot", true), h(v, x, ue, "\u25B3", "\\bigtriangleup"), h(v, x, ue, "\u25BD", "\\bigtriangledown"), h(v, x, ue, "\u2020", "\\dagger"), h(v, x, ue, "\u22C4", "\\diamond"), h(v, x, ue, "\u22C6", "\\star"), h(v, x, ue, "\u25C3", "\\triangleleft"), h(v, x, ue, "\u25B9", "\\triangleright"), h(v, x, Ar, "{", "\\{"), h(te, x, L, "{", "\\{"), h(te, x, L, "{", "\\textbraceleft"), h(v, x, sr, "}", "\\}"), h(te, x, L, "}", "\\}"), h(te, x, L, "}", "\\textbraceright"), h(v, x, Ar, "{", "\\lbrace"), h(v, x, sr, "}", "\\rbrace"), h(v, x, Ar, "[", "\\lbrack", true), h(te, x, L, "[", "\\lbrack", true), h(v, x, sr, "]", "\\rbrack", true), h(te, x, L, "]", "\\rbrack", true), h(v, x, Ar, "(", "\\lparen", true), h(v, x, sr, ")", "\\rparen", true), h(te, x, L, "<", "\\textless", true), h(te, x, L, ">", "\\textgreater", true), h(v, x, Ar, "\u230A", "\\lfloor", true), h(v, x, sr, "\u230B", "\\rfloor", true), h(v, x, Ar, "\u2308", "\\lceil", true), h(v, x, sr, "\u2309", "\\rceil", true), h(v, x, L, "\\", "\\backslash"), h(v, x, L, "\u2223", "|"), h(v, x, L, "\u2223", "\\vert"), h(te, x, L, "|", "\\textbar", true), h(v, x, L, "\u2225", "\\|"), h(v, x, L, "\u2225", "\\Vert"), h(te, x, L, "\u2225", "\\textbardbl"), h(te, x, L, "~", "\\textasciitilde"), h(te, x, L, "\\", "\\textbackslash"), h(te, x, L, "^", "\\textasciicircum"), h(v, x, B, "\u2191", "\\uparrow", true), h(v, x, B, "\u21D1", "\\Uparrow", true), h(v, x, B, "\u2193", "\\downarrow", true), h(v, x, B, "\u21D3", "\\Downarrow", true), h(v, x, B, "\u2195", "\\updownarrow", true), h(v, x, B, "\u21D5", "\\Updownarrow", true), h(v, x, Tt, "\u2210", "\\coprod"), h(v, x, Tt, "\u22C1", "\\bigvee"), h(v, x, Tt, "\u22C0", "\\bigwedge"), h(v, x, Tt, "\u2A04", "\\biguplus"), h(v, x, Tt, "\u22C2", "\\bigcap"), h(v, x, Tt, "\u22C3", "\\bigcup"), h(v, x, Tt, "\u222B", "\\int"), h(v, x, Tt, "\u222B", "\\intop"), h(v, x, Tt, "\u222C", "\\iint"), h(v, x, Tt, "\u222D", "\\iiint"), h(v, x, Tt, "\u220F", "\\prod"), h(v, x, Tt, "\u2211", "\\sum"), h(v, x, Tt, "\u2A02", "\\bigotimes"), h(v, x, Tt, "\u2A01", "\\bigoplus"), h(v, x, Tt, "\u2A00", "\\bigodot"), h(v, x, Tt, "\u222E", "\\oint"), h(v, x, Tt, "\u222F", "\\oiint"), h(v, x, Tt, "\u2230", "\\oiiint"), h(v, x, Tt, "\u2A06", "\\bigsqcup"), h(v, x, Tt, "\u222B", "\\smallint"), h(te, x, rn, "\u2026", "\\textellipsis"), h(v, x, rn, "\u2026", "\\mathellipsis"), h(te, x, rn, "\u2026", "\\ldots", true), h(v, x, rn, "\u2026", "\\ldots", true), h(v, x, rn, "\u22EF", "\\@cdots", true), h(v, x, rn, "\u22F1", "\\ddots", true), h(v, x, L, "\u22EE", "\\varvdots"), h(v, x, gt, "\u02CA", "\\acute"), h(v, x, gt, "\u02CB", "\\grave"), h(v, x, gt, "\xA8", "\\ddot"), h(v, x, gt, "~", "\\tilde"), h(v, x, gt, "\u02C9", "\\bar"), h(v, x, gt, "\u02D8", "\\breve"), h(v, x, gt, "\u02C7", "\\check"), h(v, x, gt, "^", "\\hat"), h(v, x, gt, "\u20D7", "\\vec"), h(v, x, gt, "\u02D9", "\\dot"), h(v, x, gt, "\u02DA", "\\mathring"), h(v, x, Te, "\uE131", "\\@imath"), h(v, x, Te, "\uE237", "\\@jmath"), h(v, x, L, "\u0131", "\u0131"), h(v, x, L, "\u0237", "\u0237"), h(te, x, L, "\u0131", "\\i", true), h(te, x, L, "\u0237", "\\j", true), h(te, x, L, "\xDF", "\\ss", true), h(te, x, L, "\xE6", "\\ae", true), h(te, x, L, "\u0153", "\\oe", true), h(te, x, L, "\xF8", "\\o", true), h(te, x, L, "\xC6", "\\AE", true), h(te, x, L, "\u0152", "\\OE", true), h(te, x, L, "\xD8", "\\O", true), h(te, x, gt, "\u02CA", "\\'"), h(te, x, gt, "\u02CB", "\\`"), h(te, x, gt, "\u02C6", "\\^"), h(te, x, gt, "\u02DC", "\\~"), h(te, x, gt, "\u02C9", "\\="), h(te, x, gt, "\u02D8", "\\u"), h(te, x, gt, "\u02D9", "\\."), h(te, x, gt, "\xB8", "\\c"), h(te, x, gt, "\u02DA", "\\r"), h(te, x, gt, "\u02C7", "\\v"), h(te, x, gt, "\xA8", '\\"'), h(te, x, gt, "\u02DD", "\\H"), h(te, x, gt, "\u25EF", "\\textcircled");
        var os = { "--": true, "---": true, "``": true, "''": true };
        h(te, x, L, "\u2013", "--", true), h(te, x, L, "\u2013", "\\textendash"), h(te, x, L, "\u2014", "---", true), h(te, x, L, "\u2014", "\\textemdash"), h(te, x, L, "\u2018", "`", true), h(te, x, L, "\u2018", "\\textquoteleft"), h(te, x, L, "\u2019", "'", true), h(te, x, L, "\u2019", "\\textquoteright"), h(te, x, L, "\u201C", "``", true), h(te, x, L, "\u201C", "\\textquotedblleft"), h(te, x, L, "\u201D", "''", true), h(te, x, L, "\u201D", "\\textquotedblright"), h(v, x, L, "\xB0", "\\degree", true), h(te, x, L, "\xB0", "\\degree"), h(te, x, L, "\xB0", "\\textdegree", true), h(v, x, L, "\xA3", "\\pounds"), h(v, x, L, "\xA3", "\\mathsterling", true), h(te, x, L, "\xA3", "\\pounds"), h(te, x, L, "\xA3", "\\textsterling", true), h(v, M, L, "\u2720", "\\maltese"), h(te, M, L, "\u2720", "\\maltese");
        for (var ss = '0123456789/@."', qa = 0; qa < ss.length; qa++) {
          var ls = ss.charAt(qa);
          h(v, x, L, ls, ls);
        }
        for (var us = '0123456789!@*()-=+";:?/.,', ki = 0; ki < us.length; ki++) {
          var cs = us.charAt(ki);
          h(te, x, L, cs, cs);
        }
        for (var Mi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", Pa = 0; Pa < Mi.length; Pa++) {
          var Di = Mi.charAt(Pa);
          h(v, x, Te, Di, Di), h(te, x, L, Di, Di);
        }
        h(v, M, L, "C", "\u2102"), h(te, M, L, "C", "\u2102"), h(v, M, L, "H", "\u210D"), h(te, M, L, "H", "\u210D"), h(v, M, L, "N", "\u2115"), h(te, M, L, "N", "\u2115"), h(v, M, L, "P", "\u2119"), h(te, M, L, "P", "\u2119"), h(v, M, L, "Q", "\u211A"), h(te, M, L, "Q", "\u211A"), h(v, M, L, "R", "\u211D"), h(te, M, L, "R", "\u211D"), h(v, M, L, "Z", "\u2124"), h(te, M, L, "Z", "\u2124"), h(v, x, Te, "h", "\u210E"), h(te, x, Te, "h", "\u210E");
        for (var De = "", pr = 0; pr < Mi.length; pr++) {
          var wt = Mi.charAt(pr);
          De = String.fromCharCode(55349, 56320 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56372 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56424 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56580 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56736 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56788 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56840 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56944 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), pr < 26 && (De = String.fromCharCode(55349, 56632 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De), De = String.fromCharCode(55349, 56476 + pr), h(v, x, Te, wt, De), h(te, x, L, wt, De));
        }
        De = String.fromCharCode(55349, 56668), h(v, x, Te, "k", De), h(te, x, L, "k", De);
        for (var _0 = 0; _0 < 10; _0++) {
          var a1 = _0.toString();
          De = String.fromCharCode(55349, 57294 + _0), h(v, x, Te, a1, De), h(te, x, L, a1, De), De = String.fromCharCode(55349, 57314 + _0), h(v, x, Te, a1, De), h(te, x, L, a1, De), De = String.fromCharCode(55349, 57324 + _0), h(v, x, Te, a1, De), h(te, x, L, a1, De), De = String.fromCharCode(55349, 57334 + _0), h(v, x, Te, a1, De), h(te, x, L, a1, De);
        }
        for (var La = "\xD0\xDE\xFE", Ia = 0; Ia < La.length; Ia++) {
          var Bi = La.charAt(Ia);
          h(v, x, Te, Bi, Bi), h(te, x, L, Bi, Bi);
        }
        var Wn = [["mathbf", "textbf", "Main-Bold"], ["mathbf", "textbf", "Main-Bold"], ["mathnormal", "textit", "Math-Italic"], ["mathnormal", "textit", "Math-Italic"], ["boldsymbol", "boldsymbol", "Main-BoldItalic"], ["boldsymbol", "boldsymbol", "Main-BoldItalic"], ["mathscr", "textscr", "Script-Regular"], ["", "", ""], ["", "", ""], ["", "", ""], ["mathfrak", "textfrak", "Fraktur-Regular"], ["mathfrak", "textfrak", "Fraktur-Regular"], ["mathbb", "textbb", "AMS-Regular"], ["mathbb", "textbb", "AMS-Regular"], ["", "", ""], ["", "", ""], ["mathsf", "textsf", "SansSerif-Regular"], ["mathsf", "textsf", "SansSerif-Regular"], ["mathboldsf", "textboldsf", "SansSerif-Bold"], ["mathboldsf", "textboldsf", "SansSerif-Bold"], ["mathitsf", "textitsf", "SansSerif-Italic"], ["mathitsf", "textitsf", "SansSerif-Italic"], ["", "", ""], ["", "", ""], ["mathtt", "texttt", "Typewriter-Regular"], ["mathtt", "texttt", "Typewriter-Regular"]], Ra = [["mathbf", "textbf", "Main-Bold"], ["", "", ""], ["mathsf", "textsf", "SansSerif-Regular"], ["mathboldsf", "textboldsf", "SansSerif-Bold"], ["mathtt", "texttt", "Typewriter-Regular"]], fs = function(i, a) {
          var o = i.charCodeAt(0), l = i.charCodeAt(1), f = (o - 55296) * 1024 + (l - 56320) + 65536, m = a === "math" ? 0 : 1;
          if (119808 <= f && f < 120484) {
            var y = Math.floor((f - 119808) / 26);
            return [Wn[y][2], Wn[y][m]];
          } else if (120782 <= f && f <= 120831) {
            var S = Math.floor((f - 120782) / 10);
            return [Ra[S][2], Ra[S][m]];
          } else {
            if (f === 120485 || f === 120486)
              return [Wn[0][2], Wn[0][m]];
            if (120486 < f && f < 120782)
              return ["", ""];
            throw new c("Unsupported character: " + i);
          }
        }, Du = [[1, 1, 1], [2, 1, 1], [3, 1, 1], [4, 2, 1], [5, 2, 1], [6, 3, 1], [7, 4, 2], [8, 6, 3], [9, 7, 6], [10, 8, 7], [11, 10, 9]], hs = [0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.2, 1.44, 1.728, 2.074, 2.488], ds = function(i, a) {
          return a.size < 2 ? i : Du[i - 1][a.size - 1];
        }, ms = function() {
          function g(a) {
            this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = a.style, this.color = a.color, this.size = a.size || g.BASESIZE, this.textSize = a.textSize || this.size, this.phantom = !!a.phantom, this.font = a.font || "", this.fontFamily = a.fontFamily || "", this.fontWeight = a.fontWeight || "", this.fontShape = a.fontShape || "", this.sizeMultiplier = hs[this.size - 1], this.maxSize = a.maxSize, this.minRuleThickness = a.minRuleThickness, this._fontMetrics = void 0;
          }
          var i = g.prototype;
          return i.extend = function(o) {
            var l = { style: this.style, size: this.size, textSize: this.textSize, color: this.color, phantom: this.phantom, font: this.font, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontShape: this.fontShape, maxSize: this.maxSize, minRuleThickness: this.minRuleThickness };
            for (var f in o)
              o.hasOwnProperty(f) && (l[f] = o[f]);
            return new g(l);
          }, i.havingStyle = function(o) {
            return this.style === o ? this : this.extend({ style: o, size: ds(this.textSize, o) });
          }, i.havingCrampedStyle = function() {
            return this.havingStyle(this.style.cramp());
          }, i.havingSize = function(o) {
            return this.size === o && this.textSize === o ? this : this.extend({ style: this.style.text(), size: o, textSize: o, sizeMultiplier: hs[o - 1] });
          }, i.havingBaseStyle = function(o) {
            o = o || this.style.text();
            var l = ds(g.BASESIZE, o);
            return this.size === l && this.textSize === g.BASESIZE && this.style === o ? this : this.extend({ style: o, size: l });
          }, i.havingBaseSizing = function() {
            var o;
            switch (this.style.id) {
              case 4:
              case 5:
                o = 3;
                break;
              case 6:
              case 7:
                o = 1;
                break;
              default:
                o = 6;
            }
            return this.extend({ style: this.style.text(), size: o });
          }, i.withColor = function(o) {
            return this.extend({ color: o });
          }, i.withPhantom = function() {
            return this.extend({ phantom: true });
          }, i.withFont = function(o) {
            return this.extend({ font: o });
          }, i.withTextFontFamily = function(o) {
            return this.extend({ fontFamily: o, font: "" });
          }, i.withTextFontWeight = function(o) {
            return this.extend({ fontWeight: o, font: "" });
          }, i.withTextFontShape = function(o) {
            return this.extend({ fontShape: o, font: "" });
          }, i.sizingClasses = function(o) {
            return o.size !== this.size ? ["sizing", "reset-size" + o.size, "size" + this.size] : [];
          }, i.baseSizingClasses = function() {
            return this.size !== g.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + g.BASESIZE] : [];
          }, i.fontMetrics = function() {
            return this._fontMetrics || (this._fontMetrics = Na(this.size)), this._fontMetrics;
          }, i.getColor = function() {
            return this.phantom ? "transparent" : this.color;
          }, g;
        }();
        ms.BASESIZE = 6;
        var ps = ms, Ni = { pt: 1, mm: 7227 / 2540, cm: 7227 / 254, in: 72.27, bp: 803 / 800, pc: 12, dd: 1238 / 1157, cc: 14856 / 1157, nd: 685 / 642, nc: 1370 / 107, sp: 1 / 65536, px: 803 / 800 }, gs = { ex: true, em: true, mu: true }, Oi = function(i) {
          return typeof i != "string" && (i = i.unit), i in Ni || i in gs || i === "ex";
        }, _t = function(i, a) {
          var o;
          if (i.unit in Ni)
            o = Ni[i.unit] / a.fontMetrics().ptPerEm / a.sizeMultiplier;
          else if (i.unit === "mu")
            o = a.fontMetrics().cssEmPerMu;
          else {
            var l;
            if (a.style.isTight() ? l = a.havingStyle(a.style.text()) : l = a, i.unit === "ex")
              o = l.fontMetrics().xHeight;
            else if (i.unit === "em")
              o = l.fontMetrics().quad;
            else
              throw new c("Invalid unit: '" + i.unit + "'");
            l !== a && (o *= l.sizeMultiplier / a.sizeMultiplier);
          }
          return Math.min(i.number * o, a.maxSize);
        }, Gn = function(i, a, o) {
          return xt[o][i] && xt[o][i].replace && (i = xt[o][i].replace), { value: i, metrics: jn(i, a, o) };
        }, gr = function(i, a, o, l, f) {
          var m = Gn(i, a, o), y = m.metrics;
          i = m.value;
          var S;
          if (y) {
            var C2 = y.italic;
            (o === "text" || l && l.font === "mathit") && (C2 = 0), S = new Ur(i, y.height, y.depth, C2, y.skew, y.width, f);
          } else
            typeof console != "undefined" && console.warn("No character metrics " + ("for '" + i + "' in style '" + a + "' and mode '" + o + "'")), S = new Ur(i, 0, 0, 0, 0, 0, f);
          if (l) {
            S.maxFontSize = l.sizeMultiplier, l.style.isTight() && S.classes.push("mtight");
            var O = l.getColor();
            O && (S.style.color = O);
          }
          return S;
        }, vs = function(i, a, o, l) {
          return l === void 0 && (l = []), o.font === "boldsymbol" && Gn(i, "Main-Bold", a).metrics ? gr(i, "Main-Bold", a, o, l.concat(["mathbf"])) : i === "\\" || xt[a][i].font === "main" ? gr(i, "Main-Regular", a, o, l) : gr(i, "AMS-Regular", a, o, l.concat(["amsrm"]));
        }, Bu = function(i, a, o, l, f) {
          return f !== "textord" && Gn(i, "Math-BoldItalic", a).metrics ? { fontName: "Math-BoldItalic", fontClass: "boldsymbol" } : { fontName: "Main-Bold", fontClass: "mathbf" };
        }, ys = function(i, a, o) {
          var l = i.mode, f = i.text, m = ["mord"], y = l === "math" || l === "text" && a.font, S = y ? a.font : a.fontFamily;
          if (f.charCodeAt(0) === 55349) {
            var C2 = fs(f, l), O = C2[0], z = C2[1];
            return gr(f, O, l, a, m.concat(z));
          } else if (S) {
            var X, K;
            if (S === "boldsymbol") {
              var Y = Bu(f, l, a, m, o);
              X = Y.fontName, K = [Y.fontClass];
            } else
              y ? (X = Ua[S].fontName, K = [S]) : (X = Vn(S, a.fontWeight, a.fontShape), K = [S, a.fontWeight, a.fontShape]);
            if (Gn(f, X, l).metrics)
              return gr(f, X, l, a, m.concat(K));
            if (os.hasOwnProperty(f) && X.substr(0, 10) === "Typewriter") {
              for (var oe = [], se = 0; se < f.length; se++)
                oe.push(gr(f[se], X, l, a, m.concat(K)));
              return ja(oe);
            }
          }
          if (o === "mathord")
            return gr(f, "Math-Italic", l, a, m.concat(["mathnormal"]));
          if (o === "textord") {
            var he = xt[l][f] && xt[l][f].font;
            if (he === "ams") {
              var me = Vn("amsrm", a.fontWeight, a.fontShape);
              return gr(f, me, l, a, m.concat("amsrm", a.fontWeight, a.fontShape));
            } else if (he === "main" || !he) {
              var ge = Vn("textrm", a.fontWeight, a.fontShape);
              return gr(f, ge, l, a, m.concat(a.fontWeight, a.fontShape));
            } else {
              var Ze = Vn(he, a.fontWeight, a.fontShape);
              return gr(f, Ze, l, a, m.concat(Ze, a.fontWeight, a.fontShape));
            }
          } else
            throw new Error("unexpected type: " + o + " in makeOrd");
        }, bs = function(i, a) {
          if (g1(i.classes) !== g1(a.classes) || i.skew !== a.skew || i.maxFontSize !== a.maxFontSize)
            return false;
          if (i.classes.length === 1) {
            var o = i.classes[0];
            if (o === "mbin" || o === "mord")
              return false;
          }
          for (var l in i.style)
            if (i.style.hasOwnProperty(l) && i.style[l] !== a.style[l])
              return false;
          for (var f in a.style)
            if (a.style.hasOwnProperty(f) && i.style[f] !== a.style[f])
              return false;
          return true;
        }, za = function(i) {
          for (var a = 0; a < i.length - 1; a++) {
            var o = i[a], l = i[a + 1];
            o instanceof Ur && l instanceof Ur && bs(o, l) && (o.text += l.text, o.height = Math.max(o.height, l.height), o.depth = Math.max(o.depth, l.depth), o.italic = l.italic, i.splice(a + 1, 1), a--);
          }
          return i;
        }, Fa = function(i) {
          for (var a = 0, o = 0, l = 0, f = 0; f < i.children.length; f++) {
            var m = i.children[f];
            m.height > a && (a = m.height), m.depth > o && (o = m.depth), m.maxFontSize > l && (l = m.maxFontSize);
          }
          i.height = a, i.depth = o, i.maxFontSize = l;
        }, lr = function(i, a, o, l) {
          var f = new jr(i, a, o, l);
          return Fa(f), f;
        }, qi = function(i, a, o, l) {
          return new jr(i, a, o, l);
        }, Ha = function(i, a, o) {
          var l = lr([i], [], a);
          return l.height = Math.max(o || a.fontMetrics().defaultRuleThickness, a.minRuleThickness), l.style.borderBottomWidth = l.height + "em", l.maxFontSize = 1, l;
        }, an = function(i, a, o, l) {
          var f = new Zt(i, a, o, l);
          return Fa(f), f;
        }, ja = function(i) {
          var a = new Fr(i);
          return Fa(a), a;
        }, xs = function(i, a) {
          return i instanceof Fr ? lr([], [i], a) : i;
        }, Nu = function(i) {
          if (i.positionType === "individualShift") {
            for (var a = i.children, o = [a[0]], l = -a[0].shift - a[0].elem.depth, f = l, m = 1; m < a.length; m++) {
              var y = -a[m].shift - f - a[m].elem.depth, S = y - (a[m - 1].elem.height + a[m - 1].elem.depth);
              f = f + y, o.push({ type: "kern", size: S }), o.push(a[m]);
            }
            return { children: o, depth: l };
          }
          var C2;
          if (i.positionType === "top") {
            for (var O = i.positionData, z = 0; z < i.children.length; z++) {
              var X = i.children[z];
              O -= X.type === "kern" ? X.size : X.elem.height + X.elem.depth;
            }
            C2 = O;
          } else if (i.positionType === "bottom")
            C2 = -i.positionData;
          else {
            var K = i.children[0];
            if (K.type !== "elem")
              throw new Error('First child must have type "elem".');
            if (i.positionType === "shift")
              C2 = -K.elem.depth - i.positionData;
            else if (i.positionType === "firstBaseline")
              C2 = -K.elem.depth;
            else
              throw new Error("Invalid positionType " + i.positionType + ".");
          }
          return { children: i.children, depth: C2 };
        }, ws = function(i, a) {
          for (var o = Nu(i), l = o.children, f = o.depth, m = 0, y = 0; y < l.length; y++) {
            var S = l[y];
            if (S.type === "elem") {
              var C2 = S.elem;
              m = Math.max(m, C2.maxFontSize, C2.height);
            }
          }
          m += 2;
          var O = lr(["pstrut"], []);
          O.style.height = m + "em";
          for (var z = [], X = f, K = f, Y = f, oe = 0; oe < l.length; oe++) {
            var se = l[oe];
            if (se.type === "kern")
              Y += se.size;
            else {
              var he = se.elem, me = se.wrapperClasses || [], ge = se.wrapperStyle || {}, Ze = lr(me, [O, he], void 0, ge);
              Ze.style.top = -m - Y - he.depth + "em", se.marginLeft && (Ze.style.marginLeft = se.marginLeft), se.marginRight && (Ze.style.marginRight = se.marginRight), z.push(Ze), Y += he.height + he.depth;
            }
            X = Math.min(X, Y), K = Math.max(K, Y);
          }
          var st = lr(["vlist"], z);
          st.style.height = K + "em";
          var ft;
          if (X < 0) {
            var at = lr([], []), ot = lr(["vlist"], [at]);
            ot.style.height = -X + "em";
            var He = lr(["vlist-s"], [new Ur("\u200B")]);
            ft = [lr(["vlist-r"], [st, He]), lr(["vlist-r"], [ot])];
          } else
            ft = [lr(["vlist-r"], [st])];
          var lt = lr(["vlist-t"], ft);
          return ft.length === 2 && lt.classes.push("vlist-t2"), lt.height = K, lt.depth = -X, lt;
        }, _s = function(i, a) {
          var o = lr(["mspace"], [], a), l = _t(i, a);
          return o.style.marginRight = l + "em", o;
        }, Vn = function(i, a, o) {
          var l = "";
          switch (i) {
            case "amsrm":
              l = "AMS";
              break;
            case "textrm":
              l = "Main";
              break;
            case "textsf":
              l = "SansSerif";
              break;
            case "texttt":
              l = "Typewriter";
              break;
            default:
              l = i;
          }
          var f;
          return a === "textbf" && o === "textit" ? f = "BoldItalic" : a === "textbf" ? f = "Bold" : a === "textit" ? f = "Italic" : f = "Regular", l + "-" + f;
        }, Ua = { mathbf: { variant: "bold", fontName: "Main-Bold" }, mathrm: { variant: "normal", fontName: "Main-Regular" }, textit: { variant: "italic", fontName: "Main-Italic" }, mathit: { variant: "italic", fontName: "Main-Italic" }, mathnormal: { variant: "italic", fontName: "Math-Italic" }, mathbb: { variant: "double-struck", fontName: "AMS-Regular" }, mathcal: { variant: "script", fontName: "Caligraphic-Regular" }, mathfrak: { variant: "fraktur", fontName: "Fraktur-Regular" }, mathscr: { variant: "script", fontName: "Script-Regular" }, mathsf: { variant: "sans-serif", fontName: "SansSerif-Regular" }, mathtt: { variant: "monospace", fontName: "Typewriter-Regular" } }, Ss = { vec: ["vec", 0.471, 0.714], oiintSize1: ["oiintSize1", 0.957, 0.499], oiintSize2: ["oiintSize2", 1.472, 0.659], oiiintSize1: ["oiiintSize1", 1.304, 0.499], oiiintSize2: ["oiiintSize2", 1.98, 0.659] }, Ou = function(i, a) {
          var o = Ss[i], l = o[0], f = o[1], m = o[2], y = new b0(l), S = new Wr([y], { width: f + "em", height: m + "em", style: "width:" + f + "em", viewBox: "0 0 " + 1e3 * f + " " + 1e3 * m, preserveAspectRatio: "xMinYMin" }), C2 = qi(["overlay"], [S], a);
          return C2.height = m, C2.style.height = m + "em", C2.style.width = f + "em", C2;
        }, H = { fontMap: Ua, makeSymbol: gr, mathsym: vs, makeSpan: lr, makeSvgSpan: qi, makeLineSpan: Ha, makeAnchor: an, makeFragment: ja, wrapFragment: xs, makeVList: ws, makeOrd: ys, makeGlue: _s, staticSvg: Ou, svgData: Ss, tryCombineChars: za }, vt = { number: 3, unit: "mu" }, S0 = { number: 4, unit: "mu" }, R1 = { number: 5, unit: "mu" }, qu = { mord: { mop: vt, mbin: S0, mrel: R1, minner: vt }, mop: { mord: vt, mop: vt, mrel: R1, minner: vt }, mbin: { mord: S0, mop: S0, mopen: S0, minner: S0 }, mrel: { mord: R1, mop: R1, mopen: R1, minner: R1 }, mopen: {}, mclose: { mop: vt, mbin: S0, mrel: R1, minner: vt }, mpunct: { mord: vt, mop: vt, mrel: R1, mopen: vt, mclose: vt, mpunct: vt, minner: vt }, minner: { mord: vt, mop: vt, mbin: S0, mrel: R1, mopen: vt, mpunct: vt, minner: vt } }, Pu = { mord: { mop: vt }, mop: { mord: vt, mop: vt }, mbin: {}, mrel: {}, mopen: {}, mclose: { mop: vt }, mpunct: {}, minner: { mop: vt } }, Pi = {}, Li = {}, Ii = {};
        function ce(g) {
          for (var i = g.type, a = g.names, o = g.props, l = g.handler, f = g.htmlBuilder, m = g.mathmlBuilder, y = { type: i, numArgs: o.numArgs, argTypes: o.argTypes, allowedInArgument: !!o.allowedInArgument, allowedInText: !!o.allowedInText, allowedInMath: o.allowedInMath === void 0 ? true : o.allowedInMath, numOptionalArgs: o.numOptionalArgs || 0, infix: !!o.infix, primitive: !!o.primitive, handler: l }, S = 0; S < a.length; ++S)
            Pi[a[S]] = y;
          i && (f && (Li[i] = f), m && (Ii[i] = m));
        }
        function A0(g) {
          var i = g.type, a = g.htmlBuilder, o = g.mathmlBuilder;
          ce({ type: i, names: [], props: { numArgs: 0 }, handler: function() {
            throw new Error("Should never be called.");
          }, htmlBuilder: a, mathmlBuilder: o });
        }
        var Ri = function(i) {
          return i.type === "ordgroup" && i.body.length === 1 ? i.body[0] : i;
        }, Ne = function(i) {
          return i.type === "ordgroup" ? i.body : [i];
        }, Ke = H.makeSpan, Lu = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Iu = ["rightmost", "mrel", "mclose", "mpunct"], Ru = { display: pe.DISPLAY, text: pe.TEXT, script: pe.SCRIPT, scriptscript: pe.SCRIPTSCRIPT }, zu = { mord: "mord", mop: "mop", mbin: "mbin", mrel: "mrel", mopen: "mopen", mclose: "mclose", mpunct: "mpunct", minner: "minner" }, Xt = function(i, a, o, l) {
          l === void 0 && (l = [null, null]);
          for (var f = [], m = 0; m < i.length; m++) {
            var y = Ie(i[m], a);
            if (y instanceof Fr) {
              var S = y.children;
              f.push.apply(f, S);
            } else
              f.push(y);
          }
          if (H.tryCombineChars(f), !o)
            return f;
          var C2 = a;
          if (i.length === 1) {
            var O = i[0];
            O.type === "sizing" ? C2 = a.havingSize(O.size) : O.type === "styling" && (C2 = a.havingStyle(Ru[O.style]));
          }
          var z = Ke([l[0] || "leftmost"], [], a), X = Ke([l[1] || "rightmost"], [], a), K = o === "root";
          return As(f, function(Y, oe) {
            var se = oe.classes[0], he = Y.classes[0];
            se === "mbin" && V.contains(Iu, he) ? oe.classes[0] = "mord" : he === "mbin" && V.contains(Lu, se) && (Y.classes[0] = "mord");
          }, { node: z }, X, K), As(f, function(Y, oe) {
            var se = Nt(oe), he = Nt(Y), me = se && he ? Y.hasClass("mtight") ? Pu[se][he] : qu[se][he] : null;
            if (me)
              return H.makeGlue(me, C2);
          }, { node: z }, X, K), f;
        }, As = function g(i, a, o, l, f) {
          l && i.push(l);
          for (var m = 0; m < i.length; m++) {
            var y = i[m], S = Wa(y);
            if (S) {
              g(S.children, a, o, null, f);
              continue;
            }
            var C2 = !y.hasClass("mspace");
            if (C2) {
              var O = a(y, o.node);
              O && (o.insertAfter ? o.insertAfter(O) : (i.unshift(O), m++));
            }
            C2 ? o.node = y : f && y.hasClass("newline") && (o.node = Ke(["leftmost"])), o.insertAfter = function(z) {
              return function(X) {
                i.splice(z + 1, 0, X), m++;
              };
            }(m);
          }
          l && i.pop();
        }, Wa = function(i) {
          return i instanceof Fr || i instanceof Zt || i instanceof jr && i.hasClass("enclosing") ? i : null;
        }, Fu = function g(i, a) {
          var o = Wa(i);
          if (o) {
            var l = o.children;
            if (l.length) {
              if (a === "right")
                return g(l[l.length - 1], "right");
              if (a === "left")
                return g(l[0], "left");
            }
          }
          return i;
        }, Nt = function(i, a) {
          return i ? (a && (i = Fu(i, a)), zu[i.classes[0]] || null) : null;
        }, T0 = function(i, a) {
          var o = ["nulldelimiter"].concat(i.baseSizingClasses());
          return Ke(a.concat(o));
        }, Ie = function(i, a, o) {
          if (!i)
            return Ke();
          if (Li[i.type]) {
            var l = Li[i.type](i, a);
            if (o && a.size !== o.size) {
              l = Ke(a.sizingClasses(o), [l], a);
              var f = a.sizeMultiplier / o.sizeMultiplier;
              l.height *= f, l.depth *= f;
            }
            return l;
          } else
            throw new c("Got group of unknown type: '" + i.type + "'");
        };
        function $n(g, i) {
          var a = Ke(["base"], g, i), o = Ke(["strut"]);
          return o.style.height = a.height + a.depth + "em", a.depth && (o.style.verticalAlign = -a.depth + "em"), a.children.unshift(o), a;
        }
        function Xn(g, i) {
          var a = null;
          g.length === 1 && g[0].type === "tag" && (a = g[0].tag, g = g[0].body);
          var o = Xt(g, i, "root"), l;
          o.length === 2 && o[1].hasClass("tag") && (l = o.pop());
          for (var f = [], m = [], y = 0; y < o.length; y++)
            if (m.push(o[y]), o[y].hasClass("mbin") || o[y].hasClass("mrel") || o[y].hasClass("allowbreak")) {
              for (var S = false; y < o.length - 1 && o[y + 1].hasClass("mspace") && !o[y + 1].hasClass("newline"); )
                y++, m.push(o[y]), o[y].hasClass("nobreak") && (S = true);
              S || (f.push($n(m, i)), m = []);
            } else
              o[y].hasClass("newline") && (m.pop(), m.length > 0 && (f.push($n(m, i)), m = []), f.push(o[y]));
          m.length > 0 && f.push($n(m, i));
          var C2;
          a ? (C2 = $n(Xt(a, i, true)), C2.classes = ["tag"], f.push(C2)) : l && f.push(l);
          var O = Ke(["katex-html"], f);
          if (O.setAttribute("aria-hidden", "true"), C2) {
            var z = C2.children[0];
            z.style.height = O.height + O.depth + "em", O.depth && (z.style.verticalAlign = -O.depth + "em");
          }
          return O;
        }
        function Tr(g) {
          return new Fr(g);
        }
        var Er = function() {
          function g(a, o, l) {
            this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = a, this.attributes = {}, this.children = o || [], this.classes = l || [];
          }
          var i = g.prototype;
          return i.setAttribute = function(o, l) {
            this.attributes[o] = l;
          }, i.getAttribute = function(o) {
            return this.attributes[o];
          }, i.toNode = function() {
            var o = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
            for (var l in this.attributes)
              Object.prototype.hasOwnProperty.call(this.attributes, l) && o.setAttribute(l, this.attributes[l]);
            this.classes.length > 0 && (o.className = g1(this.classes));
            for (var f = 0; f < this.children.length; f++)
              o.appendChild(this.children[f].toNode());
            return o;
          }, i.toMarkup = function() {
            var o = "<" + this.type;
            for (var l in this.attributes)
              Object.prototype.hasOwnProperty.call(this.attributes, l) && (o += " " + l + '="', o += V.escape(this.attributes[l]), o += '"');
            this.classes.length > 0 && (o += ' class ="' + V.escape(g1(this.classes)) + '"'), o += ">";
            for (var f = 0; f < this.children.length; f++)
              o += this.children[f].toMarkup();
            return o += "</" + this.type + ">", o;
          }, i.toText = function() {
            return this.children.map(function(o) {
              return o.toText();
            }).join("");
          }, g;
        }(), on = function() {
          function g(a) {
            this.text = void 0, this.text = a;
          }
          var i = g.prototype;
          return i.toNode = function() {
            return document.createTextNode(this.text);
          }, i.toMarkup = function() {
            return V.escape(this.toText());
          }, i.toText = function() {
            return this.text;
          }, g;
        }(), Ts = function() {
          function g(a) {
            this.width = void 0, this.character = void 0, this.width = a, a >= 0.05555 && a <= 0.05556 ? this.character = "\u200A" : a >= 0.1666 && a <= 0.1667 ? this.character = "\u2009" : a >= 0.2222 && a <= 0.2223 ? this.character = "\u2005" : a >= 0.2777 && a <= 0.2778 ? this.character = "\u2005\u200A" : a >= -0.05556 && a <= -0.05555 ? this.character = "\u200A\u2063" : a >= -0.1667 && a <= -0.1666 ? this.character = "\u2009\u2063" : a >= -0.2223 && a <= -0.2222 ? this.character = "\u205F\u2063" : a >= -0.2778 && a <= -0.2777 ? this.character = "\u2005\u2063" : this.character = null;
          }
          var i = g.prototype;
          return i.toNode = function() {
            if (this.character)
              return document.createTextNode(this.character);
            var o = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            return o.setAttribute("width", this.width + "em"), o;
          }, i.toMarkup = function() {
            return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + this.width + 'em"/>';
          }, i.toText = function() {
            return this.character ? this.character : " ";
          }, g;
        }(), ne = { MathNode: Er, TextNode: on, SpaceNode: Ts, newDocumentFragment: Tr }, Cr = function(i, a, o) {
          return xt[a][i] && xt[a][i].replace && i.charCodeAt(0) !== 55349 && !(os.hasOwnProperty(i) && o && (o.fontFamily && o.fontFamily.substr(4, 2) === "tt" || o.font && o.font.substr(4, 2) === "tt")) && (i = xt[a][i].replace), new ne.TextNode(i);
        }, zi = function(i) {
          return i.length === 1 ? i[0] : new ne.MathNode("mrow", i);
        }, ur = function(i, a) {
          if (a.fontFamily === "texttt")
            return "monospace";
          if (a.fontFamily === "textsf")
            return a.fontShape === "textit" && a.fontWeight === "textbf" ? "sans-serif-bold-italic" : a.fontShape === "textit" ? "sans-serif-italic" : a.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
          if (a.fontShape === "textit" && a.fontWeight === "textbf")
            return "bold-italic";
          if (a.fontShape === "textit")
            return "italic";
          if (a.fontWeight === "textbf")
            return "bold";
          var o = a.font;
          if (!o || o === "mathnormal")
            return null;
          var l = i.mode;
          if (o === "mathit")
            return "italic";
          if (o === "boldsymbol")
            return i.type === "textord" ? "bold" : "bold-italic";
          if (o === "mathbf")
            return "bold";
          if (o === "mathbb")
            return "double-struck";
          if (o === "mathfrak")
            return "fraktur";
          if (o === "mathscr" || o === "mathcal")
            return "script";
          if (o === "mathsf")
            return "sans-serif";
          if (o === "mathtt")
            return "monospace";
          var f = i.text;
          if (V.contains(["\\imath", "\\jmath"], f))
            return null;
          xt[l][f] && xt[l][f].replace && (f = xt[l][f].replace);
          var m = H.fontMap[o].fontName;
          return jn(f, m, l) ? H.fontMap[o].variant : null;
        }, kr = function(i, a, o) {
          if (i.length === 1) {
            var l = ct(i[0], a);
            return o && l instanceof Er && l.type === "mo" && (l.setAttribute("lspace", "0em"), l.setAttribute("rspace", "0em")), [l];
          }
          for (var f = [], m, y = 0; y < i.length; y++) {
            var S = ct(i[y], a);
            if (S instanceof Er && m instanceof Er) {
              if (S.type === "mtext" && m.type === "mtext" && S.getAttribute("mathvariant") === m.getAttribute("mathvariant")) {
                var C2;
                (C2 = m.children).push.apply(C2, S.children);
                continue;
              } else if (S.type === "mn" && m.type === "mn") {
                var O;
                (O = m.children).push.apply(O, S.children);
                continue;
              } else if (S.type === "mi" && S.children.length === 1 && m.type === "mn") {
                var z = S.children[0];
                if (z instanceof on && z.text === ".") {
                  var X;
                  (X = m.children).push.apply(X, S.children);
                  continue;
                }
              } else if (m.type === "mi" && m.children.length === 1) {
                var K = m.children[0];
                if (K instanceof on && K.text === "\u0338" && (S.type === "mo" || S.type === "mi" || S.type === "mn")) {
                  var Y = S.children[0];
                  Y instanceof on && Y.text.length > 0 && (Y.text = Y.text.slice(0, 1) + "\u0338" + Y.text.slice(1), f.pop());
                }
              }
            }
            f.push(S), m = S;
          }
          return f;
        }, Lt = function(i, a, o) {
          return zi(kr(i, a, o));
        }, ct = function(i, a) {
          if (!i)
            return new ne.MathNode("mrow");
          if (Ii[i.type]) {
            var o = Ii[i.type](i, a);
            return o;
          } else
            throw new c("Got group of unknown type: '" + i.type + "'");
        };
        function Ga(g, i, a, o, l) {
          var f = kr(g, a), m;
          f.length === 1 && f[0] instanceof Er && V.contains(["mrow", "mtable"], f[0].type) ? m = f[0] : m = new ne.MathNode("mrow", f);
          var y = new ne.MathNode("annotation", [new ne.TextNode(i)]);
          y.setAttribute("encoding", "application/x-tex");
          var S = new ne.MathNode("semantics", [m, y]), C2 = new ne.MathNode("math", [S]);
          C2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), o && C2.setAttribute("display", "block");
          var O = l ? "katex" : "katex-mathml";
          return H.makeSpan([O], [C2]);
        }
        var z1 = function(i) {
          return new ps({ style: i.displayMode ? pe.DISPLAY : pe.TEXT, maxSize: i.maxSize, minRuleThickness: i.minRuleThickness });
        }, Yn = function(i, a) {
          if (a.displayMode) {
            var o = ["katex-display"];
            a.leqno && o.push("leqno"), a.fleqn && o.push("fleqn"), i = H.makeSpan(o, [i]);
          }
          return i;
        }, Va = function(i, a, o) {
          var l = z1(o), f;
          if (o.output === "mathml")
            return Ga(i, a, l, o.displayMode, true);
          if (o.output === "html") {
            var m = Xn(i, l);
            f = H.makeSpan(["katex"], [m]);
          } else {
            var y = Ga(i, a, l, o.displayMode, false), S = Xn(i, l);
            f = H.makeSpan(["katex"], [y, S]);
          }
          return Yn(f, o);
        }, yt = function(i, a, o) {
          var l = z1(o), f = Xn(i, l), m = H.makeSpan(["katex"], [f]);
          return Yn(m, o);
        }, E0 = null, $a = { widehat: "^", widecheck: "\u02C7", widetilde: "~", utilde: "~", overleftarrow: "\u2190", underleftarrow: "\u2190", xleftarrow: "\u2190", overrightarrow: "\u2192", underrightarrow: "\u2192", xrightarrow: "\u2192", underbrace: "\u23DF", overbrace: "\u23DE", overgroup: "\u23E0", undergroup: "\u23E1", overleftrightarrow: "\u2194", underleftrightarrow: "\u2194", xleftrightarrow: "\u2194", Overrightarrow: "\u21D2", xRightarrow: "\u21D2", overleftharpoon: "\u21BC", xleftharpoonup: "\u21BC", overrightharpoon: "\u21C0", xrightharpoonup: "\u21C0", xLeftarrow: "\u21D0", xLeftrightarrow: "\u21D4", xhookleftarrow: "\u21A9", xhookrightarrow: "\u21AA", xmapsto: "\u21A6", xrightharpoondown: "\u21C1", xleftharpoondown: "\u21BD", xrightleftharpoons: "\u21CC", xleftrightharpoons: "\u21CB", xtwoheadleftarrow: "\u219E", xtwoheadrightarrow: "\u21A0", xlongequal: "=", xtofrom: "\u21C4", xrightleftarrows: "\u21C4", xrightequilibrium: "\u21CC", xleftequilibrium: "\u21CB", "\\cdrightarrow": "\u2192", "\\cdleftarrow": "\u2190", "\\cdlongequal": "=" }, Hu = function(i) {
          var a = new ne.MathNode("mo", [new ne.TextNode($a[i.replace(/^\\/, "")])]);
          return a.setAttribute("stretchy", "true"), a;
        }, Xa = { overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"], overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"], underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"], underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"], xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"], "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"], xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"], "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"], Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"], xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"], xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"], overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"], xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"], xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"], overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"], xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"], xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"], xlongequal: [["longequal"], 0.888, 334, "xMinYMin"], "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"], xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"], xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"], overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522], overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548], underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548], underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522], xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522], xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560], xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716], xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716], xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522], xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522], overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522], underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522], overgroup: [["leftgroup", "rightgroup"], 0.888, 342], undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342], xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522], xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528], xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901], xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716], xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716] }, ju = function(i) {
          return i.type === "ordgroup" ? i.body.length : 1;
        }, Uu = function(i, a) {
          function o() {
            var S = 4e5, C2 = i.label.substr(1);
            if (V.contains(["widehat", "widecheck", "widetilde", "utilde"], C2)) {
              var O = i, z = ju(O.base), X, K, Y;
              if (z > 5)
                C2 === "widehat" || C2 === "widecheck" ? (X = 420, S = 2364, Y = 0.42, K = C2 + "4") : (X = 312, S = 2340, Y = 0.34, K = "tilde4");
              else {
                var oe = [1, 1, 2, 2, 3, 3][z];
                C2 === "widehat" || C2 === "widecheck" ? (S = [0, 1062, 2364, 2364, 2364][oe], X = [0, 239, 300, 360, 420][oe], Y = [0, 0.24, 0.3, 0.3, 0.36, 0.42][oe], K = C2 + oe) : (S = [0, 600, 1033, 2339, 2340][oe], X = [0, 260, 286, 306, 312][oe], Y = [0, 0.26, 0.286, 0.3, 0.306, 0.34][oe], K = "tilde" + oe);
              }
              var se = new b0(K), he = new Wr([se], { width: "100%", height: Y + "em", viewBox: "0 0 " + S + " " + X, preserveAspectRatio: "none" });
              return { span: H.makeSvgSpan([], [he], a), minWidth: 0, height: Y };
            } else {
              var me = [], ge = Xa[C2], Ze = ge[0], st = ge[1], ft = ge[2], at = ft / 1e3, ot = Ze.length, He, lt;
              if (ot === 1) {
                var yr = ge[3];
                He = ["hide-tail"], lt = [yr];
              } else if (ot === 2)
                He = ["halfarrow-left", "halfarrow-right"], lt = ["xMinYMin", "xMaxYMin"];
              else if (ot === 3)
                He = ["brace-left", "brace-center", "brace-right"], lt = ["xMinYMin", "xMidYMin", "xMaxYMin"];
              else
                throw new Error(`Correct katexImagesData or update code here to support
                    ` + ot + " children.");
              for (var Et = 0; Et < ot; Et++) {
                var x1 = new b0(Ze[Et]), Or = new Wr([x1], { width: "400em", height: at + "em", viewBox: "0 0 " + S + " " + ft, preserveAspectRatio: lt[Et] + " slice" }), Rt = H.makeSvgSpan([He[Et]], [Or], a);
                if (ot === 1)
                  return { span: Rt, minWidth: st, height: at };
                Rt.style.height = at + "em", me.push(Rt);
              }
              return { span: H.makeSpan(["stretchy"], me, a), minWidth: st, height: at };
            }
          }
          var l = o(), f = l.span, m = l.minWidth, y = l.height;
          return f.height = y, f.style.height = y + "em", m > 0 && (f.style.minWidth = m + "em"), f;
        }, Wu = function(i, a, o, l, f) {
          var m, y = i.height + i.depth + o + l;
          if (/fbox|color|angl/.test(a)) {
            if (m = H.makeSpan(["stretchy", a], [], f), a === "fbox") {
              var S = f.color && f.getColor();
              S && (m.style.borderColor = S);
            }
          } else {
            var C2 = [];
            /^[bx]cancel$/.test(a) && C2.push(new x0({ x1: "0", y1: "0", x2: "100%", y2: "100%", "stroke-width": "0.046em" })), /^x?cancel$/.test(a) && C2.push(new x0({ x1: "0", y1: "100%", x2: "100%", y2: "0", "stroke-width": "0.046em" }));
            var O = new Wr(C2, { width: "100%", height: y + "em" });
            m = H.makeSvgSpan([], [O], f);
          }
          return m.height = y, m.style.height = y + "em", m;
        }, v1 = { encloseSpan: Wu, mathMLnode: Hu, svgSpan: Uu };
        function Oe(g, i) {
          if (!g || g.type !== i)
            throw new Error("Expected node of type " + i + ", but got " + (g ? "node of type " + g.type : String(g)));
          return g;
        }
        function r0(g) {
          var i = Fi(g);
          if (!i)
            throw new Error("Expected node of symbol group type, but got " + (g ? "node of type " + g.type : String(g)));
          return i;
        }
        function Fi(g) {
          return g && (g.type === "atom" || Mu.hasOwnProperty(g.type)) ? g : null;
        }
        var Hi = function(i, a) {
          var o, l, f;
          i && i.type === "supsub" ? (l = Oe(i.base, "accent"), o = l.base, i.base = o, f = Da(Ie(i, a)), i.base = l) : (l = Oe(i, "accent"), o = l.base);
          var m = Ie(o, a.havingCrampedStyle()), y = l.isShifty && V.isCharacterBox(o), S = 0;
          if (y) {
            var C2 = V.getBaseElem(o), O = Ie(C2, a.havingCrampedStyle());
            S = w0(O).skew;
          }
          var z = l.label === "\\c", X = z ? m.height + m.depth : Math.min(m.height, a.fontMetrics().xHeight), K;
          if (l.isStretchy)
            K = v1.svgSpan(l, a), K = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: m }, { type: "elem", elem: K, wrapperClasses: ["svg-align"], wrapperStyle: S > 0 ? { width: "calc(100% - " + 2 * S + "em)", marginLeft: 2 * S + "em" } : void 0 }] }, a);
          else {
            var Y, oe;
            l.label === "\\vec" ? (Y = H.staticSvg("vec", a), oe = H.svgData.vec[1]) : (Y = H.makeOrd({ mode: l.mode, text: l.label }, a, "textord"), Y = w0(Y), Y.italic = 0, oe = Y.width, z && (X += Y.depth)), K = H.makeSpan(["accent-body"], [Y]);
            var se = l.label === "\\textcircled";
            se && (K.classes.push("accent-full"), X = m.height);
            var he = S;
            se || (he -= oe / 2), K.style.left = he + "em", l.label === "\\textcircled" && (K.style.top = ".2em"), K = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: m }, { type: "kern", size: -X }, { type: "elem", elem: K }] }, a);
          }
          var me = H.makeSpan(["mord", "accent"], [K], a);
          return f ? (f.children[0] = me, f.height = Math.max(me.height, f.height), f.classes[0] = "mord", f) : me;
        }, Ya = function(i, a) {
          var o = i.isStretchy ? v1.mathMLnode(i.label) : new ne.MathNode("mo", [Cr(i.label, i.mode)]), l = new ne.MathNode("mover", [ct(i.base, a), o]);
          return l.setAttribute("accent", "true"), l;
        }, Ka = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(g) {
          return "\\" + g;
        }).join("|"));
        ce({ type: "accent", names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = Ri(a[0]), l = !Ka.test(i.funcName), f = !l || i.funcName === "\\widehat" || i.funcName === "\\widetilde" || i.funcName === "\\widecheck";
          return { type: "accent", mode: i.parser.mode, label: i.funcName, isStretchy: l, isShifty: f, base: o };
        }, htmlBuilder: Hi, mathmlBuilder: Ya }), ce({ type: "accent", names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"], props: { numArgs: 1, allowedInText: true, allowedInMath: true, argTypes: ["primitive"] }, handler: function(i, a) {
          var o = a[0], l = i.parser.mode;
          return l === "math" && (i.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + i.funcName + " works only in text mode"), l = "text"), { type: "accent", mode: l, label: i.funcName, isStretchy: false, isShifty: true, base: o };
        }, htmlBuilder: Hi, mathmlBuilder: Ya }), ce({ type: "accentUnder", names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          return { type: "accentUnder", mode: o.mode, label: l, base: f };
        }, htmlBuilder: function(i, a) {
          var o = Ie(i.base, a), l = v1.svgSpan(i, a), f = i.label === "\\utilde" ? 0.12 : 0, m = H.makeVList({ positionType: "top", positionData: o.height, children: [{ type: "elem", elem: l, wrapperClasses: ["svg-align"] }, { type: "kern", size: f }, { type: "elem", elem: o }] }, a);
          return H.makeSpan(["mord", "accentunder"], [m], a);
        }, mathmlBuilder: function(i, a) {
          var o = v1.mathMLnode(i.label), l = new ne.MathNode("munder", [ct(i.base, a), o]);
          return l.setAttribute("accentunder", "true"), l;
        } });
        var sn = function(i) {
          var a = new ne.MathNode("mpadded", i ? [i] : []);
          return a.setAttribute("width", "+0.6em"), a.setAttribute("lspace", "0.3em"), a;
        };
        ce({ type: "xArrow", names: ["\\xleftarrow", "\\xrightarrow", "\\xLeftarrow", "\\xRightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xrightharpoondown", "\\xrightharpoonup", "\\xleftharpoondown", "\\xleftharpoonup", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xlongequal", "\\xtwoheadrightarrow", "\\xtwoheadleftarrow", "\\xtofrom", "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium", "\\\\cdrightarrow", "\\\\cdleftarrow", "\\\\cdlongequal"], props: { numArgs: 1, numOptionalArgs: 1 }, handler: function(i, a, o) {
          var l = i.parser, f = i.funcName;
          return { type: "xArrow", mode: l.mode, label: f, body: a[0], below: o[0] };
        }, htmlBuilder: function(i, a) {
          var o = a.style, l = a.havingStyle(o.sup()), f = H.wrapFragment(Ie(i.body, l, a), a), m = i.label.slice(0, 2) === "\\x" ? "x" : "cd";
          f.classes.push(m + "-arrow-pad");
          var y;
          i.below && (l = a.havingStyle(o.sub()), y = H.wrapFragment(Ie(i.below, l, a), a), y.classes.push(m + "-arrow-pad"));
          var S = v1.svgSpan(i, a), C2 = -a.fontMetrics().axisHeight + 0.5 * S.height, O = -a.fontMetrics().axisHeight - 0.5 * S.height - 0.111;
          (f.depth > 0.25 || i.label === "\\xleftequilibrium") && (O -= f.depth);
          var z;
          if (y) {
            var X = -a.fontMetrics().axisHeight + y.height + 0.5 * S.height + 0.111;
            z = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: f, shift: O }, { type: "elem", elem: S, shift: C2 }, { type: "elem", elem: y, shift: X }] }, a);
          } else
            z = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: f, shift: O }, { type: "elem", elem: S, shift: C2 }] }, a);
          return z.children[0].children[0].children[1].classes.push("svg-align"), H.makeSpan(["mrel", "x-arrow"], [z], a);
        }, mathmlBuilder: function(i, a) {
          var o = v1.mathMLnode(i.label);
          o.setAttribute("minsize", i.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var l;
          if (i.body) {
            var f = sn(ct(i.body, a));
            if (i.below) {
              var m = sn(ct(i.below, a));
              l = new ne.MathNode("munderover", [o, m, f]);
            } else
              l = new ne.MathNode("mover", [o, f]);
          } else if (i.below) {
            var y = sn(ct(i.below, a));
            l = new ne.MathNode("munder", [o, y]);
          } else
            l = sn(), l = new ne.MathNode("mover", [o, l]);
          return l;
        } });
        var Es = { ">": "\\\\cdrightarrow", "<": "\\\\cdleftarrow", "=": "\\\\cdlongequal", A: "\\uparrow", V: "\\downarrow", "|": "\\Vert", ".": "no arrow" }, Cs = function() {
          return { type: "styling", body: [], mode: "math", style: "display" };
        }, ji = function(i) {
          return i.type === "textord" && i.text === "@";
        }, Za = function(i, a) {
          return (i.type === "mathord" || i.type === "atom") && i.text === a;
        };
        function Gu(g, i, a) {
          var o = Es[g];
          switch (o) {
            case "\\\\cdrightarrow":
            case "\\\\cdleftarrow":
              return a.callFunction(o, [i[0]], [i[1]]);
            case "\\uparrow":
            case "\\downarrow": {
              var l = a.callFunction("\\\\cdleft", [i[0]], []), f = { type: "atom", text: o, mode: "math", family: "rel" }, m = a.callFunction("\\Big", [f], []), y = a.callFunction("\\\\cdright", [i[1]], []), S = { type: "ordgroup", mode: "math", body: [l, m, y] };
              return a.callFunction("\\\\cdparent", [S], []);
            }
            case "\\\\cdlongequal":
              return a.callFunction("\\\\cdlongequal", [], []);
            case "\\Vert": {
              var C2 = { type: "textord", text: "\\Vert", mode: "math" };
              return a.callFunction("\\Big", [C2], []);
            }
            default:
              return { type: "textord", text: " ", mode: "math" };
          }
        }
        function ks(g) {
          var i = [];
          for (g.gullet.beginGroup(), g.gullet.macros.set("\\cr", "\\\\\\relax"), g.gullet.beginGroup(); ; ) {
            i.push(g.parseExpression(false, "\\\\")), g.gullet.endGroup(), g.gullet.beginGroup();
            var a = g.fetch().text;
            if (a === "&" || a === "\\\\")
              g.consume();
            else if (a === "\\end") {
              i[i.length - 1].length === 0 && i.pop();
              break;
            } else
              throw new c("Expected \\\\ or \\cr or \\end", g.nextToken);
          }
          for (var o = [], l = [o], f = 0; f < i.length; f++) {
            for (var m = i[f], y = Cs(), S = 0; S < m.length; S++)
              if (!ji(m[S]))
                y.body.push(m[S]);
              else {
                o.push(y), S += 1;
                var C2 = r0(m[S]).text, O = new Array(2);
                if (O[0] = { type: "ordgroup", mode: "math", body: [] }, O[1] = { type: "ordgroup", mode: "math", body: [] }, !("=|.".indexOf(C2) > -1))
                  if ("<>AV".indexOf(C2) > -1)
                    for (var z = 0; z < 2; z++) {
                      for (var X = true, K = S + 1; K < m.length; K++) {
                        if (Za(m[K], C2)) {
                          X = false, S = K;
                          break;
                        }
                        if (ji(m[K]))
                          throw new c("Missing a " + C2 + " character to complete a CD arrow.", m[K]);
                        O[z].body.push(m[K]);
                      }
                      if (X)
                        throw new c("Missing a " + C2 + " character to complete a CD arrow.", m[S]);
                    }
                  else
                    throw new c('Expected one of "<>AV=|." after @', m[S]);
                var Y = Gu(C2, O, g), oe = { type: "styling", body: [Y], mode: "math", style: "display" };
                o.push(oe), y = Cs();
              }
            f % 2 == 0 ? o.push(y) : o.shift(), o = [], l.push(o);
          }
          g.gullet.endGroup(), g.gullet.endGroup();
          var se = new Array(l[0].length).fill({ type: "align", align: "c", pregap: 0.25, postgap: 0.25 });
          return { type: "array", mode: "math", body: l, arraystretch: 1, addJot: true, rowGaps: [null], cols: se, colSeparationType: "CD", hLinesBeforeRow: new Array(l.length + 1).fill([]) };
        }
        ce({ type: "cdlabel", names: ["\\\\cdleft", "\\\\cdright"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName;
          return { type: "cdlabel", mode: o.mode, side: l.slice(4), label: a[0] };
        }, htmlBuilder: function(i, a) {
          var o = a.havingStyle(a.style.sup()), l = H.wrapFragment(Ie(i.label, o, a), a);
          return l.classes.push("cd-label-" + i.side), l.style.bottom = 0.8 - l.depth + "em", l.height = 0, l.depth = 0, l;
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mrow", [ct(i.label, a)]);
          return o = new ne.MathNode("mpadded", [o]), o.setAttribute("width", "0"), i.side === "left" && o.setAttribute("lspace", "-1width"), o.setAttribute("voffset", "0.7em"), o = new ne.MathNode("mstyle", [o]), o.setAttribute("displaystyle", "false"), o.setAttribute("scriptlevel", "1"), o;
        } }), ce({ type: "cdlabelparent", names: ["\\\\cdparent"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser;
          return { type: "cdlabelparent", mode: o.mode, fragment: a[0] };
        }, htmlBuilder: function(i, a) {
          var o = H.wrapFragment(Ie(i.fragment, a), a);
          return o.classes.push("cd-vert-arrow"), o;
        }, mathmlBuilder: function(i, a) {
          return new ne.MathNode("mrow", [ct(i.fragment, a)]);
        } }), ce({ type: "textord", names: ["\\@char"], props: { numArgs: 1, allowedInText: true }, handler: function(i, a) {
          for (var o = i.parser, l = Oe(a[0], "ordgroup"), f = l.body, m = "", y = 0; y < f.length; y++) {
            var S = Oe(f[y], "textord");
            m += S.text;
          }
          var C2 = parseInt(m), O;
          if (isNaN(C2))
            throw new c("\\@char has non-numeric argument " + m);
          if (C2 < 0 || C2 >= 1114111)
            throw new c("\\@char with invalid code point " + m);
          return C2 <= 65535 ? O = String.fromCharCode(C2) : (C2 -= 65536, O = String.fromCharCode((C2 >> 10) + 55296, (C2 & 1023) + 56320)), { type: "textord", mode: o.mode, text: O };
        } });
        var vr = function(i, a) {
          var o = Xt(i.body, a.withColor(i.color), false);
          return H.makeFragment(o);
        }, Ui = function(i, a) {
          var o = kr(i.body, a.withColor(i.color)), l = new ne.MathNode("mstyle", o);
          return l.setAttribute("mathcolor", i.color), l;
        };
        ce({ type: "color", names: ["\\textcolor"], props: { numArgs: 2, allowedInText: true, argTypes: ["color", "original"] }, handler: function(i, a) {
          var o = i.parser, l = Oe(a[0], "color-token").color, f = a[1];
          return { type: "color", mode: o.mode, color: l, body: Ne(f) };
        }, htmlBuilder: vr, mathmlBuilder: Ui }), ce({ type: "color", names: ["\\color"], props: { numArgs: 1, allowedInText: true, argTypes: ["color"] }, handler: function(i, a) {
          var o = i.parser, l = i.breakOnTokenText, f = Oe(a[0], "color-token").color;
          o.gullet.macros.set("\\current@color", f);
          var m = o.parseExpression(true, l);
          return { type: "color", mode: o.mode, color: f, body: m };
        }, htmlBuilder: vr, mathmlBuilder: Ui }), ce({ type: "cr", names: ["\\\\"], props: { numArgs: 0, numOptionalArgs: 1, argTypes: ["size"], allowedInText: true }, handler: function(i, a, o) {
          var l = i.parser, f = o[0], m = !l.settings.displayMode || !l.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return { type: "cr", mode: l.mode, newLine: m, size: f && Oe(f, "size").value };
        }, htmlBuilder: function(i, a) {
          var o = H.makeSpan(["mspace"], [], a);
          return i.newLine && (o.classes.push("newline"), i.size && (o.style.marginTop = _t(i.size, a) + "em")), o;
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mspace");
          return i.newLine && (o.setAttribute("linebreak", "newline"), i.size && o.setAttribute("height", _t(i.size, a) + "em")), o;
        } });
        var C0 = { "\\global": "\\global", "\\long": "\\\\globallong", "\\\\globallong": "\\\\globallong", "\\def": "\\gdef", "\\gdef": "\\gdef", "\\edef": "\\xdef", "\\xdef": "\\xdef", "\\let": "\\\\globallet", "\\futurelet": "\\\\globalfuture" }, Ja = function(i) {
          var a = i.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(a))
            throw new c("Expected a control sequence", i);
          return a;
        }, Ms = function(i) {
          var a = i.gullet.popToken();
          return a.text === "=" && (a = i.gullet.popToken(), a.text === " " && (a = i.gullet.popToken())), a;
        }, Ds = function(i, a, o, l) {
          var f = i.gullet.macros.get(o.text);
          f == null && (o.noexpand = true, f = { tokens: [o], numArgs: 0, unexpandable: !i.gullet.isExpandable(o.text) }), i.gullet.macros.set(a, f, l);
        };
        ce({ type: "internal", names: ["\\global", "\\long", "\\\\globallong"], props: { numArgs: 0, allowedInText: true }, handler: function(i) {
          var a = i.parser, o = i.funcName;
          a.consumeSpaces();
          var l = a.fetch();
          if (C0[l.text])
            return (o === "\\global" || o === "\\\\globallong") && (l.text = C0[l.text]), Oe(a.parseFunction(), "internal");
          throw new c("Invalid token after macro prefix", l);
        } }), ce({ type: "internal", names: ["\\def", "\\gdef", "\\edef", "\\xdef"], props: { numArgs: 0, allowedInText: true, primitive: true }, handler: function(i) {
          var a = i.parser, o = i.funcName, l = a.gullet.popToken(), f = l.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(f))
            throw new c("Expected a control sequence", l);
          for (var m = 0, y, S = [[]]; a.gullet.future().text !== "{"; )
            if (l = a.gullet.popToken(), l.text === "#") {
              if (a.gullet.future().text === "{") {
                y = a.gullet.future(), S[m].push("{");
                break;
              }
              if (l = a.gullet.popToken(), !/^[1-9]$/.test(l.text))
                throw new c('Invalid argument number "' + l.text + '"');
              if (parseInt(l.text) !== m + 1)
                throw new c('Argument number "' + l.text + '" out of order');
              m++, S.push([]);
            } else {
              if (l.text === "EOF")
                throw new c("Expected a macro definition");
              S[m].push(l.text);
            }
          var C2 = a.gullet.consumeArg(), O = C2.tokens;
          return y && O.unshift(y), (o === "\\edef" || o === "\\xdef") && (O = a.gullet.expandTokens(O), O.reverse()), a.gullet.macros.set(f, { tokens: O, numArgs: m, delimiters: S }, o === C0[o]), { type: "internal", mode: a.mode };
        } }), ce({ type: "internal", names: ["\\let", "\\\\globallet"], props: { numArgs: 0, allowedInText: true, primitive: true }, handler: function(i) {
          var a = i.parser, o = i.funcName, l = Ja(a.gullet.popToken());
          a.gullet.consumeSpaces();
          var f = Ms(a);
          return Ds(a, l, f, o === "\\\\globallet"), { type: "internal", mode: a.mode };
        } }), ce({ type: "internal", names: ["\\futurelet", "\\\\globalfuture"], props: { numArgs: 0, allowedInText: true, primitive: true }, handler: function(i) {
          var a = i.parser, o = i.funcName, l = Ja(a.gullet.popToken()), f = a.gullet.popToken(), m = a.gullet.popToken();
          return Ds(a, l, m, o === "\\\\globalfuture"), a.gullet.pushToken(m), a.gullet.pushToken(f), { type: "internal", mode: a.mode };
        } });
        var Kn = function(i, a, o) {
          var l = xt.math[i] && xt.math[i].replace, f = jn(l || i, a, o);
          if (!f)
            throw new Error("Unsupported symbol " + i + " and font size " + a + ".");
          return f;
        }, Qa = function(i, a, o, l) {
          var f = o.havingBaseStyle(a), m = H.makeSpan(l.concat(f.sizingClasses(o)), [i], o), y = f.sizeMultiplier / o.sizeMultiplier;
          return m.height *= y, m.depth *= y, m.maxFontSize = f.sizeMultiplier, m;
        }, Bs = function(i, a, o) {
          var l = a.havingBaseStyle(o), f = (1 - a.sizeMultiplier / l.sizeMultiplier) * a.fontMetrics().axisHeight;
          i.classes.push("delimcenter"), i.style.top = f + "em", i.height -= f, i.depth += f;
        }, Vu = function(i, a, o, l, f, m) {
          var y = H.makeSymbol(i, "Main-Regular", f, l), S = Qa(y, a, l, m);
          return o && Bs(S, l, a), S;
        }, ln = function(i, a, o, l) {
          return H.makeSymbol(i, "Size" + a + "-Regular", o, l);
        }, Ns = function(i, a, o, l, f, m) {
          var y = ln(i, a, f, l), S = Qa(H.makeSpan(["delimsizing", "size" + a], [y], l), pe.TEXT, l, m);
          return o && Bs(S, l, pe.TEXT), S;
        }, eo = function(i, a, o) {
          var l;
          a === "Size1-Regular" ? l = "delim-size1" : l = "delim-size4";
          var f = H.makeSpan(["delimsizinginner", l], [H.makeSpan([], [H.makeSymbol(i, a, o)])]);
          return { type: "elem", elem: f };
        }, Zn = function(i, a, o) {
          var l = Gr["Size4-Regular"][i.charCodeAt(0)] ? Gr["Size4-Regular"][i.charCodeAt(0)][4].toFixed(3) : Gr["Size1-Regular"][i.charCodeAt(0)][4].toFixed(3), f = new b0("inner", zn(i, Math.round(1e3 * a))), m = new Wr([f], { width: l + "em", height: a + "em", style: "width:" + l + "em", viewBox: "0 0 " + 1e3 * l + " " + Math.round(1e3 * a), preserveAspectRatio: "xMinYMin" }), y = H.makeSvgSpan([], [m], o);
          return y.height = a, y.style.height = a + "em", y.style.width = l + "em", { type: "elem", elem: y };
        }, Wi = 8e-3, o1 = { type: "kern", size: -1 * Wi }, Gi = ["|", "\\lvert", "\\rvert", "\\vert"], $u = ["\\|", "\\lVert", "\\rVert", "\\Vert"], Os = function(i, a, o, l, f, m) {
          var y, S, C2, O;
          y = C2 = O = i, S = null;
          var z = "Size1-Regular";
          i === "\\uparrow" ? C2 = O = "\u23D0" : i === "\\Uparrow" ? C2 = O = "\u2016" : i === "\\downarrow" ? y = C2 = "\u23D0" : i === "\\Downarrow" ? y = C2 = "\u2016" : i === "\\updownarrow" ? (y = "\\uparrow", C2 = "\u23D0", O = "\\downarrow") : i === "\\Updownarrow" ? (y = "\\Uparrow", C2 = "\u2016", O = "\\Downarrow") : V.contains(Gi, i) ? C2 = "\u2223" : V.contains($u, i) ? C2 = "\u2225" : i === "[" || i === "\\lbrack" ? (y = "\u23A1", C2 = "\u23A2", O = "\u23A3", z = "Size4-Regular") : i === "]" || i === "\\rbrack" ? (y = "\u23A4", C2 = "\u23A5", O = "\u23A6", z = "Size4-Regular") : i === "\\lfloor" || i === "\u230A" ? (C2 = y = "\u23A2", O = "\u23A3", z = "Size4-Regular") : i === "\\lceil" || i === "\u2308" ? (y = "\u23A1", C2 = O = "\u23A2", z = "Size4-Regular") : i === "\\rfloor" || i === "\u230B" ? (C2 = y = "\u23A5", O = "\u23A6", z = "Size4-Regular") : i === "\\rceil" || i === "\u2309" ? (y = "\u23A4", C2 = O = "\u23A5", z = "Size4-Regular") : i === "(" || i === "\\lparen" ? (y = "\u239B", C2 = "\u239C", O = "\u239D", z = "Size4-Regular") : i === ")" || i === "\\rparen" ? (y = "\u239E", C2 = "\u239F", O = "\u23A0", z = "Size4-Regular") : i === "\\{" || i === "\\lbrace" ? (y = "\u23A7", S = "\u23A8", O = "\u23A9", C2 = "\u23AA", z = "Size4-Regular") : i === "\\}" || i === "\\rbrace" ? (y = "\u23AB", S = "\u23AC", O = "\u23AD", C2 = "\u23AA", z = "Size4-Regular") : i === "\\lgroup" || i === "\u27EE" ? (y = "\u23A7", O = "\u23A9", C2 = "\u23AA", z = "Size4-Regular") : i === "\\rgroup" || i === "\u27EF" ? (y = "\u23AB", O = "\u23AD", C2 = "\u23AA", z = "Size4-Regular") : i === "\\lmoustache" || i === "\u23B0" ? (y = "\u23A7", O = "\u23AD", C2 = "\u23AA", z = "Size4-Regular") : (i === "\\rmoustache" || i === "\u23B1") && (y = "\u23AB", O = "\u23A9", C2 = "\u23AA", z = "Size4-Regular");
          var X = Kn(y, z, f), K = X.height + X.depth, Y = Kn(C2, z, f), oe = Y.height + Y.depth, se = Kn(O, z, f), he = se.height + se.depth, me = 0, ge = 1;
          if (S !== null) {
            var Ze = Kn(S, z, f);
            me = Ze.height + Ze.depth, ge = 2;
          }
          var st = K + he + me, ft = Math.max(0, Math.ceil((a - st) / (ge * oe))), at = st + ft * ge * oe, ot = l.fontMetrics().axisHeight;
          o && (ot *= l.sizeMultiplier);
          var He = at / 2 - ot, lt = [];
          if (lt.push(eo(O, z, f)), lt.push(o1), S === null) {
            var yr = at - K - he + 2 * Wi;
            lt.push(Zn(C2, yr, l));
          } else {
            var Et = (at - K - he - me) / 2 + 2 * Wi;
            lt.push(Zn(C2, Et, l)), lt.push(o1), lt.push(eo(S, z, f)), lt.push(o1), lt.push(Zn(C2, Et, l));
          }
          lt.push(o1), lt.push(eo(y, z, f));
          var x1 = l.havingBaseStyle(pe.TEXT), Or = H.makeVList({ positionType: "bottom", positionData: He, children: lt }, x1);
          return Qa(H.makeSpan(["delimsizing", "mult"], [Or], x1), pe.TEXT, l, m);
        }, to = 80, n0 = 0.08, Mr = function(i, a, o, l, f) {
          var m = y0(i, l, o), y = new b0(i, m), S = new Wr([y], { width: "400em", height: a + "em", viewBox: "0 0 400000 " + o, preserveAspectRatio: "xMinYMin slice" });
          return H.makeSvgSpan(["hide-tail"], [S], f);
        }, qs = function(i, a) {
          var o = a.havingBaseSizing(), l = fe("\\surd", i * o.sizeMultiplier, $, o), f = o.sizeMultiplier, m = Math.max(0, a.minRuleThickness - a.fontMetrics().sqrtRuleThickness), y, S = 0, C2 = 0, O = 0, z;
          return l.type === "small" ? (O = 1e3 + 1e3 * m + to, i < 1 ? f = 1 : i < 1.4 && (f = 0.7), S = (1 + m + n0) / f, C2 = (1 + m) / f, y = Mr("sqrtMain", S, O, m, a), y.style.minWidth = "0.853em", z = 0.833 / f) : l.type === "large" ? (O = (1e3 + to) * Jn[l.size], C2 = (Jn[l.size] + m) / f, S = (Jn[l.size] + m + n0) / f, y = Mr("sqrtSize" + l.size, S, O, m, a), y.style.minWidth = "1.02em", z = 1 / f) : (S = i + m + n0, C2 = i + m, O = Math.floor(1e3 * i + m) + to, y = Mr("sqrtTall", S, O, m, a), y.style.minWidth = "0.742em", z = 1.056), y.height = C2, y.style.height = S + "em", { span: y, advanceWidth: z, ruleWidth: (a.fontMetrics().sqrtRuleThickness + m) * f };
        }, Ps = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"], Xu = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"], Ls = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], Jn = [0, 1.2, 1.8, 2.4, 3], Yu = function(i, a, o, l, f) {
          if (i === "<" || i === "\\lt" || i === "\u27E8" ? i = "\\langle" : (i === ">" || i === "\\gt" || i === "\u27E9") && (i = "\\rangle"), V.contains(Ps, i) || V.contains(Ls, i))
            return Ns(i, a, false, o, l, f);
          if (V.contains(Xu, i))
            return Os(i, Jn[a], false, o, l, f);
          throw new c("Illegal delimiter: '" + i + "'");
        }, i0 = [{ type: "small", style: pe.SCRIPTSCRIPT }, { type: "small", style: pe.SCRIPT }, { type: "small", style: pe.TEXT }, { type: "large", size: 1 }, { type: "large", size: 2 }, { type: "large", size: 3 }, { type: "large", size: 4 }], I = [{ type: "small", style: pe.SCRIPTSCRIPT }, { type: "small", style: pe.SCRIPT }, { type: "small", style: pe.TEXT }, { type: "stack" }], $ = [{ type: "small", style: pe.SCRIPTSCRIPT }, { type: "small", style: pe.SCRIPT }, { type: "small", style: pe.TEXT }, { type: "large", size: 1 }, { type: "large", size: 2 }, { type: "large", size: 3 }, { type: "large", size: 4 }, { type: "stack" }], W = function(i) {
          if (i.type === "small")
            return "Main-Regular";
          if (i.type === "large")
            return "Size" + i.size + "-Regular";
          if (i.type === "stack")
            return "Size4-Regular";
          throw new Error("Add support for delim type '" + i.type + "' here.");
        }, fe = function(i, a, o, l) {
          for (var f = Math.min(2, 3 - l.style.size), m = f; m < o.length && o[m].type !== "stack"; m++) {
            var y = Kn(i, W(o[m]), "math"), S = y.height + y.depth;
            if (o[m].type === "small") {
              var C2 = l.havingBaseStyle(o[m].style);
              S *= C2.sizeMultiplier;
            }
            if (S > a)
              return o[m];
          }
          return o[o.length - 1];
        }, Be = function(i, a, o, l, f, m) {
          i === "<" || i === "\\lt" || i === "\u27E8" ? i = "\\langle" : (i === ">" || i === "\\gt" || i === "\u27E9") && (i = "\\rangle");
          var y;
          V.contains(Ls, i) ? y = i0 : V.contains(Ps, i) ? y = $ : y = I;
          var S = fe(i, a, y, l);
          return S.type === "small" ? Vu(i, S.style, o, l, f, m) : S.type === "large" ? Ns(i, S.size, o, l, f, m) : Os(i, a, o, l, f, m);
        }, nt = function(i, a, o, l, f, m) {
          var y = l.fontMetrics().axisHeight * l.sizeMultiplier, S = 901, C2 = 5 / l.fontMetrics().ptPerEm, O = Math.max(a - y, o + y), z = Math.max(O / 500 * S, 2 * O - C2);
          return Be(i, z, true, l, f, m);
        }, Qe = { sqrtImage: qs, sizedDelim: Yu, sizeToMaxHeight: Jn, customSizedDelim: Be, leftRightDelim: nt }, tt = { "\\bigl": { mclass: "mopen", size: 1 }, "\\Bigl": { mclass: "mopen", size: 2 }, "\\biggl": { mclass: "mopen", size: 3 }, "\\Biggl": { mclass: "mopen", size: 4 }, "\\bigr": { mclass: "mclose", size: 1 }, "\\Bigr": { mclass: "mclose", size: 2 }, "\\biggr": { mclass: "mclose", size: 3 }, "\\Biggr": { mclass: "mclose", size: 4 }, "\\bigm": { mclass: "mrel", size: 1 }, "\\Bigm": { mclass: "mrel", size: 2 }, "\\biggm": { mclass: "mrel", size: 3 }, "\\Biggm": { mclass: "mrel", size: 4 }, "\\big": { mclass: "mord", size: 1 }, "\\Big": { mclass: "mord", size: 2 }, "\\bigg": { mclass: "mord", size: 3 }, "\\Bigg": { mclass: "mord", size: 4 } }, ro = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
        function Vi(g, i) {
          var a = Fi(g);
          if (a && V.contains(ro, a.text))
            return a;
          throw a ? new c("Invalid delimiter '" + a.text + "' after '" + i.funcName + "'", g) : new c("Invalid delimiter type '" + g.type + "'", g);
        }
        ce({ type: "delimsizing", names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"], props: { numArgs: 1, argTypes: ["primitive"] }, handler: function(i, a) {
          var o = Vi(a[0], i);
          return { type: "delimsizing", mode: i.parser.mode, size: tt[i.funcName].size, mclass: tt[i.funcName].mclass, delim: o.text };
        }, htmlBuilder: function(i, a) {
          return i.delim === "." ? H.makeSpan([i.mclass]) : Qe.sizedDelim(i.delim, i.size, a, i.mode, [i.mclass]);
        }, mathmlBuilder: function(i) {
          var a = [];
          i.delim !== "." && a.push(Cr(i.delim, i.mode));
          var o = new ne.MathNode("mo", a);
          return i.mclass === "mopen" || i.mclass === "mclose" ? o.setAttribute("fence", "true") : o.setAttribute("fence", "false"), o.setAttribute("stretchy", "true"), o.setAttribute("minsize", Qe.sizeToMaxHeight[i.size] + "em"), o.setAttribute("maxsize", Qe.sizeToMaxHeight[i.size] + "em"), o;
        } });
        function Dr(g) {
          if (!g.body)
            throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
        }
        ce({ type: "leftright-right", names: ["\\right"], props: { numArgs: 1, primitive: true }, handler: function(i, a) {
          var o = i.parser.gullet.macros.get("\\current@color");
          if (o && typeof o != "string")
            throw new c("\\current@color set to non-string in \\right");
          return { type: "leftright-right", mode: i.parser.mode, delim: Vi(a[0], i).text, color: o };
        } }), ce({ type: "leftright", names: ["\\left"], props: { numArgs: 1, primitive: true }, handler: function(i, a) {
          var o = Vi(a[0], i), l = i.parser;
          ++l.leftrightDepth;
          var f = l.parseExpression(false);
          --l.leftrightDepth, l.expect("\\right", false);
          var m = Oe(l.parseFunction(), "leftright-right");
          return { type: "leftright", mode: l.mode, body: f, left: o.text, right: m.delim, rightColor: m.color };
        }, htmlBuilder: function(i, a) {
          Dr(i);
          for (var o = Xt(i.body, a, true, ["mopen", "mclose"]), l = 0, f = 0, m = false, y = 0; y < o.length; y++)
            o[y].isMiddle ? m = true : (l = Math.max(o[y].height, l), f = Math.max(o[y].depth, f));
          l *= a.sizeMultiplier, f *= a.sizeMultiplier;
          var S;
          if (i.left === "." ? S = T0(a, ["mopen"]) : S = Qe.leftRightDelim(i.left, l, f, a, i.mode, ["mopen"]), o.unshift(S), m)
            for (var C2 = 1; C2 < o.length; C2++) {
              var O = o[C2], z = O.isMiddle;
              z && (o[C2] = Qe.leftRightDelim(z.delim, l, f, z.options, i.mode, []));
            }
          var X;
          if (i.right === ".")
            X = T0(a, ["mclose"]);
          else {
            var K = i.rightColor ? a.withColor(i.rightColor) : a;
            X = Qe.leftRightDelim(i.right, l, f, K, i.mode, ["mclose"]);
          }
          return o.push(X), H.makeSpan(["minner"], o, a);
        }, mathmlBuilder: function(i, a) {
          Dr(i);
          var o = kr(i.body, a);
          if (i.left !== ".") {
            var l = new ne.MathNode("mo", [Cr(i.left, i.mode)]);
            l.setAttribute("fence", "true"), o.unshift(l);
          }
          if (i.right !== ".") {
            var f = new ne.MathNode("mo", [Cr(i.right, i.mode)]);
            f.setAttribute("fence", "true"), i.rightColor && f.setAttribute("mathcolor", i.rightColor), o.push(f);
          }
          return zi(o);
        } }), ce({ type: "middle", names: ["\\middle"], props: { numArgs: 1, primitive: true }, handler: function(i, a) {
          var o = Vi(a[0], i);
          if (!i.parser.leftrightDepth)
            throw new c("\\middle without preceding \\left", o);
          return { type: "middle", mode: i.parser.mode, delim: o.text };
        }, htmlBuilder: function(i, a) {
          var o;
          if (i.delim === ".")
            o = T0(a, []);
          else {
            o = Qe.sizedDelim(i.delim, 1, a, i.mode, []);
            var l = { delim: i.delim, options: a };
            o.isMiddle = l;
          }
          return o;
        }, mathmlBuilder: function(i, a) {
          var o = i.delim === "\\vert" || i.delim === "|" ? Cr("|", "text") : Cr(i.delim, i.mode), l = new ne.MathNode("mo", [o]);
          return l.setAttribute("fence", "true"), l.setAttribute("lspace", "0.05em"), l.setAttribute("rspace", "0.05em"), l;
        } });
        var un = function(i, a) {
          var o = H.wrapFragment(Ie(i.body, a), a), l = i.label.substr(1), f = a.sizeMultiplier, m, y = 0, S = V.isCharacterBox(i.body);
          if (l === "sout")
            m = H.makeSpan(["stretchy", "sout"]), m.height = a.fontMetrics().defaultRuleThickness / f, y = -0.5 * a.fontMetrics().xHeight;
          else if (l === "phase") {
            var C2 = _t({ number: 0.6, unit: "pt" }, a), O = _t({ number: 0.35, unit: "ex" }, a), z = a.havingBaseSizing();
            f = f / z.sizeMultiplier;
            var X = o.height + o.depth + C2 + O;
            o.style.paddingLeft = X / 2 + C2 + "em";
            var K = Math.floor(1e3 * X * f), Y = Q1(K), oe = new Wr([new b0("phase", Y)], { width: "400em", height: K / 1e3 + "em", viewBox: "0 0 400000 " + K, preserveAspectRatio: "xMinYMin slice" });
            m = H.makeSvgSpan(["hide-tail"], [oe], a), m.style.height = X + "em", y = o.depth + C2 + O;
          } else {
            /cancel/.test(l) ? S || o.classes.push("cancel-pad") : l === "angl" ? o.classes.push("anglpad") : o.classes.push("boxpad");
            var se = 0, he = 0, me = 0;
            /box/.test(l) ? (me = Math.max(a.fontMetrics().fboxrule, a.minRuleThickness), se = a.fontMetrics().fboxsep + (l === "colorbox" ? 0 : me), he = se) : l === "angl" ? (me = Math.max(a.fontMetrics().defaultRuleThickness, a.minRuleThickness), se = 4 * me, he = Math.max(0, 0.25 - o.depth)) : (se = S ? 0.2 : 0, he = se), m = v1.encloseSpan(o, l, se, he, a), /fbox|boxed|fcolorbox/.test(l) ? (m.style.borderStyle = "solid", m.style.borderWidth = me + "em") : l === "angl" && me !== 0.049 && (m.style.borderTopWidth = me + "em", m.style.borderRightWidth = me + "em"), y = o.depth + he, i.backgroundColor && (m.style.backgroundColor = i.backgroundColor, i.borderColor && (m.style.borderColor = i.borderColor));
          }
          var ge;
          if (i.backgroundColor)
            ge = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: m, shift: y }, { type: "elem", elem: o, shift: 0 }] }, a);
          else {
            var Ze = /cancel|phase/.test(l) ? ["svg-align"] : [];
            ge = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: o, shift: 0 }, { type: "elem", elem: m, shift: y, wrapperClasses: Ze }] }, a);
          }
          return /cancel/.test(l) && (ge.height = o.height, ge.depth = o.depth), /cancel/.test(l) && !S ? H.makeSpan(["mord", "cancel-lap"], [ge], a) : H.makeSpan(["mord"], [ge], a);
        }, no = function(i, a) {
          var o = 0, l = new ne.MathNode(i.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [ct(i.body, a)]);
          switch (i.label) {
            case "\\cancel":
              l.setAttribute("notation", "updiagonalstrike");
              break;
            case "\\bcancel":
              l.setAttribute("notation", "downdiagonalstrike");
              break;
            case "\\phase":
              l.setAttribute("notation", "phasorangle");
              break;
            case "\\sout":
              l.setAttribute("notation", "horizontalstrike");
              break;
            case "\\fbox":
              l.setAttribute("notation", "box");
              break;
            case "\\angl":
              l.setAttribute("notation", "actuarial");
              break;
            case "\\fcolorbox":
            case "\\colorbox":
              if (o = a.fontMetrics().fboxsep * a.fontMetrics().ptPerEm, l.setAttribute("width", "+" + 2 * o + "pt"), l.setAttribute("height", "+" + 2 * o + "pt"), l.setAttribute("lspace", o + "pt"), l.setAttribute("voffset", o + "pt"), i.label === "\\fcolorbox") {
                var f = Math.max(a.fontMetrics().fboxrule, a.minRuleThickness);
                l.setAttribute("style", "border: " + f + "em solid " + String(i.borderColor));
              }
              break;
            case "\\xcancel":
              l.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
              break;
          }
          return i.backgroundColor && l.setAttribute("mathbackground", i.backgroundColor), l;
        };
        ce({ type: "enclose", names: ["\\colorbox"], props: { numArgs: 2, allowedInText: true, argTypes: ["color", "text"] }, handler: function(i, a, o) {
          var l = i.parser, f = i.funcName, m = Oe(a[0], "color-token").color, y = a[1];
          return { type: "enclose", mode: l.mode, label: f, backgroundColor: m, body: y };
        }, htmlBuilder: un, mathmlBuilder: no }), ce({ type: "enclose", names: ["\\fcolorbox"], props: { numArgs: 3, allowedInText: true, argTypes: ["color", "color", "text"] }, handler: function(i, a, o) {
          var l = i.parser, f = i.funcName, m = Oe(a[0], "color-token").color, y = Oe(a[1], "color-token").color, S = a[2];
          return { type: "enclose", mode: l.mode, label: f, backgroundColor: y, borderColor: m, body: S };
        }, htmlBuilder: un, mathmlBuilder: no }), ce({ type: "enclose", names: ["\\fbox"], props: { numArgs: 1, argTypes: ["hbox"], allowedInText: true }, handler: function(i, a) {
          var o = i.parser;
          return { type: "enclose", mode: o.mode, label: "\\fbox", body: a[0] };
        } }), ce({ type: "enclose", names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          return { type: "enclose", mode: o.mode, label: l, body: f };
        }, htmlBuilder: un, mathmlBuilder: no }), ce({ type: "enclose", names: ["\\angl"], props: { numArgs: 1, argTypes: ["hbox"], allowedInText: false }, handler: function(i, a) {
          var o = i.parser;
          return { type: "enclose", mode: o.mode, label: "\\angl", body: a[0] };
        } });
        var k0 = {};
        function Br(g) {
          for (var i = g.type, a = g.names, o = g.props, l = g.handler, f = g.htmlBuilder, m = g.mathmlBuilder, y = { type: i, numArgs: o.numArgs || 0, allowedInText: false, numOptionalArgs: 0, handler: l }, S = 0; S < a.length; ++S)
            k0[a[S]] = y;
          f && (Li[i] = f), m && (Ii[i] = m);
        }
        function Qn(g) {
          var i = [];
          g.consumeSpaces();
          for (var a = g.fetch().text; a === "\\hline" || a === "\\hdashline"; )
            g.consume(), i.push(a === "\\hdashline"), g.consumeSpaces(), a = g.fetch().text;
          return i;
        }
        var rt = function(i) {
          var a = i.parser.settings;
          if (!a.displayMode)
            throw new c("{" + i.envName + "} can be used only in display mode.");
        };
        function a0(g, i, a) {
          var o = i.hskipBeforeAndAfter, l = i.addJot, f = i.cols, m = i.arraystretch, y = i.colSeparationType, S = i.addEqnNum, C2 = i.singleRow, O = i.emptySingleRow, z = i.maxNumCols, X = i.leqno;
          if (g.gullet.beginGroup(), C2 || g.gullet.macros.set("\\cr", "\\\\\\relax"), !m) {
            var K = g.gullet.expandMacroAsText("\\arraystretch");
            if (K == null)
              m = 1;
            else if (m = parseFloat(K), !m || m < 0)
              throw new c("Invalid \\arraystretch: " + K);
          }
          g.gullet.beginGroup();
          var Y = [], oe = [Y], se = [], he = [];
          for (he.push(Qn(g)); ; ) {
            var me = g.parseExpression(false, C2 ? "\\end" : "\\\\");
            g.gullet.endGroup(), g.gullet.beginGroup(), me = { type: "ordgroup", mode: g.mode, body: me }, a && (me = { type: "styling", mode: g.mode, style: a, body: [me] }), Y.push(me);
            var ge = g.fetch().text;
            if (ge === "&") {
              if (z && Y.length === z) {
                if (C2 || y)
                  throw new c("Too many tab characters: &", g.nextToken);
                g.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
              }
              g.consume();
            } else if (ge === "\\end") {
              Y.length === 1 && me.type === "styling" && me.body[0].body.length === 0 && (oe.length > 1 || !O) && oe.pop(), he.length < oe.length + 1 && he.push([]);
              break;
            } else if (ge === "\\\\") {
              g.consume();
              var Ze = void 0;
              g.gullet.future().text !== " " && (Ze = g.parseSizeGroup(true)), se.push(Ze ? Ze.value : null), he.push(Qn(g)), Y = [], oe.push(Y);
            } else
              throw new c("Expected & or \\\\ or \\cr or \\end", g.nextToken);
          }
          return g.gullet.endGroup(), g.gullet.endGroup(), { type: "array", mode: g.mode, addJot: l, arraystretch: m, body: oe, cols: f, rowGaps: se, hskipBeforeAndAfter: o, hLinesBeforeRow: he, colSeparationType: y, addEqnNum: S, leqno: X };
        }
        function $i(g) {
          return g.substr(0, 1) === "d" ? "display" : "text";
        }
        var Nr = function(i, a) {
          var o, l, f = i.body.length, m = i.hLinesBeforeRow, y = 0, S = new Array(f), C2 = [], O = Math.max(a.fontMetrics().arrayRuleWidth, a.minRuleThickness), z = 1 / a.fontMetrics().ptPerEm, X = 5 * z;
          if (i.colSeparationType && i.colSeparationType === "small") {
            var K = a.havingStyle(pe.SCRIPT).sizeMultiplier;
            X = 0.2778 * (K / a.sizeMultiplier);
          }
          var Y = i.colSeparationType === "CD" ? _t({ number: 3, unit: "ex" }, a) : 12 * z, oe = 3 * z, se = i.arraystretch * Y, he = 0.7 * se, me = 0.3 * se, ge = 0;
          function Ze(na) {
            for (var ia = 0; ia < na.length; ++ia)
              ia > 0 && (ge += 0.25), C2.push({ pos: ge, isDashed: na[ia] });
          }
          for (Ze(m[0]), o = 0; o < i.body.length; ++o) {
            var st = i.body[o], ft = he, at = me;
            y < st.length && (y = st.length);
            var ot = new Array(st.length);
            for (l = 0; l < st.length; ++l) {
              var He = Ie(st[l], a);
              at < He.depth && (at = He.depth), ft < He.height && (ft = He.height), ot[l] = He;
            }
            var lt = i.rowGaps[o], yr = 0;
            lt && (yr = _t(lt, a), yr > 0 && (yr += me, at < yr && (at = yr), yr = 0)), i.addJot && (at += oe), ot.height = ft, ot.depth = at, ge += ft, ot.pos = ge, ge += at + yr, S[o] = ot, Ze(m[o + 1]);
          }
          var Et = ge / 2 + a.fontMetrics().axisHeight, x1 = i.cols || [], Or = [], Rt, B0, Qt = [];
          if (i.addEqnNum)
            for (o = 0; o < f; ++o) {
              var si = S[o], f2 = si.pos - Et, vo = H.makeSpan(["eqn-num"], [], a);
              vo.depth = si.depth, vo.height = si.height, Qt.push({ type: "elem", elem: vo, shift: f2 });
            }
          for (l = 0, B0 = 0; l < y || B0 < x1.length; ++l, ++B0) {
            for (var W1 = x1[B0] || {}, ea = true; W1.type === "separator"; ) {
              if (ea || (Rt = H.makeSpan(["arraycolsep"], []), Rt.style.width = a.fontMetrics().doubleRuleSep + "em", Or.push(Rt)), W1.separator === "|" || W1.separator === ":") {
                var h2 = W1.separator === "|" ? "solid" : "dashed", w1 = H.makeSpan(["vertical-separator"], [], a);
                w1.style.height = ge + "em", w1.style.borderRightWidth = O + "em", w1.style.borderRightStyle = h2, w1.style.margin = "0 -" + O / 2 + "em";
                var yo = ge - Et;
                yo && (w1.style.verticalAlign = -yo + "em"), Or.push(w1);
              } else
                throw new c("Invalid separator type: " + W1.separator);
              B0++, W1 = x1[B0] || {}, ea = false;
            }
            if (!(l >= y)) {
              var vn = void 0;
              (l > 0 || i.hskipBeforeAndAfter) && (vn = V.deflt(W1.pregap, X), vn !== 0 && (Rt = H.makeSpan(["arraycolsep"], []), Rt.style.width = vn + "em", Or.push(Rt)));
              var yn = [];
              for (o = 0; o < f; ++o) {
                var l0 = S[o], ta = l0[l];
                if (!!ta) {
                  var d2 = l0.pos - Et;
                  ta.depth = l0.depth, ta.height = l0.height, yn.push({ type: "elem", elem: ta, shift: d2 });
                }
              }
              yn = H.makeVList({ positionType: "individualShift", children: yn }, a), yn = H.makeSpan(["col-align-" + (W1.align || "c")], [yn]), Or.push(yn), (l < y - 1 || i.hskipBeforeAndAfter) && (vn = V.deflt(W1.postgap, X), vn !== 0 && (Rt = H.makeSpan(["arraycolsep"], []), Rt.style.width = vn + "em", Or.push(Rt)));
            }
          }
          if (S = H.makeSpan(["mtable"], Or), C2.length > 0) {
            for (var bo = H.makeLineSpan("hline", a, O), Qs = H.makeLineSpan("hdashline", a, O), xo = [{ type: "elem", elem: S, shift: 0 }]; C2.length > 0; ) {
              var el = C2.pop(), tl = el.pos - Et;
              el.isDashed ? xo.push({ type: "elem", elem: Qs, shift: tl }) : xo.push({ type: "elem", elem: bo, shift: tl });
            }
            S = H.makeVList({ positionType: "individualShift", children: xo }, a);
          }
          if (i.addEqnNum) {
            var ra = H.makeVList({ positionType: "individualShift", children: Qt }, a);
            return ra = H.makeSpan(["tag"], [ra], a), H.makeFragment([S, ra]);
          } else
            return H.makeSpan(["mord"], [S], a);
        }, Ku = { c: "center ", l: "left ", r: "right " }, y1 = function(i, a) {
          for (var o = [], l = new ne.MathNode("mtd", [], ["mtr-glue"]), f = new ne.MathNode("mtd", [], ["mml-eqn-num"]), m = 0; m < i.body.length; m++) {
            for (var y = i.body[m], S = [], C2 = 0; C2 < y.length; C2++)
              S.push(new ne.MathNode("mtd", [ct(y[C2], a)]));
            i.addEqnNum && (S.unshift(l), S.push(l), i.leqno ? S.unshift(f) : S.push(f)), o.push(new ne.MathNode("mtr", S));
          }
          var O = new ne.MathNode("mtable", o), z = i.arraystretch === 0.5 ? 0.1 : 0.16 + i.arraystretch - 1 + (i.addJot ? 0.09 : 0);
          O.setAttribute("rowspacing", z.toFixed(4) + "em");
          var X = "", K = "";
          if (i.cols && i.cols.length > 0) {
            var Y = i.cols, oe = "", se = false, he = 0, me = Y.length;
            Y[0].type === "separator" && (X += "top ", he = 1), Y[Y.length - 1].type === "separator" && (X += "bottom ", me -= 1);
            for (var ge = he; ge < me; ge++)
              Y[ge].type === "align" ? (K += Ku[Y[ge].align], se && (oe += "none "), se = true) : Y[ge].type === "separator" && se && (oe += Y[ge].separator === "|" ? "solid " : "dashed ", se = false);
            O.setAttribute("columnalign", K.trim()), /[sd]/.test(oe) && O.setAttribute("columnlines", oe.trim());
          }
          if (i.colSeparationType === "align") {
            for (var Ze = i.cols || [], st = "", ft = 1; ft < Ze.length; ft++)
              st += ft % 2 ? "0em " : "1em ";
            O.setAttribute("columnspacing", st.trim());
          } else
            i.colSeparationType === "alignat" || i.colSeparationType === "gather" ? O.setAttribute("columnspacing", "0em") : i.colSeparationType === "small" ? O.setAttribute("columnspacing", "0.2778em") : i.colSeparationType === "CD" ? O.setAttribute("columnspacing", "0.5em") : O.setAttribute("columnspacing", "1em");
          var at = "", ot = i.hLinesBeforeRow;
          X += ot[0].length > 0 ? "left " : "", X += ot[ot.length - 1].length > 0 ? "right " : "";
          for (var He = 1; He < ot.length - 1; He++)
            at += ot[He].length === 0 ? "none " : ot[He][0] ? "dashed " : "solid ";
          return /[sd]/.test(at) && O.setAttribute("rowlines", at.trim()), X !== "" && (O = new ne.MathNode("menclose", [O]), O.setAttribute("notation", X.trim())), i.arraystretch && i.arraystretch < 1 && (O = new ne.MathNode("mstyle", [O]), O.setAttribute("scriptlevel", "1")), O;
        }, Is = function(i, a) {
          i.envName.indexOf("ed") === -1 && rt(i);
          var o = [], l = i.envName.indexOf("at") > -1 ? "alignat" : "align", f = a0(i.parser, { cols: o, addJot: true, addEqnNum: i.envName === "align" || i.envName === "alignat", emptySingleRow: true, colSeparationType: l, maxNumCols: i.envName === "split" ? 2 : void 0, leqno: i.parser.settings.leqno }, "display"), m, y = 0, S = { type: "ordgroup", mode: i.mode, body: [] };
          if (a[0] && a[0].type === "ordgroup") {
            for (var C2 = "", O = 0; O < a[0].body.length; O++) {
              var z = Oe(a[0].body[O], "textord");
              C2 += z.text;
            }
            m = Number(C2), y = m * 2;
          }
          var X = !y;
          f.body.forEach(function(se) {
            for (var he = 1; he < se.length; he += 2) {
              var me = Oe(se[he], "styling"), ge = Oe(me.body[0], "ordgroup");
              ge.body.unshift(S);
            }
            if (X)
              y < se.length && (y = se.length);
            else {
              var Ze = se.length / 2;
              if (m < Ze)
                throw new c("Too many math in a row: " + ("expected " + m + ", but got " + Ze), se[0]);
            }
          });
          for (var K = 0; K < y; ++K) {
            var Y = "r", oe = 0;
            K % 2 == 1 ? Y = "l" : K > 0 && X && (oe = 1), o[K] = { type: "align", align: Y, pregap: oe, postgap: 0 };
          }
          return f.colSeparationType = X ? "align" : "alignat", f;
        };
        Br({ type: "array", names: ["array", "darray"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = Fi(a[0]), l = o ? [a[0]] : Oe(a[0], "ordgroup").body, f = l.map(function(y) {
            var S = r0(y), C2 = S.text;
            if ("lcr".indexOf(C2) !== -1)
              return { type: "align", align: C2 };
            if (C2 === "|")
              return { type: "separator", separator: "|" };
            if (C2 === ":")
              return { type: "separator", separator: ":" };
            throw new c("Unknown column alignment: " + C2, y);
          }), m = { cols: f, hskipBeforeAndAfter: true, maxNumCols: f.length };
          return a0(i.parser, m, $i(i.envName));
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"], props: { numArgs: 0 }, handler: function(i) {
          var a = { matrix: null, pmatrix: ["(", ")"], bmatrix: ["[", "]"], Bmatrix: ["\\{", "\\}"], vmatrix: ["|", "|"], Vmatrix: ["\\Vert", "\\Vert"] }[i.envName.replace("*", "")], o = "c", l = { hskipBeforeAndAfter: false, cols: [{ type: "align", align: o }] };
          if (i.envName.charAt(i.envName.length - 1) === "*") {
            var f = i.parser;
            if (f.consumeSpaces(), f.fetch().text === "[") {
              if (f.consume(), f.consumeSpaces(), o = f.fetch().text, "lcr".indexOf(o) === -1)
                throw new c("Expected l or c or r", f.nextToken);
              f.consume(), f.consumeSpaces(), f.expect("]"), f.consume(), l.cols = [{ type: "align", align: o }];
            }
          }
          var m = a0(i.parser, l, $i(i.envName)), y = Math.max.apply(Math, [0].concat(m.body.map(function(S) {
            return S.length;
          })));
          return m.cols = new Array(y).fill({ type: "align", align: o }), a ? { type: "leftright", mode: i.mode, body: [m], left: a[0], right: a[1], rightColor: void 0 } : m;
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["smallmatrix"], props: { numArgs: 0 }, handler: function(i) {
          var a = { arraystretch: 0.5 }, o = a0(i.parser, a, "script");
          return o.colSeparationType = "small", o;
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["subarray"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = Fi(a[0]), l = o ? [a[0]] : Oe(a[0], "ordgroup").body, f = l.map(function(y) {
            var S = r0(y), C2 = S.text;
            if ("lc".indexOf(C2) !== -1)
              return { type: "align", align: C2 };
            throw new c("Unknown column alignment: " + C2, y);
          });
          if (f.length > 1)
            throw new c("{subarray} can contain only one column");
          var m = { cols: f, hskipBeforeAndAfter: false, arraystretch: 0.5 };
          if (m = a0(i.parser, m, "script"), m.body.length > 0 && m.body[0].length > 1)
            throw new c("{subarray} can contain only one column");
          return m;
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["cases", "dcases", "rcases", "drcases"], props: { numArgs: 0 }, handler: function(i) {
          var a = { arraystretch: 1.2, cols: [{ type: "align", align: "l", pregap: 0, postgap: 1 }, { type: "align", align: "l", pregap: 0, postgap: 0 }] }, o = a0(i.parser, a, $i(i.envName));
          return { type: "leftright", mode: i.mode, body: [o], left: i.envName.indexOf("r") > -1 ? "." : "\\{", right: i.envName.indexOf("r") > -1 ? "\\}" : ".", rightColor: void 0 };
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["align", "align*", "aligned", "split"], props: { numArgs: 0 }, handler: Is, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["gathered", "gather", "gather*"], props: { numArgs: 0 }, handler: function(i) {
          V.contains(["gather", "gather*"], i.envName) && rt(i);
          var a = { cols: [{ type: "align", align: "c" }], addJot: true, colSeparationType: "gather", addEqnNum: i.envName === "gather", emptySingleRow: true, leqno: i.parser.settings.leqno };
          return a0(i.parser, a, "display");
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["alignat", "alignat*", "alignedat"], props: { numArgs: 1 }, handler: Is, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["equation", "equation*"], props: { numArgs: 0 }, handler: function(i) {
          rt(i);
          var a = { addEqnNum: i.envName === "equation", emptySingleRow: true, singleRow: true, maxNumCols: 1, leqno: i.parser.settings.leqno };
          return a0(i.parser, a, "display");
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), Br({ type: "array", names: ["CD"], props: { numArgs: 0 }, handler: function(i) {
          return rt(i), ks(i.parser);
        }, htmlBuilder: Nr, mathmlBuilder: y1 }), ce({ type: "text", names: ["\\hline", "\\hdashline"], props: { numArgs: 0, allowedInText: true, allowedInMath: true }, handler: function(i, a) {
          throw new c(i.funcName + " valid only within array environment");
        } });
        var Xi = k0, F1 = Xi;
        ce({ type: "environment", names: ["\\begin", "\\end"], props: { numArgs: 1, argTypes: ["text"] }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          if (f.type !== "ordgroup")
            throw new c("Invalid environment name", f);
          for (var m = "", y = 0; y < f.body.length; ++y)
            m += Oe(f.body[y], "textord").text;
          if (l === "\\begin") {
            if (!F1.hasOwnProperty(m))
              throw new c("No such environment: " + m, f);
            var S = F1[m], C2 = o.parseArguments("\\begin{" + m + "}", S), O = C2.args, z = C2.optArgs, X = { mode: o.mode, envName: m, parser: o }, K = S.handler(X, O, z);
            o.expect("\\end", false);
            var Y = o.nextToken, oe = Oe(o.parseFunction(), "environment");
            if (oe.name !== m)
              throw new c("Mismatch: \\begin{" + m + "} matched by \\end{" + oe.name + "}", Y);
            return K;
          }
          return { type: "environment", mode: o.mode, name: m, nameGroup: f };
        } });
        var Yi = H.makeSpan;
        function io(g, i) {
          var a = Xt(g.body, i, true);
          return Yi([g.mclass], a, i);
        }
        function ei(g, i) {
          var a, o = kr(g.body, i);
          return g.mclass === "minner" ? ne.newDocumentFragment(o) : (g.mclass === "mord" ? g.isCharacterBox ? (a = o[0], a.type = "mi") : a = new ne.MathNode("mi", o) : (g.isCharacterBox ? (a = o[0], a.type = "mo") : a = new ne.MathNode("mo", o), g.mclass === "mbin" ? (a.attributes.lspace = "0.22em", a.attributes.rspace = "0.22em") : g.mclass === "mpunct" ? (a.attributes.lspace = "0em", a.attributes.rspace = "0.17em") : (g.mclass === "mopen" || g.mclass === "mclose") && (a.attributes.lspace = "0em", a.attributes.rspace = "0em")), a);
        }
        ce({ type: "mclass", names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"], props: { numArgs: 1, primitive: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          return { type: "mclass", mode: o.mode, mclass: "m" + l.substr(5), body: Ne(f), isCharacterBox: V.isCharacterBox(f) };
        }, htmlBuilder: io, mathmlBuilder: ei });
        var Ki = function(i) {
          var a = i.type === "ordgroup" && i.body.length ? i.body[0] : i;
          return a.type === "atom" && (a.family === "bin" || a.family === "rel") ? "m" + a.family : "mord";
        };
        ce({ type: "mclass", names: ["\\@binrel"], props: { numArgs: 2 }, handler: function(i, a) {
          var o = i.parser;
          return { type: "mclass", mode: o.mode, mclass: Ki(a[0]), body: Ne(a[1]), isCharacterBox: V.isCharacterBox(a[1]) };
        } }), ce({ type: "mclass", names: ["\\stackrel", "\\overset", "\\underset"], props: { numArgs: 2 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[1], m = a[0], y;
          l !== "\\stackrel" ? y = Ki(f) : y = "mrel";
          var S = { type: "op", mode: f.mode, limits: true, alwaysHandleSupSub: true, parentIsSupSub: false, symbol: false, suppressBaseShift: l !== "\\stackrel", body: Ne(f) }, C2 = { type: "supsub", mode: m.mode, base: S, sup: l === "\\underset" ? null : m, sub: l === "\\underset" ? m : null };
          return { type: "mclass", mode: o.mode, mclass: y, body: [C2], isCharacterBox: V.isCharacterBox(C2) };
        }, htmlBuilder: io, mathmlBuilder: ei });
        var ao = function(i, a) {
          var o = i.font, l = a.withFont(o);
          return Ie(i.body, l);
        }, ti = function(i, a) {
          var o = i.font, l = a.withFont(o);
          return ct(i.body, l);
        }, oo = { "\\Bbb": "\\mathbb", "\\bold": "\\mathbf", "\\frak": "\\mathfrak", "\\bm": "\\boldsymbol" };
        ce({ type: "font", names: ["\\mathrm", "\\mathit", "\\mathbf", "\\mathnormal", "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf", "\\mathtt", "\\Bbb", "\\bold", "\\frak"], props: { numArgs: 1, allowedInArgument: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = Ri(a[0]), m = l;
          return m in oo && (m = oo[m]), { type: "font", mode: o.mode, font: m.slice(1), body: f };
        }, htmlBuilder: ao, mathmlBuilder: ti }), ce({ type: "mclass", names: ["\\boldsymbol", "\\bm"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = a[0], f = V.isCharacterBox(l);
          return { type: "mclass", mode: o.mode, mclass: Ki(l), body: [{ type: "font", mode: o.mode, font: "boldsymbol", body: l }], isCharacterBox: f };
        } }), ce({ type: "font", names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"], props: { numArgs: 0, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = i.breakOnTokenText, m = o.mode, y = o.parseExpression(true, f), S = "math" + l.slice(1);
          return { type: "font", mode: m, font: S, body: { type: "ordgroup", mode: o.mode, body: y } };
        }, htmlBuilder: ao, mathmlBuilder: ti });
        var cn = function(i, a) {
          var o = a;
          return i === "display" ? o = o.id >= pe.SCRIPT.id ? o.text() : pe.DISPLAY : i === "text" && o.size === pe.DISPLAY.size ? o = pe.TEXT : i === "script" ? o = pe.SCRIPT : i === "scriptscript" && (o = pe.SCRIPTSCRIPT), o;
        }, H1 = function(i, a) {
          var o = cn(i.size, a.style), l = o.fracNum(), f = o.fracDen(), m;
          m = a.havingStyle(l);
          var y = Ie(i.numer, m, a);
          if (i.continued) {
            var S = 8.5 / a.fontMetrics().ptPerEm, C2 = 3.5 / a.fontMetrics().ptPerEm;
            y.height = y.height < S ? S : y.height, y.depth = y.depth < C2 ? C2 : y.depth;
          }
          m = a.havingStyle(f);
          var O = Ie(i.denom, m, a), z, X, K;
          i.hasBarLine ? (i.barSize ? (X = _t(i.barSize, a), z = H.makeLineSpan("frac-line", a, X)) : z = H.makeLineSpan("frac-line", a), X = z.height, K = z.height) : (z = null, X = 0, K = a.fontMetrics().defaultRuleThickness);
          var Y, oe, se;
          o.size === pe.DISPLAY.size || i.size === "display" ? (Y = a.fontMetrics().num1, X > 0 ? oe = 3 * K : oe = 7 * K, se = a.fontMetrics().denom1) : (X > 0 ? (Y = a.fontMetrics().num2, oe = K) : (Y = a.fontMetrics().num3, oe = 3 * K), se = a.fontMetrics().denom2);
          var he;
          if (z) {
            var ge = a.fontMetrics().axisHeight;
            Y - y.depth - (ge + 0.5 * X) < oe && (Y += oe - (Y - y.depth - (ge + 0.5 * X))), ge - 0.5 * X - (O.height - se) < oe && (se += oe - (ge - 0.5 * X - (O.height - se)));
            var Ze = -(ge - 0.5 * X);
            he = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: O, shift: se }, { type: "elem", elem: z, shift: Ze }, { type: "elem", elem: y, shift: -Y }] }, a);
          } else {
            var me = Y - y.depth - (O.height - se);
            me < oe && (Y += 0.5 * (oe - me), se += 0.5 * (oe - me)), he = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: O, shift: se }, { type: "elem", elem: y, shift: -Y }] }, a);
          }
          m = a.havingStyle(o), he.height *= m.sizeMultiplier / a.sizeMultiplier, he.depth *= m.sizeMultiplier / a.sizeMultiplier;
          var st;
          o.size === pe.DISPLAY.size ? st = a.fontMetrics().delim1 : o.size === pe.SCRIPTSCRIPT.size ? st = a.havingStyle(pe.SCRIPT).fontMetrics().delim2 : st = a.fontMetrics().delim2;
          var ft, at;
          return i.leftDelim == null ? ft = T0(a, ["mopen"]) : ft = Qe.customSizedDelim(i.leftDelim, st, true, a.havingStyle(o), i.mode, ["mopen"]), i.continued ? at = H.makeSpan([]) : i.rightDelim == null ? at = T0(a, ["mclose"]) : at = Qe.customSizedDelim(i.rightDelim, st, true, a.havingStyle(o), i.mode, ["mclose"]), H.makeSpan(["mord"].concat(m.sizingClasses(a)), [ft, H.makeSpan(["mfrac"], [he]), at], a);
        }, fn = function(i, a) {
          var o = new ne.MathNode("mfrac", [ct(i.numer, a), ct(i.denom, a)]);
          if (!i.hasBarLine)
            o.setAttribute("linethickness", "0px");
          else if (i.barSize) {
            var l = _t(i.barSize, a);
            o.setAttribute("linethickness", l + "em");
          }
          var f = cn(i.size, a.style);
          if (f.size !== a.style.size) {
            o = new ne.MathNode("mstyle", [o]);
            var m = f.size === pe.DISPLAY.size ? "true" : "false";
            o.setAttribute("displaystyle", m), o.setAttribute("scriptlevel", "0");
          }
          if (i.leftDelim != null || i.rightDelim != null) {
            var y = [];
            if (i.leftDelim != null) {
              var S = new ne.MathNode("mo", [new ne.TextNode(i.leftDelim.replace("\\", ""))]);
              S.setAttribute("fence", "true"), y.push(S);
            }
            if (y.push(o), i.rightDelim != null) {
              var C2 = new ne.MathNode("mo", [new ne.TextNode(i.rightDelim.replace("\\", ""))]);
              C2.setAttribute("fence", "true"), y.push(C2);
            }
            return zi(y);
          }
          return o;
        };
        ce({ type: "genfrac", names: ["\\dfrac", "\\frac", "\\tfrac", "\\dbinom", "\\binom", "\\tbinom", "\\\\atopfrac", "\\\\bracefrac", "\\\\brackfrac"], props: { numArgs: 2, allowedInArgument: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0], m = a[1], y, S = null, C2 = null, O = "auto";
          switch (l) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              y = true;
              break;
            case "\\\\atopfrac":
              y = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              y = false, S = "(", C2 = ")";
              break;
            case "\\\\bracefrac":
              y = false, S = "\\{", C2 = "\\}";
              break;
            case "\\\\brackfrac":
              y = false, S = "[", C2 = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (l) {
            case "\\dfrac":
            case "\\dbinom":
              O = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              O = "text";
              break;
          }
          return { type: "genfrac", mode: o.mode, continued: false, numer: f, denom: m, hasBarLine: y, leftDelim: S, rightDelim: C2, size: O, barSize: null };
        }, htmlBuilder: H1, mathmlBuilder: fn }), ce({ type: "genfrac", names: ["\\cfrac"], props: { numArgs: 2 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0], m = a[1];
          return { type: "genfrac", mode: o.mode, continued: true, numer: f, denom: m, hasBarLine: true, leftDelim: null, rightDelim: null, size: "display", barSize: null };
        } }), ce({ type: "infix", names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"], props: { numArgs: 0, infix: true }, handler: function(i) {
          var a = i.parser, o = i.funcName, l = i.token, f;
          switch (o) {
            case "\\over":
              f = "\\frac";
              break;
            case "\\choose":
              f = "\\binom";
              break;
            case "\\atop":
              f = "\\\\atopfrac";
              break;
            case "\\brace":
              f = "\\\\bracefrac";
              break;
            case "\\brack":
              f = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return { type: "infix", mode: a.mode, replaceWith: f, token: l };
        } });
        var Rs = ["display", "text", "script", "scriptscript"], zs = function(i) {
          var a = null;
          return i.length > 0 && (a = i, a = a === "." ? null : a), a;
        };
        ce({ type: "genfrac", names: ["\\genfrac"], props: { numArgs: 6, allowedInArgument: true, argTypes: ["math", "math", "size", "text", "math", "math"] }, handler: function(i, a) {
          var o = i.parser, l = a[4], f = a[5], m = Ri(a[0]), y = m.type === "atom" && m.family === "open" ? zs(m.text) : null, S = Ri(a[1]), C2 = S.type === "atom" && S.family === "close" ? zs(S.text) : null, O = Oe(a[2], "size"), z, X = null;
          O.isBlank ? z = true : (X = O.value, z = X.number > 0);
          var K = "auto", Y = a[3];
          if (Y.type === "ordgroup") {
            if (Y.body.length > 0) {
              var oe = Oe(Y.body[0], "textord");
              K = Rs[Number(oe.text)];
            }
          } else
            Y = Oe(Y, "textord"), K = Rs[Number(Y.text)];
          return { type: "genfrac", mode: o.mode, numer: l, denom: f, continued: false, hasBarLine: z, barSize: X, leftDelim: y, rightDelim: C2, size: K };
        }, htmlBuilder: H1, mathmlBuilder: fn }), ce({ type: "infix", names: ["\\above"], props: { numArgs: 1, argTypes: ["size"], infix: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = i.token;
          return { type: "infix", mode: o.mode, replaceWith: "\\\\abovefrac", size: Oe(a[0], "size").value, token: f };
        } }), ce({ type: "genfrac", names: ["\\\\abovefrac"], props: { numArgs: 3, argTypes: ["math", "size", "math"] }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0], m = ae(Oe(a[1], "infix").size), y = a[2], S = m.number > 0;
          return { type: "genfrac", mode: o.mode, numer: f, denom: y, continued: false, hasBarLine: S, barSize: m, leftDelim: null, rightDelim: null, size: "auto" };
        }, htmlBuilder: H1, mathmlBuilder: fn });
        var Fs = function(i, a) {
          var o = a.style, l, f;
          i.type === "supsub" ? (l = i.sup ? Ie(i.sup, a.havingStyle(o.sup()), a) : Ie(i.sub, a.havingStyle(o.sub()), a), f = Oe(i.base, "horizBrace")) : f = Oe(i, "horizBrace");
          var m = Ie(f.base, a.havingBaseStyle(pe.DISPLAY)), y = v1.svgSpan(f, a), S;
          if (f.isOver ? (S = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: m }, { type: "kern", size: 0.1 }, { type: "elem", elem: y }] }, a), S.children[0].children[0].children[1].classes.push("svg-align")) : (S = H.makeVList({ positionType: "bottom", positionData: m.depth + 0.1 + y.height, children: [{ type: "elem", elem: y }, { type: "kern", size: 0.1 }, { type: "elem", elem: m }] }, a), S.children[0].children[0].children[0].classes.push("svg-align")), l) {
            var C2 = H.makeSpan(["mord", f.isOver ? "mover" : "munder"], [S], a);
            f.isOver ? S = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: C2 }, { type: "kern", size: 0.2 }, { type: "elem", elem: l }] }, a) : S = H.makeVList({ positionType: "bottom", positionData: C2.depth + 0.2 + l.height + l.depth, children: [{ type: "elem", elem: l }, { type: "kern", size: 0.2 }, { type: "elem", elem: C2 }] }, a);
          }
          return H.makeSpan(["mord", f.isOver ? "mover" : "munder"], [S], a);
        }, Zi = function(i, a) {
          var o = v1.mathMLnode(i.label);
          return new ne.MathNode(i.isOver ? "mover" : "munder", [ct(i.base, a), o]);
        };
        ce({ type: "horizBrace", names: ["\\overbrace", "\\underbrace"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName;
          return { type: "horizBrace", mode: o.mode, label: l, isOver: /^\\over/.test(l), base: a[0] };
        }, htmlBuilder: Fs, mathmlBuilder: Zi }), ce({ type: "href", names: ["\\href"], props: { numArgs: 2, argTypes: ["url", "original"], allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = a[1], f = Oe(a[0], "url").url;
          return o.settings.isTrusted({ command: "\\href", url: f }) ? { type: "href", mode: o.mode, href: f, body: Ne(l) } : o.formatUnsupportedCmd("\\href");
        }, htmlBuilder: function(i, a) {
          var o = Xt(i.body, a, false);
          return H.makeAnchor(i.href, [], o, a);
        }, mathmlBuilder: function(i, a) {
          var o = Lt(i.body, a);
          return o instanceof Er || (o = new Er("mrow", [o])), o.setAttribute("href", i.href), o;
        } }), ce({ type: "href", names: ["\\url"], props: { numArgs: 1, argTypes: ["url"], allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = Oe(a[0], "url").url;
          if (!o.settings.isTrusted({ command: "\\url", url: l }))
            return o.formatUnsupportedCmd("\\url");
          for (var f = [], m = 0; m < l.length; m++) {
            var y = l[m];
            y === "~" && (y = "\\textasciitilde"), f.push({ type: "textord", mode: "text", text: y });
          }
          var S = { type: "text", mode: o.mode, font: "\\texttt", body: f };
          return { type: "href", mode: o.mode, href: l, body: Ne(S) };
        } }), ce({ type: "hbox", names: ["\\hbox"], props: { numArgs: 1, argTypes: ["text"], allowedInText: true, primitive: true }, handler: function(i, a) {
          var o = i.parser;
          return { type: "hbox", mode: o.mode, body: Ne(a[0]) };
        }, htmlBuilder: function(i, a) {
          var o = Xt(i.body, a, false);
          return H.makeFragment(o);
        }, mathmlBuilder: function(i, a) {
          return new ne.MathNode("mrow", kr(i.body, a));
        } }), ce({ type: "html", names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"], props: { numArgs: 2, argTypes: ["raw", "original"], allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = i.token, m = Oe(a[0], "raw").string, y = a[1];
          o.settings.strict && o.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          var S, C2 = {};
          switch (l) {
            case "\\htmlClass":
              C2.class = m, S = { command: "\\htmlClass", class: m };
              break;
            case "\\htmlId":
              C2.id = m, S = { command: "\\htmlId", id: m };
              break;
            case "\\htmlStyle":
              C2.style = m, S = { command: "\\htmlStyle", style: m };
              break;
            case "\\htmlData": {
              for (var O = m.split(","), z = 0; z < O.length; z++) {
                var X = O[z].split("=");
                if (X.length !== 2)
                  throw new c("Error parsing key-value for \\htmlData");
                C2["data-" + X[0].trim()] = X[1].trim();
              }
              S = { command: "\\htmlData", attributes: C2 };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          return o.settings.isTrusted(S) ? { type: "html", mode: o.mode, attributes: C2, body: Ne(y) } : o.formatUnsupportedCmd(l);
        }, htmlBuilder: function(i, a) {
          var o = Xt(i.body, a, false), l = ["enclosing"];
          i.attributes.class && l.push.apply(l, i.attributes.class.trim().split(/\s+/));
          var f = H.makeSpan(l, o, a);
          for (var m in i.attributes)
            m !== "class" && i.attributes.hasOwnProperty(m) && f.setAttribute(m, i.attributes[m]);
          return f;
        }, mathmlBuilder: function(i, a) {
          return Lt(i.body, a);
        } }), ce({ type: "htmlmathml", names: ["\\html@mathml"], props: { numArgs: 2, allowedInText: true }, handler: function(i, a) {
          var o = i.parser;
          return { type: "htmlmathml", mode: o.mode, html: Ne(a[0]), mathml: Ne(a[1]) };
        }, htmlBuilder: function(i, a) {
          var o = Xt(i.html, a, false);
          return H.makeFragment(o);
        }, mathmlBuilder: function(i, a) {
          return Lt(i.mathml, a);
        } });
        var hn = function(i) {
          if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(i))
            return { number: +i, unit: "bp" };
          var a = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(i);
          if (!a)
            throw new c("Invalid size: '" + i + "' in \\includegraphics");
          var o = { number: +(a[1] + a[2]), unit: a[3] };
          if (!Oi(o))
            throw new c("Invalid unit: '" + o.unit + "' in \\includegraphics.");
          return o;
        };
        ce({ type: "includegraphics", names: ["\\includegraphics"], props: { numArgs: 1, numOptionalArgs: 1, argTypes: ["raw", "url"], allowedInText: false }, handler: function(i, a, o) {
          var l = i.parser, f = { number: 0, unit: "em" }, m = { number: 0.9, unit: "em" }, y = { number: 0, unit: "em" }, S = "";
          if (o[0])
            for (var C2 = Oe(o[0], "raw").string, O = C2.split(","), z = 0; z < O.length; z++) {
              var X = O[z].split("=");
              if (X.length === 2) {
                var K = X[1].trim();
                switch (X[0].trim()) {
                  case "alt":
                    S = K;
                    break;
                  case "width":
                    f = hn(K);
                    break;
                  case "height":
                    m = hn(K);
                    break;
                  case "totalheight":
                    y = hn(K);
                    break;
                  default:
                    throw new c("Invalid key: '" + X[0] + "' in \\includegraphics.");
                }
              }
            }
          var Y = Oe(a[0], "url").url;
          return S === "" && (S = Y, S = S.replace(/^.*[\\/]/, ""), S = S.substring(0, S.lastIndexOf("."))), l.settings.isTrusted({ command: "\\includegraphics", url: Y }) ? { type: "includegraphics", mode: l.mode, alt: S, width: f, height: m, totalheight: y, src: Y } : l.formatUnsupportedCmd("\\includegraphics");
        }, htmlBuilder: function(i, a) {
          var o = _t(i.height, a), l = 0;
          i.totalheight.number > 0 && (l = _t(i.totalheight, a) - o, l = Number(l.toFixed(2)));
          var f = 0;
          i.width.number > 0 && (f = _t(i.width, a));
          var m = { height: o + l + "em" };
          f > 0 && (m.width = f + "em"), l > 0 && (m.verticalAlign = -l + "em");
          var y = new Hn(i.src, i.alt, m);
          return y.height = o, y.depth = l, y;
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mglyph", []);
          o.setAttribute("alt", i.alt);
          var l = _t(i.height, a), f = 0;
          if (i.totalheight.number > 0 && (f = _t(i.totalheight, a) - l, f = f.toFixed(2), o.setAttribute("valign", "-" + f + "em")), o.setAttribute("height", l + f + "em"), i.width.number > 0) {
            var m = _t(i.width, a);
            o.setAttribute("width", m + "em");
          }
          return o.setAttribute("src", i.src), o;
        } }), ce({ type: "kern", names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"], props: { numArgs: 1, argTypes: ["size"], primitive: true, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = Oe(a[0], "size");
          if (o.settings.strict) {
            var m = l[1] === "m", y = f.value.unit === "mu";
            m ? (y || o.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + l + " supports only mu units, " + ("not " + f.value.unit + " units")), o.mode !== "math" && o.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + l + " works only in math mode")) : y && o.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + l + " doesn't support mu units");
          }
          return { type: "kern", mode: o.mode, dimension: f.value };
        }, htmlBuilder: function(i, a) {
          return H.makeGlue(i.dimension, a);
        }, mathmlBuilder: function(i, a) {
          var o = _t(i.dimension, a);
          return new ne.SpaceNode(o);
        } }), ce({ type: "lap", names: ["\\mathllap", "\\mathrlap", "\\mathclap"], props: { numArgs: 1, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          return { type: "lap", mode: o.mode, alignment: l.slice(5), body: f };
        }, htmlBuilder: function(i, a) {
          var o;
          i.alignment === "clap" ? (o = H.makeSpan([], [Ie(i.body, a)]), o = H.makeSpan(["inner"], [o], a)) : o = H.makeSpan(["inner"], [Ie(i.body, a)]);
          var l = H.makeSpan(["fix"], []), f = H.makeSpan([i.alignment], [o, l], a), m = H.makeSpan(["strut"]);
          return m.style.height = f.height + f.depth + "em", f.depth && (m.style.verticalAlign = -f.depth + "em"), f.children.unshift(m), f = H.makeSpan(["thinbox"], [f], a), H.makeSpan(["mord", "vbox"], [f], a);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mpadded", [ct(i.body, a)]);
          if (i.alignment !== "rlap") {
            var l = i.alignment === "llap" ? "-1" : "-0.5";
            o.setAttribute("lspace", l + "width");
          }
          return o.setAttribute("width", "0px"), o;
        } }), ce({ type: "styling", names: ["\\(", "$"], props: { numArgs: 0, allowedInText: true, allowedInMath: false }, handler: function(i, a) {
          var o = i.funcName, l = i.parser, f = l.mode;
          l.switchMode("math");
          var m = o === "\\(" ? "\\)" : "$", y = l.parseExpression(false, m);
          return l.expect(m), l.switchMode(f), { type: "styling", mode: l.mode, style: "text", body: y };
        } }), ce({ type: "text", names: ["\\)", "\\]"], props: { numArgs: 0, allowedInText: true, allowedInMath: false }, handler: function(i, a) {
          throw new c("Mismatched " + i.funcName);
        } });
        var Ji = function(i, a) {
          switch (a.style.size) {
            case pe.DISPLAY.size:
              return i.display;
            case pe.TEXT.size:
              return i.text;
            case pe.SCRIPT.size:
              return i.script;
            case pe.SCRIPTSCRIPT.size:
              return i.scriptscript;
            default:
              return i.text;
          }
        };
        ce({ type: "mathchoice", names: ["\\mathchoice"], props: { numArgs: 4, primitive: true }, handler: function(i, a) {
          var o = i.parser;
          return { type: "mathchoice", mode: o.mode, display: Ne(a[0]), text: Ne(a[1]), script: Ne(a[2]), scriptscript: Ne(a[3]) };
        }, htmlBuilder: function(i, a) {
          var o = Ji(i, a), l = Xt(o, a, false);
          return H.makeFragment(l);
        }, mathmlBuilder: function(i, a) {
          var o = Ji(i, a);
          return Lt(o, a);
        } });
        var Hs = function(i, a, o, l, f, m, y) {
          i = H.makeSpan([], [i]);
          var S = o && V.isCharacterBox(o), C2, O;
          if (a) {
            var z = Ie(a, l.havingStyle(f.sup()), l);
            O = { elem: z, kern: Math.max(l.fontMetrics().bigOpSpacing1, l.fontMetrics().bigOpSpacing3 - z.depth) };
          }
          if (o) {
            var X = Ie(o, l.havingStyle(f.sub()), l);
            C2 = { elem: X, kern: Math.max(l.fontMetrics().bigOpSpacing2, l.fontMetrics().bigOpSpacing4 - X.height) };
          }
          var K;
          if (O && C2) {
            var Y = l.fontMetrics().bigOpSpacing5 + C2.elem.height + C2.elem.depth + C2.kern + i.depth + y;
            K = H.makeVList({ positionType: "bottom", positionData: Y, children: [{ type: "kern", size: l.fontMetrics().bigOpSpacing5 }, { type: "elem", elem: C2.elem, marginLeft: -m + "em" }, { type: "kern", size: C2.kern }, { type: "elem", elem: i }, { type: "kern", size: O.kern }, { type: "elem", elem: O.elem, marginLeft: m + "em" }, { type: "kern", size: l.fontMetrics().bigOpSpacing5 }] }, l);
          } else if (C2) {
            var oe = i.height - y;
            K = H.makeVList({ positionType: "top", positionData: oe, children: [{ type: "kern", size: l.fontMetrics().bigOpSpacing5 }, { type: "elem", elem: C2.elem, marginLeft: -m + "em" }, { type: "kern", size: C2.kern }, { type: "elem", elem: i }] }, l);
          } else if (O) {
            var se = i.depth + y;
            K = H.makeVList({ positionType: "bottom", positionData: se, children: [{ type: "elem", elem: i }, { type: "kern", size: O.kern }, { type: "elem", elem: O.elem, marginLeft: m + "em" }, { type: "kern", size: l.fontMetrics().bigOpSpacing5 }] }, l);
          } else
            return i;
          var he = [K];
          if (C2 && m !== 0 && !S) {
            var me = H.makeSpan(["mspace"], [], l);
            me.style.marginRight = m + "em", he.unshift(me);
          }
          return H.makeSpan(["mop", "op-limits"], he, l);
        }, so = ["\\smallint"], dn = function(i, a) {
          var o, l, f = false, m;
          i.type === "supsub" ? (o = i.sup, l = i.sub, m = Oe(i.base, "op"), f = true) : m = Oe(i, "op");
          var y = a.style, S = false;
          y.size === pe.DISPLAY.size && m.symbol && !V.contains(so, m.name) && (S = true);
          var C2;
          if (m.symbol) {
            var O = S ? "Size2-Regular" : "Size1-Regular", z = "";
            if ((m.name === "\\oiint" || m.name === "\\oiiint") && (z = m.name.substr(1), m.name = z === "oiint" ? "\\iint" : "\\iiint"), C2 = H.makeSymbol(m.name, O, "math", a, ["mop", "op-symbol", S ? "large-op" : "small-op"]), z.length > 0) {
              var X = C2.italic, K = H.staticSvg(z + "Size" + (S ? "2" : "1"), a);
              C2 = H.makeVList({ positionType: "individualShift", children: [{ type: "elem", elem: C2, shift: 0 }, { type: "elem", elem: K, shift: S ? 0.08 : 0 }] }, a), m.name = "\\" + z, C2.classes.unshift("mop"), C2.italic = X;
            }
          } else if (m.body) {
            var Y = Xt(m.body, a, true);
            Y.length === 1 && Y[0] instanceof Ur ? (C2 = Y[0], C2.classes[0] = "mop") : C2 = H.makeSpan(["mop"], Y, a);
          } else {
            for (var oe = [], se = 1; se < m.name.length; se++)
              oe.push(H.mathsym(m.name[se], m.mode, a));
            C2 = H.makeSpan(["mop"], oe, a);
          }
          var he = 0, me = 0;
          return (C2 instanceof Ur || m.name === "\\oiint" || m.name === "\\oiiint") && !m.suppressBaseShift && (he = (C2.height - C2.depth) / 2 - a.fontMetrics().axisHeight, me = C2.italic), f ? Hs(C2, o, l, a, y, me, he) : (he && (C2.style.position = "relative", C2.style.top = he + "em"), C2);
        }, ri = function(i, a) {
          var o;
          if (i.symbol)
            o = new Er("mo", [Cr(i.name, i.mode)]), V.contains(so, i.name) && o.setAttribute("largeop", "false");
          else if (i.body)
            o = new Er("mo", kr(i.body, a));
          else {
            o = new Er("mi", [new on(i.name.slice(1))]);
            var l = new Er("mo", [Cr("\u2061", "text")]);
            i.parentIsSupSub ? o = new Er("mrow", [o, l]) : o = Tr([o, l]);
          }
          return o;
        }, It = { "\u220F": "\\prod", "\u2210": "\\coprod", "\u2211": "\\sum", "\u22C0": "\\bigwedge", "\u22C1": "\\bigvee", "\u22C2": "\\bigcap", "\u22C3": "\\bigcup", "\u2A00": "\\bigodot", "\u2A01": "\\bigoplus", "\u2A02": "\\bigotimes", "\u2A04": "\\biguplus", "\u2A06": "\\bigsqcup" };
        ce({ type: "op", names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"], props: { numArgs: 0 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = l;
          return f.length === 1 && (f = It[f]), { type: "op", mode: o.mode, limits: true, parentIsSupSub: false, symbol: true, name: f };
        }, htmlBuilder: dn, mathmlBuilder: ri }), ce({ type: "op", names: ["\\mathop"], props: { numArgs: 1, primitive: true }, handler: function(i, a) {
          var o = i.parser, l = a[0];
          return { type: "op", mode: o.mode, limits: false, parentIsSupSub: false, symbol: false, body: Ne(l) };
        }, htmlBuilder: dn, mathmlBuilder: ri });
        var Jt = { "\u222B": "\\int", "\u222C": "\\iint", "\u222D": "\\iiint", "\u222E": "\\oint", "\u222F": "\\oiint", "\u2230": "\\oiiint" };
        ce({ type: "op", names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"], props: { numArgs: 0 }, handler: function(i) {
          var a = i.parser, o = i.funcName;
          return { type: "op", mode: a.mode, limits: false, parentIsSupSub: false, symbol: false, name: o };
        }, htmlBuilder: dn, mathmlBuilder: ri }), ce({ type: "op", names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"], props: { numArgs: 0 }, handler: function(i) {
          var a = i.parser, o = i.funcName;
          return { type: "op", mode: a.mode, limits: true, parentIsSupSub: false, symbol: false, name: o };
        }, htmlBuilder: dn, mathmlBuilder: ri }), ce({ type: "op", names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"], props: { numArgs: 0 }, handler: function(i) {
          var a = i.parser, o = i.funcName, l = o;
          return l.length === 1 && (l = Jt[l]), { type: "op", mode: a.mode, limits: false, parentIsSupSub: false, symbol: true, name: l };
        }, htmlBuilder: dn, mathmlBuilder: ri });
        var js = {};
        function A(g, i) {
          js[g] = i;
        }
        var lo = function(i, a) {
          var o, l, f = false, m;
          i.type === "supsub" ? (o = i.sup, l = i.sub, m = Oe(i.base, "operatorname"), f = true) : m = Oe(i, "operatorname");
          var y;
          if (m.body.length > 0) {
            for (var S = m.body.map(function(X) {
              var K = X.text;
              return typeof K == "string" ? { type: "textord", mode: X.mode, text: K } : X;
            }), C2 = Xt(S, a.withFont("mathrm"), true), O = 0; O < C2.length; O++) {
              var z = C2[O];
              z instanceof Ur && (z.text = z.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
            }
            y = H.makeSpan(["mop"], C2, a);
          } else
            y = H.makeSpan(["mop"], [], a);
          return f ? Hs(y, o, l, a, a.style, 0, 0) : y;
        }, Zu = function(i, a) {
          for (var o = kr(i.body, a.withFont("mathrm")), l = true, f = 0; f < o.length; f++) {
            var m = o[f];
            if (!(m instanceof ne.SpaceNode))
              if (m instanceof ne.MathNode)
                switch (m.type) {
                  case "mi":
                  case "mn":
                  case "ms":
                  case "mspace":
                  case "mtext":
                    break;
                  case "mo": {
                    var y = m.children[0];
                    m.children.length === 1 && y instanceof ne.TextNode ? y.text = y.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : l = false;
                    break;
                  }
                  default:
                    l = false;
                }
              else
                l = false;
          }
          if (l) {
            var S = o.map(function(z) {
              return z.toText();
            }).join("");
            o = [new ne.TextNode(S)];
          }
          var C2 = new ne.MathNode("mi", o);
          C2.setAttribute("mathvariant", "normal");
          var O = new ne.MathNode("mo", [Cr("\u2061", "text")]);
          return i.parentIsSupSub ? new ne.MathNode("mrow", [C2, O]) : ne.newDocumentFragment([C2, O]);
        };
        ce({ type: "operatorname", names: ["\\operatorname@", "\\operatornamewithlimits"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          return { type: "operatorname", mode: o.mode, body: Ne(f), alwaysHandleSupSub: l === "\\operatornamewithlimits", limits: false, parentIsSupSub: false };
        }, htmlBuilder: lo, mathmlBuilder: Zu }), A("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), A0({ type: "ordgroup", htmlBuilder: function(i, a) {
          return i.semisimple ? H.makeFragment(Xt(i.body, a, false)) : H.makeSpan(["mord"], Xt(i.body, a, true), a);
        }, mathmlBuilder: function(i, a) {
          return Lt(i.body, a, true);
        } }), ce({ type: "overline", names: ["\\overline"], props: { numArgs: 1 }, handler: function(i, a) {
          var o = i.parser, l = a[0];
          return { type: "overline", mode: o.mode, body: l };
        }, htmlBuilder: function(i, a) {
          var o = Ie(i.body, a.havingCrampedStyle()), l = H.makeLineSpan("overline-line", a), f = a.fontMetrics().defaultRuleThickness, m = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: o }, { type: "kern", size: 3 * f }, { type: "elem", elem: l }, { type: "kern", size: f }] }, a);
          return H.makeSpan(["mord", "overline"], [m], a);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mo", [new ne.TextNode("\u203E")]);
          o.setAttribute("stretchy", "true");
          var l = new ne.MathNode("mover", [ct(i.body, a), o]);
          return l.setAttribute("accent", "true"), l;
        } }), ce({ type: "phantom", names: ["\\phantom"], props: { numArgs: 1, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = a[0];
          return { type: "phantom", mode: o.mode, body: Ne(l) };
        }, htmlBuilder: function(i, a) {
          var o = Xt(i.body, a.withPhantom(), false);
          return H.makeFragment(o);
        }, mathmlBuilder: function(i, a) {
          var o = kr(i.body, a);
          return new ne.MathNode("mphantom", o);
        } }), ce({ type: "hphantom", names: ["\\hphantom"], props: { numArgs: 1, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = a[0];
          return { type: "hphantom", mode: o.mode, body: l };
        }, htmlBuilder: function(i, a) {
          var o = H.makeSpan([], [Ie(i.body, a.withPhantom())]);
          if (o.height = 0, o.depth = 0, o.children)
            for (var l = 0; l < o.children.length; l++)
              o.children[l].height = 0, o.children[l].depth = 0;
          return o = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: o }] }, a), H.makeSpan(["mord"], [o], a);
        }, mathmlBuilder: function(i, a) {
          var o = kr(Ne(i.body), a), l = new ne.MathNode("mphantom", o), f = new ne.MathNode("mpadded", [l]);
          return f.setAttribute("height", "0px"), f.setAttribute("depth", "0px"), f;
        } }), ce({ type: "vphantom", names: ["\\vphantom"], props: { numArgs: 1, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = a[0];
          return { type: "vphantom", mode: o.mode, body: l };
        }, htmlBuilder: function(i, a) {
          var o = H.makeSpan(["inner"], [Ie(i.body, a.withPhantom())]), l = H.makeSpan(["fix"], []);
          return H.makeSpan(["mord", "rlap"], [o, l], a);
        }, mathmlBuilder: function(i, a) {
          var o = kr(Ne(i.body), a), l = new ne.MathNode("mphantom", o), f = new ne.MathNode("mpadded", [l]);
          return f.setAttribute("width", "0px"), f;
        } }), ce({ type: "raisebox", names: ["\\raisebox"], props: { numArgs: 2, argTypes: ["size", "hbox"], allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = Oe(a[0], "size").value, f = a[1];
          return { type: "raisebox", mode: o.mode, dy: l, body: f };
        }, htmlBuilder: function(i, a) {
          var o = Ie(i.body, a), l = _t(i.dy, a);
          return H.makeVList({ positionType: "shift", positionData: -l, children: [{ type: "elem", elem: o }] }, a);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mpadded", [ct(i.body, a)]), l = i.dy.number + i.dy.unit;
          return o.setAttribute("voffset", l), o;
        } }), ce({ type: "rule", names: ["\\rule"], props: { numArgs: 2, numOptionalArgs: 1, argTypes: ["size", "size", "size"] }, handler: function(i, a, o) {
          var l = i.parser, f = o[0], m = Oe(a[0], "size"), y = Oe(a[1], "size");
          return { type: "rule", mode: l.mode, shift: f && Oe(f, "size").value, width: m.value, height: y.value };
        }, htmlBuilder: function(i, a) {
          var o = H.makeSpan(["mord", "rule"], [], a), l = _t(i.width, a), f = _t(i.height, a), m = i.shift ? _t(i.shift, a) : 0;
          return o.style.borderRightWidth = l + "em", o.style.borderTopWidth = f + "em", o.style.bottom = m + "em", o.width = l, o.height = f + m, o.depth = -m, o.maxFontSize = f * 1.125 * a.sizeMultiplier, o;
        }, mathmlBuilder: function(i, a) {
          var o = _t(i.width, a), l = _t(i.height, a), f = i.shift ? _t(i.shift, a) : 0, m = a.color && a.getColor() || "black", y = new ne.MathNode("mspace");
          y.setAttribute("mathbackground", m), y.setAttribute("width", o + "em"), y.setAttribute("height", l + "em");
          var S = new ne.MathNode("mpadded", [y]);
          return f >= 0 ? S.setAttribute("height", "+" + f + "em") : (S.setAttribute("height", f + "em"), S.setAttribute("depth", "+" + -f + "em")), S.setAttribute("voffset", f + "em"), S;
        } });
        function Qi(g, i, a) {
          for (var o = Xt(g, i, false), l = i.sizeMultiplier / a.sizeMultiplier, f = 0; f < o.length; f++) {
            var m = o[f].classes.indexOf("sizing");
            m < 0 ? Array.prototype.push.apply(o[f].classes, i.sizingClasses(a)) : o[f].classes[m + 1] === "reset-size" + i.size && (o[f].classes[m + 1] = "reset-size" + a.size), o[f].height *= l, o[f].depth *= l;
          }
          return H.makeFragment(o);
        }
        var mn = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], uo = function(i, a) {
          var o = a.havingSize(i.size);
          return Qi(i.body, o, a);
        };
        ce({ type: "sizing", names: mn, props: { numArgs: 0, allowedInText: true }, handler: function(i, a) {
          var o = i.breakOnTokenText, l = i.funcName, f = i.parser, m = f.parseExpression(false, o);
          return { type: "sizing", mode: f.mode, size: mn.indexOf(l) + 1, body: m };
        }, htmlBuilder: uo, mathmlBuilder: function(i, a) {
          var o = a.havingSize(i.size), l = kr(i.body, o), f = new ne.MathNode("mstyle", l);
          return f.setAttribute("mathsize", o.sizeMultiplier + "em"), f;
        } }), ce({ type: "smash", names: ["\\smash"], props: { numArgs: 1, numOptionalArgs: 1, allowedInText: true }, handler: function(i, a, o) {
          var l = i.parser, f = false, m = false, y = o[0] && Oe(o[0], "ordgroup");
          if (y)
            for (var S = "", C2 = 0; C2 < y.body.length; ++C2) {
              var O = y.body[C2];
              if (S = O.text, S === "t")
                f = true;
              else if (S === "b")
                m = true;
              else {
                f = false, m = false;
                break;
              }
            }
          else
            f = true, m = true;
          var z = a[0];
          return { type: "smash", mode: l.mode, body: z, smashHeight: f, smashDepth: m };
        }, htmlBuilder: function(i, a) {
          var o = H.makeSpan([], [Ie(i.body, a)]);
          if (!i.smashHeight && !i.smashDepth)
            return o;
          if (i.smashHeight && (o.height = 0, o.children))
            for (var l = 0; l < o.children.length; l++)
              o.children[l].height = 0;
          if (i.smashDepth && (o.depth = 0, o.children))
            for (var f = 0; f < o.children.length; f++)
              o.children[f].depth = 0;
          var m = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: o }] }, a);
          return H.makeSpan(["mord"], [m], a);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mpadded", [ct(i.body, a)]);
          return i.smashHeight && o.setAttribute("height", "0px"), i.smashDepth && o.setAttribute("depth", "0px"), o;
        } }), ce({ type: "sqrt", names: ["\\sqrt"], props: { numArgs: 1, numOptionalArgs: 1 }, handler: function(i, a, o) {
          var l = i.parser, f = o[0], m = a[0];
          return { type: "sqrt", mode: l.mode, body: m, index: f };
        }, htmlBuilder: function(i, a) {
          var o = Ie(i.body, a.havingCrampedStyle());
          o.height === 0 && (o.height = a.fontMetrics().xHeight), o = H.wrapFragment(o, a);
          var l = a.fontMetrics(), f = l.defaultRuleThickness, m = f;
          a.style.id < pe.TEXT.id && (m = a.fontMetrics().xHeight);
          var y = f + m / 4, S = o.height + o.depth + y + f, C2 = Qe.sqrtImage(S, a), O = C2.span, z = C2.ruleWidth, X = C2.advanceWidth, K = O.height - z;
          K > o.height + o.depth + y && (y = (y + K - o.height - o.depth) / 2);
          var Y = O.height - o.height - y - z;
          o.style.paddingLeft = X + "em";
          var oe = H.makeVList({ positionType: "firstBaseline", children: [{ type: "elem", elem: o, wrapperClasses: ["svg-align"] }, { type: "kern", size: -(o.height + Y) }, { type: "elem", elem: O }, { type: "kern", size: z }] }, a);
          if (i.index) {
            var se = a.havingStyle(pe.SCRIPTSCRIPT), he = Ie(i.index, se, a), me = 0.6 * (oe.height - oe.depth), ge = H.makeVList({ positionType: "shift", positionData: -me, children: [{ type: "elem", elem: he }] }, a), Ze = H.makeSpan(["root"], [ge]);
            return H.makeSpan(["mord", "sqrt"], [Ze, oe], a);
          } else
            return H.makeSpan(["mord", "sqrt"], [oe], a);
        }, mathmlBuilder: function(i, a) {
          var o = i.body, l = i.index;
          return l ? new ne.MathNode("mroot", [ct(o, a), ct(l, a)]) : new ne.MathNode("msqrt", [ct(o, a)]);
        } });
        var M0 = { display: pe.DISPLAY, text: pe.TEXT, script: pe.SCRIPT, scriptscript: pe.SCRIPTSCRIPT };
        ce({ type: "styling", names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"], props: { numArgs: 0, allowedInText: true, primitive: true }, handler: function(i, a) {
          var o = i.breakOnTokenText, l = i.funcName, f = i.parser, m = f.parseExpression(true, o), y = l.slice(1, l.length - 5);
          return { type: "styling", mode: f.mode, style: y, body: m };
        }, htmlBuilder: function(i, a) {
          var o = M0[i.style], l = a.havingStyle(o).withFont("");
          return Qi(i.body, l, a);
        }, mathmlBuilder: function(i, a) {
          var o = M0[i.style], l = a.havingStyle(o), f = kr(i.body, l), m = new ne.MathNode("mstyle", f), y = { display: ["0", "true"], text: ["0", "false"], script: ["1", "false"], scriptscript: ["2", "false"] }, S = y[i.style];
          return m.setAttribute("scriptlevel", S[0]), m.setAttribute("displaystyle", S[1]), m;
        } });
        var ni = function(i, a) {
          var o = i.base;
          if (o)
            if (o.type === "op") {
              var l = o.limits && (a.style.size === pe.DISPLAY.size || o.alwaysHandleSupSub);
              return l ? dn : null;
            } else if (o.type === "operatorname") {
              var f = o.alwaysHandleSupSub && (a.style.size === pe.DISPLAY.size || o.limits);
              return f ? lo : null;
            } else {
              if (o.type === "accent")
                return V.isCharacterBox(o.base) ? Hi : null;
              if (o.type === "horizBrace") {
                var m = !i.sub;
                return m === o.isOver ? Fs : null;
              } else
                return null;
            }
          else
            return null;
        };
        A0({ type: "supsub", htmlBuilder: function(i, a) {
          var o = ni(i, a);
          if (o)
            return o(i, a);
          var l = i.base, f = i.sup, m = i.sub, y = Ie(l, a), S, C2, O = a.fontMetrics(), z = 0, X = 0, K = l && V.isCharacterBox(l);
          if (f) {
            var Y = a.havingStyle(a.style.sup());
            S = Ie(f, Y, a), K || (z = y.height - Y.fontMetrics().supDrop * Y.sizeMultiplier / a.sizeMultiplier);
          }
          if (m) {
            var oe = a.havingStyle(a.style.sub());
            C2 = Ie(m, oe, a), K || (X = y.depth + oe.fontMetrics().subDrop * oe.sizeMultiplier / a.sizeMultiplier);
          }
          var se;
          a.style === pe.DISPLAY ? se = O.sup1 : a.style.cramped ? se = O.sup3 : se = O.sup2;
          var he = a.sizeMultiplier, me = 0.5 / O.ptPerEm / he + "em", ge = null;
          if (C2) {
            var Ze = i.base && i.base.type === "op" && i.base.name && (i.base.name === "\\oiint" || i.base.name === "\\oiiint");
            (y instanceof Ur || Ze) && (ge = -y.italic + "em");
          }
          var st;
          if (S && C2) {
            z = Math.max(z, se, S.depth + 0.25 * O.xHeight), X = Math.max(X, O.sub2);
            var ft = O.defaultRuleThickness, at = 4 * ft;
            if (z - S.depth - (C2.height - X) < at) {
              X = at - (z - S.depth) + C2.height;
              var ot = 0.8 * O.xHeight - (z - S.depth);
              ot > 0 && (z += ot, X -= ot);
            }
            var He = [{ type: "elem", elem: C2, shift: X, marginRight: me, marginLeft: ge }, { type: "elem", elem: S, shift: -z, marginRight: me }];
            st = H.makeVList({ positionType: "individualShift", children: He }, a);
          } else if (C2) {
            X = Math.max(X, O.sub1, C2.height - 0.8 * O.xHeight);
            var lt = [{ type: "elem", elem: C2, marginLeft: ge, marginRight: me }];
            st = H.makeVList({ positionType: "shift", positionData: X, children: lt }, a);
          } else if (S)
            z = Math.max(z, se, S.depth + 0.25 * O.xHeight), st = H.makeVList({ positionType: "shift", positionData: -z, children: [{ type: "elem", elem: S, marginRight: me }] }, a);
          else
            throw new Error("supsub must have either sup or sub.");
          var yr = Nt(y, "right") || "mord";
          return H.makeSpan([yr], [y, H.makeSpan(["msupsub"], [st])], a);
        }, mathmlBuilder: function(i, a) {
          var o = false, l, f;
          i.base && i.base.type === "horizBrace" && (f = !!i.sup, f === i.base.isOver && (o = true, l = i.base.isOver)), i.base && (i.base.type === "op" || i.base.type === "operatorname") && (i.base.parentIsSupSub = true);
          var m = [ct(i.base, a)];
          i.sub && m.push(ct(i.sub, a)), i.sup && m.push(ct(i.sup, a));
          var y;
          if (o)
            y = l ? "mover" : "munder";
          else if (i.sub)
            if (i.sup) {
              var O = i.base;
              O && O.type === "op" && O.limits && a.style === pe.DISPLAY || O && O.type === "operatorname" && O.alwaysHandleSupSub && (a.style === pe.DISPLAY || O.limits) ? y = "munderover" : y = "msubsup";
            } else {
              var C2 = i.base;
              C2 && C2.type === "op" && C2.limits && (a.style === pe.DISPLAY || C2.alwaysHandleSupSub) || C2 && C2.type === "operatorname" && C2.alwaysHandleSupSub && (C2.limits || a.style === pe.DISPLAY) ? y = "munder" : y = "msub";
            }
          else {
            var S = i.base;
            S && S.type === "op" && S.limits && (a.style === pe.DISPLAY || S.alwaysHandleSupSub) || S && S.type === "operatorname" && S.alwaysHandleSupSub && (S.limits || a.style === pe.DISPLAY) ? y = "mover" : y = "msup";
          }
          return new ne.MathNode(y, m);
        } }), A0({ type: "atom", htmlBuilder: function(i, a) {
          return H.mathsym(i.text, i.mode, a, ["m" + i.family]);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mo", [Cr(i.text, i.mode)]);
          if (i.family === "bin") {
            var l = ur(i, a);
            l === "bold-italic" && o.setAttribute("mathvariant", l);
          } else
            i.family === "punct" ? o.setAttribute("separator", "true") : (i.family === "open" || i.family === "close") && o.setAttribute("stretchy", "false");
          return o;
        } });
        var pn = { mi: "italic", mn: "normal", mtext: "normal" };
        A0({ type: "mathord", htmlBuilder: function(i, a) {
          return H.makeOrd(i, a, "mathord");
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mi", [Cr(i.text, i.mode, a)]), l = ur(i, a) || "italic";
          return l !== pn[o.type] && o.setAttribute("mathvariant", l), o;
        } }), A0({ type: "textord", htmlBuilder: function(i, a) {
          return H.makeOrd(i, a, "textord");
        }, mathmlBuilder: function(i, a) {
          var o = Cr(i.text, i.mode, a), l = ur(i, a) || "normal", f;
          return i.mode === "text" ? f = new ne.MathNode("mtext", [o]) : /[0-9]/.test(i.text) ? f = new ne.MathNode("mn", [o]) : i.text === "\\prime" ? f = new ne.MathNode("mo", [o]) : f = new ne.MathNode("mi", [o]), l !== pn[f.type] && f.setAttribute("mathvariant", l), f;
        } });
        var gn = { "\\nobreak": "nobreak", "\\allowbreak": "allowbreak" }, o0 = { " ": {}, "\\ ": {}, "~": { className: "nobreak" }, "\\space": {}, "\\nobreakspace": { className: "nobreak" } };
        A0({ type: "spacing", htmlBuilder: function(i, a) {
          if (o0.hasOwnProperty(i.text)) {
            var o = o0[i.text].className || "";
            if (i.mode === "text") {
              var l = H.makeOrd(i, a, "textord");
              return l.classes.push(o), l;
            } else
              return H.makeSpan(["mspace", o], [H.mathsym(i.text, i.mode, a)], a);
          } else {
            if (gn.hasOwnProperty(i.text))
              return H.makeSpan(["mspace", gn[i.text]], [], a);
            throw new c('Unknown type of space "' + i.text + '"');
          }
        }, mathmlBuilder: function(i, a) {
          var o;
          if (o0.hasOwnProperty(i.text))
            o = new ne.MathNode("mtext", [new ne.TextNode("\xA0")]);
          else {
            if (gn.hasOwnProperty(i.text))
              return new ne.MathNode("mspace");
            throw new c('Unknown type of space "' + i.text + '"');
          }
          return o;
        } });
        var Us = function() {
          var i = new ne.MathNode("mtd", []);
          return i.setAttribute("width", "50%"), i;
        };
        A0({ type: "tag", mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mtable", [new ne.MathNode("mtr", [Us(), new ne.MathNode("mtd", [Lt(i.body, a)]), Us(), new ne.MathNode("mtd", [Lt(i.tag, a)])])]);
          return o.setAttribute("width", "100%"), o;
        } });
        var Ws = { "\\text": void 0, "\\textrm": "textrm", "\\textsf": "textsf", "\\texttt": "texttt", "\\textnormal": "textrm" }, Gs = { "\\textbf": "textbf", "\\textmd": "textmd" }, Ju = { "\\textit": "textit", "\\textup": "textup" }, Vs = function(i, a) {
          var o = i.font;
          return o ? Ws[o] ? a.withTextFontFamily(Ws[o]) : Gs[o] ? a.withTextFontWeight(Gs[o]) : a.withTextFontShape(Ju[o]) : a;
        };
        ce({ type: "text", names: ["\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", "\\textbf", "\\textmd", "\\textit", "\\textup"], props: { numArgs: 1, argTypes: ["text"], allowedInArgument: true, allowedInText: true }, handler: function(i, a) {
          var o = i.parser, l = i.funcName, f = a[0];
          return { type: "text", mode: o.mode, body: Ne(f), font: l };
        }, htmlBuilder: function(i, a) {
          var o = Vs(i, a), l = Xt(i.body, o, true);
          return H.makeSpan(["mord", "text"], l, o);
        }, mathmlBuilder: function(i, a) {
          var o = Vs(i, a);
          return Lt(i.body, o);
        } }), ce({ type: "underline", names: ["\\underline"], props: { numArgs: 1, allowedInText: true }, handler: function(i, a) {
          var o = i.parser;
          return { type: "underline", mode: o.mode, body: a[0] };
        }, htmlBuilder: function(i, a) {
          var o = Ie(i.body, a), l = H.makeLineSpan("underline-line", a), f = a.fontMetrics().defaultRuleThickness, m = H.makeVList({ positionType: "top", positionData: o.height, children: [{ type: "kern", size: f }, { type: "elem", elem: l }, { type: "kern", size: 3 * f }, { type: "elem", elem: o }] }, a);
          return H.makeSpan(["mord", "underline"], [m], a);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.MathNode("mo", [new ne.TextNode("\u203E")]);
          o.setAttribute("stretchy", "true");
          var l = new ne.MathNode("munder", [ct(i.body, a), o]);
          return l.setAttribute("accentunder", "true"), l;
        } }), ce({ type: "vcenter", names: ["\\vcenter"], props: { numArgs: 1, argTypes: ["original"], allowedInText: false }, handler: function(i, a) {
          var o = i.parser;
          return { type: "vcenter", mode: o.mode, body: a[0] };
        }, htmlBuilder: function(i, a) {
          var o = Ie(i.body, a), l = a.fontMetrics().axisHeight, f = 0.5 * (o.height - l - (o.depth + l));
          return H.makeVList({ positionType: "shift", positionData: f, children: [{ type: "elem", elem: o }] }, a);
        }, mathmlBuilder: function(i, a) {
          return new ne.MathNode("mpadded", [ct(i.body, a)], ["vcenter"]);
        } }), ce({ type: "verb", names: ["\\verb"], props: { numArgs: 0, allowedInText: true }, handler: function(i, a, o) {
          throw new c("\\verb ended by end of line instead of matching delimiter");
        }, htmlBuilder: function(i, a) {
          for (var o = ii(i), l = [], f = a.havingStyle(a.style.text()), m = 0; m < o.length; m++) {
            var y = o[m];
            y === "~" && (y = "\\textasciitilde"), l.push(H.makeSymbol(y, "Typewriter-Regular", i.mode, f, ["mord", "texttt"]));
          }
          return H.makeSpan(["mord", "text"].concat(f.sizingClasses(a)), H.tryCombineChars(l), f);
        }, mathmlBuilder: function(i, a) {
          var o = new ne.TextNode(ii(i)), l = new ne.MathNode("mtext", [o]);
          return l.setAttribute("mathvariant", "monospace"), l;
        } });
        var ii = function(i) {
          return i.body.replace(/ /g, i.star ? "\u2423" : "\xA0");
        }, ai = Pi, j1 = ai, _14 = function() {
          function g(i, a, o) {
            this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = i, this.start = a, this.end = o;
          }
          return g.range = function(a, o) {
            return o ? !a || !a.loc || !o.loc || a.loc.lexer !== o.loc.lexer ? null : new g(a.loc.lexer, a.loc.start, o.loc.end) : a && a.loc;
          }, g;
        }(), Vr = function() {
          function g(a, o) {
            this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = a, this.loc = o;
          }
          var i = g.prototype;
          return i.range = function(o, l) {
            return new g(l, _14.range(this, o));
          }, g;
        }(), oi = `[ \r
	]`, $r = "\\\\[a-zA-Z@]+", We = "\\\\[^\uD800-\uDFFF]", Qu = "(" + $r + ")" + oi + "*", e2 = `\\\\(
|[ \r	]+
?)[ \r	]*`, co = "[\u0300-\u036F]", D0 = new RegExp(co + "+$"), t22 = "(" + oi + "+)|" + (e2 + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (co + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (co + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + Qu) + ("|" + We + ")"), $s = function() {
          function g(a, o) {
            this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = a, this.settings = o, this.tokenRegex = new RegExp(t22, "g"), this.catcodes = { "%": 14, "~": 13 };
          }
          var i = g.prototype;
          return i.setCatcode = function(o, l) {
            this.catcodes[o] = l;
          }, i.lex = function() {
            var o = this.input, l = this.tokenRegex.lastIndex;
            if (l === o.length)
              return new Vr("EOF", new _14(this, l, l));
            var f = this.tokenRegex.exec(o);
            if (f === null || f.index !== l)
              throw new c("Unexpected character: '" + o[l] + "'", new Vr(o[l], new _14(this, l, l + 1)));
            var m = f[6] || f[3] || (f[2] ? "\\ " : " ");
            if (this.catcodes[m] === 14) {
              var y = o.indexOf(`
`, this.tokenRegex.lastIndex);
              return y === -1 ? (this.tokenRegex.lastIndex = o.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = y + 1, this.lex();
            }
            return new Vr(m, new _14(this, l, this.tokenRegex.lastIndex));
          }, g;
        }(), r22 = function() {
          function g(a, o) {
            a === void 0 && (a = {}), o === void 0 && (o = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = o, this.builtins = a, this.undefStack = [];
          }
          var i = g.prototype;
          return i.beginGroup = function() {
            this.undefStack.push({});
          }, i.endGroup = function() {
            if (this.undefStack.length === 0)
              throw new c("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
            var o = this.undefStack.pop();
            for (var l in o)
              o.hasOwnProperty(l) && (o[l] === void 0 ? delete this.current[l] : this.current[l] = o[l]);
          }, i.endGroups = function() {
            for (; this.undefStack.length > 0; )
              this.endGroup();
          }, i.has = function(o) {
            return this.current.hasOwnProperty(o) || this.builtins.hasOwnProperty(o);
          }, i.get = function(o) {
            return this.current.hasOwnProperty(o) ? this.current[o] : this.builtins[o];
          }, i.set = function(o, l, f) {
            if (f === void 0 && (f = false), f) {
              for (var m = 0; m < this.undefStack.length; m++)
                delete this.undefStack[m][o];
              this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][o] = l);
            } else {
              var y = this.undefStack[this.undefStack.length - 1];
              y && !y.hasOwnProperty(o) && (y[o] = this.current[o]);
            }
            this.current[o] = l;
          }, g;
        }(), n2 = js, i2 = n2;
        A("\\noexpand", function(g) {
          var i = g.popToken();
          return g.isExpandable(i.text) && (i.noexpand = true, i.treatAsRelax = true), { tokens: [i], numArgs: 0 };
        }), A("\\expandafter", function(g) {
          var i = g.popToken();
          return g.expandOnce(true), { tokens: [i], numArgs: 0 };
        }), A("\\@firstoftwo", function(g) {
          var i = g.consumeArgs(2);
          return { tokens: i[0], numArgs: 0 };
        }), A("\\@secondoftwo", function(g) {
          var i = g.consumeArgs(2);
          return { tokens: i[1], numArgs: 0 };
        }), A("\\@ifnextchar", function(g) {
          var i = g.consumeArgs(3);
          g.consumeSpaces();
          var a = g.future();
          return i[0].length === 1 && i[0][0].text === a.text ? { tokens: i[1], numArgs: 0 } : { tokens: i[2], numArgs: 0 };
        }), A("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), A("\\TextOrMath", function(g) {
          var i = g.consumeArgs(2);
          return g.mode === "text" ? { tokens: i[0], numArgs: 0 } : { tokens: i[1], numArgs: 0 };
        });
        var b1 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
        A("\\char", function(g) {
          var i = g.popToken(), a, o = "";
          if (i.text === "'")
            a = 8, i = g.popToken();
          else if (i.text === '"')
            a = 16, i = g.popToken();
          else if (i.text === "`")
            if (i = g.popToken(), i.text[0] === "\\")
              o = i.text.charCodeAt(1);
            else {
              if (i.text === "EOF")
                throw new c("\\char` missing argument");
              o = i.text.charCodeAt(0);
            }
          else
            a = 10;
          if (a) {
            if (o = b1[i.text], o == null || o >= a)
              throw new c("Invalid base-" + a + " digit " + i.text);
            for (var l; (l = b1[g.future().text]) != null && l < a; )
              o *= a, o += l, g.popToken();
          }
          return "\\@char{" + o + "}";
        });
        var fo = function(i, a, o) {
          var l = i.consumeArg().tokens;
          if (l.length !== 1)
            throw new c("\\newcommand's first argument must be a macro name");
          var f = l[0].text, m = i.isDefined(f);
          if (m && !a)
            throw new c("\\newcommand{" + f + "} attempting to redefine " + (f + "; use \\renewcommand"));
          if (!m && !o)
            throw new c("\\renewcommand{" + f + "} when command " + f + " does not yet exist; use \\newcommand");
          var y = 0;
          if (l = i.consumeArg().tokens, l.length === 1 && l[0].text === "[") {
            for (var S = "", C2 = i.expandNextToken(); C2.text !== "]" && C2.text !== "EOF"; )
              S += C2.text, C2 = i.expandNextToken();
            if (!S.match(/^\s*[0-9]+\s*$/))
              throw new c("Invalid number of arguments: " + S);
            y = parseInt(S), l = i.consumeArg().tokens;
          }
          return i.macros.set(f, { tokens: l, numArgs: y }), "";
        };
        A("\\newcommand", function(g) {
          return fo(g, false, true);
        }), A("\\renewcommand", function(g) {
          return fo(g, true, false);
        }), A("\\providecommand", function(g) {
          return fo(g, true, true);
        }), A("\\message", function(g) {
          var i = g.consumeArgs(1)[0];
          return console.log(i.reverse().map(function(a) {
            return a.text;
          }).join("")), "";
        }), A("\\errmessage", function(g) {
          var i = g.consumeArgs(1)[0];
          return console.error(i.reverse().map(function(a) {
            return a.text;
          }).join("")), "";
        }), A("\\show", function(g) {
          var i = g.popToken(), a = i.text;
          return console.log(i, g.macros.get(a), j1[a], xt.math[a], xt.text[a]), "";
        }), A("\\bgroup", "{"), A("\\egroup", "}"), A("~", "\\nobreakspace"), A("\\lq", "`"), A("\\rq", "'"), A("\\aa", "\\r a"), A("\\AA", "\\r A"), A("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}"), A("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), A("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}"), A("\u212C", "\\mathscr{B}"), A("\u2130", "\\mathscr{E}"), A("\u2131", "\\mathscr{F}"), A("\u210B", "\\mathscr{H}"), A("\u2110", "\\mathscr{I}"), A("\u2112", "\\mathscr{L}"), A("\u2133", "\\mathscr{M}"), A("\u211B", "\\mathscr{R}"), A("\u212D", "\\mathfrak{C}"), A("\u210C", "\\mathfrak{H}"), A("\u2128", "\\mathfrak{Z}"), A("\\Bbbk", "\\Bbb{k}"), A("\xB7", "\\cdotp"), A("\\llap", "\\mathllap{\\textrm{#1}}"), A("\\rlap", "\\mathrlap{\\textrm{#1}}"), A("\\clap", "\\mathclap{\\textrm{#1}}"), A("\\mathstrut", "\\vphantom{(}"), A("\\underbar", "\\underline{\\text{#1}}"), A("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'), A("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}"), A("\\ne", "\\neq"), A("\u2260", "\\neq"), A("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}"), A("\u2209", "\\notin"), A("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}"), A("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}"), A("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}"), A("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}"), A("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}"), A("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}"), A("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}"), A("\u27C2", "\\perp"), A("\u203C", "\\mathclose{!\\mkern-0.8mu!}"), A("\u220C", "\\notni"), A("\u231C", "\\ulcorner"), A("\u231D", "\\urcorner"), A("\u231E", "\\llcorner"), A("\u231F", "\\lrcorner"), A("\xA9", "\\copyright"), A("\xAE", "\\textregistered"), A("\uFE0F", "\\textregistered"), A("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'), A("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'), A("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'), A("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'), A("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}"), A("\u22EE", "\\vdots"), A("\\varGamma", "\\mathit{\\Gamma}"), A("\\varDelta", "\\mathit{\\Delta}"), A("\\varTheta", "\\mathit{\\Theta}"), A("\\varLambda", "\\mathit{\\Lambda}"), A("\\varXi", "\\mathit{\\Xi}"), A("\\varPi", "\\mathit{\\Pi}"), A("\\varSigma", "\\mathit{\\Sigma}"), A("\\varUpsilon", "\\mathit{\\Upsilon}"), A("\\varPhi", "\\mathit{\\Phi}"), A("\\varPsi", "\\mathit{\\Psi}"), A("\\varOmega", "\\mathit{\\Omega}"), A("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), A("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu"), A("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), A("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), A("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), A("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
        var Xs = { ",": "\\dotsc", "\\not": "\\dotsb", "+": "\\dotsb", "=": "\\dotsb", "<": "\\dotsb", ">": "\\dotsb", "-": "\\dotsb", "*": "\\dotsb", ":": "\\dotsb", "\\DOTSB": "\\dotsb", "\\coprod": "\\dotsb", "\\bigvee": "\\dotsb", "\\bigwedge": "\\dotsb", "\\biguplus": "\\dotsb", "\\bigcap": "\\dotsb", "\\bigcup": "\\dotsb", "\\prod": "\\dotsb", "\\sum": "\\dotsb", "\\bigotimes": "\\dotsb", "\\bigoplus": "\\dotsb", "\\bigodot": "\\dotsb", "\\bigsqcup": "\\dotsb", "\\And": "\\dotsb", "\\longrightarrow": "\\dotsb", "\\Longrightarrow": "\\dotsb", "\\longleftarrow": "\\dotsb", "\\Longleftarrow": "\\dotsb", "\\longleftrightarrow": "\\dotsb", "\\Longleftrightarrow": "\\dotsb", "\\mapsto": "\\dotsb", "\\longmapsto": "\\dotsb", "\\hookrightarrow": "\\dotsb", "\\doteq": "\\dotsb", "\\mathbin": "\\dotsb", "\\mathrel": "\\dotsb", "\\relbar": "\\dotsb", "\\Relbar": "\\dotsb", "\\xrightarrow": "\\dotsb", "\\xleftarrow": "\\dotsb", "\\DOTSI": "\\dotsi", "\\int": "\\dotsi", "\\oint": "\\dotsi", "\\iint": "\\dotsi", "\\iiint": "\\dotsi", "\\iiiint": "\\dotsi", "\\idotsint": "\\dotsi", "\\DOTSX": "\\dotsx" };
        A("\\dots", function(g) {
          var i = "\\dotso", a = g.expandAfterFuture().text;
          return a in Xs ? i = Xs[a] : (a.substr(0, 4) === "\\not" || a in xt.math && V.contains(["bin", "rel"], xt.math[a].group)) && (i = "\\dotsb"), i;
        });
        var ho = { ")": true, "]": true, "\\rbrack": true, "\\}": true, "\\rbrace": true, "\\rangle": true, "\\rceil": true, "\\rfloor": true, "\\rgroup": true, "\\rmoustache": true, "\\right": true, "\\bigr": true, "\\biggr": true, "\\Bigr": true, "\\Biggr": true, $: true, ";": true, ".": true, ",": true };
        A("\\dotso", function(g) {
          var i = g.future().text;
          return i in ho ? "\\ldots\\," : "\\ldots";
        }), A("\\dotsc", function(g) {
          var i = g.future().text;
          return i in ho && i !== "," ? "\\ldots\\," : "\\ldots";
        }), A("\\cdots", function(g) {
          var i = g.future().text;
          return i in ho ? "\\@cdots\\," : "\\@cdots";
        }), A("\\dotsb", "\\cdots"), A("\\dotsm", "\\cdots"), A("\\dotsi", "\\!\\cdots"), A("\\dotsx", "\\ldots\\,"), A("\\DOTSI", "\\relax"), A("\\DOTSB", "\\relax"), A("\\DOTSX", "\\relax"), A("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), A("\\,", "\\tmspace+{3mu}{.1667em}"), A("\\thinspace", "\\,"), A("\\>", "\\mskip{4mu}"), A("\\:", "\\tmspace+{4mu}{.2222em}"), A("\\medspace", "\\:"), A("\\;", "\\tmspace+{5mu}{.2777em}"), A("\\thickspace", "\\;"), A("\\!", "\\tmspace-{3mu}{.1667em}"), A("\\negthinspace", "\\!"), A("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), A("\\negthickspace", "\\tmspace-{5mu}{.277em}"), A("\\enspace", "\\kern.5em "), A("\\enskip", "\\hskip.5em\\relax"), A("\\quad", "\\hskip1em\\relax"), A("\\qquad", "\\hskip2em\\relax"), A("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), A("\\tag@paren", "\\tag@literal{({#1})}"), A("\\tag@literal", function(g) {
          if (g.macros.get("\\df@tag"))
            throw new c("Multiple \\tag");
          return "\\gdef\\df@tag{\\text{#1}}";
        }), A("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), A("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), A("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), A("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), A("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}"), A("\\newline", "\\\\\\relax"), A("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
        var Ys = Gr["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * Gr["Main-Regular"]["A".charCodeAt(0)][1] + "em";
        A("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Ys + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"), A("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Ys + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"), A("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), A("\\@hspace", "\\hskip #1\\relax"), A("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), A("\\ordinarycolon", ":"), A("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), A("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'), A("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'), A("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'), A("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'), A("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'), A("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'), A("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'), A("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'), A("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'), A("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'), A("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'), A("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'), A("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'), A("\u2237", "\\dblcolon"), A("\u2239", "\\eqcolon"), A("\u2254", "\\coloneqq"), A("\u2255", "\\eqqcolon"), A("\u2A74", "\\Coloneqq"), A("\\ratio", "\\vcentcolon"), A("\\coloncolon", "\\dblcolon"), A("\\colonequals", "\\coloneqq"), A("\\coloncolonequals", "\\Coloneqq"), A("\\equalscolon", "\\eqqcolon"), A("\\equalscoloncolon", "\\Eqqcolon"), A("\\colonminus", "\\coloneq"), A("\\coloncolonminus", "\\Coloneq"), A("\\minuscolon", "\\eqcolon"), A("\\minuscoloncolon", "\\Eqcolon"), A("\\coloncolonapprox", "\\Colonapprox"), A("\\coloncolonsim", "\\Colonsim"), A("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), A("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), A("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), A("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), A("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}"), A("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), A("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), A("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), A("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), A("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), A("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), A("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), A("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), A("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}"), A("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}"), A("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}"), A("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}"), A("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}"), A("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}"), A("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}"), A("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}"), A("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}"), A("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}"), A("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}"), A("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}"), A("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}"), A("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}"), A("\\imath", "\\html@mathml{\\@imath}{\u0131}"), A("\\jmath", "\\html@mathml{\\@jmath}{\u0237}"), A("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}"), A("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}"), A("\u27E6", "\\llbracket"), A("\u27E7", "\\rrbracket"), A("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}"), A("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}"), A("\u2983", "\\lBrace"), A("\u2984", "\\rBrace"), A("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}"), A("\u29B5", "\\minuso"), A("\\darr", "\\downarrow"), A("\\dArr", "\\Downarrow"), A("\\Darr", "\\Downarrow"), A("\\lang", "\\langle"), A("\\rang", "\\rangle"), A("\\uarr", "\\uparrow"), A("\\uArr", "\\Uparrow"), A("\\Uarr", "\\Uparrow"), A("\\N", "\\mathbb{N}"), A("\\R", "\\mathbb{R}"), A("\\Z", "\\mathbb{Z}"), A("\\alef", "\\aleph"), A("\\alefsym", "\\aleph"), A("\\Alpha", "\\mathrm{A}"), A("\\Beta", "\\mathrm{B}"), A("\\bull", "\\bullet"), A("\\Chi", "\\mathrm{X}"), A("\\clubs", "\\clubsuit"), A("\\cnums", "\\mathbb{C}"), A("\\Complex", "\\mathbb{C}"), A("\\Dagger", "\\ddagger"), A("\\diamonds", "\\diamondsuit"), A("\\empty", "\\emptyset"), A("\\Epsilon", "\\mathrm{E}"), A("\\Eta", "\\mathrm{H}"), A("\\exist", "\\exists"), A("\\harr", "\\leftrightarrow"), A("\\hArr", "\\Leftrightarrow"), A("\\Harr", "\\Leftrightarrow"), A("\\hearts", "\\heartsuit"), A("\\image", "\\Im"), A("\\infin", "\\infty"), A("\\Iota", "\\mathrm{I}"), A("\\isin", "\\in"), A("\\Kappa", "\\mathrm{K}"), A("\\larr", "\\leftarrow"), A("\\lArr", "\\Leftarrow"), A("\\Larr", "\\Leftarrow"), A("\\lrarr", "\\leftrightarrow"), A("\\lrArr", "\\Leftrightarrow"), A("\\Lrarr", "\\Leftrightarrow"), A("\\Mu", "\\mathrm{M}"), A("\\natnums", "\\mathbb{N}"), A("\\Nu", "\\mathrm{N}"), A("\\Omicron", "\\mathrm{O}"), A("\\plusmn", "\\pm"), A("\\rarr", "\\rightarrow"), A("\\rArr", "\\Rightarrow"), A("\\Rarr", "\\Rightarrow"), A("\\real", "\\Re"), A("\\reals", "\\mathbb{R}"), A("\\Reals", "\\mathbb{R}"), A("\\Rho", "\\mathrm{P}"), A("\\sdot", "\\cdot"), A("\\sect", "\\S"), A("\\spades", "\\spadesuit"), A("\\sub", "\\subset"), A("\\sube", "\\subseteq"), A("\\supe", "\\supseteq"), A("\\Tau", "\\mathrm{T}"), A("\\thetasym", "\\vartheta"), A("\\weierp", "\\wp"), A("\\Zeta", "\\mathrm{Z}"), A("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), A("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), A("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), A("\\bra", "\\mathinner{\\langle{#1}|}"), A("\\ket", "\\mathinner{|{#1}\\rangle}"), A("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), A("\\Bra", "\\left\\langle#1\\right|"), A("\\Ket", "\\left|#1\\right\\rangle"), A("\\angln", "{\\angl n}"), A("\\blue", "\\textcolor{##6495ed}{#1}"), A("\\orange", "\\textcolor{##ffa500}{#1}"), A("\\pink", "\\textcolor{##ff00af}{#1}"), A("\\red", "\\textcolor{##df0030}{#1}"), A("\\green", "\\textcolor{##28ae7b}{#1}"), A("\\gray", "\\textcolor{gray}{#1}"), A("\\purple", "\\textcolor{##9d38bd}{#1}"), A("\\blueA", "\\textcolor{##ccfaff}{#1}"), A("\\blueB", "\\textcolor{##80f6ff}{#1}"), A("\\blueC", "\\textcolor{##63d9ea}{#1}"), A("\\blueD", "\\textcolor{##11accd}{#1}"), A("\\blueE", "\\textcolor{##0c7f99}{#1}"), A("\\tealA", "\\textcolor{##94fff5}{#1}"), A("\\tealB", "\\textcolor{##26edd5}{#1}"), A("\\tealC", "\\textcolor{##01d1c1}{#1}"), A("\\tealD", "\\textcolor{##01a995}{#1}"), A("\\tealE", "\\textcolor{##208170}{#1}"), A("\\greenA", "\\textcolor{##b6ffb0}{#1}"), A("\\greenB", "\\textcolor{##8af281}{#1}"), A("\\greenC", "\\textcolor{##74cf70}{#1}"), A("\\greenD", "\\textcolor{##1fab54}{#1}"), A("\\greenE", "\\textcolor{##0d923f}{#1}"), A("\\goldA", "\\textcolor{##ffd0a9}{#1}"), A("\\goldB", "\\textcolor{##ffbb71}{#1}"), A("\\goldC", "\\textcolor{##ff9c39}{#1}"), A("\\goldD", "\\textcolor{##e07d10}{#1}"), A("\\goldE", "\\textcolor{##a75a05}{#1}"), A("\\redA", "\\textcolor{##fca9a9}{#1}"), A("\\redB", "\\textcolor{##ff8482}{#1}"), A("\\redC", "\\textcolor{##f9685d}{#1}"), A("\\redD", "\\textcolor{##e84d39}{#1}"), A("\\redE", "\\textcolor{##bc2612}{#1}"), A("\\maroonA", "\\textcolor{##ffbde0}{#1}"), A("\\maroonB", "\\textcolor{##ff92c6}{#1}"), A("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), A("\\maroonD", "\\textcolor{##ca337c}{#1}"), A("\\maroonE", "\\textcolor{##9e034e}{#1}"), A("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), A("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), A("\\purpleC", "\\textcolor{##aa87ff}{#1}"), A("\\purpleD", "\\textcolor{##7854ab}{#1}"), A("\\purpleE", "\\textcolor{##543b78}{#1}"), A("\\mintA", "\\textcolor{##f5f9e8}{#1}"), A("\\mintB", "\\textcolor{##edf2df}{#1}"), A("\\mintC", "\\textcolor{##e0e5cc}{#1}"), A("\\grayA", "\\textcolor{##f6f7f7}{#1}"), A("\\grayB", "\\textcolor{##f0f1f2}{#1}"), A("\\grayC", "\\textcolor{##e3e5e6}{#1}"), A("\\grayD", "\\textcolor{##d6d8da}{#1}"), A("\\grayE", "\\textcolor{##babec2}{#1}"), A("\\grayF", "\\textcolor{##888d93}{#1}"), A("\\grayG", "\\textcolor{##626569}{#1}"), A("\\grayH", "\\textcolor{##3b3e40}{#1}"), A("\\grayI", "\\textcolor{##21242c}{#1}"), A("\\kaBlue", "\\textcolor{##314453}{#1}"), A("\\kaGreen", "\\textcolor{##71B307}{#1}");
        var Ks = { "\\relax": true, "^": true, _: true, "\\limits": true, "\\nolimits": true }, U1 = function() {
          function g(a, o, l) {
            this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = o, this.expansionCount = 0, this.feed(a), this.macros = new r22(i2, o.macros), this.mode = l, this.stack = [];
          }
          var i = g.prototype;
          return i.feed = function(o) {
            this.lexer = new $s(o, this.settings);
          }, i.switchMode = function(o) {
            this.mode = o;
          }, i.beginGroup = function() {
            this.macros.beginGroup();
          }, i.endGroup = function() {
            this.macros.endGroup();
          }, i.endGroups = function() {
            this.macros.endGroups();
          }, i.future = function() {
            return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
          }, i.popToken = function() {
            return this.future(), this.stack.pop();
          }, i.pushToken = function(o) {
            this.stack.push(o);
          }, i.pushTokens = function(o) {
            var l;
            (l = this.stack).push.apply(l, o);
          }, i.scanArgument = function(o) {
            var l, f, m;
            if (o) {
              if (this.consumeSpaces(), this.future().text !== "[")
                return null;
              l = this.popToken();
              var y = this.consumeArg(["]"]);
              m = y.tokens, f = y.end;
            } else {
              var S = this.consumeArg();
              m = S.tokens, l = S.start, f = S.end;
            }
            return this.pushToken(new Vr("EOF", f.loc)), this.pushTokens(m), l.range(f, "");
          }, i.consumeSpaces = function() {
            for (; ; ) {
              var o = this.future();
              if (o.text === " ")
                this.stack.pop();
              else
                break;
            }
          }, i.consumeArg = function(o) {
            var l = [], f = o && o.length > 0;
            f || this.consumeSpaces();
            var m = this.future(), y, S = 0, C2 = 0;
            do {
              if (y = this.popToken(), l.push(y), y.text === "{")
                ++S;
              else if (y.text === "}") {
                if (--S, S === -1)
                  throw new c("Extra }", y);
              } else if (y.text === "EOF")
                throw new c("Unexpected end of input in a macro argument, expected '" + (o && f ? o[C2] : "}") + "'", y);
              if (o && f)
                if ((S === 0 || S === 1 && o[C2] === "{") && y.text === o[C2]) {
                  if (++C2, C2 === o.length) {
                    l.splice(-C2, C2);
                    break;
                  }
                } else
                  C2 = 0;
            } while (S !== 0 || f);
            return m.text === "{" && l[l.length - 1].text === "}" && (l.pop(), l.shift()), l.reverse(), { tokens: l, start: m, end: y };
          }, i.consumeArgs = function(o, l) {
            if (l) {
              if (l.length !== o + 1)
                throw new c("The length of delimiters doesn't match the number of args!");
              for (var f = l[0], m = 0; m < f.length; m++) {
                var y = this.popToken();
                if (f[m] !== y.text)
                  throw new c("Use of the macro doesn't match its definition", y);
              }
            }
            for (var S = [], C2 = 0; C2 < o; C2++)
              S.push(this.consumeArg(l && l[C2 + 1]).tokens);
            return S;
          }, i.expandOnce = function(o) {
            var l = this.popToken(), f = l.text, m = l.noexpand ? null : this._getExpansion(f);
            if (m == null || o && m.unexpandable) {
              if (o && m == null && f[0] === "\\" && !this.isDefined(f))
                throw new c("Undefined control sequence: " + f);
              return this.pushToken(l), l;
            }
            if (this.expansionCount++, this.expansionCount > this.settings.maxExpand)
              throw new c("Too many expansions: infinite loop or need to increase maxExpand setting");
            var y = m.tokens, S = this.consumeArgs(m.numArgs, m.delimiters);
            if (m.numArgs) {
              y = y.slice();
              for (var C2 = y.length - 1; C2 >= 0; --C2) {
                var O = y[C2];
                if (O.text === "#") {
                  if (C2 === 0)
                    throw new c("Incomplete placeholder at end of macro body", O);
                  if (O = y[--C2], O.text === "#")
                    y.splice(C2 + 1, 1);
                  else if (/^[1-9]$/.test(O.text)) {
                    var z;
                    (z = y).splice.apply(z, [C2, 2].concat(S[+O.text - 1]));
                  } else
                    throw new c("Not a valid argument number", O);
                }
              }
            }
            return this.pushTokens(y), y;
          }, i.expandAfterFuture = function() {
            return this.expandOnce(), this.future();
          }, i.expandNextToken = function() {
            for (; ; ) {
              var o = this.expandOnce();
              if (o instanceof Vr)
                if (o.text === "\\relax" || o.treatAsRelax)
                  this.stack.pop();
                else
                  return this.stack.pop();
            }
            throw new Error();
          }, i.expandMacro = function(o) {
            return this.macros.has(o) ? this.expandTokens([new Vr(o)]) : void 0;
          }, i.expandTokens = function(o) {
            var l = [], f = this.stack.length;
            for (this.pushTokens(o); this.stack.length > f; ) {
              var m = this.expandOnce(true);
              m instanceof Vr && (m.treatAsRelax && (m.noexpand = false, m.treatAsRelax = false), l.push(this.stack.pop()));
            }
            return l;
          }, i.expandMacroAsText = function(o) {
            var l = this.expandMacro(o);
            return l && l.map(function(f) {
              return f.text;
            }).join("");
          }, i._getExpansion = function(o) {
            var l = this.macros.get(o);
            if (l == null)
              return l;
            if (o.length === 1) {
              var f = this.lexer.catcodes[o];
              if (f != null && f !== 13)
                return;
            }
            var m = typeof l == "function" ? l(this) : l;
            if (typeof m == "string") {
              var y = 0;
              if (m.indexOf("#") !== -1)
                for (var S = m.replace(/##/g, ""); S.indexOf("#" + (y + 1)) !== -1; )
                  ++y;
              for (var C2 = new $s(m, this.settings), O = [], z = C2.lex(); z.text !== "EOF"; )
                O.push(z), z = C2.lex();
              O.reverse();
              var X = { tokens: O, numArgs: y };
              return X;
            }
            return m;
          }, i.isDefined = function(o) {
            return this.macros.has(o) || j1.hasOwnProperty(o) || xt.math.hasOwnProperty(o) || xt.text.hasOwnProperty(o) || Ks.hasOwnProperty(o);
          }, i.isExpandable = function(o) {
            var l = this.macros.get(o);
            return l != null ? typeof l == "string" || typeof l == "function" || !l.unexpandable : j1.hasOwnProperty(o) && !j1[o].primitive;
          }, g;
        }(), mo = { "\u0301": { text: "\\'", math: "\\acute" }, "\u0300": { text: "\\`", math: "\\grave" }, "\u0308": { text: '\\"', math: "\\ddot" }, "\u0303": { text: "\\~", math: "\\tilde" }, "\u0304": { text: "\\=", math: "\\bar" }, "\u0306": { text: "\\u", math: "\\breve" }, "\u030C": { text: "\\v", math: "\\check" }, "\u0302": { text: "\\^", math: "\\hat" }, "\u0307": { text: "\\.", math: "\\dot" }, "\u030A": { text: "\\r", math: "\\mathring" }, "\u030B": { text: "\\H" }, "\u0327": { text: "\\c" } }, Zs = { \u00E1: "a\u0301", \u00E0: "a\u0300", \u00E4: "a\u0308", \u01DF: "a\u0308\u0304", \u00E3: "a\u0303", \u0101: "a\u0304", \u0103: "a\u0306", \u1EAF: "a\u0306\u0301", \u1EB1: "a\u0306\u0300", \u1EB5: "a\u0306\u0303", \u01CE: "a\u030C", \u00E2: "a\u0302", \u1EA5: "a\u0302\u0301", \u1EA7: "a\u0302\u0300", \u1EAB: "a\u0302\u0303", \u0227: "a\u0307", \u01E1: "a\u0307\u0304", \u00E5: "a\u030A", \u01FB: "a\u030A\u0301", \u1E03: "b\u0307", \u0107: "c\u0301", \u1E09: "c\u0327\u0301", \u010D: "c\u030C", \u0109: "c\u0302", \u010B: "c\u0307", \u00E7: "c\u0327", \u010F: "d\u030C", \u1E0B: "d\u0307", \u1E11: "d\u0327", \u00E9: "e\u0301", \u00E8: "e\u0300", \u00EB: "e\u0308", \u1EBD: "e\u0303", \u0113: "e\u0304", \u1E17: "e\u0304\u0301", \u1E15: "e\u0304\u0300", \u0115: "e\u0306", \u1E1D: "e\u0327\u0306", \u011B: "e\u030C", \u00EA: "e\u0302", \u1EBF: "e\u0302\u0301", \u1EC1: "e\u0302\u0300", \u1EC5: "e\u0302\u0303", \u0117: "e\u0307", \u0229: "e\u0327", \u1E1F: "f\u0307", \u01F5: "g\u0301", \u1E21: "g\u0304", \u011F: "g\u0306", \u01E7: "g\u030C", \u011D: "g\u0302", \u0121: "g\u0307", \u0123: "g\u0327", \u1E27: "h\u0308", \u021F: "h\u030C", \u0125: "h\u0302", \u1E23: "h\u0307", \u1E29: "h\u0327", \u00ED: "i\u0301", \u00EC: "i\u0300", \u00EF: "i\u0308", \u1E2F: "i\u0308\u0301", \u0129: "i\u0303", \u012B: "i\u0304", \u012D: "i\u0306", \u01D0: "i\u030C", \u00EE: "i\u0302", \u01F0: "j\u030C", \u0135: "j\u0302", \u1E31: "k\u0301", \u01E9: "k\u030C", \u0137: "k\u0327", \u013A: "l\u0301", \u013E: "l\u030C", \u013C: "l\u0327", \u1E3F: "m\u0301", \u1E41: "m\u0307", \u0144: "n\u0301", \u01F9: "n\u0300", \u00F1: "n\u0303", \u0148: "n\u030C", \u1E45: "n\u0307", \u0146: "n\u0327", \u00F3: "o\u0301", \u00F2: "o\u0300", \u00F6: "o\u0308", \u022B: "o\u0308\u0304", \u00F5: "o\u0303", \u1E4D: "o\u0303\u0301", \u1E4F: "o\u0303\u0308", \u022D: "o\u0303\u0304", \u014D: "o\u0304", \u1E53: "o\u0304\u0301", \u1E51: "o\u0304\u0300", \u014F: "o\u0306", \u01D2: "o\u030C", \u00F4: "o\u0302", \u1ED1: "o\u0302\u0301", \u1ED3: "o\u0302\u0300", \u1ED7: "o\u0302\u0303", \u022F: "o\u0307", \u0231: "o\u0307\u0304", \u0151: "o\u030B", \u1E55: "p\u0301", \u1E57: "p\u0307", \u0155: "r\u0301", \u0159: "r\u030C", \u1E59: "r\u0307", \u0157: "r\u0327", \u015B: "s\u0301", \u1E65: "s\u0301\u0307", \u0161: "s\u030C", \u1E67: "s\u030C\u0307", \u015D: "s\u0302", \u1E61: "s\u0307", \u015F: "s\u0327", \u1E97: "t\u0308", \u0165: "t\u030C", \u1E6B: "t\u0307", \u0163: "t\u0327", \u00FA: "u\u0301", \u00F9: "u\u0300", \u00FC: "u\u0308", \u01D8: "u\u0308\u0301", \u01DC: "u\u0308\u0300", \u01D6: "u\u0308\u0304", \u01DA: "u\u0308\u030C", \u0169: "u\u0303", \u1E79: "u\u0303\u0301", \u016B: "u\u0304", \u1E7B: "u\u0304\u0308", \u016D: "u\u0306", \u01D4: "u\u030C", \u00FB: "u\u0302", \u016F: "u\u030A", \u0171: "u\u030B", \u1E7D: "v\u0303", \u1E83: "w\u0301", \u1E81: "w\u0300", \u1E85: "w\u0308", \u0175: "w\u0302", \u1E87: "w\u0307", \u1E98: "w\u030A", \u1E8D: "x\u0308", \u1E8B: "x\u0307", \u00FD: "y\u0301", \u1EF3: "y\u0300", \u00FF: "y\u0308", \u1EF9: "y\u0303", \u0233: "y\u0304", \u0177: "y\u0302", \u1E8F: "y\u0307", \u1E99: "y\u030A", \u017A: "z\u0301", \u017E: "z\u030C", \u1E91: "z\u0302", \u017C: "z\u0307", \u00C1: "A\u0301", \u00C0: "A\u0300", \u00C4: "A\u0308", \u01DE: "A\u0308\u0304", \u00C3: "A\u0303", \u0100: "A\u0304", \u0102: "A\u0306", \u1EAE: "A\u0306\u0301", \u1EB0: "A\u0306\u0300", \u1EB4: "A\u0306\u0303", \u01CD: "A\u030C", \u00C2: "A\u0302", \u1EA4: "A\u0302\u0301", \u1EA6: "A\u0302\u0300", \u1EAA: "A\u0302\u0303", \u0226: "A\u0307", \u01E0: "A\u0307\u0304", \u00C5: "A\u030A", \u01FA: "A\u030A\u0301", \u1E02: "B\u0307", \u0106: "C\u0301", \u1E08: "C\u0327\u0301", \u010C: "C\u030C", \u0108: "C\u0302", \u010A: "C\u0307", \u00C7: "C\u0327", \u010E: "D\u030C", \u1E0A: "D\u0307", \u1E10: "D\u0327", \u00C9: "E\u0301", \u00C8: "E\u0300", \u00CB: "E\u0308", \u1EBC: "E\u0303", \u0112: "E\u0304", \u1E16: "E\u0304\u0301", \u1E14: "E\u0304\u0300", \u0114: "E\u0306", \u1E1C: "E\u0327\u0306", \u011A: "E\u030C", \u00CA: "E\u0302", \u1EBE: "E\u0302\u0301", \u1EC0: "E\u0302\u0300", \u1EC4: "E\u0302\u0303", \u0116: "E\u0307", \u0228: "E\u0327", \u1E1E: "F\u0307", \u01F4: "G\u0301", \u1E20: "G\u0304", \u011E: "G\u0306", \u01E6: "G\u030C", \u011C: "G\u0302", \u0120: "G\u0307", \u0122: "G\u0327", \u1E26: "H\u0308", \u021E: "H\u030C", \u0124: "H\u0302", \u1E22: "H\u0307", \u1E28: "H\u0327", \u00CD: "I\u0301", \u00CC: "I\u0300", \u00CF: "I\u0308", \u1E2E: "I\u0308\u0301", \u0128: "I\u0303", \u012A: "I\u0304", \u012C: "I\u0306", \u01CF: "I\u030C", \u00CE: "I\u0302", \u0130: "I\u0307", \u0134: "J\u0302", \u1E30: "K\u0301", \u01E8: "K\u030C", \u0136: "K\u0327", \u0139: "L\u0301", \u013D: "L\u030C", \u013B: "L\u0327", \u1E3E: "M\u0301", \u1E40: "M\u0307", \u0143: "N\u0301", \u01F8: "N\u0300", \u00D1: "N\u0303", \u0147: "N\u030C", \u1E44: "N\u0307", \u0145: "N\u0327", \u00D3: "O\u0301", \u00D2: "O\u0300", \u00D6: "O\u0308", \u022A: "O\u0308\u0304", \u00D5: "O\u0303", \u1E4C: "O\u0303\u0301", \u1E4E: "O\u0303\u0308", \u022C: "O\u0303\u0304", \u014C: "O\u0304", \u1E52: "O\u0304\u0301", \u1E50: "O\u0304\u0300", \u014E: "O\u0306", \u01D1: "O\u030C", \u00D4: "O\u0302", \u1ED0: "O\u0302\u0301", \u1ED2: "O\u0302\u0300", \u1ED6: "O\u0302\u0303", \u022E: "O\u0307", \u0230: "O\u0307\u0304", \u0150: "O\u030B", \u1E54: "P\u0301", \u1E56: "P\u0307", \u0154: "R\u0301", \u0158: "R\u030C", \u1E58: "R\u0307", \u0156: "R\u0327", \u015A: "S\u0301", \u1E64: "S\u0301\u0307", \u0160: "S\u030C", \u1E66: "S\u030C\u0307", \u015C: "S\u0302", \u1E60: "S\u0307", \u015E: "S\u0327", \u0164: "T\u030C", \u1E6A: "T\u0307", \u0162: "T\u0327", \u00DA: "U\u0301", \u00D9: "U\u0300", \u00DC: "U\u0308", \u01D7: "U\u0308\u0301", \u01DB: "U\u0308\u0300", \u01D5: "U\u0308\u0304", \u01D9: "U\u0308\u030C", \u0168: "U\u0303", \u1E78: "U\u0303\u0301", \u016A: "U\u0304", \u1E7A: "U\u0304\u0308", \u016C: "U\u0306", \u01D3: "U\u030C", \u00DB: "U\u0302", \u016E: "U\u030A", \u0170: "U\u030B", \u1E7C: "V\u0303", \u1E82: "W\u0301", \u1E80: "W\u0300", \u1E84: "W\u0308", \u0174: "W\u0302", \u1E86: "W\u0307", \u1E8C: "X\u0308", \u1E8A: "X\u0307", \u00DD: "Y\u0301", \u1EF2: "Y\u0300", \u0178: "Y\u0308", \u1EF8: "Y\u0303", \u0232: "Y\u0304", \u0176: "Y\u0302", \u1E8E: "Y\u0307", \u0179: "Z\u0301", \u017D: "Z\u030C", \u1E90: "Z\u0302", \u017B: "Z\u0307", \u03AC: "\u03B1\u0301", \u1F70: "\u03B1\u0300", \u1FB1: "\u03B1\u0304", \u1FB0: "\u03B1\u0306", \u03AD: "\u03B5\u0301", \u1F72: "\u03B5\u0300", \u03AE: "\u03B7\u0301", \u1F74: "\u03B7\u0300", \u03AF: "\u03B9\u0301", \u1F76: "\u03B9\u0300", \u03CA: "\u03B9\u0308", \u0390: "\u03B9\u0308\u0301", \u1FD2: "\u03B9\u0308\u0300", \u1FD1: "\u03B9\u0304", \u1FD0: "\u03B9\u0306", \u03CC: "\u03BF\u0301", \u1F78: "\u03BF\u0300", \u03CD: "\u03C5\u0301", \u1F7A: "\u03C5\u0300", \u03CB: "\u03C5\u0308", \u03B0: "\u03C5\u0308\u0301", \u1FE2: "\u03C5\u0308\u0300", \u1FE1: "\u03C5\u0304", \u1FE0: "\u03C5\u0306", \u03CE: "\u03C9\u0301", \u1F7C: "\u03C9\u0300", \u038E: "\u03A5\u0301", \u1FEA: "\u03A5\u0300", \u03AB: "\u03A5\u0308", \u1FE9: "\u03A5\u0304", \u1FE8: "\u03A5\u0306", \u038F: "\u03A9\u0301", \u1FFA: "\u03A9\u0300" }, Js = function() {
          function g(a, o) {
            this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new U1(a, o, this.mode), this.settings = o, this.leftrightDepth = 0;
          }
          var i = g.prototype;
          return i.expect = function(o, l) {
            if (l === void 0 && (l = true), this.fetch().text !== o)
              throw new c("Expected '" + o + "', got '" + this.fetch().text + "'", this.fetch());
            l && this.consume();
          }, i.consume = function() {
            this.nextToken = null;
          }, i.fetch = function() {
            return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
          }, i.switchMode = function(o) {
            this.mode = o, this.gullet.switchMode(o);
          }, i.parse = function() {
            this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
            try {
              var o = this.parseExpression(false);
              return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), o;
            } finally {
              this.gullet.endGroups();
            }
          }, i.parseExpression = function(o, l) {
            for (var f = []; ; ) {
              this.mode === "math" && this.consumeSpaces();
              var m = this.fetch();
              if (g.endOfExpression.indexOf(m.text) !== -1 || l && m.text === l || o && j1[m.text] && j1[m.text].infix)
                break;
              var y = this.parseAtom(l);
              if (y) {
                if (y.type === "internal")
                  continue;
              } else
                break;
              f.push(y);
            }
            return this.mode === "text" && this.formLigatures(f), this.handleInfixNodes(f);
          }, i.handleInfixNodes = function(o) {
            for (var l = -1, f, m = 0; m < o.length; m++)
              if (o[m].type === "infix") {
                if (l !== -1)
                  throw new c("only one infix operator per group", o[m].token);
                l = m, f = o[m].replaceWith;
              }
            if (l !== -1 && f) {
              var y, S, C2 = o.slice(0, l), O = o.slice(l + 1);
              C2.length === 1 && C2[0].type === "ordgroup" ? y = C2[0] : y = { type: "ordgroup", mode: this.mode, body: C2 }, O.length === 1 && O[0].type === "ordgroup" ? S = O[0] : S = { type: "ordgroup", mode: this.mode, body: O };
              var z;
              return f === "\\\\abovefrac" ? z = this.callFunction(f, [y, o[l], S], []) : z = this.callFunction(f, [y, S], []), [z];
            } else
              return o;
          }, i.handleSupSubscript = function(o) {
            var l = this.fetch(), f = l.text;
            this.consume(), this.consumeSpaces();
            var m = this.parseGroup(o);
            if (!m)
              throw new c("Expected group after '" + f + "'", l);
            return m;
          }, i.formatUnsupportedCmd = function(o) {
            for (var l = [], f = 0; f < o.length; f++)
              l.push({ type: "textord", mode: "text", text: o[f] });
            var m = { type: "text", mode: this.mode, body: l }, y = { type: "color", mode: this.mode, color: this.settings.errorColor, body: [m] };
            return y;
          }, i.parseAtom = function(o) {
            var l = this.parseGroup("atom", o);
            if (this.mode === "text")
              return l;
            for (var f, m; ; ) {
              this.consumeSpaces();
              var y = this.fetch();
              if (y.text === "\\limits" || y.text === "\\nolimits") {
                if (l && l.type === "op") {
                  var S = y.text === "\\limits";
                  l.limits = S, l.alwaysHandleSupSub = true;
                } else if (l && l.type === "operatorname")
                  l.alwaysHandleSupSub && (l.limits = y.text === "\\limits");
                else
                  throw new c("Limit controls must follow a math operator", y);
                this.consume();
              } else if (y.text === "^") {
                if (f)
                  throw new c("Double superscript", y);
                f = this.handleSupSubscript("superscript");
              } else if (y.text === "_") {
                if (m)
                  throw new c("Double subscript", y);
                m = this.handleSupSubscript("subscript");
              } else if (y.text === "'") {
                if (f)
                  throw new c("Double superscript", y);
                var C2 = { type: "textord", mode: this.mode, text: "\\prime" }, O = [C2];
                for (this.consume(); this.fetch().text === "'"; )
                  O.push(C2), this.consume();
                this.fetch().text === "^" && O.push(this.handleSupSubscript("superscript")), f = { type: "ordgroup", mode: this.mode, body: O };
              } else
                break;
            }
            return f || m ? { type: "supsub", mode: this.mode, base: l, sup: f, sub: m } : l;
          }, i.parseFunction = function(o, l) {
            var f = this.fetch(), m = f.text, y = j1[m];
            if (!y)
              return null;
            if (this.consume(), l && l !== "atom" && !y.allowedInArgument)
              throw new c("Got function '" + m + "' with no arguments" + (l ? " as " + l : ""), f);
            if (this.mode === "text" && !y.allowedInText)
              throw new c("Can't use function '" + m + "' in text mode", f);
            if (this.mode === "math" && y.allowedInMath === false)
              throw new c("Can't use function '" + m + "' in math mode", f);
            var S = this.parseArguments(m, y), C2 = S.args, O = S.optArgs;
            return this.callFunction(m, C2, O, f, o);
          }, i.callFunction = function(o, l, f, m, y) {
            var S = { funcName: o, parser: this, token: m, breakOnTokenText: y }, C2 = j1[o];
            if (C2 && C2.handler)
              return C2.handler(S, l, f);
            throw new c("No function handler for " + o);
          }, i.parseArguments = function(o, l) {
            var f = l.numArgs + l.numOptionalArgs;
            if (f === 0)
              return { args: [], optArgs: [] };
            for (var m = [], y = [], S = 0; S < f; S++) {
              var C2 = l.argTypes && l.argTypes[S], O = S < l.numOptionalArgs;
              (l.primitive && C2 == null || l.type === "sqrt" && S === 1 && y[0] == null) && (C2 = "primitive");
              var z = this.parseGroupOfType("argument to '" + o + "'", C2, O);
              if (O)
                y.push(z);
              else if (z != null)
                m.push(z);
              else
                throw new c("Null argument, please report this as a bug");
            }
            return { args: m, optArgs: y };
          }, i.parseGroupOfType = function(o, l, f) {
            switch (l) {
              case "color":
                return this.parseColorGroup(f);
              case "size":
                return this.parseSizeGroup(f);
              case "url":
                return this.parseUrlGroup(f);
              case "math":
              case "text":
                return this.parseArgumentGroup(f, l);
              case "hbox": {
                var m = this.parseArgumentGroup(f, "text");
                return m != null ? { type: "styling", mode: m.mode, body: [m], style: "text" } : null;
              }
              case "raw": {
                var y = this.parseStringGroup("raw", f);
                return y != null ? { type: "raw", mode: "text", string: y.text } : null;
              }
              case "primitive": {
                if (f)
                  throw new c("A primitive argument cannot be optional");
                var S = this.parseGroup(o);
                if (S == null)
                  throw new c("Expected group as " + o, this.fetch());
                return S;
              }
              case "original":
              case null:
              case void 0:
                return this.parseArgumentGroup(f);
              default:
                throw new c("Unknown group type as " + o, this.fetch());
            }
          }, i.consumeSpaces = function() {
            for (; this.fetch().text === " "; )
              this.consume();
          }, i.parseStringGroup = function(o, l) {
            var f = this.gullet.scanArgument(l);
            if (f == null)
              return null;
            for (var m = "", y; (y = this.fetch()).text !== "EOF"; )
              m += y.text, this.consume();
            return this.consume(), f.text = m, f;
          }, i.parseRegexGroup = function(o, l) {
            for (var f = this.fetch(), m = f, y = "", S; (S = this.fetch()).text !== "EOF" && o.test(y + S.text); )
              m = S, y += m.text, this.consume();
            if (y === "")
              throw new c("Invalid " + l + ": '" + f.text + "'", f);
            return f.range(m, y);
          }, i.parseColorGroup = function(o) {
            var l = this.parseStringGroup("color", o);
            if (l == null)
              return null;
            var f = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(l.text);
            if (!f)
              throw new c("Invalid color: '" + l.text + "'", l);
            var m = f[0];
            return /^[0-9a-f]{6}$/i.test(m) && (m = "#" + m), { type: "color-token", mode: this.mode, color: m };
          }, i.parseSizeGroup = function(o) {
            var l, f = false;
            if (this.gullet.consumeSpaces(), !o && this.gullet.future().text !== "{" ? l = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : l = this.parseStringGroup("size", o), !l)
              return null;
            !o && l.text.length === 0 && (l.text = "0pt", f = true);
            var m = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(l.text);
            if (!m)
              throw new c("Invalid size: '" + l.text + "'", l);
            var y = { number: +(m[1] + m[2]), unit: m[3] };
            if (!Oi(y))
              throw new c("Invalid unit: '" + y.unit + "'", l);
            return { type: "size", mode: this.mode, value: y, isBlank: f };
          }, i.parseUrlGroup = function(o) {
            this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
            var l = this.parseStringGroup("url", o);
            if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), l == null)
              return null;
            var f = l.text.replace(/\\([#$%&~_^{}])/g, "$1");
            return { type: "url", mode: this.mode, url: f };
          }, i.parseArgumentGroup = function(o, l) {
            var f = this.gullet.scanArgument(o);
            if (f == null)
              return null;
            var m = this.mode;
            l && this.switchMode(l), this.gullet.beginGroup();
            var y = this.parseExpression(false, "EOF");
            this.expect("EOF"), this.gullet.endGroup();
            var S = { type: "ordgroup", mode: this.mode, loc: f.loc, body: y };
            return l && this.switchMode(m), S;
          }, i.parseGroup = function(o, l) {
            var f = this.fetch(), m = f.text, y;
            if (m === "{" || m === "\\begingroup") {
              this.consume();
              var S = m === "{" ? "}" : "\\endgroup";
              this.gullet.beginGroup();
              var C2 = this.parseExpression(false, S), O = this.fetch();
              this.expect(S), this.gullet.endGroup(), y = { type: "ordgroup", mode: this.mode, loc: _14.range(f, O), body: C2, semisimple: m === "\\begingroup" || void 0 };
            } else if (y = this.parseFunction(l, o) || this.parseSymbol(), y == null && m[0] === "\\" && !Ks.hasOwnProperty(m)) {
              if (this.settings.throwOnError)
                throw new c("Undefined control sequence: " + m, f);
              y = this.formatUnsupportedCmd(m), this.consume();
            }
            return y;
          }, i.formLigatures = function(o) {
            for (var l = o.length - 1, f = 0; f < l; ++f) {
              var m = o[f], y = m.text;
              y === "-" && o[f + 1].text === "-" && (f + 1 < l && o[f + 2].text === "-" ? (o.splice(f, 3, { type: "textord", mode: "text", loc: _14.range(m, o[f + 2]), text: "---" }), l -= 2) : (o.splice(f, 2, { type: "textord", mode: "text", loc: _14.range(m, o[f + 1]), text: "--" }), l -= 1)), (y === "'" || y === "`") && o[f + 1].text === y && (o.splice(f, 2, { type: "textord", mode: "text", loc: _14.range(m, o[f + 1]), text: y + y }), l -= 1);
            }
          }, i.parseSymbol = function() {
            var o = this.fetch(), l = o.text;
            if (/^\\verb[^a-zA-Z]/.test(l)) {
              this.consume();
              var f = l.slice(5), m = f.charAt(0) === "*";
              if (m && (f = f.slice(1)), f.length < 2 || f.charAt(0) !== f.slice(-1))
                throw new c(`\\verb assertion failed --
                    please report what input caused this bug`);
              return f = f.slice(1, -1), { type: "verb", mode: "text", body: f, star: m };
            }
            Zs.hasOwnProperty(l[0]) && !xt[this.mode][l[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + l[0] + '" used in math mode', o), l = Zs[l[0]] + l.substr(1));
            var y = D0.exec(l);
            y && (l = l.substring(0, y.index), l === "i" ? l = "\u0131" : l === "j" && (l = "\u0237"));
            var S;
            if (xt[this.mode][l]) {
              this.settings.strict && this.mode === "math" && La.indexOf(l) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + l[0] + '" used in math mode', o);
              var C2 = xt[this.mode][l].group, O = _14.range(o), z;
              if (Oa.hasOwnProperty(C2)) {
                var X = C2;
                z = { type: "atom", mode: this.mode, family: X, loc: O, text: l };
              } else
                z = { type: C2, mode: this.mode, loc: O, text: l };
              S = z;
            } else if (l.charCodeAt(0) >= 128)
              this.settings.strict && (J1(l.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + l[0] + '" used in math mode', o) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + l[0] + '"' + (" (" + l.charCodeAt(0) + ")"), o)), S = { type: "textord", mode: "text", loc: _14.range(o), text: l };
            else
              return null;
            if (this.consume(), y)
              for (var K = 0; K < y[0].length; K++) {
                var Y = y[0][K];
                if (!mo[Y])
                  throw new c("Unknown accent ' " + Y + "'", o);
                var oe = mo[Y][this.mode] || mo[Y].text;
                if (!oe)
                  throw new c("Accent " + Y + " unsupported in " + this.mode + " mode", o);
                S = { type: "accent", mode: this.mode, loc: _14.range(o), label: oe, isStretchy: false, isShifty: true, base: S };
              }
            return S;
          }, g;
        }();
        Js.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
        var a2 = function(i, a) {
          if (!(typeof i == "string" || i instanceof String))
            throw new TypeError("KaTeX can only parse string typed expression");
          var o = new Js(i, a);
          delete o.gullet.macros.current["\\df@tag"];
          var l = o.parse();
          if (delete o.gullet.macros.current["\\current@color"], delete o.gullet.macros.current["\\color"], o.gullet.macros.get("\\df@tag")) {
            if (!a.displayMode)
              throw new c("\\tag works only in display equations");
            o.gullet.feed("\\df@tag"), l = [{ type: "tag", mode: "text", body: l, tag: o.parse() }];
          }
          return l;
        }, po = a2, s0 = function(i, a, o) {
          a.textContent = "";
          var l = go(i, o).toNode();
          a.appendChild(l);
        };
        typeof document != "undefined" && document.compatMode !== "CSS1Compat" && (typeof console != "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), s0 = function() {
          throw new c("KaTeX doesn't work in quirks mode.");
        });
        var o2 = function(i, a) {
          var o = go(i, a).toMarkup();
          return o;
        }, s2 = function(i, a) {
          var o = new de(a);
          return po(i, o);
        }, Xr = function(i, a, o) {
          if (o.throwOnError || !(i instanceof c))
            throw i;
          var l = H.makeSpan(["katex-error"], [new Ur(a)]);
          return l.setAttribute("title", i.toString()), l.setAttribute("style", "color:" + o.errorColor), l;
        }, go = function(i, a) {
          var o = new de(a);
          try {
            var l = po(i, o);
            return Va(l, i, o);
          } catch (f) {
            return Xr(f, i, o);
          }
        }, l2 = function(i, a) {
          var o = new de(a);
          try {
            var l = po(i, o);
            return yt(l, i, o);
          } catch (f) {
            return Xr(f, i, o);
          }
        }, u2 = { version: "0.13.20", render: s0, renderToString: o2, ParseError: c, __parse: s2, __renderToDomTree: go, __renderToHTMLTree: l2, __setFontMetrics: Ba, __defineSymbol: h, __defineMacro: A, __domTree: { Span: jr, Anchor: Zt, SymbolNode: Ur, SvgNode: Wr, PathNode: b0, LineNode: x0 } }, c2 = u2;
        return r6 = r6.default, r6;
      }();
    });
  });
  var Sl = J((JT, y7) => {
    y7.exports = Array.isArray || function(r6) {
      return r6 != null && r6.length >= 0 && Object.prototype.toString.call(r6) === "[object Array]";
    };
  });
  var Z2 = J((QT, b7) => {
    var gv = Sl();
    function vv(t2, r6) {
      return function() {
        var s = arguments.length;
        if (s === 0)
          return r6();
        var c = arguments[s - 1];
        return gv(c) || typeof c[t2] != "function" ? r6.apply(this, arguments) : c[t2].apply(c, Array.prototype.slice.call(arguments, 0, s - 1));
      };
    }
    b7.exports = vv;
  });
  var Do = J((eE, x7) => {
    function yv(t2) {
      return t2 != null && typeof t2 == "object" && t2["@@functional/placeholder"] === true;
    }
    x7.exports = yv;
  });
  var z0 = J((tE, w7) => {
    var bv = Do();
    function xv(t2) {
      return function r6(s) {
        return arguments.length === 0 || bv(s) ? r6 : t2.apply(this, arguments);
      };
    }
    w7.exports = xv;
  });
  var fr = J((rE, _72) => {
    var J2 = z0(), Bo = Do();
    function wv(t2) {
      return function r6(s, c) {
        switch (arguments.length) {
          case 0:
            return r6;
          case 1:
            return Bo(s) ? r6 : J2(function(p) {
              return t2(s, p);
            });
          default:
            return Bo(s) && Bo(c) ? r6 : Bo(s) ? J2(function(p) {
              return t2(p, c);
            }) : Bo(c) ? J2(function(p) {
              return t2(s, p);
            }) : t2(s, c);
        }
      };
    }
    _72.exports = wv;
  });
  var A7 = J((nE, S7) => {
    var _v = Z2(), Sv = fr(), Av = Sv(_v("forEach", function(r6, s) {
      for (var c = s.length, p = 0; p < c; )
        r6(s[p]), p += 1;
      return s;
    }));
    S7.exports = Av;
  });
  var E7 = J((iE, T7) => {
    function Tv(t2) {
      return t2 != null && typeof t2["@@transducer/step"] == "function";
    }
    T7.exports = Tv;
  });
  var No = J((aE, C7) => {
    var Ev = Sl(), Cv = E7();
    function kv(t2, r6, s) {
      return function() {
        if (arguments.length === 0)
          return s();
        var c = Array.prototype.slice.call(arguments, 0), p = c.pop();
        if (!Ev(p)) {
          for (var w = 0; w < t2.length; ) {
            if (typeof p[t2[w]] == "function")
              return p[t2[w]].apply(p, c);
            w += 1;
          }
          if (Cv(p)) {
            var T = r6.apply(null, c);
            return T(p);
          }
        }
        return s.apply(this, arguments);
      };
    }
    C7.exports = kv;
  });
  var Q2 = J((oE, k7) => {
    function Mv(t2) {
      return t2 && t2["@@transducer/reduced"] ? t2 : { "@@transducer/value": t2, "@@transducer/reduced": true };
    }
    k7.exports = Mv;
  });
  var Oo = J((sE, M7) => {
    M7.exports = { init: function() {
      return this.xf["@@transducer/init"]();
    }, result: function(t2) {
      return this.xf["@@transducer/result"](t2);
    } };
  });
  var B7 = J((lE, D7) => {
    var Dv = fr(), Bv = Q2(), Nv = Oo(), Ov = function() {
      function t2(r6, s) {
        this.xf = s, this.f = r6, this.found = false;
      }
      return t2.prototype["@@transducer/init"] = Nv.init, t2.prototype["@@transducer/result"] = function(r6) {
        return this.found || (r6 = this.xf["@@transducer/step"](r6, void 0)), this.xf["@@transducer/result"](r6);
      }, t2.prototype["@@transducer/step"] = function(r6, s) {
        return this.f(s) && (this.found = true, r6 = Bv(this.xf["@@transducer/step"](r6, s))), r6;
      }, t2;
    }(), qv = Dv(function(r6, s) {
      return new Ov(r6, s);
    });
    D7.exports = qv;
  });
  var O7 = J((uE, N7) => {
    var Pv = fr(), Lv = No(), Iv = B7(), Rv = Pv(Lv(["find"], Iv, function(r6, s) {
      for (var c = 0, p = s.length; c < p; ) {
        if (r6(s[c]))
          return s[c];
        c += 1;
      }
    }));
    N7.exports = Rv;
  });
  var P7 = J((cE, q7) => {
    function zv(t2) {
      return function() {
        return !t2.apply(this, arguments);
      };
    }
    q7.exports = zv;
  });
  var I7 = J((fE, L7) => {
    function Fv(t2, r6) {
      for (var s = 0, c = r6.length, p = []; s < c; )
        t2(r6[s]) && (p[p.length] = r6[s]), s += 1;
      return p;
    }
    L7.exports = Fv;
  });
  var z7 = J((hE, R7) => {
    function Hv(t2) {
      return Object.prototype.toString.call(t2) === "[object Object]";
    }
    R7.exports = Hv;
  });
  var H7 = J((dE, F7) => {
    function jv(t2) {
      return Object.prototype.toString.call(t2) === "[object String]";
    }
    F7.exports = jv;
  });
  var U7 = J((mE, j7) => {
    var Uv = z0(), Wv = Sl(), Gv = H7(), Vv = Uv(function(r6) {
      return Wv(r6) ? true : !r6 || typeof r6 != "object" || Gv(r6) ? false : r6.nodeType === 1 ? !!r6.length : r6.length === 0 ? true : r6.length > 0 ? r6.hasOwnProperty(0) && r6.hasOwnProperty(r6.length - 1) : false;
    });
    j7.exports = Vv;
  });
  var G7 = J((pE, W7) => {
    var $v = function() {
      function t2(r6) {
        this.f = r6;
      }
      return t2.prototype["@@transducer/init"] = function() {
        throw new Error("init not implemented on XWrap");
      }, t2.prototype["@@transducer/result"] = function(r6) {
        return r6;
      }, t2.prototype["@@transducer/step"] = function(r6, s) {
        return this.f(r6, s);
      }, t2;
    }();
    function Xv(t2) {
      return new $v(t2);
    }
    W7.exports = Xv;
  });
  var Al = J((gE, V7) => {
    function Yv(t2, r6) {
      switch (t2) {
        case 0:
          return function() {
            return r6.apply(this, arguments);
          };
        case 1:
          return function(s) {
            return r6.apply(this, arguments);
          };
        case 2:
          return function(s, c) {
            return r6.apply(this, arguments);
          };
        case 3:
          return function(s, c, p) {
            return r6.apply(this, arguments);
          };
        case 4:
          return function(s, c, p, w) {
            return r6.apply(this, arguments);
          };
        case 5:
          return function(s, c, p, w, T) {
            return r6.apply(this, arguments);
          };
        case 6:
          return function(s, c, p, w, T, k) {
            return r6.apply(this, arguments);
          };
        case 7:
          return function(s, c, p, w, T, k, P) {
            return r6.apply(this, arguments);
          };
        case 8:
          return function(s, c, p, w, T, k, P, j) {
            return r6.apply(this, arguments);
          };
        case 9:
          return function(s, c, p, w, T, k, P, j, U) {
            return r6.apply(this, arguments);
          };
        case 10:
          return function(s, c, p, w, T, k, P, j, U, ee) {
            return r6.apply(this, arguments);
          };
        default:
          throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
      }
    }
    V7.exports = Yv;
  });
  var X7 = J((vE, $7) => {
    var Kv = Al(), Zv = fr(), Jv = Zv(function(r6, s) {
      return Kv(r6.length, function() {
        return r6.apply(s, arguments);
      });
    });
    $7.exports = Jv;
  });
  var Tl = J((yE, J7) => {
    var Qv = U7(), ey = G7(), ty = X7();
    function ry(t2, r6, s) {
      for (var c = 0, p = s.length; c < p; ) {
        if (r6 = t2["@@transducer/step"](r6, s[c]), r6 && r6["@@transducer/reduced"]) {
          r6 = r6["@@transducer/value"];
          break;
        }
        c += 1;
      }
      return t2["@@transducer/result"](r6);
    }
    function Y7(t2, r6, s) {
      for (var c = s.next(); !c.done; ) {
        if (r6 = t2["@@transducer/step"](r6, c.value), r6 && r6["@@transducer/reduced"]) {
          r6 = r6["@@transducer/value"];
          break;
        }
        c = s.next();
      }
      return t2["@@transducer/result"](r6);
    }
    function K7(t2, r6, s, c) {
      return t2["@@transducer/result"](s[c](ty(t2["@@transducer/step"], t2), r6));
    }
    var Z7 = typeof Symbol != "undefined" ? Symbol.iterator : "@@iterator";
    function ny(t2, r6, s) {
      if (typeof t2 == "function" && (t2 = ey(t2)), Qv(s))
        return ry(t2, r6, s);
      if (typeof s["fantasy-land/reduce"] == "function")
        return K7(t2, r6, s, "fantasy-land/reduce");
      if (s[Z7] != null)
        return Y7(t2, r6, s[Z7]());
      if (typeof s.next == "function")
        return Y7(t2, r6, s);
      if (typeof s.reduce == "function")
        return K7(t2, r6, s, "reduce");
      throw new TypeError("reduce: list must be array or iterable");
    }
    J7.exports = ny;
  });
  var t9 = J((bE, e9) => {
    var iy = fr(), Q7 = Oo(), ay = function() {
      function t2(r6, s) {
        this.xf = s, this.f = r6;
      }
      return t2.prototype["@@transducer/init"] = Q7.init, t2.prototype["@@transducer/result"] = Q7.result, t2.prototype["@@transducer/step"] = function(r6, s) {
        return this.f(s) ? this.xf["@@transducer/step"](r6, s) : r6;
      }, t2;
    }(), oy = iy(function(r6, s) {
      return new ay(r6, s);
    });
    e9.exports = oy;
  });
  var qo = J((xE, r9) => {
    function sy(t2, r6) {
      return Object.prototype.hasOwnProperty.call(r6, t2);
    }
    r9.exports = sy;
  });
  var a9 = J((wE, i9) => {
    var ly = qo(), n9 = Object.prototype.toString, uy = function() {
      return n9.call(arguments) === "[object Arguments]" ? function(r6) {
        return n9.call(r6) === "[object Arguments]";
      } : function(r6) {
        return ly("callee", r6);
      };
    }();
    i9.exports = uy;
  });
  var El = J((_E2, c9) => {
    var o9 = z0(), s9 = qo(), cy = a9(), fy = !{ toString: null }.propertyIsEnumerable("toString"), l9 = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"], u9 = function() {
      "use strict";
      return arguments.propertyIsEnumerable("length");
    }(), hy = function(r6, s) {
      for (var c = 0; c < r6.length; ) {
        if (r6[c] === s)
          return true;
        c += 1;
      }
      return false;
    }, dy = typeof Object.keys == "function" && !u9 ? o9(function(r6) {
      return Object(r6) !== r6 ? [] : Object.keys(r6);
    }) : o9(function(r6) {
      if (Object(r6) !== r6)
        return [];
      var s, c, p = [], w = u9 && cy(r6);
      for (s in r6)
        s9(s, r6) && (!w || s !== "length") && (p[p.length] = s);
      if (fy)
        for (c = l9.length - 1; c >= 0; )
          s = l9[c], s9(s, r6) && !hy(p, s) && (p[p.length] = s), c -= 1;
      return p;
    });
    c9.exports = dy;
  });
  var h9 = J((SE, f9) => {
    var my = fr(), py = No(), gy = I7(), vy = z7(), yy = Tl(), by = t9(), xy = El(), wy = my(py(["filter"], by, function(t2, r6) {
      return vy(r6) ? yy(function(s, c) {
        return t2(r6[c]) && (s[c] = r6[c]), s;
      }, {}, xy(r6)) : gy(t2, r6);
    }));
    f9.exports = wy;
  });
  var m9 = J((AE, d9) => {
    var _y = P7(), Sy = fr(), Ay = h9(), Ty = Sy(function(r6, s) {
      return Ay(_y(r6), s);
    });
    d9.exports = Ty;
  });
  var g9 = J((TE, p9) => {
    function Ey(t2, r6) {
      t2 = t2 || [], r6 = r6 || [];
      var s, c = t2.length, p = r6.length, w = [];
      for (s = 0; s < c; )
        w[w.length] = t2[s], s += 1;
      for (s = 0; s < p; )
        w[w.length] = r6[s], s += 1;
      return w;
    }
    p9.exports = Ey;
  });
  var x9 = J((EE, b9) => {
    var Cy = Al(), v9 = Do();
    function y9(t2, r6, s) {
      return function() {
        for (var c = [], p = 0, w = t2, T = 0; T < r6.length || p < arguments.length; ) {
          var k;
          T < r6.length && (!v9(r6[T]) || p >= arguments.length) ? k = r6[T] : (k = arguments[p], p += 1), c[T] = k, v9(k) || (w -= 1), T += 1;
        }
        return w <= 0 ? s.apply(this, c) : Cy(w, y9(t2, c, s));
      };
    }
    b9.exports = y9;
  });
  var e5 = J((CE, w9) => {
    var ky = Al(), My = z0(), Dy = fr(), By = x9(), Ny = Dy(function(r6, s) {
      return r6 === 1 ? My(s) : ky(r6, By(r6, [], s));
    });
    w9.exports = Ny;
  });
  var S9 = J((kE, _92) => {
    var Oy = g9(), qy = z0(), Py = e5(), Ly = qy(function(r6) {
      return Py(r6.length, function() {
        var s = 0, c = arguments[0], p = arguments[arguments.length - 1], w = Array.prototype.slice.call(arguments, 0);
        return w[0] = function() {
          var T = c.apply(this, Oy(arguments, [s, p]));
          return s += 1, T;
        }, r6.apply(this, w);
      });
    });
    _92.exports = Ly;
  });
  var T9 = J((ME, A9) => {
    function Iy(t2, r6) {
      for (var s = 0, c = r6.length, p = Array(c); s < c; )
        p[s] = t2(r6[s]), s += 1;
      return p;
    }
    A9.exports = Iy;
  });
  var k9 = J((DE, C9) => {
    var Ry = fr(), E9 = Oo(), zy = function() {
      function t2(r6, s) {
        this.xf = s, this.f = r6;
      }
      return t2.prototype["@@transducer/init"] = E9.init, t2.prototype["@@transducer/result"] = E9.result, t2.prototype["@@transducer/step"] = function(r6, s) {
        return this.xf["@@transducer/step"](r6, this.f(s));
      }, t2;
    }(), Fy = Ry(function(r6, s) {
      return new zy(r6, s);
    });
    C9.exports = Fy;
  });
  var D9 = J((BE, M9) => {
    var Hy = fr(), jy = No(), Uy = T9(), Wy = Tl(), Gy = k9(), Vy = e5(), $y = El(), Xy = Hy(jy(["fantasy-land/map", "map"], Gy, function(r6, s) {
      switch (Object.prototype.toString.call(s)) {
        case "[object Function]":
          return Vy(s.length, function() {
            return r6.call(this, s.apply(this, arguments));
          });
        case "[object Object]":
          return Wy(function(c, p) {
            return c[p] = r6(s[p]), c;
          }, {}, $y(s));
        default:
          return Uy(r6, s);
      }
    }));
    M9.exports = Xy;
  });
  var r5 = J((t5) => {
    "use strict";
    Object.defineProperty(t5, "__esModule", { value: true });
    var Yy = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), Ky = String.fromCodePoint || function(t2) {
      var r6 = "";
      return t2 > 65535 && (t2 -= 65536, r6 += String.fromCharCode(t2 >>> 10 & 1023 | 55296), t2 = 56320 | t2 & 1023), r6 += String.fromCharCode(t2), r6;
    };
    function Zy(t2) {
      var r6;
      return t2 >= 55296 && t2 <= 57343 || t2 > 1114111 ? "\uFFFD" : Ky((r6 = Yy.get(t2)) !== null && r6 !== void 0 ? r6 : t2);
    }
    t5.default = Zy;
  });
  var B9 = J((n5) => {
    "use strict";
    Object.defineProperty(n5, "__esModule", { value: true });
    n5.default = new Uint16Array([14866, 60, 237, 340, 721, 1312, 1562, 1654, 1838, 1957, 2183, 2239, 2301, 2958, 3037, 3893, 4123, 4298, 4330, 4801, 5191, 5395, 5752, 5903, 5943, 5972, 6050, 0, 0, 0, 0, 0, 0, 6135, 6565, 7422, 8183, 8738, 9242, 9503, 9938, 10189, 10573, 10637, 10715, 11950, 12246, 13539, 13950, 14445, 14533, 15364, 16514, 16980, 17390, 17763, 17849, 18036, 18125, 4096, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 92, 100, 106, 115, 122, 137, 142, 151, 157, 163, 167, 182, 196, 204, 220, 229, 108, 105, 103, 33024, 198, 59, 32768, 198, 80, 33024, 38, 59, 32768, 38, 99, 117, 116, 101, 33024, 193, 59, 32768, 193, 114, 101, 118, 101, 59, 32768, 258, 512, 105, 121, 127, 134, 114, 99, 33024, 194, 59, 32768, 194, 59, 32768, 1040, 114, 59, 32896, 55349, 56580, 114, 97, 118, 101, 33024, 192, 59, 32768, 192, 112, 104, 97, 59, 32768, 913, 97, 99, 114, 59, 32768, 256, 100, 59, 32768, 10835, 512, 103, 112, 172, 177, 111, 110, 59, 32768, 260, 102, 59, 32896, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 32768, 8289, 105, 110, 103, 33024, 197, 59, 32768, 197, 512, 99, 115, 209, 214, 114, 59, 32896, 55349, 56476, 105, 103, 110, 59, 32768, 8788, 105, 108, 100, 101, 33024, 195, 59, 32768, 195, 109, 108, 33024, 196, 59, 32768, 196, 2048, 97, 99, 101, 102, 111, 114, 115, 117, 253, 278, 282, 310, 315, 321, 327, 332, 512, 99, 114, 258, 267, 107, 115, 108, 97, 115, 104, 59, 32768, 8726, 583, 271, 274, 59, 32768, 10983, 101, 100, 59, 32768, 8966, 121, 59, 32768, 1041, 768, 99, 114, 116, 289, 296, 306, 97, 117, 115, 101, 59, 32768, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 32768, 8492, 97, 59, 32768, 914, 114, 59, 32896, 55349, 56581, 112, 102, 59, 32896, 55349, 56633, 101, 118, 101, 59, 32768, 728, 99, 114, 59, 32768, 8492, 109, 112, 101, 113, 59, 32768, 8782, 3584, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 368, 373, 380, 426, 461, 466, 487, 491, 495, 533, 593, 695, 701, 707, 99, 121, 59, 32768, 1063, 80, 89, 33024, 169, 59, 32768, 169, 768, 99, 112, 121, 387, 393, 419, 117, 116, 101, 59, 32768, 262, 512, 59, 105, 398, 400, 32768, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 32768, 8517, 108, 101, 121, 115, 59, 32768, 8493, 1024, 97, 101, 105, 111, 435, 441, 449, 454, 114, 111, 110, 59, 32768, 268, 100, 105, 108, 33024, 199, 59, 32768, 199, 114, 99, 59, 32768, 264, 110, 105, 110, 116, 59, 32768, 8752, 111, 116, 59, 32768, 266, 512, 100, 110, 471, 478, 105, 108, 108, 97, 59, 32768, 184, 116, 101, 114, 68, 111, 116, 59, 32768, 183, 114, 59, 32768, 8493, 105, 59, 32768, 935, 114, 99, 108, 101, 1024, 68, 77, 80, 84, 508, 513, 520, 526, 111, 116, 59, 32768, 8857, 105, 110, 117, 115, 59, 32768, 8854, 108, 117, 115, 59, 32768, 8853, 105, 109, 101, 115, 59, 32768, 8855, 111, 512, 99, 115, 539, 562, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8754, 101, 67, 117, 114, 108, 121, 512, 68, 81, 573, 586, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 32768, 8221, 117, 111, 116, 101, 59, 32768, 8217, 1024, 108, 110, 112, 117, 602, 614, 648, 664, 111, 110, 512, 59, 101, 609, 611, 32768, 8759, 59, 32768, 10868, 768, 103, 105, 116, 621, 629, 634, 114, 117, 101, 110, 116, 59, 32768, 8801, 110, 116, 59, 32768, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8750, 512, 102, 114, 653, 656, 59, 32768, 8450, 111, 100, 117, 99, 116, 59, 32768, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8755, 111, 115, 115, 59, 32768, 10799, 99, 114, 59, 32896, 55349, 56478, 112, 512, 59, 67, 713, 715, 32768, 8915, 97, 112, 59, 32768, 8781, 2816, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 743, 758, 763, 768, 773, 795, 809, 821, 826, 910, 1295, 512, 59, 111, 748, 750, 32768, 8517, 116, 114, 97, 104, 100, 59, 32768, 10513, 99, 121, 59, 32768, 1026, 99, 121, 59, 32768, 1029, 99, 121, 59, 32768, 1039, 768, 103, 114, 115, 780, 786, 790, 103, 101, 114, 59, 32768, 8225, 114, 59, 32768, 8609, 104, 118, 59, 32768, 10980, 512, 97, 121, 800, 806, 114, 111, 110, 59, 32768, 270, 59, 32768, 1044, 108, 512, 59, 116, 815, 817, 32768, 8711, 97, 59, 32768, 916, 114, 59, 32896, 55349, 56583, 512, 97, 102, 831, 897, 512, 99, 109, 836, 891, 114, 105, 116, 105, 99, 97, 108, 1024, 65, 68, 71, 84, 852, 859, 877, 884, 99, 117, 116, 101, 59, 32768, 180, 111, 581, 864, 867, 59, 32768, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 32768, 733, 114, 97, 118, 101, 59, 32768, 96, 105, 108, 100, 101, 59, 32768, 732, 111, 110, 100, 59, 32768, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 32768, 8518, 2113, 920, 0, 0, 0, 925, 946, 0, 1139, 102, 59, 32896, 55349, 56635, 768, 59, 68, 69, 931, 933, 938, 32768, 168, 111, 116, 59, 32768, 8412, 113, 117, 97, 108, 59, 32768, 8784, 98, 108, 101, 1536, 67, 68, 76, 82, 85, 86, 961, 978, 996, 1080, 1101, 1125, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8751, 111, 1093, 985, 0, 0, 988, 59, 32768, 168, 110, 65, 114, 114, 111, 119, 59, 32768, 8659, 512, 101, 111, 1001, 1034, 102, 116, 768, 65, 82, 84, 1010, 1017, 1029, 114, 114, 111, 119, 59, 32768, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8660, 101, 101, 59, 32768, 10980, 110, 103, 512, 76, 82, 1041, 1068, 101, 102, 116, 512, 65, 82, 1049, 1056, 114, 114, 111, 119, 59, 32768, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10233, 105, 103, 104, 116, 512, 65, 84, 1089, 1096, 114, 114, 111, 119, 59, 32768, 8658, 101, 101, 59, 32768, 8872, 112, 1042, 1108, 0, 0, 1115, 114, 114, 111, 119, 59, 32768, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8741, 110, 1536, 65, 66, 76, 82, 84, 97, 1152, 1179, 1186, 1236, 1272, 1288, 114, 114, 111, 119, 768, 59, 66, 85, 1163, 1165, 1170, 32768, 8595, 97, 114, 59, 32768, 10515, 112, 65, 114, 114, 111, 119, 59, 32768, 8693, 114, 101, 118, 101, 59, 32768, 785, 101, 102, 116, 1315, 1196, 0, 1209, 0, 1220, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 32768, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10590, 101, 99, 116, 111, 114, 512, 59, 66, 1229, 1231, 32768, 8637, 97, 114, 59, 32768, 10582, 105, 103, 104, 116, 805, 1245, 0, 1256, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10591, 101, 99, 116, 111, 114, 512, 59, 66, 1265, 1267, 32768, 8641, 97, 114, 59, 32768, 10583, 101, 101, 512, 59, 65, 1279, 1281, 32768, 8868, 114, 114, 111, 119, 59, 32768, 8615, 114, 114, 111, 119, 59, 32768, 8659, 512, 99, 116, 1300, 1305, 114, 59, 32896, 55349, 56479, 114, 111, 107, 59, 32768, 272, 4096, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1344, 1348, 1354, 1363, 1386, 1391, 1396, 1405, 1413, 1460, 1475, 1483, 1514, 1527, 1531, 1538, 71, 59, 32768, 330, 72, 33024, 208, 59, 32768, 208, 99, 117, 116, 101, 33024, 201, 59, 32768, 201, 768, 97, 105, 121, 1370, 1376, 1383, 114, 111, 110, 59, 32768, 282, 114, 99, 33024, 202, 59, 32768, 202, 59, 32768, 1069, 111, 116, 59, 32768, 278, 114, 59, 32896, 55349, 56584, 114, 97, 118, 101, 33024, 200, 59, 32768, 200, 101, 109, 101, 110, 116, 59, 32768, 8712, 512, 97, 112, 1418, 1423, 99, 114, 59, 32768, 274, 116, 121, 1060, 1431, 0, 0, 1444, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9643, 512, 103, 112, 1465, 1470, 111, 110, 59, 32768, 280, 102, 59, 32896, 55349, 56636, 115, 105, 108, 111, 110, 59, 32768, 917, 117, 512, 97, 105, 1489, 1504, 108, 512, 59, 84, 1495, 1497, 32768, 10869, 105, 108, 100, 101, 59, 32768, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 8652, 512, 99, 105, 1519, 1523, 114, 59, 32768, 8496, 109, 59, 32768, 10867, 97, 59, 32768, 919, 109, 108, 33024, 203, 59, 32768, 203, 512, 105, 112, 1543, 1549, 115, 116, 115, 59, 32768, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 32768, 8519, 1280, 99, 102, 105, 111, 115, 1572, 1576, 1581, 1620, 1648, 121, 59, 32768, 1060, 114, 59, 32896, 55349, 56585, 108, 108, 101, 100, 1060, 1591, 0, 0, 1604, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9642, 1601, 1628, 0, 1633, 0, 0, 1639, 102, 59, 32896, 55349, 56637, 65, 108, 108, 59, 32768, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 32768, 8497, 99, 114, 59, 32768, 8497, 3072, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1678, 1683, 1688, 1701, 1708, 1729, 1734, 1739, 1742, 1748, 1828, 1834, 99, 121, 59, 32768, 1027, 33024, 62, 59, 32768, 62, 109, 109, 97, 512, 59, 100, 1696, 1698, 32768, 915, 59, 32768, 988, 114, 101, 118, 101, 59, 32768, 286, 768, 101, 105, 121, 1715, 1721, 1726, 100, 105, 108, 59, 32768, 290, 114, 99, 59, 32768, 284, 59, 32768, 1043, 111, 116, 59, 32768, 288, 114, 59, 32896, 55349, 56586, 59, 32768, 8921, 112, 102, 59, 32896, 55349, 56638, 101, 97, 116, 101, 114, 1536, 69, 70, 71, 76, 83, 84, 1766, 1783, 1794, 1803, 1809, 1821, 113, 117, 97, 108, 512, 59, 76, 1775, 1777, 32768, 8805, 101, 115, 115, 59, 32768, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8807, 114, 101, 97, 116, 101, 114, 59, 32768, 10914, 101, 115, 115, 59, 32768, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 10878, 105, 108, 100, 101, 59, 32768, 8819, 99, 114, 59, 32896, 55349, 56482, 59, 32768, 8811, 2048, 65, 97, 99, 102, 105, 111, 115, 117, 1854, 1861, 1874, 1880, 1884, 1897, 1919, 1934, 82, 68, 99, 121, 59, 32768, 1066, 512, 99, 116, 1866, 1871, 101, 107, 59, 32768, 711, 59, 32768, 94, 105, 114, 99, 59, 32768, 292, 114, 59, 32768, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 32768, 8459, 833, 1902, 0, 1906, 102, 59, 32768, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 32768, 9472, 512, 99, 116, 1924, 1928, 114, 59, 32768, 8459, 114, 111, 107, 59, 32768, 294, 109, 112, 533, 1940, 1950, 111, 119, 110, 72, 117, 109, 112, 59, 32768, 8782, 113, 117, 97, 108, 59, 32768, 8783, 3584, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 1985, 1990, 1996, 2001, 2010, 2025, 2030, 2034, 2043, 2077, 2134, 2155, 2160, 2167, 99, 121, 59, 32768, 1045, 108, 105, 103, 59, 32768, 306, 99, 121, 59, 32768, 1025, 99, 117, 116, 101, 33024, 205, 59, 32768, 205, 512, 105, 121, 2015, 2022, 114, 99, 33024, 206, 59, 32768, 206, 59, 32768, 1048, 111, 116, 59, 32768, 304, 114, 59, 32768, 8465, 114, 97, 118, 101, 33024, 204, 59, 32768, 204, 768, 59, 97, 112, 2050, 2052, 2070, 32768, 8465, 512, 99, 103, 2057, 2061, 114, 59, 32768, 298, 105, 110, 97, 114, 121, 73, 59, 32768, 8520, 108, 105, 101, 115, 59, 32768, 8658, 837, 2082, 0, 2110, 512, 59, 101, 2086, 2088, 32768, 8748, 512, 103, 114, 2093, 2099, 114, 97, 108, 59, 32768, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 32768, 8898, 105, 115, 105, 98, 108, 101, 512, 67, 84, 2120, 2127, 111, 109, 109, 97, 59, 32768, 8291, 105, 109, 101, 115, 59, 32768, 8290, 768, 103, 112, 116, 2141, 2146, 2151, 111, 110, 59, 32768, 302, 102, 59, 32896, 55349, 56640, 97, 59, 32768, 921, 99, 114, 59, 32768, 8464, 105, 108, 100, 101, 59, 32768, 296, 828, 2172, 0, 2177, 99, 121, 59, 32768, 1030, 108, 33024, 207, 59, 32768, 207, 1280, 99, 102, 111, 115, 117, 2193, 2206, 2211, 2217, 2232, 512, 105, 121, 2198, 2203, 114, 99, 59, 32768, 308, 59, 32768, 1049, 114, 59, 32896, 55349, 56589, 112, 102, 59, 32896, 55349, 56641, 820, 2222, 0, 2227, 114, 59, 32896, 55349, 56485, 114, 99, 121, 59, 32768, 1032, 107, 99, 121, 59, 32768, 1028, 1792, 72, 74, 97, 99, 102, 111, 115, 2253, 2258, 2263, 2269, 2283, 2288, 2294, 99, 121, 59, 32768, 1061, 99, 121, 59, 32768, 1036, 112, 112, 97, 59, 32768, 922, 512, 101, 121, 2274, 2280, 100, 105, 108, 59, 32768, 310, 59, 32768, 1050, 114, 59, 32896, 55349, 56590, 112, 102, 59, 32896, 55349, 56642, 99, 114, 59, 32896, 55349, 56486, 2816, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2323, 2328, 2333, 2374, 2396, 2775, 2780, 2797, 2804, 2934, 2954, 99, 121, 59, 32768, 1033, 33024, 60, 59, 32768, 60, 1280, 99, 109, 110, 112, 114, 2344, 2350, 2356, 2360, 2370, 117, 116, 101, 59, 32768, 313, 98, 100, 97, 59, 32768, 923, 103, 59, 32768, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 32768, 8466, 114, 59, 32768, 8606, 768, 97, 101, 121, 2381, 2387, 2393, 114, 111, 110, 59, 32768, 317, 100, 105, 108, 59, 32768, 315, 59, 32768, 1051, 512, 102, 115, 2401, 2702, 116, 2560, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2423, 2470, 2479, 2530, 2537, 2561, 2618, 2666, 2683, 2690, 512, 110, 114, 2428, 2441, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10216, 114, 111, 119, 768, 59, 66, 82, 2451, 2453, 2458, 32768, 8592, 97, 114, 59, 32768, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8646, 101, 105, 108, 105, 110, 103, 59, 32768, 8968, 111, 838, 2485, 0, 2498, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10214, 110, 805, 2503, 0, 2514, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10593, 101, 99, 116, 111, 114, 512, 59, 66, 2523, 2525, 32768, 8643, 97, 114, 59, 32768, 10585, 108, 111, 111, 114, 59, 32768, 8970, 105, 103, 104, 116, 512, 65, 86, 2546, 2553, 114, 114, 111, 119, 59, 32768, 8596, 101, 99, 116, 111, 114, 59, 32768, 10574, 512, 101, 114, 2566, 2591, 101, 768, 59, 65, 86, 2574, 2576, 2583, 32768, 8867, 114, 114, 111, 119, 59, 32768, 8612, 101, 99, 116, 111, 114, 59, 32768, 10586, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 2604, 2606, 2611, 32768, 8882, 97, 114, 59, 32768, 10703, 113, 117, 97, 108, 59, 32768, 8884, 112, 768, 68, 84, 86, 2626, 2638, 2649, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 32768, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10592, 101, 99, 116, 111, 114, 512, 59, 66, 2659, 2661, 32768, 8639, 97, 114, 59, 32768, 10584, 101, 99, 116, 111, 114, 512, 59, 66, 2676, 2678, 32768, 8636, 97, 114, 59, 32768, 10578, 114, 114, 111, 119, 59, 32768, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8660, 115, 1536, 69, 70, 71, 76, 83, 84, 2716, 2730, 2741, 2750, 2756, 2768, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 32768, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8806, 114, 101, 97, 116, 101, 114, 59, 32768, 8822, 101, 115, 115, 59, 32768, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 10877, 105, 108, 100, 101, 59, 32768, 8818, 114, 59, 32896, 55349, 56591, 512, 59, 101, 2785, 2787, 32768, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8666, 105, 100, 111, 116, 59, 32768, 319, 768, 110, 112, 119, 2811, 2899, 2904, 103, 1024, 76, 82, 108, 114, 2821, 2848, 2860, 2887, 101, 102, 116, 512, 65, 82, 2829, 2836, 114, 114, 111, 119, 59, 32768, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10230, 101, 102, 116, 512, 97, 114, 2868, 2875, 114, 114, 111, 119, 59, 32768, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10233, 102, 59, 32896, 55349, 56643, 101, 114, 512, 76, 82, 2911, 2922, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8600, 768, 99, 104, 116, 2941, 2945, 2948, 114, 59, 32768, 8466, 59, 32768, 8624, 114, 111, 107, 59, 32768, 321, 59, 32768, 8810, 2048, 97, 99, 101, 102, 105, 111, 115, 117, 2974, 2978, 2982, 3007, 3012, 3022, 3028, 3033, 112, 59, 32768, 10501, 121, 59, 32768, 1052, 512, 100, 108, 2987, 2998, 105, 117, 109, 83, 112, 97, 99, 101, 59, 32768, 8287, 108, 105, 110, 116, 114, 102, 59, 32768, 8499, 114, 59, 32896, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 32768, 8723, 112, 102, 59, 32896, 55349, 56644, 99, 114, 59, 32768, 8499, 59, 32768, 924, 2304, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3055, 3060, 3067, 3089, 3201, 3206, 3874, 3880, 3889, 99, 121, 59, 32768, 1034, 99, 117, 116, 101, 59, 32768, 323, 768, 97, 101, 121, 3074, 3080, 3086, 114, 111, 110, 59, 32768, 327, 100, 105, 108, 59, 32768, 325, 59, 32768, 1053, 768, 103, 115, 119, 3096, 3160, 3194, 97, 116, 105, 118, 101, 768, 77, 84, 86, 3108, 3121, 3145, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 32768, 8203, 104, 105, 512, 99, 110, 3128, 3137, 107, 83, 112, 97, 99, 101, 59, 32768, 8203, 83, 112, 97, 99, 101, 59, 32768, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 32768, 8203, 116, 101, 100, 512, 71, 76, 3168, 3184, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 32768, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 32768, 8810, 76, 105, 110, 101, 59, 32768, 10, 114, 59, 32896, 55349, 56593, 1024, 66, 110, 112, 116, 3215, 3222, 3238, 3242, 114, 101, 97, 107, 59, 32768, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 32768, 160, 102, 59, 32768, 8469, 3328, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3269, 3271, 3293, 3312, 3352, 3430, 3455, 3551, 3589, 3625, 3678, 3821, 3861, 32768, 10988, 512, 111, 117, 3276, 3286, 110, 103, 114, 117, 101, 110, 116, 59, 32768, 8802, 112, 67, 97, 112, 59, 32768, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8742, 768, 108, 113, 120, 3319, 3327, 3345, 101, 109, 101, 110, 116, 59, 32768, 8713, 117, 97, 108, 512, 59, 84, 3335, 3337, 32768, 8800, 105, 108, 100, 101, 59, 32896, 8770, 824, 105, 115, 116, 115, 59, 32768, 8708, 114, 101, 97, 116, 101, 114, 1792, 59, 69, 70, 71, 76, 83, 84, 3373, 3375, 3382, 3394, 3404, 3410, 3423, 32768, 8815, 113, 117, 97, 108, 59, 32768, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32896, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 32896, 8811, 824, 101, 115, 115, 59, 32768, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32896, 10878, 824, 105, 108, 100, 101, 59, 32768, 8821, 117, 109, 112, 533, 3437, 3448, 111, 119, 110, 72, 117, 109, 112, 59, 32896, 8782, 824, 113, 117, 97, 108, 59, 32896, 8783, 824, 101, 512, 102, 115, 3461, 3492, 116, 84, 114, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 3477, 3479, 3485, 32768, 8938, 97, 114, 59, 32896, 10703, 824, 113, 117, 97, 108, 59, 32768, 8940, 115, 1536, 59, 69, 71, 76, 83, 84, 3506, 3508, 3515, 3524, 3531, 3544, 32768, 8814, 113, 117, 97, 108, 59, 32768, 8816, 114, 101, 97, 116, 101, 114, 59, 32768, 8824, 101, 115, 115, 59, 32896, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32896, 10877, 824, 105, 108, 100, 101, 59, 32768, 8820, 101, 115, 116, 101, 100, 512, 71, 76, 3561, 3578, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 32896, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 32896, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 768, 59, 69, 83, 3603, 3605, 3613, 32768, 8832, 113, 117, 97, 108, 59, 32896, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8928, 512, 101, 105, 3630, 3645, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 32768, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 3663, 3665, 3671, 32768, 8939, 97, 114, 59, 32896, 10704, 824, 113, 117, 97, 108, 59, 32768, 8941, 512, 113, 117, 3683, 3732, 117, 97, 114, 101, 83, 117, 512, 98, 112, 3694, 3712, 115, 101, 116, 512, 59, 69, 3702, 3705, 32896, 8847, 824, 113, 117, 97, 108, 59, 32768, 8930, 101, 114, 115, 101, 116, 512, 59, 69, 3722, 3725, 32896, 8848, 824, 113, 117, 97, 108, 59, 32768, 8931, 768, 98, 99, 112, 3739, 3757, 3801, 115, 101, 116, 512, 59, 69, 3747, 3750, 32896, 8834, 8402, 113, 117, 97, 108, 59, 32768, 8840, 99, 101, 101, 100, 115, 1024, 59, 69, 83, 84, 3771, 3773, 3781, 3793, 32768, 8833, 113, 117, 97, 108, 59, 32896, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8929, 105, 108, 100, 101, 59, 32896, 8831, 824, 101, 114, 115, 101, 116, 512, 59, 69, 3811, 3814, 32896, 8835, 8402, 113, 117, 97, 108, 59, 32768, 8841, 105, 108, 100, 101, 1024, 59, 69, 70, 84, 3834, 3836, 3843, 3854, 32768, 8769, 113, 117, 97, 108, 59, 32768, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8775, 105, 108, 100, 101, 59, 32768, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8740, 99, 114, 59, 32896, 55349, 56489, 105, 108, 100, 101, 33024, 209, 59, 32768, 209, 59, 32768, 925, 3584, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 3921, 3927, 3936, 3951, 3958, 3963, 3972, 3996, 4002, 4034, 4037, 4055, 4071, 4078, 108, 105, 103, 59, 32768, 338, 99, 117, 116, 101, 33024, 211, 59, 32768, 211, 512, 105, 121, 3941, 3948, 114, 99, 33024, 212, 59, 32768, 212, 59, 32768, 1054, 98, 108, 97, 99, 59, 32768, 336, 114, 59, 32896, 55349, 56594, 114, 97, 118, 101, 33024, 210, 59, 32768, 210, 768, 97, 101, 105, 3979, 3984, 3989, 99, 114, 59, 32768, 332, 103, 97, 59, 32768, 937, 99, 114, 111, 110, 59, 32768, 927, 112, 102, 59, 32896, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 512, 68, 81, 4014, 4027, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 32768, 8220, 117, 111, 116, 101, 59, 32768, 8216, 59, 32768, 10836, 512, 99, 108, 4042, 4047, 114, 59, 32896, 55349, 56490, 97, 115, 104, 33024, 216, 59, 32768, 216, 105, 573, 4060, 4067, 100, 101, 33024, 213, 59, 32768, 213, 101, 115, 59, 32768, 10807, 109, 108, 33024, 214, 59, 32768, 214, 101, 114, 512, 66, 80, 4085, 4109, 512, 97, 114, 4090, 4094, 114, 59, 32768, 8254, 97, 99, 512, 101, 107, 4101, 4104, 59, 32768, 9182, 101, 116, 59, 32768, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 32768, 9180, 2304, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4141, 4150, 4154, 4159, 4163, 4166, 4176, 4198, 4284, 114, 116, 105, 97, 108, 68, 59, 32768, 8706, 121, 59, 32768, 1055, 114, 59, 32896, 55349, 56595, 105, 59, 32768, 934, 59, 32768, 928, 117, 115, 77, 105, 110, 117, 115, 59, 32768, 177, 512, 105, 112, 4181, 4194, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 32768, 8460, 102, 59, 32768, 8473, 1024, 59, 101, 105, 111, 4207, 4209, 4251, 4256, 32768, 10939, 99, 101, 100, 101, 115, 1024, 59, 69, 83, 84, 4223, 4225, 4232, 4244, 32768, 8826, 113, 117, 97, 108, 59, 32768, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8828, 105, 108, 100, 101, 59, 32768, 8830, 109, 101, 59, 32768, 8243, 512, 100, 112, 4261, 4267, 117, 99, 116, 59, 32768, 8719, 111, 114, 116, 105, 111, 110, 512, 59, 97, 4278, 4280, 32768, 8759, 108, 59, 32768, 8733, 512, 99, 105, 4289, 4294, 114, 59, 32896, 55349, 56491, 59, 32768, 936, 1024, 85, 102, 111, 115, 4306, 4313, 4318, 4323, 79, 84, 33024, 34, 59, 32768, 34, 114, 59, 32896, 55349, 56596, 112, 102, 59, 32768, 8474, 99, 114, 59, 32896, 55349, 56492, 3072, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4354, 4360, 4366, 4395, 4417, 4473, 4477, 4481, 4743, 4764, 4776, 4788, 97, 114, 114, 59, 32768, 10512, 71, 33024, 174, 59, 32768, 174, 768, 99, 110, 114, 4373, 4379, 4383, 117, 116, 101, 59, 32768, 340, 103, 59, 32768, 10219, 114, 512, 59, 116, 4389, 4391, 32768, 8608, 108, 59, 32768, 10518, 768, 97, 101, 121, 4402, 4408, 4414, 114, 111, 110, 59, 32768, 344, 100, 105, 108, 59, 32768, 342, 59, 32768, 1056, 512, 59, 118, 4422, 4424, 32768, 8476, 101, 114, 115, 101, 512, 69, 85, 4433, 4458, 512, 108, 113, 4438, 4446, 101, 109, 101, 110, 116, 59, 32768, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 10607, 114, 59, 32768, 8476, 111, 59, 32768, 929, 103, 104, 116, 2048, 65, 67, 68, 70, 84, 85, 86, 97, 4501, 4547, 4556, 4607, 4614, 4671, 4719, 4736, 512, 110, 114, 4506, 4519, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10217, 114, 111, 119, 768, 59, 66, 76, 4529, 4531, 4536, 32768, 8594, 97, 114, 59, 32768, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8644, 101, 105, 108, 105, 110, 103, 59, 32768, 8969, 111, 838, 4562, 0, 4575, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10215, 110, 805, 4580, 0, 4591, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10589, 101, 99, 116, 111, 114, 512, 59, 66, 4600, 4602, 32768, 8642, 97, 114, 59, 32768, 10581, 108, 111, 111, 114, 59, 32768, 8971, 512, 101, 114, 4619, 4644, 101, 768, 59, 65, 86, 4627, 4629, 4636, 32768, 8866, 114, 114, 111, 119, 59, 32768, 8614, 101, 99, 116, 111, 114, 59, 32768, 10587, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 4657, 4659, 4664, 32768, 8883, 97, 114, 59, 32768, 10704, 113, 117, 97, 108, 59, 32768, 8885, 112, 768, 68, 84, 86, 4679, 4691, 4702, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 32768, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10588, 101, 99, 116, 111, 114, 512, 59, 66, 4712, 4714, 32768, 8638, 97, 114, 59, 32768, 10580, 101, 99, 116, 111, 114, 512, 59, 66, 4729, 4731, 32768, 8640, 97, 114, 59, 32768, 10579, 114, 114, 111, 119, 59, 32768, 8658, 512, 112, 117, 4748, 4752, 102, 59, 32768, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 32768, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8667, 512, 99, 104, 4781, 4785, 114, 59, 32768, 8475, 59, 32768, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 32768, 10740, 3328, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 4827, 4842, 4849, 4856, 4889, 4894, 4949, 4955, 4967, 4973, 5059, 5065, 5070, 512, 67, 99, 4832, 4838, 72, 99, 121, 59, 32768, 1065, 121, 59, 32768, 1064, 70, 84, 99, 121, 59, 32768, 1068, 99, 117, 116, 101, 59, 32768, 346, 1280, 59, 97, 101, 105, 121, 4867, 4869, 4875, 4881, 4886, 32768, 10940, 114, 111, 110, 59, 32768, 352, 100, 105, 108, 59, 32768, 350, 114, 99, 59, 32768, 348, 59, 32768, 1057, 114, 59, 32896, 55349, 56598, 111, 114, 116, 1024, 68, 76, 82, 85, 4906, 4917, 4928, 4940, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8594, 112, 65, 114, 114, 111, 119, 59, 32768, 8593, 103, 109, 97, 59, 32768, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 32768, 8728, 112, 102, 59, 32896, 55349, 56650, 1091, 4979, 0, 0, 4983, 116, 59, 32768, 8730, 97, 114, 101, 1024, 59, 73, 83, 85, 4994, 4996, 5010, 5052, 32768, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 32768, 8851, 117, 512, 98, 112, 5016, 5033, 115, 101, 116, 512, 59, 69, 5024, 5026, 32768, 8847, 113, 117, 97, 108, 59, 32768, 8849, 101, 114, 115, 101, 116, 512, 59, 69, 5043, 5045, 32768, 8848, 113, 117, 97, 108, 59, 32768, 8850, 110, 105, 111, 110, 59, 32768, 8852, 99, 114, 59, 32896, 55349, 56494, 97, 114, 59, 32768, 8902, 1024, 98, 99, 109, 112, 5079, 5102, 5155, 5158, 512, 59, 115, 5084, 5086, 32768, 8912, 101, 116, 512, 59, 69, 5093, 5095, 32768, 8912, 113, 117, 97, 108, 59, 32768, 8838, 512, 99, 104, 5107, 5148, 101, 101, 100, 115, 1024, 59, 69, 83, 84, 5120, 5122, 5129, 5141, 32768, 8827, 113, 117, 97, 108, 59, 32768, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8829, 105, 108, 100, 101, 59, 32768, 8831, 84, 104, 97, 116, 59, 32768, 8715, 59, 32768, 8721, 768, 59, 101, 115, 5165, 5167, 5185, 32768, 8913, 114, 115, 101, 116, 512, 59, 69, 5176, 5178, 32768, 8835, 113, 117, 97, 108, 59, 32768, 8839, 101, 116, 59, 32768, 8913, 2816, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5213, 5221, 5227, 5241, 5252, 5274, 5279, 5323, 5362, 5368, 5378, 79, 82, 78, 33024, 222, 59, 32768, 222, 65, 68, 69, 59, 32768, 8482, 512, 72, 99, 5232, 5237, 99, 121, 59, 32768, 1035, 121, 59, 32768, 1062, 512, 98, 117, 5246, 5249, 59, 32768, 9, 59, 32768, 932, 768, 97, 101, 121, 5259, 5265, 5271, 114, 111, 110, 59, 32768, 356, 100, 105, 108, 59, 32768, 354, 59, 32768, 1058, 114, 59, 32896, 55349, 56599, 512, 101, 105, 5284, 5300, 835, 5289, 0, 5297, 101, 102, 111, 114, 101, 59, 32768, 8756, 97, 59, 32768, 920, 512, 99, 110, 5305, 5315, 107, 83, 112, 97, 99, 101, 59, 32896, 8287, 8202, 83, 112, 97, 99, 101, 59, 32768, 8201, 108, 100, 101, 1024, 59, 69, 70, 84, 5335, 5337, 5344, 5355, 32768, 8764, 113, 117, 97, 108, 59, 32768, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8773, 105, 108, 100, 101, 59, 32768, 8776, 112, 102, 59, 32896, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 32768, 8411, 512, 99, 116, 5383, 5388, 114, 59, 32896, 55349, 56495, 114, 111, 107, 59, 32768, 358, 5426, 5417, 5444, 5458, 5473, 0, 5480, 5485, 0, 0, 0, 0, 0, 5494, 5500, 5564, 5579, 0, 5726, 5732, 5738, 5745, 512, 99, 114, 5421, 5429, 117, 116, 101, 33024, 218, 59, 32768, 218, 114, 512, 59, 111, 5435, 5437, 32768, 8607, 99, 105, 114, 59, 32768, 10569, 114, 820, 5449, 0, 5453, 121, 59, 32768, 1038, 118, 101, 59, 32768, 364, 512, 105, 121, 5462, 5469, 114, 99, 33024, 219, 59, 32768, 219, 59, 32768, 1059, 98, 108, 97, 99, 59, 32768, 368, 114, 59, 32896, 55349, 56600, 114, 97, 118, 101, 33024, 217, 59, 32768, 217, 97, 99, 114, 59, 32768, 362, 512, 100, 105, 5504, 5548, 101, 114, 512, 66, 80, 5511, 5535, 512, 97, 114, 5516, 5520, 114, 59, 32768, 95, 97, 99, 512, 101, 107, 5527, 5530, 59, 32768, 9183, 101, 116, 59, 32768, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 32768, 9181, 111, 110, 512, 59, 80, 5555, 5557, 32768, 8899, 108, 117, 115, 59, 32768, 8846, 512, 103, 112, 5568, 5573, 111, 110, 59, 32768, 370, 102, 59, 32896, 55349, 56652, 2048, 65, 68, 69, 84, 97, 100, 112, 115, 5595, 5624, 5635, 5648, 5664, 5671, 5682, 5712, 114, 114, 111, 119, 768, 59, 66, 68, 5606, 5608, 5613, 32768, 8593, 97, 114, 59, 32768, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 10606, 101, 101, 512, 59, 65, 5655, 5657, 32768, 8869, 114, 114, 111, 119, 59, 32768, 8613, 114, 114, 111, 119, 59, 32768, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 32768, 8661, 101, 114, 512, 76, 82, 5689, 5700, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8599, 105, 512, 59, 108, 5718, 5720, 32768, 978, 111, 110, 59, 32768, 933, 105, 110, 103, 59, 32768, 366, 99, 114, 59, 32896, 55349, 56496, 105, 108, 100, 101, 59, 32768, 360, 109, 108, 33024, 220, 59, 32768, 220, 2304, 68, 98, 99, 100, 101, 102, 111, 115, 118, 5770, 5776, 5781, 5785, 5798, 5878, 5883, 5889, 5895, 97, 115, 104, 59, 32768, 8875, 97, 114, 59, 32768, 10987, 121, 59, 32768, 1042, 97, 115, 104, 512, 59, 108, 5793, 5795, 32768, 8873, 59, 32768, 10982, 512, 101, 114, 5803, 5806, 59, 32768, 8897, 768, 98, 116, 121, 5813, 5818, 5866, 97, 114, 59, 32768, 8214, 512, 59, 105, 5823, 5825, 32768, 8214, 99, 97, 108, 1024, 66, 76, 83, 84, 5837, 5842, 5848, 5859, 97, 114, 59, 32768, 8739, 105, 110, 101, 59, 32768, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 32768, 10072, 105, 108, 100, 101, 59, 32768, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 32768, 8202, 114, 59, 32896, 55349, 56601, 112, 102, 59, 32896, 55349, 56653, 99, 114, 59, 32896, 55349, 56497, 100, 97, 115, 104, 59, 32768, 8874, 1280, 99, 101, 102, 111, 115, 5913, 5919, 5925, 5930, 5936, 105, 114, 99, 59, 32768, 372, 100, 103, 101, 59, 32768, 8896, 114, 59, 32896, 55349, 56602, 112, 102, 59, 32896, 55349, 56654, 99, 114, 59, 32896, 55349, 56498, 1024, 102, 105, 111, 115, 5951, 5956, 5959, 5965, 114, 59, 32896, 55349, 56603, 59, 32768, 926, 112, 102, 59, 32896, 55349, 56655, 99, 114, 59, 32896, 55349, 56499, 2304, 65, 73, 85, 97, 99, 102, 111, 115, 117, 5990, 5995, 6e3, 6005, 6014, 6027, 6032, 6038, 6044, 99, 121, 59, 32768, 1071, 99, 121, 59, 32768, 1031, 99, 121, 59, 32768, 1070, 99, 117, 116, 101, 33024, 221, 59, 32768, 221, 512, 105, 121, 6019, 6024, 114, 99, 59, 32768, 374, 59, 32768, 1067, 114, 59, 32896, 55349, 56604, 112, 102, 59, 32896, 55349, 56656, 99, 114, 59, 32896, 55349, 56500, 109, 108, 59, 32768, 376, 2048, 72, 97, 99, 100, 101, 102, 111, 115, 6066, 6071, 6078, 6092, 6097, 6119, 6123, 6128, 99, 121, 59, 32768, 1046, 99, 117, 116, 101, 59, 32768, 377, 512, 97, 121, 6083, 6089, 114, 111, 110, 59, 32768, 381, 59, 32768, 1047, 111, 116, 59, 32768, 379, 835, 6102, 0, 6116, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 32768, 8203, 97, 59, 32768, 918, 114, 59, 32768, 8488, 112, 102, 59, 32768, 8484, 99, 114, 59, 32896, 55349, 56501, 5938, 6159, 6168, 6175, 0, 6214, 6222, 6233, 0, 0, 0, 0, 6242, 6267, 6290, 6429, 6444, 0, 6495, 6503, 6531, 6540, 0, 6547, 99, 117, 116, 101, 33024, 225, 59, 32768, 225, 114, 101, 118, 101, 59, 32768, 259, 1536, 59, 69, 100, 105, 117, 121, 6187, 6189, 6193, 6196, 6203, 6210, 32768, 8766, 59, 32896, 8766, 819, 59, 32768, 8767, 114, 99, 33024, 226, 59, 32768, 226, 116, 101, 33024, 180, 59, 32768, 180, 59, 32768, 1072, 108, 105, 103, 33024, 230, 59, 32768, 230, 512, 59, 114, 6226, 6228, 32768, 8289, 59, 32896, 55349, 56606, 114, 97, 118, 101, 33024, 224, 59, 32768, 224, 512, 101, 112, 6246, 6261, 512, 102, 112, 6251, 6257, 115, 121, 109, 59, 32768, 8501, 104, 59, 32768, 8501, 104, 97, 59, 32768, 945, 512, 97, 112, 6271, 6284, 512, 99, 108, 6276, 6280, 114, 59, 32768, 257, 103, 59, 32768, 10815, 33024, 38, 59, 32768, 38, 1077, 6295, 0, 0, 6326, 1280, 59, 97, 100, 115, 118, 6305, 6307, 6312, 6315, 6322, 32768, 8743, 110, 100, 59, 32768, 10837, 59, 32768, 10844, 108, 111, 112, 101, 59, 32768, 10840, 59, 32768, 10842, 1792, 59, 101, 108, 109, 114, 115, 122, 6340, 6342, 6345, 6349, 6391, 6410, 6422, 32768, 8736, 59, 32768, 10660, 101, 59, 32768, 8736, 115, 100, 512, 59, 97, 6356, 6358, 32768, 8737, 2098, 6368, 6371, 6374, 6377, 6380, 6383, 6386, 6389, 59, 32768, 10664, 59, 32768, 10665, 59, 32768, 10666, 59, 32768, 10667, 59, 32768, 10668, 59, 32768, 10669, 59, 32768, 10670, 59, 32768, 10671, 116, 512, 59, 118, 6397, 6399, 32768, 8735, 98, 512, 59, 100, 6405, 6407, 32768, 8894, 59, 32768, 10653, 512, 112, 116, 6415, 6419, 104, 59, 32768, 8738, 59, 32768, 197, 97, 114, 114, 59, 32768, 9084, 512, 103, 112, 6433, 6438, 111, 110, 59, 32768, 261, 102, 59, 32896, 55349, 56658, 1792, 59, 69, 97, 101, 105, 111, 112, 6458, 6460, 6463, 6469, 6472, 6476, 6480, 32768, 8776, 59, 32768, 10864, 99, 105, 114, 59, 32768, 10863, 59, 32768, 8778, 100, 59, 32768, 8779, 115, 59, 32768, 39, 114, 111, 120, 512, 59, 101, 6488, 6490, 32768, 8776, 113, 59, 32768, 8778, 105, 110, 103, 33024, 229, 59, 32768, 229, 768, 99, 116, 121, 6509, 6514, 6517, 114, 59, 32896, 55349, 56502, 59, 32768, 42, 109, 112, 512, 59, 101, 6524, 6526, 32768, 8776, 113, 59, 32768, 8781, 105, 108, 100, 101, 33024, 227, 59, 32768, 227, 109, 108, 33024, 228, 59, 32768, 228, 512, 99, 105, 6551, 6559, 111, 110, 105, 110, 116, 59, 32768, 8755, 110, 116, 59, 32768, 10769, 4096, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 6597, 6602, 6673, 6688, 6701, 6707, 6768, 6773, 6891, 6898, 6999, 7023, 7309, 7316, 7334, 7383, 111, 116, 59, 32768, 10989, 512, 99, 114, 6607, 6652, 107, 1024, 99, 101, 112, 115, 6617, 6623, 6632, 6639, 111, 110, 103, 59, 32768, 8780, 112, 115, 105, 108, 111, 110, 59, 32768, 1014, 114, 105, 109, 101, 59, 32768, 8245, 105, 109, 512, 59, 101, 6646, 6648, 32768, 8765, 113, 59, 32768, 8909, 583, 6656, 6661, 101, 101, 59, 32768, 8893, 101, 100, 512, 59, 103, 6667, 6669, 32768, 8965, 101, 59, 32768, 8965, 114, 107, 512, 59, 116, 6680, 6682, 32768, 9141, 98, 114, 107, 59, 32768, 9142, 512, 111, 121, 6693, 6698, 110, 103, 59, 32768, 8780, 59, 32768, 1073, 113, 117, 111, 59, 32768, 8222, 1280, 99, 109, 112, 114, 116, 6718, 6731, 6738, 6743, 6749, 97, 117, 115, 512, 59, 101, 6726, 6728, 32768, 8757, 59, 32768, 8757, 112, 116, 121, 118, 59, 32768, 10672, 115, 105, 59, 32768, 1014, 110, 111, 117, 59, 32768, 8492, 768, 97, 104, 119, 6756, 6759, 6762, 59, 32768, 946, 59, 32768, 8502, 101, 101, 110, 59, 32768, 8812, 114, 59, 32896, 55349, 56607, 103, 1792, 99, 111, 115, 116, 117, 118, 119, 6789, 6809, 6834, 6850, 6872, 6879, 6884, 768, 97, 105, 117, 6796, 6800, 6805, 112, 59, 32768, 8898, 114, 99, 59, 32768, 9711, 112, 59, 32768, 8899, 768, 100, 112, 116, 6816, 6821, 6827, 111, 116, 59, 32768, 10752, 108, 117, 115, 59, 32768, 10753, 105, 109, 101, 115, 59, 32768, 10754, 1090, 6840, 0, 0, 6846, 99, 117, 112, 59, 32768, 10758, 97, 114, 59, 32768, 9733, 114, 105, 97, 110, 103, 108, 101, 512, 100, 117, 6862, 6868, 111, 119, 110, 59, 32768, 9661, 112, 59, 32768, 9651, 112, 108, 117, 115, 59, 32768, 10756, 101, 101, 59, 32768, 8897, 101, 100, 103, 101, 59, 32768, 8896, 97, 114, 111, 119, 59, 32768, 10509, 768, 97, 107, 111, 6905, 6976, 6994, 512, 99, 110, 6910, 6972, 107, 768, 108, 115, 116, 6918, 6927, 6935, 111, 122, 101, 110, 103, 101, 59, 32768, 10731, 113, 117, 97, 114, 101, 59, 32768, 9642, 114, 105, 97, 110, 103, 108, 101, 1024, 59, 100, 108, 114, 6951, 6953, 6959, 6965, 32768, 9652, 111, 119, 110, 59, 32768, 9662, 101, 102, 116, 59, 32768, 9666, 105, 103, 104, 116, 59, 32768, 9656, 107, 59, 32768, 9251, 770, 6981, 0, 6991, 771, 6985, 0, 6988, 59, 32768, 9618, 59, 32768, 9617, 52, 59, 32768, 9619, 99, 107, 59, 32768, 9608, 512, 101, 111, 7004, 7019, 512, 59, 113, 7009, 7012, 32896, 61, 8421, 117, 105, 118, 59, 32896, 8801, 8421, 116, 59, 32768, 8976, 1024, 112, 116, 119, 120, 7032, 7037, 7049, 7055, 102, 59, 32896, 55349, 56659, 512, 59, 116, 7042, 7044, 32768, 8869, 111, 109, 59, 32768, 8869, 116, 105, 101, 59, 32768, 8904, 3072, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7080, 7101, 7126, 7147, 7182, 7187, 7208, 7233, 7240, 7246, 7253, 7274, 1024, 76, 82, 108, 114, 7089, 7092, 7095, 7098, 59, 32768, 9559, 59, 32768, 9556, 59, 32768, 9558, 59, 32768, 9555, 1280, 59, 68, 85, 100, 117, 7112, 7114, 7117, 7120, 7123, 32768, 9552, 59, 32768, 9574, 59, 32768, 9577, 59, 32768, 9572, 59, 32768, 9575, 1024, 76, 82, 108, 114, 7135, 7138, 7141, 7144, 59, 32768, 9565, 59, 32768, 9562, 59, 32768, 9564, 59, 32768, 9561, 1792, 59, 72, 76, 82, 104, 108, 114, 7162, 7164, 7167, 7170, 7173, 7176, 7179, 32768, 9553, 59, 32768, 9580, 59, 32768, 9571, 59, 32768, 9568, 59, 32768, 9579, 59, 32768, 9570, 59, 32768, 9567, 111, 120, 59, 32768, 10697, 1024, 76, 82, 108, 114, 7196, 7199, 7202, 7205, 59, 32768, 9557, 59, 32768, 9554, 59, 32768, 9488, 59, 32768, 9484, 1280, 59, 68, 85, 100, 117, 7219, 7221, 7224, 7227, 7230, 32768, 9472, 59, 32768, 9573, 59, 32768, 9576, 59, 32768, 9516, 59, 32768, 9524, 105, 110, 117, 115, 59, 32768, 8863, 108, 117, 115, 59, 32768, 8862, 105, 109, 101, 115, 59, 32768, 8864, 1024, 76, 82, 108, 114, 7262, 7265, 7268, 7271, 59, 32768, 9563, 59, 32768, 9560, 59, 32768, 9496, 59, 32768, 9492, 1792, 59, 72, 76, 82, 104, 108, 114, 7289, 7291, 7294, 7297, 7300, 7303, 7306, 32768, 9474, 59, 32768, 9578, 59, 32768, 9569, 59, 32768, 9566, 59, 32768, 9532, 59, 32768, 9508, 59, 32768, 9500, 114, 105, 109, 101, 59, 32768, 8245, 512, 101, 118, 7321, 7326, 118, 101, 59, 32768, 728, 98, 97, 114, 33024, 166, 59, 32768, 166, 1024, 99, 101, 105, 111, 7343, 7348, 7353, 7364, 114, 59, 32896, 55349, 56503, 109, 105, 59, 32768, 8271, 109, 512, 59, 101, 7359, 7361, 32768, 8765, 59, 32768, 8909, 108, 768, 59, 98, 104, 7372, 7374, 7377, 32768, 92, 59, 32768, 10693, 115, 117, 98, 59, 32768, 10184, 573, 7387, 7399, 108, 512, 59, 101, 7392, 7394, 32768, 8226, 116, 59, 32768, 8226, 112, 768, 59, 69, 101, 7406, 7408, 7411, 32768, 8782, 59, 32768, 10926, 512, 59, 113, 7416, 7418, 32768, 8783, 59, 32768, 8783, 6450, 7448, 0, 7523, 7571, 7576, 7613, 0, 7618, 7647, 0, 0, 7764, 0, 0, 7779, 0, 0, 7899, 7914, 7949, 7955, 0, 8158, 0, 8176, 768, 99, 112, 114, 7454, 7460, 7509, 117, 116, 101, 59, 32768, 263, 1536, 59, 97, 98, 99, 100, 115, 7473, 7475, 7480, 7487, 7500, 7505, 32768, 8745, 110, 100, 59, 32768, 10820, 114, 99, 117, 112, 59, 32768, 10825, 512, 97, 117, 7492, 7496, 112, 59, 32768, 10827, 112, 59, 32768, 10823, 111, 116, 59, 32768, 10816, 59, 32896, 8745, 65024, 512, 101, 111, 7514, 7518, 116, 59, 32768, 8257, 110, 59, 32768, 711, 1024, 97, 101, 105, 117, 7531, 7544, 7552, 7557, 833, 7536, 0, 7540, 115, 59, 32768, 10829, 111, 110, 59, 32768, 269, 100, 105, 108, 33024, 231, 59, 32768, 231, 114, 99, 59, 32768, 265, 112, 115, 512, 59, 115, 7564, 7566, 32768, 10828, 109, 59, 32768, 10832, 111, 116, 59, 32768, 267, 768, 100, 109, 110, 7582, 7589, 7596, 105, 108, 33024, 184, 59, 32768, 184, 112, 116, 121, 118, 59, 32768, 10674, 116, 33280, 162, 59, 101, 7603, 7605, 32768, 162, 114, 100, 111, 116, 59, 32768, 183, 114, 59, 32896, 55349, 56608, 768, 99, 101, 105, 7624, 7628, 7643, 121, 59, 32768, 1095, 99, 107, 512, 59, 109, 7635, 7637, 32768, 10003, 97, 114, 107, 59, 32768, 10003, 59, 32768, 967, 114, 1792, 59, 69, 99, 101, 102, 109, 115, 7662, 7664, 7667, 7742, 7745, 7752, 7757, 32768, 9675, 59, 32768, 10691, 768, 59, 101, 108, 7674, 7676, 7680, 32768, 710, 113, 59, 32768, 8791, 101, 1074, 7687, 0, 0, 7709, 114, 114, 111, 119, 512, 108, 114, 7695, 7701, 101, 102, 116, 59, 32768, 8634, 105, 103, 104, 116, 59, 32768, 8635, 1280, 82, 83, 97, 99, 100, 7719, 7722, 7725, 7730, 7736, 59, 32768, 174, 59, 32768, 9416, 115, 116, 59, 32768, 8859, 105, 114, 99, 59, 32768, 8858, 97, 115, 104, 59, 32768, 8861, 59, 32768, 8791, 110, 105, 110, 116, 59, 32768, 10768, 105, 100, 59, 32768, 10991, 99, 105, 114, 59, 32768, 10690, 117, 98, 115, 512, 59, 117, 7771, 7773, 32768, 9827, 105, 116, 59, 32768, 9827, 1341, 7785, 7804, 7850, 0, 7871, 111, 110, 512, 59, 101, 7791, 7793, 32768, 58, 512, 59, 113, 7798, 7800, 32768, 8788, 59, 32768, 8788, 1086, 7809, 0, 0, 7820, 97, 512, 59, 116, 7814, 7816, 32768, 44, 59, 32768, 64, 768, 59, 102, 108, 7826, 7828, 7832, 32768, 8705, 110, 59, 32768, 8728, 101, 512, 109, 120, 7838, 7844, 101, 110, 116, 59, 32768, 8705, 101, 115, 59, 32768, 8450, 824, 7854, 0, 7866, 512, 59, 100, 7858, 7860, 32768, 8773, 111, 116, 59, 32768, 10861, 110, 116, 59, 32768, 8750, 768, 102, 114, 121, 7877, 7881, 7886, 59, 32896, 55349, 56660, 111, 100, 59, 32768, 8720, 33280, 169, 59, 115, 7892, 7894, 32768, 169, 114, 59, 32768, 8471, 512, 97, 111, 7903, 7908, 114, 114, 59, 32768, 8629, 115, 115, 59, 32768, 10007, 512, 99, 117, 7918, 7923, 114, 59, 32896, 55349, 56504, 512, 98, 112, 7928, 7938, 512, 59, 101, 7933, 7935, 32768, 10959, 59, 32768, 10961, 512, 59, 101, 7943, 7945, 32768, 10960, 59, 32768, 10962, 100, 111, 116, 59, 32768, 8943, 1792, 100, 101, 108, 112, 114, 118, 119, 7969, 7983, 7996, 8009, 8057, 8147, 8152, 97, 114, 114, 512, 108, 114, 7977, 7980, 59, 32768, 10552, 59, 32768, 10549, 1089, 7989, 0, 0, 7993, 114, 59, 32768, 8926, 99, 59, 32768, 8927, 97, 114, 114, 512, 59, 112, 8004, 8006, 32768, 8630, 59, 32768, 10557, 1536, 59, 98, 99, 100, 111, 115, 8022, 8024, 8031, 8044, 8049, 8053, 32768, 8746, 114, 99, 97, 112, 59, 32768, 10824, 512, 97, 117, 8036, 8040, 112, 59, 32768, 10822, 112, 59, 32768, 10826, 111, 116, 59, 32768, 8845, 114, 59, 32768, 10821, 59, 32896, 8746, 65024, 1024, 97, 108, 114, 118, 8066, 8078, 8116, 8123, 114, 114, 512, 59, 109, 8073, 8075, 32768, 8631, 59, 32768, 10556, 121, 768, 101, 118, 119, 8086, 8104, 8109, 113, 1089, 8093, 0, 0, 8099, 114, 101, 99, 59, 32768, 8926, 117, 99, 99, 59, 32768, 8927, 101, 101, 59, 32768, 8910, 101, 100, 103, 101, 59, 32768, 8911, 101, 110, 33024, 164, 59, 32768, 164, 101, 97, 114, 114, 111, 119, 512, 108, 114, 8134, 8140, 101, 102, 116, 59, 32768, 8630, 105, 103, 104, 116, 59, 32768, 8631, 101, 101, 59, 32768, 8910, 101, 100, 59, 32768, 8911, 512, 99, 105, 8162, 8170, 111, 110, 105, 110, 116, 59, 32768, 8754, 110, 116, 59, 32768, 8753, 108, 99, 116, 121, 59, 32768, 9005, 4864, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8221, 8226, 8231, 8267, 8282, 8296, 8327, 8351, 8366, 8379, 8466, 8471, 8487, 8621, 8647, 8676, 8697, 8712, 8720, 114, 114, 59, 32768, 8659, 97, 114, 59, 32768, 10597, 1024, 103, 108, 114, 115, 8240, 8246, 8252, 8256, 103, 101, 114, 59, 32768, 8224, 101, 116, 104, 59, 32768, 8504, 114, 59, 32768, 8595, 104, 512, 59, 118, 8262, 8264, 32768, 8208, 59, 32768, 8867, 572, 8271, 8278, 97, 114, 111, 119, 59, 32768, 10511, 97, 99, 59, 32768, 733, 512, 97, 121, 8287, 8293, 114, 111, 110, 59, 32768, 271, 59, 32768, 1076, 768, 59, 97, 111, 8303, 8305, 8320, 32768, 8518, 512, 103, 114, 8310, 8316, 103, 101, 114, 59, 32768, 8225, 114, 59, 32768, 8650, 116, 115, 101, 113, 59, 32768, 10871, 768, 103, 108, 109, 8334, 8339, 8344, 33024, 176, 59, 32768, 176, 116, 97, 59, 32768, 948, 112, 116, 121, 118, 59, 32768, 10673, 512, 105, 114, 8356, 8362, 115, 104, 116, 59, 32768, 10623, 59, 32896, 55349, 56609, 97, 114, 512, 108, 114, 8373, 8376, 59, 32768, 8643, 59, 32768, 8642, 1280, 97, 101, 103, 115, 118, 8390, 8418, 8421, 8428, 8433, 109, 768, 59, 111, 115, 8398, 8400, 8415, 32768, 8900, 110, 100, 512, 59, 115, 8407, 8409, 32768, 8900, 117, 105, 116, 59, 32768, 9830, 59, 32768, 9830, 59, 32768, 168, 97, 109, 109, 97, 59, 32768, 989, 105, 110, 59, 32768, 8946, 768, 59, 105, 111, 8440, 8442, 8461, 32768, 247, 100, 101, 33280, 247, 59, 111, 8450, 8452, 32768, 247, 110, 116, 105, 109, 101, 115, 59, 32768, 8903, 110, 120, 59, 32768, 8903, 99, 121, 59, 32768, 1106, 99, 1088, 8478, 0, 0, 8483, 114, 110, 59, 32768, 8990, 111, 112, 59, 32768, 8973, 1280, 108, 112, 116, 117, 119, 8498, 8504, 8509, 8556, 8570, 108, 97, 114, 59, 32768, 36, 102, 59, 32896, 55349, 56661, 1280, 59, 101, 109, 112, 115, 8520, 8522, 8535, 8542, 8548, 32768, 729, 113, 512, 59, 100, 8528, 8530, 32768, 8784, 111, 116, 59, 32768, 8785, 105, 110, 117, 115, 59, 32768, 8760, 108, 117, 115, 59, 32768, 8724, 113, 117, 97, 114, 101, 59, 32768, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 32768, 8966, 110, 768, 97, 100, 104, 8578, 8585, 8597, 114, 114, 111, 119, 59, 32768, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 32768, 8650, 97, 114, 112, 111, 111, 110, 512, 108, 114, 8608, 8614, 101, 102, 116, 59, 32768, 8643, 105, 103, 104, 116, 59, 32768, 8642, 563, 8625, 8633, 107, 97, 114, 111, 119, 59, 32768, 10512, 1088, 8638, 0, 0, 8643, 114, 110, 59, 32768, 8991, 111, 112, 59, 32768, 8972, 768, 99, 111, 116, 8654, 8666, 8670, 512, 114, 121, 8659, 8663, 59, 32896, 55349, 56505, 59, 32768, 1109, 108, 59, 32768, 10742, 114, 111, 107, 59, 32768, 273, 512, 100, 114, 8681, 8686, 111, 116, 59, 32768, 8945, 105, 512, 59, 102, 8692, 8694, 32768, 9663, 59, 32768, 9662, 512, 97, 104, 8702, 8707, 114, 114, 59, 32768, 8693, 97, 114, 59, 32768, 10607, 97, 110, 103, 108, 101, 59, 32768, 10662, 512, 99, 105, 8725, 8729, 121, 59, 32768, 1119, 103, 114, 97, 114, 114, 59, 32768, 10239, 4608, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 8774, 8788, 8807, 8844, 8849, 8852, 8866, 8895, 8929, 8977, 8989, 9004, 9046, 9136, 9151, 9171, 9184, 9199, 512, 68, 111, 8779, 8784, 111, 116, 59, 32768, 10871, 116, 59, 32768, 8785, 512, 99, 115, 8793, 8801, 117, 116, 101, 33024, 233, 59, 32768, 233, 116, 101, 114, 59, 32768, 10862, 1024, 97, 105, 111, 121, 8816, 8822, 8835, 8841, 114, 111, 110, 59, 32768, 283, 114, 512, 59, 99, 8828, 8830, 32768, 8790, 33024, 234, 59, 32768, 234, 108, 111, 110, 59, 32768, 8789, 59, 32768, 1101, 111, 116, 59, 32768, 279, 59, 32768, 8519, 512, 68, 114, 8857, 8862, 111, 116, 59, 32768, 8786, 59, 32896, 55349, 56610, 768, 59, 114, 115, 8873, 8875, 8883, 32768, 10906, 97, 118, 101, 33024, 232, 59, 32768, 232, 512, 59, 100, 8888, 8890, 32768, 10902, 111, 116, 59, 32768, 10904, 1024, 59, 105, 108, 115, 8904, 8906, 8914, 8917, 32768, 10905, 110, 116, 101, 114, 115, 59, 32768, 9191, 59, 32768, 8467, 512, 59, 100, 8922, 8924, 32768, 10901, 111, 116, 59, 32768, 10903, 768, 97, 112, 115, 8936, 8941, 8960, 99, 114, 59, 32768, 275, 116, 121, 768, 59, 115, 118, 8950, 8952, 8957, 32768, 8709, 101, 116, 59, 32768, 8709, 59, 32768, 8709, 112, 512, 49, 59, 8966, 8975, 516, 8970, 8973, 59, 32768, 8196, 59, 32768, 8197, 32768, 8195, 512, 103, 115, 8982, 8985, 59, 32768, 331, 112, 59, 32768, 8194, 512, 103, 112, 8994, 8999, 111, 110, 59, 32768, 281, 102, 59, 32896, 55349, 56662, 768, 97, 108, 115, 9011, 9023, 9028, 114, 512, 59, 115, 9017, 9019, 32768, 8917, 108, 59, 32768, 10723, 117, 115, 59, 32768, 10865, 105, 768, 59, 108, 118, 9036, 9038, 9043, 32768, 949, 111, 110, 59, 32768, 949, 59, 32768, 1013, 1024, 99, 115, 117, 118, 9055, 9071, 9099, 9128, 512, 105, 111, 9060, 9065, 114, 99, 59, 32768, 8790, 108, 111, 110, 59, 32768, 8789, 1082, 9077, 0, 0, 9081, 109, 59, 32768, 8770, 97, 110, 116, 512, 103, 108, 9088, 9093, 116, 114, 59, 32768, 10902, 101, 115, 115, 59, 32768, 10901, 768, 97, 101, 105, 9106, 9111, 9116, 108, 115, 59, 32768, 61, 115, 116, 59, 32768, 8799, 118, 512, 59, 68, 9122, 9124, 32768, 8801, 68, 59, 32768, 10872, 112, 97, 114, 115, 108, 59, 32768, 10725, 512, 68, 97, 9141, 9146, 111, 116, 59, 32768, 8787, 114, 114, 59, 32768, 10609, 768, 99, 100, 105, 9158, 9162, 9167, 114, 59, 32768, 8495, 111, 116, 59, 32768, 8784, 109, 59, 32768, 8770, 512, 97, 104, 9176, 9179, 59, 32768, 951, 33024, 240, 59, 32768, 240, 512, 109, 114, 9189, 9195, 108, 33024, 235, 59, 32768, 235, 111, 59, 32768, 8364, 768, 99, 105, 112, 9206, 9210, 9215, 108, 59, 32768, 33, 115, 116, 59, 32768, 8707, 512, 101, 111, 9220, 9230, 99, 116, 97, 116, 105, 111, 110, 59, 32768, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 32768, 8519, 4914, 9262, 0, 9276, 0, 9280, 9287, 0, 0, 9318, 9324, 0, 9331, 0, 9352, 9357, 9386, 0, 9395, 9497, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 32768, 8786, 121, 59, 32768, 1092, 109, 97, 108, 101, 59, 32768, 9792, 768, 105, 108, 114, 9293, 9299, 9313, 108, 105, 103, 59, 32768, 64259, 1082, 9305, 0, 0, 9309, 103, 59, 32768, 64256, 105, 103, 59, 32768, 64260, 59, 32896, 55349, 56611, 108, 105, 103, 59, 32768, 64257, 108, 105, 103, 59, 32896, 102, 106, 768, 97, 108, 116, 9337, 9341, 9346, 116, 59, 32768, 9837, 105, 103, 59, 32768, 64258, 110, 115, 59, 32768, 9649, 111, 102, 59, 32768, 402, 833, 9361, 0, 9366, 102, 59, 32896, 55349, 56663, 512, 97, 107, 9370, 9375, 108, 108, 59, 32768, 8704, 512, 59, 118, 9380, 9382, 32768, 8916, 59, 32768, 10969, 97, 114, 116, 105, 110, 116, 59, 32768, 10765, 512, 97, 111, 9399, 9491, 512, 99, 115, 9404, 9487, 1794, 9413, 9443, 9453, 9470, 9474, 0, 9484, 1795, 9421, 9426, 9429, 9434, 9437, 0, 9440, 33024, 189, 59, 32768, 189, 59, 32768, 8531, 33024, 188, 59, 32768, 188, 59, 32768, 8533, 59, 32768, 8537, 59, 32768, 8539, 772, 9447, 0, 9450, 59, 32768, 8532, 59, 32768, 8534, 1285, 9459, 9464, 0, 0, 9467, 33024, 190, 59, 32768, 190, 59, 32768, 8535, 59, 32768, 8540, 53, 59, 32768, 8536, 775, 9478, 0, 9481, 59, 32768, 8538, 59, 32768, 8541, 56, 59, 32768, 8542, 108, 59, 32768, 8260, 119, 110, 59, 32768, 8994, 99, 114, 59, 32896, 55349, 56507, 4352, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 9537, 9547, 9575, 9582, 9595, 9600, 9679, 9684, 9694, 9700, 9705, 9725, 9773, 9779, 9785, 9810, 9917, 512, 59, 108, 9542, 9544, 32768, 8807, 59, 32768, 10892, 768, 99, 109, 112, 9554, 9560, 9572, 117, 116, 101, 59, 32768, 501, 109, 97, 512, 59, 100, 9567, 9569, 32768, 947, 59, 32768, 989, 59, 32768, 10886, 114, 101, 118, 101, 59, 32768, 287, 512, 105, 121, 9587, 9592, 114, 99, 59, 32768, 285, 59, 32768, 1075, 111, 116, 59, 32768, 289, 1024, 59, 108, 113, 115, 9609, 9611, 9614, 9633, 32768, 8805, 59, 32768, 8923, 768, 59, 113, 115, 9621, 9623, 9626, 32768, 8805, 59, 32768, 8807, 108, 97, 110, 116, 59, 32768, 10878, 1024, 59, 99, 100, 108, 9642, 9644, 9648, 9667, 32768, 10878, 99, 59, 32768, 10921, 111, 116, 512, 59, 111, 9655, 9657, 32768, 10880, 512, 59, 108, 9662, 9664, 32768, 10882, 59, 32768, 10884, 512, 59, 101, 9672, 9675, 32896, 8923, 65024, 115, 59, 32768, 10900, 114, 59, 32896, 55349, 56612, 512, 59, 103, 9689, 9691, 32768, 8811, 59, 32768, 8921, 109, 101, 108, 59, 32768, 8503, 99, 121, 59, 32768, 1107, 1024, 59, 69, 97, 106, 9714, 9716, 9719, 9722, 32768, 8823, 59, 32768, 10898, 59, 32768, 10917, 59, 32768, 10916, 1024, 69, 97, 101, 115, 9734, 9737, 9751, 9768, 59, 32768, 8809, 112, 512, 59, 112, 9743, 9745, 32768, 10890, 114, 111, 120, 59, 32768, 10890, 512, 59, 113, 9756, 9758, 32768, 10888, 512, 59, 113, 9763, 9765, 32768, 10888, 59, 32768, 8809, 105, 109, 59, 32768, 8935, 112, 102, 59, 32896, 55349, 56664, 97, 118, 101, 59, 32768, 96, 512, 99, 105, 9790, 9794, 114, 59, 32768, 8458, 109, 768, 59, 101, 108, 9802, 9804, 9807, 32768, 8819, 59, 32768, 10894, 59, 32768, 10896, 34304, 62, 59, 99, 100, 108, 113, 114, 9824, 9826, 9838, 9843, 9849, 9856, 32768, 62, 512, 99, 105, 9831, 9834, 59, 32768, 10919, 114, 59, 32768, 10874, 111, 116, 59, 32768, 8919, 80, 97, 114, 59, 32768, 10645, 117, 101, 115, 116, 59, 32768, 10876, 1280, 97, 100, 101, 108, 115, 9867, 9882, 9887, 9906, 9912, 833, 9872, 0, 9879, 112, 114, 111, 120, 59, 32768, 10886, 114, 59, 32768, 10616, 111, 116, 59, 32768, 8919, 113, 512, 108, 113, 9893, 9899, 101, 115, 115, 59, 32768, 8923, 108, 101, 115, 115, 59, 32768, 10892, 101, 115, 115, 59, 32768, 8823, 105, 109, 59, 32768, 8819, 512, 101, 110, 9922, 9932, 114, 116, 110, 101, 113, 113, 59, 32896, 8809, 65024, 69, 59, 32896, 8809, 65024, 2560, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 9958, 9963, 10015, 10020, 10026, 10060, 10065, 10085, 10147, 10171, 114, 114, 59, 32768, 8660, 1024, 105, 108, 109, 114, 9972, 9978, 9982, 9988, 114, 115, 112, 59, 32768, 8202, 102, 59, 32768, 189, 105, 108, 116, 59, 32768, 8459, 512, 100, 114, 9993, 9998, 99, 121, 59, 32768, 1098, 768, 59, 99, 119, 10005, 10007, 10012, 32768, 8596, 105, 114, 59, 32768, 10568, 59, 32768, 8621, 97, 114, 59, 32768, 8463, 105, 114, 99, 59, 32768, 293, 768, 97, 108, 114, 10033, 10048, 10054, 114, 116, 115, 512, 59, 117, 10041, 10043, 32768, 9829, 105, 116, 59, 32768, 9829, 108, 105, 112, 59, 32768, 8230, 99, 111, 110, 59, 32768, 8889, 114, 59, 32896, 55349, 56613, 115, 512, 101, 119, 10071, 10078, 97, 114, 111, 119, 59, 32768, 10533, 97, 114, 111, 119, 59, 32768, 10534, 1280, 97, 109, 111, 112, 114, 10096, 10101, 10107, 10136, 10141, 114, 114, 59, 32768, 8703, 116, 104, 116, 59, 32768, 8763, 107, 512, 108, 114, 10113, 10124, 101, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8618, 102, 59, 32896, 55349, 56665, 98, 97, 114, 59, 32768, 8213, 768, 99, 108, 116, 10154, 10159, 10165, 114, 59, 32896, 55349, 56509, 97, 115, 104, 59, 32768, 8463, 114, 111, 107, 59, 32768, 295, 512, 98, 112, 10176, 10182, 117, 108, 108, 59, 32768, 8259, 104, 101, 110, 59, 32768, 8208, 5426, 10211, 0, 10220, 0, 10239, 10255, 10267, 0, 10276, 10312, 0, 0, 10318, 10371, 10458, 10485, 10491, 0, 10500, 10545, 10558, 99, 117, 116, 101, 33024, 237, 59, 32768, 237, 768, 59, 105, 121, 10226, 10228, 10235, 32768, 8291, 114, 99, 33024, 238, 59, 32768, 238, 59, 32768, 1080, 512, 99, 120, 10243, 10247, 121, 59, 32768, 1077, 99, 108, 33024, 161, 59, 32768, 161, 512, 102, 114, 10259, 10262, 59, 32768, 8660, 59, 32896, 55349, 56614, 114, 97, 118, 101, 33024, 236, 59, 32768, 236, 1024, 59, 105, 110, 111, 10284, 10286, 10300, 10306, 32768, 8520, 512, 105, 110, 10291, 10296, 110, 116, 59, 32768, 10764, 116, 59, 32768, 8749, 102, 105, 110, 59, 32768, 10716, 116, 97, 59, 32768, 8489, 108, 105, 103, 59, 32768, 307, 768, 97, 111, 112, 10324, 10361, 10365, 768, 99, 103, 116, 10331, 10335, 10357, 114, 59, 32768, 299, 768, 101, 108, 112, 10342, 10345, 10351, 59, 32768, 8465, 105, 110, 101, 59, 32768, 8464, 97, 114, 116, 59, 32768, 8465, 104, 59, 32768, 305, 102, 59, 32768, 8887, 101, 100, 59, 32768, 437, 1280, 59, 99, 102, 111, 116, 10381, 10383, 10389, 10403, 10409, 32768, 8712, 97, 114, 101, 59, 32768, 8453, 105, 110, 512, 59, 116, 10396, 10398, 32768, 8734, 105, 101, 59, 32768, 10717, 100, 111, 116, 59, 32768, 305, 1280, 59, 99, 101, 108, 112, 10420, 10422, 10427, 10444, 10451, 32768, 8747, 97, 108, 59, 32768, 8890, 512, 103, 114, 10432, 10438, 101, 114, 115, 59, 32768, 8484, 99, 97, 108, 59, 32768, 8890, 97, 114, 104, 107, 59, 32768, 10775, 114, 111, 100, 59, 32768, 10812, 1024, 99, 103, 112, 116, 10466, 10470, 10475, 10480, 121, 59, 32768, 1105, 111, 110, 59, 32768, 303, 102, 59, 32896, 55349, 56666, 97, 59, 32768, 953, 114, 111, 100, 59, 32768, 10812, 117, 101, 115, 116, 33024, 191, 59, 32768, 191, 512, 99, 105, 10504, 10509, 114, 59, 32896, 55349, 56510, 110, 1280, 59, 69, 100, 115, 118, 10521, 10523, 10526, 10531, 10541, 32768, 8712, 59, 32768, 8953, 111, 116, 59, 32768, 8949, 512, 59, 118, 10536, 10538, 32768, 8948, 59, 32768, 8947, 59, 32768, 8712, 512, 59, 105, 10549, 10551, 32768, 8290, 108, 100, 101, 59, 32768, 297, 828, 10562, 0, 10567, 99, 121, 59, 32768, 1110, 108, 33024, 239, 59, 32768, 239, 1536, 99, 102, 109, 111, 115, 117, 10585, 10598, 10603, 10609, 10615, 10630, 512, 105, 121, 10590, 10595, 114, 99, 59, 32768, 309, 59, 32768, 1081, 114, 59, 32896, 55349, 56615, 97, 116, 104, 59, 32768, 567, 112, 102, 59, 32896, 55349, 56667, 820, 10620, 0, 10625, 114, 59, 32896, 55349, 56511, 114, 99, 121, 59, 32768, 1112, 107, 99, 121, 59, 32768, 1108, 2048, 97, 99, 102, 103, 104, 106, 111, 115, 10653, 10666, 10680, 10685, 10692, 10697, 10702, 10708, 112, 112, 97, 512, 59, 118, 10661, 10663, 32768, 954, 59, 32768, 1008, 512, 101, 121, 10671, 10677, 100, 105, 108, 59, 32768, 311, 59, 32768, 1082, 114, 59, 32896, 55349, 56616, 114, 101, 101, 110, 59, 32768, 312, 99, 121, 59, 32768, 1093, 99, 121, 59, 32768, 1116, 112, 102, 59, 32896, 55349, 56668, 99, 114, 59, 32896, 55349, 56512, 5888, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 10761, 10783, 10789, 10799, 10804, 10957, 11011, 11047, 11094, 11349, 11372, 11382, 11409, 11414, 11451, 11478, 11526, 11698, 11711, 11755, 11823, 11910, 11929, 768, 97, 114, 116, 10768, 10773, 10777, 114, 114, 59, 32768, 8666, 114, 59, 32768, 8656, 97, 105, 108, 59, 32768, 10523, 97, 114, 114, 59, 32768, 10510, 512, 59, 103, 10794, 10796, 32768, 8806, 59, 32768, 10891, 97, 114, 59, 32768, 10594, 4660, 10824, 0, 10830, 0, 10838, 0, 0, 0, 0, 0, 10844, 10850, 0, 10867, 10870, 10877, 0, 10933, 117, 116, 101, 59, 32768, 314, 109, 112, 116, 121, 118, 59, 32768, 10676, 114, 97, 110, 59, 32768, 8466, 98, 100, 97, 59, 32768, 955, 103, 768, 59, 100, 108, 10857, 10859, 10862, 32768, 10216, 59, 32768, 10641, 101, 59, 32768, 10216, 59, 32768, 10885, 117, 111, 33024, 171, 59, 32768, 171, 114, 2048, 59, 98, 102, 104, 108, 112, 115, 116, 10894, 10896, 10907, 10911, 10915, 10919, 10923, 10928, 32768, 8592, 512, 59, 102, 10901, 10903, 32768, 8676, 115, 59, 32768, 10527, 115, 59, 32768, 10525, 107, 59, 32768, 8617, 112, 59, 32768, 8619, 108, 59, 32768, 10553, 105, 109, 59, 32768, 10611, 108, 59, 32768, 8610, 768, 59, 97, 101, 10939, 10941, 10946, 32768, 10923, 105, 108, 59, 32768, 10521, 512, 59, 115, 10951, 10953, 32768, 10925, 59, 32896, 10925, 65024, 768, 97, 98, 114, 10964, 10969, 10974, 114, 114, 59, 32768, 10508, 114, 107, 59, 32768, 10098, 512, 97, 107, 10979, 10991, 99, 512, 101, 107, 10985, 10988, 59, 32768, 123, 59, 32768, 91, 512, 101, 115, 10996, 10999, 59, 32768, 10635, 108, 512, 100, 117, 11005, 11008, 59, 32768, 10639, 59, 32768, 10637, 1024, 97, 101, 117, 121, 11020, 11026, 11040, 11044, 114, 111, 110, 59, 32768, 318, 512, 100, 105, 11031, 11036, 105, 108, 59, 32768, 316, 108, 59, 32768, 8968, 98, 59, 32768, 123, 59, 32768, 1083, 1024, 99, 113, 114, 115, 11056, 11060, 11072, 11090, 97, 59, 32768, 10550, 117, 111, 512, 59, 114, 11067, 11069, 32768, 8220, 59, 32768, 8222, 512, 100, 117, 11077, 11083, 104, 97, 114, 59, 32768, 10599, 115, 104, 97, 114, 59, 32768, 10571, 104, 59, 32768, 8626, 1280, 59, 102, 103, 113, 115, 11105, 11107, 11228, 11231, 11250, 32768, 8804, 116, 1280, 97, 104, 108, 114, 116, 11119, 11136, 11157, 11169, 11216, 114, 114, 111, 119, 512, 59, 116, 11128, 11130, 32768, 8592, 97, 105, 108, 59, 32768, 8610, 97, 114, 112, 111, 111, 110, 512, 100, 117, 11147, 11153, 111, 119, 110, 59, 32768, 8637, 112, 59, 32768, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 32768, 8647, 105, 103, 104, 116, 768, 97, 104, 115, 11180, 11194, 11204, 114, 114, 111, 119, 512, 59, 115, 11189, 11191, 32768, 8596, 59, 32768, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 32768, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 32768, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 32768, 8907, 59, 32768, 8922, 768, 59, 113, 115, 11238, 11240, 11243, 32768, 8804, 59, 32768, 8806, 108, 97, 110, 116, 59, 32768, 10877, 1280, 59, 99, 100, 103, 115, 11261, 11263, 11267, 11286, 11298, 32768, 10877, 99, 59, 32768, 10920, 111, 116, 512, 59, 111, 11274, 11276, 32768, 10879, 512, 59, 114, 11281, 11283, 32768, 10881, 59, 32768, 10883, 512, 59, 101, 11291, 11294, 32896, 8922, 65024, 115, 59, 32768, 10899, 1280, 97, 100, 101, 103, 115, 11309, 11317, 11322, 11339, 11344, 112, 112, 114, 111, 120, 59, 32768, 10885, 111, 116, 59, 32768, 8918, 113, 512, 103, 113, 11328, 11333, 116, 114, 59, 32768, 8922, 103, 116, 114, 59, 32768, 10891, 116, 114, 59, 32768, 8822, 105, 109, 59, 32768, 8818, 768, 105, 108, 114, 11356, 11362, 11368, 115, 104, 116, 59, 32768, 10620, 111, 111, 114, 59, 32768, 8970, 59, 32896, 55349, 56617, 512, 59, 69, 11377, 11379, 32768, 8822, 59, 32768, 10897, 562, 11386, 11405, 114, 512, 100, 117, 11391, 11394, 59, 32768, 8637, 512, 59, 108, 11399, 11401, 32768, 8636, 59, 32768, 10602, 108, 107, 59, 32768, 9604, 99, 121, 59, 32768, 1113, 1280, 59, 97, 99, 104, 116, 11425, 11427, 11432, 11440, 11446, 32768, 8810, 114, 114, 59, 32768, 8647, 111, 114, 110, 101, 114, 59, 32768, 8990, 97, 114, 100, 59, 32768, 10603, 114, 105, 59, 32768, 9722, 512, 105, 111, 11456, 11462, 100, 111, 116, 59, 32768, 320, 117, 115, 116, 512, 59, 97, 11470, 11472, 32768, 9136, 99, 104, 101, 59, 32768, 9136, 1024, 69, 97, 101, 115, 11487, 11490, 11504, 11521, 59, 32768, 8808, 112, 512, 59, 112, 11496, 11498, 32768, 10889, 114, 111, 120, 59, 32768, 10889, 512, 59, 113, 11509, 11511, 32768, 10887, 512, 59, 113, 11516, 11518, 32768, 10887, 59, 32768, 8808, 105, 109, 59, 32768, 8934, 2048, 97, 98, 110, 111, 112, 116, 119, 122, 11543, 11556, 11561, 11616, 11640, 11660, 11667, 11680, 512, 110, 114, 11548, 11552, 103, 59, 32768, 10220, 114, 59, 32768, 8701, 114, 107, 59, 32768, 10214, 103, 768, 108, 109, 114, 11569, 11596, 11604, 101, 102, 116, 512, 97, 114, 11577, 11584, 114, 114, 111, 119, 59, 32768, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10231, 97, 112, 115, 116, 111, 59, 32768, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10230, 112, 97, 114, 114, 111, 119, 512, 108, 114, 11627, 11633, 101, 102, 116, 59, 32768, 8619, 105, 103, 104, 116, 59, 32768, 8620, 768, 97, 102, 108, 11647, 11651, 11655, 114, 59, 32768, 10629, 59, 32896, 55349, 56669, 117, 115, 59, 32768, 10797, 105, 109, 101, 115, 59, 32768, 10804, 562, 11671, 11676, 115, 116, 59, 32768, 8727, 97, 114, 59, 32768, 95, 768, 59, 101, 102, 11687, 11689, 11695, 32768, 9674, 110, 103, 101, 59, 32768, 9674, 59, 32768, 10731, 97, 114, 512, 59, 108, 11705, 11707, 32768, 40, 116, 59, 32768, 10643, 1280, 97, 99, 104, 109, 116, 11722, 11727, 11735, 11747, 11750, 114, 114, 59, 32768, 8646, 111, 114, 110, 101, 114, 59, 32768, 8991, 97, 114, 512, 59, 100, 11742, 11744, 32768, 8651, 59, 32768, 10605, 59, 32768, 8206, 114, 105, 59, 32768, 8895, 1536, 97, 99, 104, 105, 113, 116, 11768, 11774, 11779, 11782, 11798, 11817, 113, 117, 111, 59, 32768, 8249, 114, 59, 32896, 55349, 56513, 59, 32768, 8624, 109, 768, 59, 101, 103, 11790, 11792, 11795, 32768, 8818, 59, 32768, 10893, 59, 32768, 10895, 512, 98, 117, 11803, 11806, 59, 32768, 91, 111, 512, 59, 114, 11812, 11814, 32768, 8216, 59, 32768, 8218, 114, 111, 107, 59, 32768, 322, 34816, 60, 59, 99, 100, 104, 105, 108, 113, 114, 11841, 11843, 11855, 11860, 11866, 11872, 11878, 11885, 32768, 60, 512, 99, 105, 11848, 11851, 59, 32768, 10918, 114, 59, 32768, 10873, 111, 116, 59, 32768, 8918, 114, 101, 101, 59, 32768, 8907, 109, 101, 115, 59, 32768, 8905, 97, 114, 114, 59, 32768, 10614, 117, 101, 115, 116, 59, 32768, 10875, 512, 80, 105, 11890, 11895, 97, 114, 59, 32768, 10646, 768, 59, 101, 102, 11902, 11904, 11907, 32768, 9667, 59, 32768, 8884, 59, 32768, 9666, 114, 512, 100, 117, 11916, 11923, 115, 104, 97, 114, 59, 32768, 10570, 104, 97, 114, 59, 32768, 10598, 512, 101, 110, 11934, 11944, 114, 116, 110, 101, 113, 113, 59, 32896, 8808, 65024, 69, 59, 32896, 8808, 65024, 3584, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 11978, 11984, 12061, 12075, 12081, 12095, 12100, 12104, 12170, 12181, 12188, 12204, 12207, 12223, 68, 111, 116, 59, 32768, 8762, 1024, 99, 108, 112, 114, 11993, 11999, 12019, 12055, 114, 33024, 175, 59, 32768, 175, 512, 101, 116, 12004, 12007, 59, 32768, 9794, 512, 59, 101, 12012, 12014, 32768, 10016, 115, 101, 59, 32768, 10016, 512, 59, 115, 12024, 12026, 32768, 8614, 116, 111, 1024, 59, 100, 108, 117, 12037, 12039, 12045, 12051, 32768, 8614, 111, 119, 110, 59, 32768, 8615, 101, 102, 116, 59, 32768, 8612, 112, 59, 32768, 8613, 107, 101, 114, 59, 32768, 9646, 512, 111, 121, 12066, 12072, 109, 109, 97, 59, 32768, 10793, 59, 32768, 1084, 97, 115, 104, 59, 32768, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 32768, 8737, 114, 59, 32896, 55349, 56618, 111, 59, 32768, 8487, 768, 99, 100, 110, 12111, 12118, 12146, 114, 111, 33024, 181, 59, 32768, 181, 1024, 59, 97, 99, 100, 12127, 12129, 12134, 12139, 32768, 8739, 115, 116, 59, 32768, 42, 105, 114, 59, 32768, 10992, 111, 116, 33024, 183, 59, 32768, 183, 117, 115, 768, 59, 98, 100, 12155, 12157, 12160, 32768, 8722, 59, 32768, 8863, 512, 59, 117, 12165, 12167, 32768, 8760, 59, 32768, 10794, 564, 12174, 12178, 112, 59, 32768, 10971, 114, 59, 32768, 8230, 112, 108, 117, 115, 59, 32768, 8723, 512, 100, 112, 12193, 12199, 101, 108, 115, 59, 32768, 8871, 102, 59, 32896, 55349, 56670, 59, 32768, 8723, 512, 99, 116, 12212, 12217, 114, 59, 32896, 55349, 56514, 112, 111, 115, 59, 32768, 8766, 768, 59, 108, 109, 12230, 12232, 12240, 32768, 956, 116, 105, 109, 97, 112, 59, 32768, 8888, 97, 112, 59, 32768, 8888, 6144, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 12294, 12315, 12364, 12376, 12393, 12472, 12496, 12547, 12553, 12636, 12641, 12703, 12725, 12747, 12752, 12876, 12881, 12957, 13033, 13089, 13294, 13359, 13384, 13499, 512, 103, 116, 12299, 12303, 59, 32896, 8921, 824, 512, 59, 118, 12308, 12311, 32896, 8811, 8402, 59, 32896, 8811, 824, 768, 101, 108, 116, 12322, 12348, 12352, 102, 116, 512, 97, 114, 12329, 12336, 114, 114, 111, 119, 59, 32768, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8654, 59, 32896, 8920, 824, 512, 59, 118, 12357, 12360, 32896, 8810, 8402, 59, 32896, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8655, 512, 68, 100, 12381, 12387, 97, 115, 104, 59, 32768, 8879, 97, 115, 104, 59, 32768, 8878, 1280, 98, 99, 110, 112, 116, 12404, 12409, 12415, 12420, 12452, 108, 97, 59, 32768, 8711, 117, 116, 101, 59, 32768, 324, 103, 59, 32896, 8736, 8402, 1280, 59, 69, 105, 111, 112, 12431, 12433, 12437, 12442, 12446, 32768, 8777, 59, 32896, 10864, 824, 100, 59, 32896, 8779, 824, 115, 59, 32768, 329, 114, 111, 120, 59, 32768, 8777, 117, 114, 512, 59, 97, 12459, 12461, 32768, 9838, 108, 512, 59, 115, 12467, 12469, 32768, 9838, 59, 32768, 8469, 836, 12477, 0, 12483, 112, 33024, 160, 59, 32768, 160, 109, 112, 512, 59, 101, 12489, 12492, 32896, 8782, 824, 59, 32896, 8783, 824, 1280, 97, 101, 111, 117, 121, 12507, 12519, 12525, 12540, 12544, 833, 12512, 0, 12515, 59, 32768, 10819, 111, 110, 59, 32768, 328, 100, 105, 108, 59, 32768, 326, 110, 103, 512, 59, 100, 12532, 12534, 32768, 8775, 111, 116, 59, 32896, 10861, 824, 112, 59, 32768, 10818, 59, 32768, 1085, 97, 115, 104, 59, 32768, 8211, 1792, 59, 65, 97, 100, 113, 115, 120, 12568, 12570, 12575, 12596, 12602, 12608, 12623, 32768, 8800, 114, 114, 59, 32768, 8663, 114, 512, 104, 114, 12581, 12585, 107, 59, 32768, 10532, 512, 59, 111, 12590, 12592, 32768, 8599, 119, 59, 32768, 8599, 111, 116, 59, 32896, 8784, 824, 117, 105, 118, 59, 32768, 8802, 512, 101, 105, 12613, 12618, 97, 114, 59, 32768, 10536, 109, 59, 32896, 8770, 824, 105, 115, 116, 512, 59, 115, 12631, 12633, 32768, 8708, 59, 32768, 8708, 114, 59, 32896, 55349, 56619, 1024, 69, 101, 115, 116, 12650, 12654, 12688, 12693, 59, 32896, 8807, 824, 768, 59, 113, 115, 12661, 12663, 12684, 32768, 8817, 768, 59, 113, 115, 12670, 12672, 12676, 32768, 8817, 59, 32896, 8807, 824, 108, 97, 110, 116, 59, 32896, 10878, 824, 59, 32896, 10878, 824, 105, 109, 59, 32768, 8821, 512, 59, 114, 12698, 12700, 32768, 8815, 59, 32768, 8815, 768, 65, 97, 112, 12710, 12715, 12720, 114, 114, 59, 32768, 8654, 114, 114, 59, 32768, 8622, 97, 114, 59, 32768, 10994, 768, 59, 115, 118, 12732, 12734, 12744, 32768, 8715, 512, 59, 100, 12739, 12741, 32768, 8956, 59, 32768, 8954, 59, 32768, 8715, 99, 121, 59, 32768, 1114, 1792, 65, 69, 97, 100, 101, 115, 116, 12767, 12772, 12776, 12781, 12785, 12853, 12858, 114, 114, 59, 32768, 8653, 59, 32896, 8806, 824, 114, 114, 59, 32768, 8602, 114, 59, 32768, 8229, 1024, 59, 102, 113, 115, 12794, 12796, 12821, 12842, 32768, 8816, 116, 512, 97, 114, 12802, 12809, 114, 114, 111, 119, 59, 32768, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8622, 768, 59, 113, 115, 12828, 12830, 12834, 32768, 8816, 59, 32896, 8806, 824, 108, 97, 110, 116, 59, 32896, 10877, 824, 512, 59, 115, 12847, 12850, 32896, 10877, 824, 59, 32768, 8814, 105, 109, 59, 32768, 8820, 512, 59, 114, 12863, 12865, 32768, 8814, 105, 512, 59, 101, 12871, 12873, 32768, 8938, 59, 32768, 8940, 105, 100, 59, 32768, 8740, 512, 112, 116, 12886, 12891, 102, 59, 32896, 55349, 56671, 33536, 172, 59, 105, 110, 12899, 12901, 12936, 32768, 172, 110, 1024, 59, 69, 100, 118, 12911, 12913, 12917, 12923, 32768, 8713, 59, 32896, 8953, 824, 111, 116, 59, 32896, 8949, 824, 818, 12928, 12931, 12934, 59, 32768, 8713, 59, 32768, 8951, 59, 32768, 8950, 105, 512, 59, 118, 12942, 12944, 32768, 8716, 818, 12949, 12952, 12955, 59, 32768, 8716, 59, 32768, 8958, 59, 32768, 8957, 768, 97, 111, 114, 12964, 12992, 12999, 114, 1024, 59, 97, 115, 116, 12974, 12976, 12983, 12988, 32768, 8742, 108, 108, 101, 108, 59, 32768, 8742, 108, 59, 32896, 11005, 8421, 59, 32896, 8706, 824, 108, 105, 110, 116, 59, 32768, 10772, 768, 59, 99, 101, 13006, 13008, 13013, 32768, 8832, 117, 101, 59, 32768, 8928, 512, 59, 99, 13018, 13021, 32896, 10927, 824, 512, 59, 101, 13026, 13028, 32768, 8832, 113, 59, 32896, 10927, 824, 1024, 65, 97, 105, 116, 13042, 13047, 13066, 13077, 114, 114, 59, 32768, 8655, 114, 114, 768, 59, 99, 119, 13056, 13058, 13062, 32768, 8603, 59, 32896, 10547, 824, 59, 32896, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8603, 114, 105, 512, 59, 101, 13084, 13086, 32768, 8939, 59, 32768, 8941, 1792, 99, 104, 105, 109, 112, 113, 117, 13104, 13128, 13151, 13169, 13174, 13179, 13194, 1024, 59, 99, 101, 114, 13113, 13115, 13120, 13124, 32768, 8833, 117, 101, 59, 32768, 8929, 59, 32896, 10928, 824, 59, 32896, 55349, 56515, 111, 114, 116, 1086, 13137, 0, 0, 13142, 105, 100, 59, 32768, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 32768, 8742, 109, 512, 59, 101, 13157, 13159, 32768, 8769, 512, 59, 113, 13164, 13166, 32768, 8772, 59, 32768, 8772, 105, 100, 59, 32768, 8740, 97, 114, 59, 32768, 8742, 115, 117, 512, 98, 112, 13186, 13190, 101, 59, 32768, 8930, 101, 59, 32768, 8931, 768, 98, 99, 112, 13201, 13241, 13254, 1024, 59, 69, 101, 115, 13210, 13212, 13216, 13219, 32768, 8836, 59, 32896, 10949, 824, 59, 32768, 8840, 101, 116, 512, 59, 101, 13226, 13229, 32896, 8834, 8402, 113, 512, 59, 113, 13235, 13237, 32768, 8840, 59, 32896, 10949, 824, 99, 512, 59, 101, 13247, 13249, 32768, 8833, 113, 59, 32896, 10928, 824, 1024, 59, 69, 101, 115, 13263, 13265, 13269, 13272, 32768, 8837, 59, 32896, 10950, 824, 59, 32768, 8841, 101, 116, 512, 59, 101, 13279, 13282, 32896, 8835, 8402, 113, 512, 59, 113, 13288, 13290, 32768, 8841, 59, 32896, 10950, 824, 1024, 103, 105, 108, 114, 13303, 13307, 13315, 13319, 108, 59, 32768, 8825, 108, 100, 101, 33024, 241, 59, 32768, 241, 103, 59, 32768, 8824, 105, 97, 110, 103, 108, 101, 512, 108, 114, 13330, 13344, 101, 102, 116, 512, 59, 101, 13338, 13340, 32768, 8938, 113, 59, 32768, 8940, 105, 103, 104, 116, 512, 59, 101, 13353, 13355, 32768, 8939, 113, 59, 32768, 8941, 512, 59, 109, 13364, 13366, 32768, 957, 768, 59, 101, 115, 13373, 13375, 13380, 32768, 35, 114, 111, 59, 32768, 8470, 112, 59, 32768, 8199, 2304, 68, 72, 97, 100, 103, 105, 108, 114, 115, 13403, 13409, 13415, 13420, 13426, 13439, 13446, 13476, 13493, 97, 115, 104, 59, 32768, 8877, 97, 114, 114, 59, 32768, 10500, 112, 59, 32896, 8781, 8402, 97, 115, 104, 59, 32768, 8876, 512, 101, 116, 13431, 13435, 59, 32896, 8805, 8402, 59, 32896, 62, 8402, 110, 102, 105, 110, 59, 32768, 10718, 768, 65, 101, 116, 13453, 13458, 13462, 114, 114, 59, 32768, 10498, 59, 32896, 8804, 8402, 512, 59, 114, 13467, 13470, 32896, 60, 8402, 105, 101, 59, 32896, 8884, 8402, 512, 65, 116, 13481, 13486, 114, 114, 59, 32768, 10499, 114, 105, 101, 59, 32896, 8885, 8402, 105, 109, 59, 32896, 8764, 8402, 768, 65, 97, 110, 13506, 13511, 13532, 114, 114, 59, 32768, 8662, 114, 512, 104, 114, 13517, 13521, 107, 59, 32768, 10531, 512, 59, 111, 13526, 13528, 32768, 8598, 119, 59, 32768, 8598, 101, 97, 114, 59, 32768, 10535, 9252, 13576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13579, 0, 13596, 13617, 13653, 13659, 13673, 13695, 13708, 0, 0, 13713, 13750, 0, 13788, 13794, 0, 13815, 13890, 13913, 13937, 13944, 59, 32768, 9416, 512, 99, 115, 13583, 13591, 117, 116, 101, 33024, 243, 59, 32768, 243, 116, 59, 32768, 8859, 512, 105, 121, 13600, 13613, 114, 512, 59, 99, 13606, 13608, 32768, 8858, 33024, 244, 59, 32768, 244, 59, 32768, 1086, 1280, 97, 98, 105, 111, 115, 13627, 13632, 13638, 13642, 13646, 115, 104, 59, 32768, 8861, 108, 97, 99, 59, 32768, 337, 118, 59, 32768, 10808, 116, 59, 32768, 8857, 111, 108, 100, 59, 32768, 10684, 108, 105, 103, 59, 32768, 339, 512, 99, 114, 13663, 13668, 105, 114, 59, 32768, 10687, 59, 32896, 55349, 56620, 1600, 13680, 0, 0, 13684, 0, 13692, 110, 59, 32768, 731, 97, 118, 101, 33024, 242, 59, 32768, 242, 59, 32768, 10689, 512, 98, 109, 13699, 13704, 97, 114, 59, 32768, 10677, 59, 32768, 937, 110, 116, 59, 32768, 8750, 1024, 97, 99, 105, 116, 13721, 13726, 13741, 13746, 114, 114, 59, 32768, 8634, 512, 105, 114, 13731, 13735, 114, 59, 32768, 10686, 111, 115, 115, 59, 32768, 10683, 110, 101, 59, 32768, 8254, 59, 32768, 10688, 768, 97, 101, 105, 13756, 13761, 13766, 99, 114, 59, 32768, 333, 103, 97, 59, 32768, 969, 768, 99, 100, 110, 13773, 13779, 13782, 114, 111, 110, 59, 32768, 959, 59, 32768, 10678, 117, 115, 59, 32768, 8854, 112, 102, 59, 32896, 55349, 56672, 768, 97, 101, 108, 13800, 13804, 13809, 114, 59, 32768, 10679, 114, 112, 59, 32768, 10681, 117, 115, 59, 32768, 8853, 1792, 59, 97, 100, 105, 111, 115, 118, 13829, 13831, 13836, 13869, 13875, 13879, 13886, 32768, 8744, 114, 114, 59, 32768, 8635, 1024, 59, 101, 102, 109, 13845, 13847, 13859, 13864, 32768, 10845, 114, 512, 59, 111, 13853, 13855, 32768, 8500, 102, 59, 32768, 8500, 33024, 170, 59, 32768, 170, 33024, 186, 59, 32768, 186, 103, 111, 102, 59, 32768, 8886, 114, 59, 32768, 10838, 108, 111, 112, 101, 59, 32768, 10839, 59, 32768, 10843, 768, 99, 108, 111, 13896, 13900, 13908, 114, 59, 32768, 8500, 97, 115, 104, 33024, 248, 59, 32768, 248, 108, 59, 32768, 8856, 105, 573, 13917, 13924, 100, 101, 33024, 245, 59, 32768, 245, 101, 115, 512, 59, 97, 13930, 13932, 32768, 8855, 115, 59, 32768, 10806, 109, 108, 33024, 246, 59, 32768, 246, 98, 97, 114, 59, 32768, 9021, 5426, 13972, 0, 14013, 0, 14017, 14053, 0, 14058, 14086, 0, 0, 14107, 14199, 0, 14202, 0, 0, 14229, 14425, 0, 14438, 114, 1024, 59, 97, 115, 116, 13981, 13983, 13997, 14009, 32768, 8741, 33280, 182, 59, 108, 13989, 13991, 32768, 182, 108, 101, 108, 59, 32768, 8741, 1082, 14003, 0, 0, 14007, 109, 59, 32768, 10995, 59, 32768, 11005, 59, 32768, 8706, 121, 59, 32768, 1087, 114, 1280, 99, 105, 109, 112, 116, 14028, 14033, 14038, 14043, 14046, 110, 116, 59, 32768, 37, 111, 100, 59, 32768, 46, 105, 108, 59, 32768, 8240, 59, 32768, 8869, 101, 110, 107, 59, 32768, 8241, 114, 59, 32896, 55349, 56621, 768, 105, 109, 111, 14064, 14074, 14080, 512, 59, 118, 14069, 14071, 32768, 966, 59, 32768, 981, 109, 97, 116, 59, 32768, 8499, 110, 101, 59, 32768, 9742, 768, 59, 116, 118, 14092, 14094, 14103, 32768, 960, 99, 104, 102, 111, 114, 107, 59, 32768, 8916, 59, 32768, 982, 512, 97, 117, 14111, 14132, 110, 512, 99, 107, 14117, 14128, 107, 512, 59, 104, 14123, 14125, 32768, 8463, 59, 32768, 8462, 118, 59, 32768, 8463, 115, 2304, 59, 97, 98, 99, 100, 101, 109, 115, 116, 14152, 14154, 14160, 14163, 14168, 14179, 14182, 14188, 14193, 32768, 43, 99, 105, 114, 59, 32768, 10787, 59, 32768, 8862, 105, 114, 59, 32768, 10786, 512, 111, 117, 14173, 14176, 59, 32768, 8724, 59, 32768, 10789, 59, 32768, 10866, 110, 33024, 177, 59, 32768, 177, 105, 109, 59, 32768, 10790, 119, 111, 59, 32768, 10791, 59, 32768, 177, 768, 105, 112, 117, 14208, 14216, 14221, 110, 116, 105, 110, 116, 59, 32768, 10773, 102, 59, 32896, 55349, 56673, 110, 100, 33024, 163, 59, 32768, 163, 2560, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 14249, 14251, 14254, 14258, 14263, 14336, 14348, 14367, 14413, 14418, 32768, 8826, 59, 32768, 10931, 112, 59, 32768, 10935, 117, 101, 59, 32768, 8828, 512, 59, 99, 14268, 14270, 32768, 10927, 1536, 59, 97, 99, 101, 110, 115, 14283, 14285, 14293, 14302, 14306, 14331, 32768, 8826, 112, 112, 114, 111, 120, 59, 32768, 10935, 117, 114, 108, 121, 101, 113, 59, 32768, 8828, 113, 59, 32768, 10927, 768, 97, 101, 115, 14313, 14321, 14326, 112, 112, 114, 111, 120, 59, 32768, 10937, 113, 113, 59, 32768, 10933, 105, 109, 59, 32768, 8936, 105, 109, 59, 32768, 8830, 109, 101, 512, 59, 115, 14343, 14345, 32768, 8242, 59, 32768, 8473, 768, 69, 97, 115, 14355, 14358, 14362, 59, 32768, 10933, 112, 59, 32768, 10937, 105, 109, 59, 32768, 8936, 768, 100, 102, 112, 14374, 14377, 14402, 59, 32768, 8719, 768, 97, 108, 115, 14384, 14390, 14396, 108, 97, 114, 59, 32768, 9006, 105, 110, 101, 59, 32768, 8978, 117, 114, 102, 59, 32768, 8979, 512, 59, 116, 14407, 14409, 32768, 8733, 111, 59, 32768, 8733, 105, 109, 59, 32768, 8830, 114, 101, 108, 59, 32768, 8880, 512, 99, 105, 14429, 14434, 114, 59, 32896, 55349, 56517, 59, 32768, 968, 110, 99, 115, 112, 59, 32768, 8200, 1536, 102, 105, 111, 112, 115, 117, 14457, 14462, 14467, 14473, 14480, 14486, 114, 59, 32896, 55349, 56622, 110, 116, 59, 32768, 10764, 112, 102, 59, 32896, 55349, 56674, 114, 105, 109, 101, 59, 32768, 8279, 99, 114, 59, 32896, 55349, 56518, 768, 97, 101, 111, 14493, 14513, 14526, 116, 512, 101, 105, 14499, 14508, 114, 110, 105, 111, 110, 115, 59, 32768, 8461, 110, 116, 59, 32768, 10774, 115, 116, 512, 59, 101, 14520, 14522, 32768, 63, 113, 59, 32768, 8799, 116, 33024, 34, 59, 32768, 34, 5376, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 14575, 14597, 14603, 14608, 14775, 14829, 14865, 14901, 14943, 14966, 15e3, 15139, 15159, 15176, 15182, 15236, 15261, 15267, 15309, 15352, 15360, 768, 97, 114, 116, 14582, 14587, 14591, 114, 114, 59, 32768, 8667, 114, 59, 32768, 8658, 97, 105, 108, 59, 32768, 10524, 97, 114, 114, 59, 32768, 10511, 97, 114, 59, 32768, 10596, 1792, 99, 100, 101, 110, 113, 114, 116, 14623, 14637, 14642, 14650, 14672, 14679, 14751, 512, 101, 117, 14628, 14632, 59, 32896, 8765, 817, 116, 101, 59, 32768, 341, 105, 99, 59, 32768, 8730, 109, 112, 116, 121, 118, 59, 32768, 10675, 103, 1024, 59, 100, 101, 108, 14660, 14662, 14665, 14668, 32768, 10217, 59, 32768, 10642, 59, 32768, 10661, 101, 59, 32768, 10217, 117, 111, 33024, 187, 59, 32768, 187, 114, 2816, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 14703, 14705, 14709, 14720, 14723, 14727, 14731, 14735, 14739, 14744, 14748, 32768, 8594, 112, 59, 32768, 10613, 512, 59, 102, 14714, 14716, 32768, 8677, 115, 59, 32768, 10528, 59, 32768, 10547, 115, 59, 32768, 10526, 107, 59, 32768, 8618, 112, 59, 32768, 8620, 108, 59, 32768, 10565, 105, 109, 59, 32768, 10612, 108, 59, 32768, 8611, 59, 32768, 8605, 512, 97, 105, 14756, 14761, 105, 108, 59, 32768, 10522, 111, 512, 59, 110, 14767, 14769, 32768, 8758, 97, 108, 115, 59, 32768, 8474, 768, 97, 98, 114, 14782, 14787, 14792, 114, 114, 59, 32768, 10509, 114, 107, 59, 32768, 10099, 512, 97, 107, 14797, 14809, 99, 512, 101, 107, 14803, 14806, 59, 32768, 125, 59, 32768, 93, 512, 101, 115, 14814, 14817, 59, 32768, 10636, 108, 512, 100, 117, 14823, 14826, 59, 32768, 10638, 59, 32768, 10640, 1024, 97, 101, 117, 121, 14838, 14844, 14858, 14862, 114, 111, 110, 59, 32768, 345, 512, 100, 105, 14849, 14854, 105, 108, 59, 32768, 343, 108, 59, 32768, 8969, 98, 59, 32768, 125, 59, 32768, 1088, 1024, 99, 108, 113, 115, 14874, 14878, 14885, 14897, 97, 59, 32768, 10551, 100, 104, 97, 114, 59, 32768, 10601, 117, 111, 512, 59, 114, 14892, 14894, 32768, 8221, 59, 32768, 8221, 104, 59, 32768, 8627, 768, 97, 99, 103, 14908, 14934, 14938, 108, 1024, 59, 105, 112, 115, 14918, 14920, 14925, 14931, 32768, 8476, 110, 101, 59, 32768, 8475, 97, 114, 116, 59, 32768, 8476, 59, 32768, 8477, 116, 59, 32768, 9645, 33024, 174, 59, 32768, 174, 768, 105, 108, 114, 14950, 14956, 14962, 115, 104, 116, 59, 32768, 10621, 111, 111, 114, 59, 32768, 8971, 59, 32896, 55349, 56623, 512, 97, 111, 14971, 14990, 114, 512, 100, 117, 14977, 14980, 59, 32768, 8641, 512, 59, 108, 14985, 14987, 32768, 8640, 59, 32768, 10604, 512, 59, 118, 14995, 14997, 32768, 961, 59, 32768, 1009, 768, 103, 110, 115, 15007, 15123, 15127, 104, 116, 1536, 97, 104, 108, 114, 115, 116, 15022, 15039, 15060, 15086, 15099, 15111, 114, 114, 111, 119, 512, 59, 116, 15031, 15033, 32768, 8594, 97, 105, 108, 59, 32768, 8611, 97, 114, 112, 111, 111, 110, 512, 100, 117, 15050, 15056, 111, 119, 110, 59, 32768, 8641, 112, 59, 32768, 8640, 101, 102, 116, 512, 97, 104, 15068, 15076, 114, 114, 111, 119, 115, 59, 32768, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 32768, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 32768, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 32768, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 32768, 8908, 103, 59, 32768, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 32768, 8787, 768, 97, 104, 109, 15146, 15151, 15156, 114, 114, 59, 32768, 8644, 97, 114, 59, 32768, 8652, 59, 32768, 8207, 111, 117, 115, 116, 512, 59, 97, 15168, 15170, 32768, 9137, 99, 104, 101, 59, 32768, 9137, 109, 105, 100, 59, 32768, 10990, 1024, 97, 98, 112, 116, 15191, 15204, 15209, 15229, 512, 110, 114, 15196, 15200, 103, 59, 32768, 10221, 114, 59, 32768, 8702, 114, 107, 59, 32768, 10215, 768, 97, 102, 108, 15216, 15220, 15224, 114, 59, 32768, 10630, 59, 32896, 55349, 56675, 117, 115, 59, 32768, 10798, 105, 109, 101, 115, 59, 32768, 10805, 512, 97, 112, 15241, 15253, 114, 512, 59, 103, 15247, 15249, 32768, 41, 116, 59, 32768, 10644, 111, 108, 105, 110, 116, 59, 32768, 10770, 97, 114, 114, 59, 32768, 8649, 1024, 97, 99, 104, 113, 15276, 15282, 15287, 15290, 113, 117, 111, 59, 32768, 8250, 114, 59, 32896, 55349, 56519, 59, 32768, 8625, 512, 98, 117, 15295, 15298, 59, 32768, 93, 111, 512, 59, 114, 15304, 15306, 32768, 8217, 59, 32768, 8217, 768, 104, 105, 114, 15316, 15322, 15328, 114, 101, 101, 59, 32768, 8908, 109, 101, 115, 59, 32768, 8906, 105, 1024, 59, 101, 102, 108, 15338, 15340, 15343, 15346, 32768, 9657, 59, 32768, 8885, 59, 32768, 9656, 116, 114, 105, 59, 32768, 10702, 108, 117, 104, 97, 114, 59, 32768, 10600, 59, 32768, 8478, 6706, 15391, 15398, 15404, 15499, 15516, 15592, 0, 15606, 15660, 0, 0, 15752, 15758, 0, 15827, 15863, 15886, 16e3, 16006, 16038, 16086, 0, 16467, 0, 0, 16506, 99, 117, 116, 101, 59, 32768, 347, 113, 117, 111, 59, 32768, 8218, 2560, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 15424, 15426, 15429, 15441, 15446, 15458, 15463, 15482, 15490, 15495, 32768, 8827, 59, 32768, 10932, 833, 15434, 0, 15437, 59, 32768, 10936, 111, 110, 59, 32768, 353, 117, 101, 59, 32768, 8829, 512, 59, 100, 15451, 15453, 32768, 10928, 105, 108, 59, 32768, 351, 114, 99, 59, 32768, 349, 768, 69, 97, 115, 15470, 15473, 15477, 59, 32768, 10934, 112, 59, 32768, 10938, 105, 109, 59, 32768, 8937, 111, 108, 105, 110, 116, 59, 32768, 10771, 105, 109, 59, 32768, 8831, 59, 32768, 1089, 111, 116, 768, 59, 98, 101, 15507, 15509, 15512, 32768, 8901, 59, 32768, 8865, 59, 32768, 10854, 1792, 65, 97, 99, 109, 115, 116, 120, 15530, 15535, 15556, 15562, 15566, 15572, 15587, 114, 114, 59, 32768, 8664, 114, 512, 104, 114, 15541, 15545, 107, 59, 32768, 10533, 512, 59, 111, 15550, 15552, 32768, 8600, 119, 59, 32768, 8600, 116, 33024, 167, 59, 32768, 167, 105, 59, 32768, 59, 119, 97, 114, 59, 32768, 10537, 109, 512, 105, 110, 15578, 15584, 110, 117, 115, 59, 32768, 8726, 59, 32768, 8726, 116, 59, 32768, 10038, 114, 512, 59, 111, 15597, 15600, 32896, 55349, 56624, 119, 110, 59, 32768, 8994, 1024, 97, 99, 111, 121, 15614, 15619, 15632, 15654, 114, 112, 59, 32768, 9839, 512, 104, 121, 15624, 15629, 99, 121, 59, 32768, 1097, 59, 32768, 1096, 114, 116, 1086, 15640, 0, 0, 15645, 105, 100, 59, 32768, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 32768, 8741, 33024, 173, 59, 32768, 173, 512, 103, 109, 15664, 15681, 109, 97, 768, 59, 102, 118, 15673, 15675, 15678, 32768, 963, 59, 32768, 962, 59, 32768, 962, 2048, 59, 100, 101, 103, 108, 110, 112, 114, 15698, 15700, 15705, 15715, 15725, 15735, 15739, 15745, 32768, 8764, 111, 116, 59, 32768, 10858, 512, 59, 113, 15710, 15712, 32768, 8771, 59, 32768, 8771, 512, 59, 69, 15720, 15722, 32768, 10910, 59, 32768, 10912, 512, 59, 69, 15730, 15732, 32768, 10909, 59, 32768, 10911, 101, 59, 32768, 8774, 108, 117, 115, 59, 32768, 10788, 97, 114, 114, 59, 32768, 10610, 97, 114, 114, 59, 32768, 8592, 1024, 97, 101, 105, 116, 15766, 15788, 15796, 15808, 512, 108, 115, 15771, 15783, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 32768, 8726, 104, 112, 59, 32768, 10803, 112, 97, 114, 115, 108, 59, 32768, 10724, 512, 100, 108, 15801, 15804, 59, 32768, 8739, 101, 59, 32768, 8995, 512, 59, 101, 15813, 15815, 32768, 10922, 512, 59, 115, 15820, 15822, 32768, 10924, 59, 32896, 10924, 65024, 768, 102, 108, 112, 15833, 15839, 15857, 116, 99, 121, 59, 32768, 1100, 512, 59, 98, 15844, 15846, 32768, 47, 512, 59, 97, 15851, 15853, 32768, 10692, 114, 59, 32768, 9023, 102, 59, 32896, 55349, 56676, 97, 512, 100, 114, 15868, 15882, 101, 115, 512, 59, 117, 15875, 15877, 32768, 9824, 105, 116, 59, 32768, 9824, 59, 32768, 8741, 768, 99, 115, 117, 15892, 15921, 15977, 512, 97, 117, 15897, 15909, 112, 512, 59, 115, 15903, 15905, 32768, 8851, 59, 32896, 8851, 65024, 112, 512, 59, 115, 15915, 15917, 32768, 8852, 59, 32896, 8852, 65024, 117, 512, 98, 112, 15927, 15952, 768, 59, 101, 115, 15934, 15936, 15939, 32768, 8847, 59, 32768, 8849, 101, 116, 512, 59, 101, 15946, 15948, 32768, 8847, 113, 59, 32768, 8849, 768, 59, 101, 115, 15959, 15961, 15964, 32768, 8848, 59, 32768, 8850, 101, 116, 512, 59, 101, 15971, 15973, 32768, 8848, 113, 59, 32768, 8850, 768, 59, 97, 102, 15984, 15986, 15996, 32768, 9633, 114, 566, 15991, 15994, 59, 32768, 9633, 59, 32768, 9642, 59, 32768, 9642, 97, 114, 114, 59, 32768, 8594, 1024, 99, 101, 109, 116, 16014, 16019, 16025, 16031, 114, 59, 32896, 55349, 56520, 116, 109, 110, 59, 32768, 8726, 105, 108, 101, 59, 32768, 8995, 97, 114, 102, 59, 32768, 8902, 512, 97, 114, 16042, 16053, 114, 512, 59, 102, 16048, 16050, 32768, 9734, 59, 32768, 9733, 512, 97, 110, 16058, 16081, 105, 103, 104, 116, 512, 101, 112, 16067, 16076, 112, 115, 105, 108, 111, 110, 59, 32768, 1013, 104, 105, 59, 32768, 981, 115, 59, 32768, 175, 1280, 98, 99, 109, 110, 112, 16096, 16221, 16288, 16291, 16295, 2304, 59, 69, 100, 101, 109, 110, 112, 114, 115, 16115, 16117, 16120, 16125, 16137, 16143, 16154, 16160, 16166, 32768, 8834, 59, 32768, 10949, 111, 116, 59, 32768, 10941, 512, 59, 100, 16130, 16132, 32768, 8838, 111, 116, 59, 32768, 10947, 117, 108, 116, 59, 32768, 10945, 512, 69, 101, 16148, 16151, 59, 32768, 10955, 59, 32768, 8842, 108, 117, 115, 59, 32768, 10943, 97, 114, 114, 59, 32768, 10617, 768, 101, 105, 117, 16173, 16206, 16210, 116, 768, 59, 101, 110, 16181, 16183, 16194, 32768, 8834, 113, 512, 59, 113, 16189, 16191, 32768, 8838, 59, 32768, 10949, 101, 113, 512, 59, 113, 16201, 16203, 32768, 8842, 59, 32768, 10955, 109, 59, 32768, 10951, 512, 98, 112, 16215, 16218, 59, 32768, 10965, 59, 32768, 10963, 99, 1536, 59, 97, 99, 101, 110, 115, 16235, 16237, 16245, 16254, 16258, 16283, 32768, 8827, 112, 112, 114, 111, 120, 59, 32768, 10936, 117, 114, 108, 121, 101, 113, 59, 32768, 8829, 113, 59, 32768, 10928, 768, 97, 101, 115, 16265, 16273, 16278, 112, 112, 114, 111, 120, 59, 32768, 10938, 113, 113, 59, 32768, 10934, 105, 109, 59, 32768, 8937, 105, 109, 59, 32768, 8831, 59, 32768, 8721, 103, 59, 32768, 9834, 3328, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 16322, 16327, 16332, 16337, 16339, 16342, 16356, 16368, 16382, 16388, 16394, 16405, 16411, 33024, 185, 59, 32768, 185, 33024, 178, 59, 32768, 178, 33024, 179, 59, 32768, 179, 32768, 8835, 59, 32768, 10950, 512, 111, 115, 16347, 16351, 116, 59, 32768, 10942, 117, 98, 59, 32768, 10968, 512, 59, 100, 16361, 16363, 32768, 8839, 111, 116, 59, 32768, 10948, 115, 512, 111, 117, 16374, 16378, 108, 59, 32768, 10185, 98, 59, 32768, 10967, 97, 114, 114, 59, 32768, 10619, 117, 108, 116, 59, 32768, 10946, 512, 69, 101, 16399, 16402, 59, 32768, 10956, 59, 32768, 8843, 108, 117, 115, 59, 32768, 10944, 768, 101, 105, 117, 16418, 16451, 16455, 116, 768, 59, 101, 110, 16426, 16428, 16439, 32768, 8835, 113, 512, 59, 113, 16434, 16436, 32768, 8839, 59, 32768, 10950, 101, 113, 512, 59, 113, 16446, 16448, 32768, 8843, 59, 32768, 10956, 109, 59, 32768, 10952, 512, 98, 112, 16460, 16463, 59, 32768, 10964, 59, 32768, 10966, 768, 65, 97, 110, 16473, 16478, 16499, 114, 114, 59, 32768, 8665, 114, 512, 104, 114, 16484, 16488, 107, 59, 32768, 10534, 512, 59, 111, 16493, 16495, 32768, 8601, 119, 59, 32768, 8601, 119, 97, 114, 59, 32768, 10538, 108, 105, 103, 33024, 223, 59, 32768, 223, 5938, 16538, 16552, 16557, 16579, 16584, 16591, 0, 16596, 16692, 0, 0, 0, 0, 0, 16731, 16780, 0, 16787, 16908, 0, 0, 0, 16938, 1091, 16543, 0, 0, 16549, 103, 101, 116, 59, 32768, 8982, 59, 32768, 964, 114, 107, 59, 32768, 9140, 768, 97, 101, 121, 16563, 16569, 16575, 114, 111, 110, 59, 32768, 357, 100, 105, 108, 59, 32768, 355, 59, 32768, 1090, 111, 116, 59, 32768, 8411, 108, 114, 101, 99, 59, 32768, 8981, 114, 59, 32896, 55349, 56625, 1024, 101, 105, 107, 111, 16604, 16641, 16670, 16684, 835, 16609, 0, 16624, 101, 512, 52, 102, 16614, 16617, 59, 32768, 8756, 111, 114, 101, 59, 32768, 8756, 97, 768, 59, 115, 118, 16631, 16633, 16638, 32768, 952, 121, 109, 59, 32768, 977, 59, 32768, 977, 512, 99, 110, 16646, 16665, 107, 512, 97, 115, 16652, 16660, 112, 112, 114, 111, 120, 59, 32768, 8776, 105, 109, 59, 32768, 8764, 115, 112, 59, 32768, 8201, 512, 97, 115, 16675, 16679, 112, 59, 32768, 8776, 105, 109, 59, 32768, 8764, 114, 110, 33024, 254, 59, 32768, 254, 829, 16696, 16701, 16727, 100, 101, 59, 32768, 732, 101, 115, 33536, 215, 59, 98, 100, 16710, 16712, 16723, 32768, 215, 512, 59, 97, 16717, 16719, 32768, 8864, 114, 59, 32768, 10801, 59, 32768, 10800, 116, 59, 32768, 8749, 768, 101, 112, 115, 16737, 16741, 16775, 97, 59, 32768, 10536, 1024, 59, 98, 99, 102, 16750, 16752, 16757, 16762, 32768, 8868, 111, 116, 59, 32768, 9014, 105, 114, 59, 32768, 10993, 512, 59, 111, 16767, 16770, 32896, 55349, 56677, 114, 107, 59, 32768, 10970, 97, 59, 32768, 10537, 114, 105, 109, 101, 59, 32768, 8244, 768, 97, 105, 112, 16793, 16798, 16899, 100, 101, 59, 32768, 8482, 1792, 97, 100, 101, 109, 112, 115, 116, 16813, 16868, 16873, 16876, 16883, 16889, 16893, 110, 103, 108, 101, 1280, 59, 100, 108, 113, 114, 16828, 16830, 16836, 16850, 16853, 32768, 9653, 111, 119, 110, 59, 32768, 9663, 101, 102, 116, 512, 59, 101, 16844, 16846, 32768, 9667, 113, 59, 32768, 8884, 59, 32768, 8796, 105, 103, 104, 116, 512, 59, 101, 16862, 16864, 32768, 9657, 113, 59, 32768, 8885, 111, 116, 59, 32768, 9708, 59, 32768, 8796, 105, 110, 117, 115, 59, 32768, 10810, 108, 117, 115, 59, 32768, 10809, 98, 59, 32768, 10701, 105, 109, 101, 59, 32768, 10811, 101, 122, 105, 117, 109, 59, 32768, 9186, 768, 99, 104, 116, 16914, 16926, 16931, 512, 114, 121, 16919, 16923, 59, 32896, 55349, 56521, 59, 32768, 1094, 99, 121, 59, 32768, 1115, 114, 111, 107, 59, 32768, 359, 512, 105, 111, 16942, 16947, 120, 116, 59, 32768, 8812, 104, 101, 97, 100, 512, 108, 114, 16956, 16967, 101, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8608, 4608, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 17016, 17021, 17026, 17043, 17057, 17072, 17095, 17110, 17119, 17139, 17172, 17187, 17202, 17290, 17330, 17336, 17365, 17381, 114, 114, 59, 32768, 8657, 97, 114, 59, 32768, 10595, 512, 99, 114, 17031, 17039, 117, 116, 101, 33024, 250, 59, 32768, 250, 114, 59, 32768, 8593, 114, 820, 17049, 0, 17053, 121, 59, 32768, 1118, 118, 101, 59, 32768, 365, 512, 105, 121, 17062, 17069, 114, 99, 33024, 251, 59, 32768, 251, 59, 32768, 1091, 768, 97, 98, 104, 17079, 17084, 17090, 114, 114, 59, 32768, 8645, 108, 97, 99, 59, 32768, 369, 97, 114, 59, 32768, 10606, 512, 105, 114, 17100, 17106, 115, 104, 116, 59, 32768, 10622, 59, 32896, 55349, 56626, 114, 97, 118, 101, 33024, 249, 59, 32768, 249, 562, 17123, 17135, 114, 512, 108, 114, 17128, 17131, 59, 32768, 8639, 59, 32768, 8638, 108, 107, 59, 32768, 9600, 512, 99, 116, 17144, 17167, 1088, 17150, 0, 0, 17163, 114, 110, 512, 59, 101, 17156, 17158, 32768, 8988, 114, 59, 32768, 8988, 111, 112, 59, 32768, 8975, 114, 105, 59, 32768, 9720, 512, 97, 108, 17177, 17182, 99, 114, 59, 32768, 363, 33024, 168, 59, 32768, 168, 512, 103, 112, 17192, 17197, 111, 110, 59, 32768, 371, 102, 59, 32896, 55349, 56678, 1536, 97, 100, 104, 108, 115, 117, 17215, 17222, 17233, 17257, 17262, 17280, 114, 114, 111, 119, 59, 32768, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 32768, 8597, 97, 114, 112, 111, 111, 110, 512, 108, 114, 17244, 17250, 101, 102, 116, 59, 32768, 8639, 105, 103, 104, 116, 59, 32768, 8638, 117, 115, 59, 32768, 8846, 105, 768, 59, 104, 108, 17270, 17272, 17275, 32768, 965, 59, 32768, 978, 111, 110, 59, 32768, 965, 112, 97, 114, 114, 111, 119, 115, 59, 32768, 8648, 768, 99, 105, 116, 17297, 17320, 17325, 1088, 17303, 0, 0, 17316, 114, 110, 512, 59, 101, 17309, 17311, 32768, 8989, 114, 59, 32768, 8989, 111, 112, 59, 32768, 8974, 110, 103, 59, 32768, 367, 114, 105, 59, 32768, 9721, 99, 114, 59, 32896, 55349, 56522, 768, 100, 105, 114, 17343, 17348, 17354, 111, 116, 59, 32768, 8944, 108, 100, 101, 59, 32768, 361, 105, 512, 59, 102, 17360, 17362, 32768, 9653, 59, 32768, 9652, 512, 97, 109, 17370, 17375, 114, 114, 59, 32768, 8648, 108, 33024, 252, 59, 32768, 252, 97, 110, 103, 108, 101, 59, 32768, 10663, 3840, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 17420, 17425, 17437, 17443, 17613, 17617, 17623, 17667, 17672, 17678, 17693, 17699, 17705, 17711, 17754, 114, 114, 59, 32768, 8661, 97, 114, 512, 59, 118, 17432, 17434, 32768, 10984, 59, 32768, 10985, 97, 115, 104, 59, 32768, 8872, 512, 110, 114, 17448, 17454, 103, 114, 116, 59, 32768, 10652, 1792, 101, 107, 110, 112, 114, 115, 116, 17469, 17478, 17485, 17494, 17515, 17526, 17578, 112, 115, 105, 108, 111, 110, 59, 32768, 1013, 97, 112, 112, 97, 59, 32768, 1008, 111, 116, 104, 105, 110, 103, 59, 32768, 8709, 768, 104, 105, 114, 17501, 17505, 17508, 105, 59, 32768, 981, 59, 32768, 982, 111, 112, 116, 111, 59, 32768, 8733, 512, 59, 104, 17520, 17522, 32768, 8597, 111, 59, 32768, 1009, 512, 105, 117, 17531, 17537, 103, 109, 97, 59, 32768, 962, 512, 98, 112, 17542, 17560, 115, 101, 116, 110, 101, 113, 512, 59, 113, 17553, 17556, 32896, 8842, 65024, 59, 32896, 10955, 65024, 115, 101, 116, 110, 101, 113, 512, 59, 113, 17571, 17574, 32896, 8843, 65024, 59, 32896, 10956, 65024, 512, 104, 114, 17583, 17589, 101, 116, 97, 59, 32768, 977, 105, 97, 110, 103, 108, 101, 512, 108, 114, 17600, 17606, 101, 102, 116, 59, 32768, 8882, 105, 103, 104, 116, 59, 32768, 8883, 121, 59, 32768, 1074, 97, 115, 104, 59, 32768, 8866, 768, 101, 108, 114, 17630, 17648, 17654, 768, 59, 98, 101, 17637, 17639, 17644, 32768, 8744, 97, 114, 59, 32768, 8891, 113, 59, 32768, 8794, 108, 105, 112, 59, 32768, 8942, 512, 98, 116, 17659, 17664, 97, 114, 59, 32768, 124, 59, 32768, 124, 114, 59, 32896, 55349, 56627, 116, 114, 105, 59, 32768, 8882, 115, 117, 512, 98, 112, 17685, 17689, 59, 32896, 8834, 8402, 59, 32896, 8835, 8402, 112, 102, 59, 32896, 55349, 56679, 114, 111, 112, 59, 32768, 8733, 116, 114, 105, 59, 32768, 8883, 512, 99, 117, 17716, 17721, 114, 59, 32896, 55349, 56523, 512, 98, 112, 17726, 17740, 110, 512, 69, 101, 17732, 17736, 59, 32896, 10955, 65024, 59, 32896, 8842, 65024, 110, 512, 69, 101, 17746, 17750, 59, 32896, 10956, 65024, 59, 32896, 8843, 65024, 105, 103, 122, 97, 103, 59, 32768, 10650, 1792, 99, 101, 102, 111, 112, 114, 115, 17777, 17783, 17815, 17820, 17826, 17829, 17842, 105, 114, 99, 59, 32768, 373, 512, 100, 105, 17788, 17809, 512, 98, 103, 17793, 17798, 97, 114, 59, 32768, 10847, 101, 512, 59, 113, 17804, 17806, 32768, 8743, 59, 32768, 8793, 101, 114, 112, 59, 32768, 8472, 114, 59, 32896, 55349, 56628, 112, 102, 59, 32896, 55349, 56680, 59, 32768, 8472, 512, 59, 101, 17834, 17836, 32768, 8768, 97, 116, 104, 59, 32768, 8768, 99, 114, 59, 32896, 55349, 56524, 5428, 17871, 17891, 0, 17897, 0, 17902, 17917, 0, 0, 17920, 17935, 17940, 17945, 0, 0, 17977, 17992, 0, 18008, 18024, 18029, 768, 97, 105, 117, 17877, 17881, 17886, 112, 59, 32768, 8898, 114, 99, 59, 32768, 9711, 112, 59, 32768, 8899, 116, 114, 105, 59, 32768, 9661, 114, 59, 32896, 55349, 56629, 512, 65, 97, 17906, 17911, 114, 114, 59, 32768, 10234, 114, 114, 59, 32768, 10231, 59, 32768, 958, 512, 65, 97, 17924, 17929, 114, 114, 59, 32768, 10232, 114, 114, 59, 32768, 10229, 97, 112, 59, 32768, 10236, 105, 115, 59, 32768, 8955, 768, 100, 112, 116, 17951, 17956, 17970, 111, 116, 59, 32768, 10752, 512, 102, 108, 17961, 17965, 59, 32896, 55349, 56681, 117, 115, 59, 32768, 10753, 105, 109, 101, 59, 32768, 10754, 512, 65, 97, 17981, 17986, 114, 114, 59, 32768, 10233, 114, 114, 59, 32768, 10230, 512, 99, 113, 17996, 18001, 114, 59, 32896, 55349, 56525, 99, 117, 112, 59, 32768, 10758, 512, 112, 116, 18012, 18018, 108, 117, 115, 59, 32768, 10756, 114, 105, 59, 32768, 9651, 101, 101, 59, 32768, 8897, 101, 100, 103, 101, 59, 32768, 8896, 2048, 97, 99, 101, 102, 105, 111, 115, 117, 18052, 18068, 18081, 18087, 18092, 18097, 18103, 18109, 99, 512, 117, 121, 18058, 18065, 116, 101, 33024, 253, 59, 32768, 253, 59, 32768, 1103, 512, 105, 121, 18073, 18078, 114, 99, 59, 32768, 375, 59, 32768, 1099, 110, 33024, 165, 59, 32768, 165, 114, 59, 32896, 55349, 56630, 99, 121, 59, 32768, 1111, 112, 102, 59, 32896, 55349, 56682, 99, 114, 59, 32896, 55349, 56526, 512, 99, 109, 18114, 18118, 121, 59, 32768, 1102, 108, 33024, 255, 59, 32768, 255, 2560, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 18145, 18152, 18166, 18171, 18186, 18191, 18196, 18204, 18210, 18216, 99, 117, 116, 101, 59, 32768, 378, 512, 97, 121, 18157, 18163, 114, 111, 110, 59, 32768, 382, 59, 32768, 1079, 111, 116, 59, 32768, 380, 512, 101, 116, 18176, 18182, 116, 114, 102, 59, 32768, 8488, 97, 59, 32768, 950, 114, 59, 32896, 55349, 56631, 99, 121, 59, 32768, 1078, 103, 114, 97, 114, 114, 59, 32768, 8669, 112, 102, 59, 32896, 55349, 56683, 99, 114, 59, 32896, 55349, 56527, 512, 106, 110, 18221, 18224, 59, 32768, 8205, 106, 59, 32768, 8204]);
  });
  var N9 = J((i5) => {
    "use strict";
    Object.defineProperty(i5, "__esModule", { value: true });
    i5.default = new Uint16Array([1024, 97, 103, 108, 113, 9, 23, 27, 31, 1086, 15, 0, 0, 19, 112, 59, 32768, 38, 111, 115, 59, 32768, 39, 116, 59, 32768, 62, 116, 59, 32768, 60, 117, 111, 116, 59, 32768, 34]);
  });
  var R9 = J((qt) => {
    "use strict";
    var a5 = qt && qt.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(qt, "__esModule", { value: true });
    qt.decodeXML = qt.decodeHTMLStrict = qt.decodeHTML = qt.determineBranch = qt.JUMP_OFFSET_BASE = qt.BinTrieFlags = qt.xmlDecodeTree = qt.htmlDecodeTree = void 0;
    var O9 = a5(B9());
    qt.htmlDecodeTree = O9.default;
    var q9 = a5(N9());
    qt.xmlDecodeTree = q9.default;
    var Jy = a5(r5()), Po;
    (function(t2) {
      t2[t2.HAS_VALUE = 32768] = "HAS_VALUE", t2[t2.BRANCH_LENGTH = 32512] = "BRANCH_LENGTH", t2[t2.MULTI_BYTE = 128] = "MULTI_BYTE", t2[t2.JUMP_TABLE = 127] = "JUMP_TABLE";
    })(Po = qt.BinTrieFlags || (qt.BinTrieFlags = {}));
    qt.JUMP_OFFSET_BASE = 48 - 1;
    function P9(t2) {
      return function(s, c) {
        for (var p = "", w = 0, T = 0; (T = s.indexOf("&", T)) >= 0; ) {
          if (p += s.slice(w, T), w = T, T += 1, s.charCodeAt(T) === 35) {
            var k = T + 1, P = 10, j = s.charCodeAt(k);
            for ((j | 32) == 120 && (P = 16, T += 1, k += 1); (j = s.charCodeAt(++T)) >= 48 && j <= 57 || P === 16 && (j | 32) >= 97 && (j | 32) <= 102; )
              ;
            if (k !== T) {
              var U = s.substring(k, T), ee = parseInt(U, P);
              if (s.charCodeAt(T) === 59)
                T += 1;
              else if (c)
                continue;
              p += Jy.default(ee), w = T;
            }
            continue;
          }
          for (var G = null, ae = 1, ie3 = 0, V = t2[ie3]; T < s.length && (ie3 = L9(t2, V, ie3 + 1, s.charCodeAt(T)), !(ie3 < 0)); T++, ae++)
            V = t2[ie3], V & Po.HAS_VALUE && (c && s.charCodeAt(T) !== 59 ? ie3 += 1 : (G = V & Po.MULTI_BYTE ? String.fromCharCode(t2[++ie3], t2[++ie3]) : String.fromCharCode(t2[++ie3]), ae = 0));
          G != null && (p += G, w = T - ae + 1);
        }
        return p + s.slice(w);
      };
    }
    function L9(t2, r6, s, c) {
      if (r6 <= 128)
        return c === r6 ? s : -1;
      var p = (r6 & Po.BRANCH_LENGTH) >> 8;
      if (p === 0)
        return -1;
      if (p === 1)
        return c === t2[s] ? s + 1 : -1;
      var w = r6 & Po.JUMP_TABLE;
      if (w) {
        var T = c - qt.JUMP_OFFSET_BASE - w;
        return T < 0 || T > p ? -1 : t2[s + T] - 1;
      }
      for (var k = s, P = k + p - 1; k <= P; ) {
        var j = k + P >>> 1, U = t2[j];
        if (U < c)
          k = j + 1;
        else if (U > c)
          P = j - 1;
        else
          return t2[j + p];
      }
      return -1;
    }
    qt.determineBranch = L9;
    var I9 = P9(O9.default), Qy = P9(q9.default);
    function eb(t2) {
      return I9(t2, false);
    }
    qt.decodeHTML = eb;
    function tb(t2) {
      return I9(t2, true);
    }
    qt.decodeHTMLStrict = tb;
    function rb(t2) {
      return Qy(t2, true);
    }
    qt.decodeXML = rb;
  });
  var o5 = J((Io) => {
    "use strict";
    var nb = Io && Io.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(Io, "__esModule", { value: true });
    var ib = nb(r5()), Lo = R9();
    function f1(t2) {
      return t2 === 32 || t2 === 10 || t2 === 9 || t2 === 12 || t2 === 13;
    }
    function ab(t2) {
      return t2 >= 97 && t2 <= 122 || t2 >= 65 && t2 <= 90;
    }
    function ht(t2, r6, s) {
      var c = t2.charCodeAt(0), p = t2.toLowerCase().charCodeAt(0);
      return function(w, T) {
        T === p || T === c ? w._state = r6 : (w._state = s, w._index--);
      };
    }
    var ob = ht("C", 24, 16), sb = ht("D", 25, 16), lb = ht("A", 26, 16), ub = ht("T", 27, 16), cb = ht("A", 28, 16), fb = ht("R", 35, 3), hb = ht("I", 36, 3), db = ht("P", 37, 3), mb = ht("T", 38, 3), pb = ht("R", 40, 1), gb = ht("I", 41, 1), vb = ht("P", 42, 1), yb = ht("T", 43, 1), bb = ht("Y", 45, 3), xb = ht("L", 46, 3), wb = ht("E", 47, 3), _b2 = ht("Y", 49, 1), Sb = ht("L", 50, 1), Ab = ht("E", 51, 1), Tb = ht("I", 54, 3), Eb = ht("T", 55, 3), Cb = ht("L", 56, 3), kb = ht("E", 57, 3), Mb = ht("I", 58, 1), Db = ht("T", 59, 1), Bb = ht("L", 60, 1), Nb = ht("E", 61, 1), Ob = ht("X", 66, 65), qb = function() {
      function t2(r6, s) {
        var c = r6.xmlMode, p = c === void 0 ? false : c, w = r6.decodeEntities, T = w === void 0 ? true : w;
        this.cbs = s, this._state = 1, this.buffer = "", this.sectionStart = 0, this._index = 0, this.bufferOffset = 0, this.baseState = 1, this.special = 1, this.running = true, this.ended = false, this.trieIndex = 0, this.trieCurrent = 0, this.trieResult = null, this.trieExcess = 0, this.xmlMode = p, this.decodeEntities = T, this.entityTrie = p ? Lo.xmlDecodeTree : Lo.htmlDecodeTree;
      }
      return t2.prototype.reset = function() {
        this._state = 1, this.buffer = "", this.sectionStart = 0, this._index = 0, this.bufferOffset = 0, this.baseState = 1, this.special = 1, this.running = true, this.ended = false;
      }, t2.prototype.write = function(r6) {
        if (this.ended)
          return this.cbs.onerror(Error(".write() after done!"));
        this.buffer.length ? this.buffer += r6 : this.buffer = r6, this.parse();
      }, t2.prototype.end = function(r6) {
        if (this.ended)
          return this.cbs.onerror(Error(".end() after done!"));
        r6 && this.write(r6), this.ended = true, this.running && this.finish();
      }, t2.prototype.pause = function() {
        this.running = false;
      }, t2.prototype.resume = function() {
        this.running = true, this._index < this.buffer.length && this.parse(), this.ended && this.finish();
      }, t2.prototype.getAbsoluteSectionStart = function() {
        return this.sectionStart + this.bufferOffset;
      }, t2.prototype.getAbsoluteIndex = function() {
        return this.bufferOffset + this._index;
      }, t2.prototype.stateText = function(r6) {
        r6 === 60 ? (this._index > this.sectionStart && this.cbs.ontext(this.getSection()), this._state = 2, this.sectionStart = this._index) : this.decodeEntities && r6 === 38 && (this.special === 1 || this.special === 4) && (this._index > this.sectionStart && this.cbs.ontext(this.getSection()), this.baseState = 1, this._state = 62, this.sectionStart = this._index);
      }, t2.prototype.isTagStartChar = function(r6) {
        return ab(r6) || this.xmlMode && !f1(r6) && r6 !== 47 && r6 !== 62;
      }, t2.prototype.stateBeforeTagName = function(r6) {
        r6 === 47 ? this._state = 5 : r6 === 60 ? (this.cbs.ontext(this.getSection()), this.sectionStart = this._index) : r6 === 62 || this.special !== 1 || f1(r6) ? this._state = 1 : r6 === 33 ? (this._state = 15, this.sectionStart = this._index + 1) : r6 === 63 ? (this._state = 17, this.sectionStart = this._index + 1) : this.isTagStartChar(r6) ? (this._state = !this.xmlMode && (r6 === 115 || r6 === 83) ? 32 : !this.xmlMode && (r6 === 116 || r6 === 84) ? 52 : 3, this.sectionStart = this._index) : this._state = 1;
      }, t2.prototype.stateInTagName = function(r6) {
        (r6 === 47 || r6 === 62 || f1(r6)) && (this.cbs.onopentagname(this.getSection()), this.sectionStart = -1, this._state = 8, this.stateBeforeAttributeName(r6));
      }, t2.prototype.stateBeforeClosingTagName = function(r6) {
        f1(r6) || (r6 === 62 ? this._state = 1 : this.special !== 1 ? this.special !== 4 && (r6 === 115 || r6 === 83) ? this._state = 33 : this.special === 4 && (r6 === 116 || r6 === 84) ? this._state = 53 : (this._state = 1, this.stateText(r6)) : this.isTagStartChar(r6) ? (this._state = 6, this.sectionStart = this._index) : (this._state = 20, this.sectionStart = this._index));
      }, t2.prototype.stateInClosingTagName = function(r6) {
        (r6 === 62 || f1(r6)) && (this.cbs.onclosetag(this.getSection()), this.sectionStart = -1, this._state = 7, this.stateAfterClosingTagName(r6));
      }, t2.prototype.stateAfterClosingTagName = function(r6) {
        r6 === 62 && (this._state = 1, this.sectionStart = this._index + 1);
      }, t2.prototype.stateBeforeAttributeName = function(r6) {
        r6 === 62 ? (this.cbs.onopentagend(), this._state = 1, this.sectionStart = this._index + 1) : r6 === 47 ? this._state = 4 : f1(r6) || (this._state = 9, this.sectionStart = this._index);
      }, t2.prototype.stateInSelfClosingTag = function(r6) {
        r6 === 62 ? (this.cbs.onselfclosingtag(), this._state = 1, this.sectionStart = this._index + 1, this.special = 1) : f1(r6) || (this._state = 8, this.stateBeforeAttributeName(r6));
      }, t2.prototype.stateInAttributeName = function(r6) {
        (r6 === 61 || r6 === 47 || r6 === 62 || f1(r6)) && (this.cbs.onattribname(this.getSection()), this.sectionStart = -1, this._state = 10, this.stateAfterAttributeName(r6));
      }, t2.prototype.stateAfterAttributeName = function(r6) {
        r6 === 61 ? this._state = 11 : r6 === 47 || r6 === 62 ? (this.cbs.onattribend(void 0), this._state = 8, this.stateBeforeAttributeName(r6)) : f1(r6) || (this.cbs.onattribend(void 0), this._state = 9, this.sectionStart = this._index);
      }, t2.prototype.stateBeforeAttributeValue = function(r6) {
        r6 === 34 ? (this._state = 12, this.sectionStart = this._index + 1) : r6 === 39 ? (this._state = 13, this.sectionStart = this._index + 1) : f1(r6) || (this.sectionStart = this._index, this._state = 14, this.stateInAttributeValueNoQuotes(r6));
      }, t2.prototype.handleInAttributeValue = function(r6, s) {
        r6 === s ? (this.cbs.onattribdata(this.getSection()), this.sectionStart = -1, this.cbs.onattribend(String.fromCharCode(s)), this._state = 8) : this.decodeEntities && r6 === 38 && (this.cbs.onattribdata(this.getSection()), this.baseState = this._state, this._state = 62, this.sectionStart = this._index);
      }, t2.prototype.stateInAttributeValueDoubleQuotes = function(r6) {
        this.handleInAttributeValue(r6, 34);
      }, t2.prototype.stateInAttributeValueSingleQuotes = function(r6) {
        this.handleInAttributeValue(r6, 39);
      }, t2.prototype.stateInAttributeValueNoQuotes = function(r6) {
        f1(r6) || r6 === 62 ? (this.cbs.onattribdata(this.getSection()), this.sectionStart = -1, this.cbs.onattribend(null), this._state = 8, this.stateBeforeAttributeName(r6)) : this.decodeEntities && r6 === 38 && (this.cbs.onattribdata(this.getSection()), this.baseState = this._state, this._state = 62, this.sectionStart = this._index);
      }, t2.prototype.stateBeforeDeclaration = function(r6) {
        this._state = r6 === 91 ? 23 : r6 === 45 ? 18 : 16;
      }, t2.prototype.stateInDeclaration = function(r6) {
        r6 === 62 && (this.cbs.ondeclaration(this.getSection()), this._state = 1, this.sectionStart = this._index + 1);
      }, t2.prototype.stateInProcessingInstruction = function(r6) {
        r6 === 62 && (this.cbs.onprocessinginstruction(this.getSection()), this._state = 1, this.sectionStart = this._index + 1);
      }, t2.prototype.stateBeforeComment = function(r6) {
        r6 === 45 ? (this._state = 19, this.sectionStart = this._index + 1) : this._state = 16;
      }, t2.prototype.stateInComment = function(r6) {
        r6 === 45 && (this._state = 21);
      }, t2.prototype.stateInSpecialComment = function(r6) {
        r6 === 62 && (this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index)), this._state = 1, this.sectionStart = this._index + 1);
      }, t2.prototype.stateAfterComment1 = function(r6) {
        r6 === 45 ? this._state = 22 : this._state = 19;
      }, t2.prototype.stateAfterComment2 = function(r6) {
        r6 === 62 ? (this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2)), this._state = 1, this.sectionStart = this._index + 1) : r6 !== 45 && (this._state = 19);
      }, t2.prototype.stateBeforeCdata6 = function(r6) {
        r6 === 91 ? (this._state = 29, this.sectionStart = this._index + 1) : (this._state = 16, this.stateInDeclaration(r6));
      }, t2.prototype.stateInCdata = function(r6) {
        r6 === 93 && (this._state = 30);
      }, t2.prototype.stateAfterCdata1 = function(r6) {
        r6 === 93 ? this._state = 31 : this._state = 29;
      }, t2.prototype.stateAfterCdata2 = function(r6) {
        r6 === 62 ? (this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2)), this._state = 1, this.sectionStart = this._index + 1) : r6 !== 93 && (this._state = 29);
      }, t2.prototype.stateBeforeSpecialS = function(r6) {
        r6 === 99 || r6 === 67 ? this._state = 34 : r6 === 116 || r6 === 84 ? this._state = 44 : (this._state = 3, this.stateInTagName(r6));
      }, t2.prototype.stateBeforeSpecialSEnd = function(r6) {
        this.special === 2 && (r6 === 99 || r6 === 67) ? this._state = 39 : this.special === 3 && (r6 === 116 || r6 === 84) ? this._state = 48 : this._state = 1;
      }, t2.prototype.stateBeforeSpecialLast = function(r6, s) {
        (r6 === 47 || r6 === 62 || f1(r6)) && (this.special = s), this._state = 3, this.stateInTagName(r6);
      }, t2.prototype.stateAfterSpecialLast = function(r6, s) {
        r6 === 62 || f1(r6) ? (this.sectionStart = this._index - s, this.special = 1, this._state = 6, this.stateInClosingTagName(r6)) : this._state = 1;
      }, t2.prototype.stateBeforeEntity = function(r6) {
        r6 === 35 ? this._state = 63 : r6 === 38 ? (this.emitPartial(this.getSection()), this.sectionStart = this._index) : (this._state = 64, this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.trieResult = null, this.trieExcess = 1, this._index--);
      }, t2.prototype.stateInNamedEntity = function(r6) {
        if (this.trieExcess += 1, this.trieIndex = (0, Lo.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, r6), this.trieIndex < 0) {
          this.emitNamedEntity(), this._index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex], this.trieCurrent & Lo.BinTrieFlags.HAS_VALUE && (!this.allowLegacyEntity() && r6 !== 59 ? this.trieIndex += 1 : (this.trieResult = this.trieCurrent & Lo.BinTrieFlags.MULTI_BYTE ? String.fromCharCode(this.entityTrie[++this.trieIndex], this.entityTrie[++this.trieIndex]) : String.fromCharCode(this.entityTrie[++this.trieIndex]), this.trieExcess = 0));
      }, t2.prototype.emitNamedEntity = function() {
        this.trieResult && this.emitPartial(this.trieResult), this.sectionStart = this._index - this.trieExcess + 1, this._state = this.baseState;
      }, t2.prototype.decodeNumericEntity = function(r6, s) {
        var c = this.sectionStart + 2 + (r6 >> 4);
        if (c !== this._index) {
          var p = this.buffer.substring(c, this._index), w = parseInt(p, r6);
          this.emitPartial((0, ib.default)(w)), this.sectionStart = this._index + Number(s);
        }
        this._state = this.baseState;
      }, t2.prototype.stateInNumericEntity = function(r6) {
        r6 === 59 ? this.decodeNumericEntity(10, true) : (r6 < 48 || r6 > 57) && (this.allowLegacyEntity() ? this.decodeNumericEntity(10, false) : this._state = this.baseState, this._index--);
      }, t2.prototype.stateInHexEntity = function(r6) {
        r6 === 59 ? this.decodeNumericEntity(16, true) : (r6 < 97 || r6 > 102) && (r6 < 65 || r6 > 70) && (r6 < 48 || r6 > 57) && (this.allowLegacyEntity() ? this.decodeNumericEntity(16, false) : this._state = this.baseState, this._index--);
      }, t2.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && this.baseState === 1;
      }, t2.prototype.cleanup = function() {
        this.running && this._state === 1 && this.sectionStart !== this._index && (this.cbs.ontext(this.buffer.substr(this.sectionStart)), this.sectionStart = this._index);
        var r6 = this.sectionStart < 0 ? this._index : this.sectionStart;
        this.buffer = r6 === this.buffer.length ? "" : this.buffer.substr(r6), this._index -= r6, this.bufferOffset += r6, this.sectionStart > 0 && (this.sectionStart = 0);
      }, t2.prototype.parse = function() {
        for (; this._index < this.buffer.length && this.running; ) {
          var r6 = this.buffer.charCodeAt(this._index);
          this._state === 1 ? this.stateText(r6) : this._state === 12 ? this.stateInAttributeValueDoubleQuotes(r6) : this._state === 9 ? this.stateInAttributeName(r6) : this._state === 19 ? this.stateInComment(r6) : this._state === 20 ? this.stateInSpecialComment(r6) : this._state === 8 ? this.stateBeforeAttributeName(r6) : this._state === 3 ? this.stateInTagName(r6) : this._state === 6 ? this.stateInClosingTagName(r6) : this._state === 2 ? this.stateBeforeTagName(r6) : this._state === 10 ? this.stateAfterAttributeName(r6) : this._state === 13 ? this.stateInAttributeValueSingleQuotes(r6) : this._state === 11 ? this.stateBeforeAttributeValue(r6) : this._state === 5 ? this.stateBeforeClosingTagName(r6) : this._state === 7 ? this.stateAfterClosingTagName(r6) : this._state === 32 ? this.stateBeforeSpecialS(r6) : this._state === 21 ? this.stateAfterComment1(r6) : this._state === 14 ? this.stateInAttributeValueNoQuotes(r6) : this._state === 4 ? this.stateInSelfClosingTag(r6) : this._state === 16 ? this.stateInDeclaration(r6) : this._state === 15 ? this.stateBeforeDeclaration(r6) : this._state === 22 ? this.stateAfterComment2(r6) : this._state === 18 ? this.stateBeforeComment(r6) : this._state === 33 ? this.stateBeforeSpecialSEnd(r6) : this._state === 53 ? Mb(this, r6) : this._state === 39 ? pb(this, r6) : this._state === 40 ? gb(this, r6) : this._state === 41 ? vb(this, r6) : this._state === 34 ? fb(this, r6) : this._state === 35 ? hb(this, r6) : this._state === 36 ? db(this, r6) : this._state === 37 ? mb(this, r6) : this._state === 38 ? this.stateBeforeSpecialLast(r6, 2) : this._state === 42 ? yb(this, r6) : this._state === 43 ? this.stateAfterSpecialLast(r6, 6) : this._state === 44 ? bb(this, r6) : this._state === 29 ? this.stateInCdata(r6) : this._state === 45 ? xb(this, r6) : this._state === 46 ? wb(this, r6) : this._state === 47 ? this.stateBeforeSpecialLast(r6, 3) : this._state === 48 ? _b2(this, r6) : this._state === 49 ? Sb(this, r6) : this._state === 50 ? Ab(this, r6) : this._state === 51 ? this.stateAfterSpecialLast(r6, 5) : this._state === 52 ? Tb(this, r6) : this._state === 54 ? Eb(this, r6) : this._state === 55 ? Cb(this, r6) : this._state === 56 ? kb(this, r6) : this._state === 57 ? this.stateBeforeSpecialLast(r6, 4) : this._state === 58 ? Db(this, r6) : this._state === 59 ? Bb(this, r6) : this._state === 60 ? Nb(this, r6) : this._state === 61 ? this.stateAfterSpecialLast(r6, 5) : this._state === 17 ? this.stateInProcessingInstruction(r6) : this._state === 64 ? this.stateInNamedEntity(r6) : this._state === 23 ? ob(this, r6) : this._state === 62 ? this.stateBeforeEntity(r6) : this._state === 24 ? sb(this, r6) : this._state === 25 ? lb(this, r6) : this._state === 30 ? this.stateAfterCdata1(r6) : this._state === 31 ? this.stateAfterCdata2(r6) : this._state === 26 ? ub(this, r6) : this._state === 27 ? cb(this, r6) : this._state === 28 ? this.stateBeforeCdata6(r6) : this._state === 66 ? this.stateInHexEntity(r6) : this._state === 65 ? this.stateInNumericEntity(r6) : Ob(this, r6), this._index++;
        }
        this.cleanup();
      }, t2.prototype.finish = function() {
        this.sectionStart < this._index && this.handleTrailingData(), this.cbs.onend();
      }, t2.prototype.handleTrailingData = function() {
        var r6 = this.buffer.substr(this.sectionStart);
        this._state === 29 || this._state === 30 || this._state === 31 ? this.cbs.oncdata(r6) : this._state === 19 || this._state === 21 || this._state === 22 ? this.cbs.oncomment(r6) : this._state === 64 && !this.xmlMode ? (this.trieExcess++, this.emitNamedEntity(), this.sectionStart < this._index && (this._state = this.baseState, this.handleTrailingData())) : this._state === 65 && !this.xmlMode ? this.decodeNumericEntity(10, false) : this._state === 66 && !this.xmlMode ? this.decodeNumericEntity(16, false) : this._state === 3 || this._state === 8 || this._state === 11 || this._state === 10 || this._state === 9 || this._state === 13 || this._state === 12 || this._state === 14 || this._state === 6 || this.cbs.ontext(r6);
      }, t2.prototype.getSection = function() {
        return this.buffer.substring(this.sectionStart, this._index);
      }, t2.prototype.emitPartial = function(r6) {
        this.baseState !== 1 ? this.cbs.onattribdata(r6) : this.cbs.ontext(r6);
      }, t2;
    }();
    Io.default = qb;
  });
  var s5 = J((ma) => {
    "use strict";
    var Pb = ma && ma.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(ma, "__esModule", { value: true });
    ma.Parser = void 0;
    var Lb = Pb(o5()), da = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]), dt = new Set(["p"]), z9 = new Set(["thead", "tbody"]), F9 = new Set(["dd", "dt"]), H9 = new Set(["rt", "rp"]), Ib = new Map([["tr", new Set(["tr", "th", "td"])], ["th", new Set(["th"])], ["td", new Set(["thead", "th", "td"])], ["body", new Set(["head", "link", "script"])], ["li", new Set(["li"])], ["p", dt], ["h1", dt], ["h2", dt], ["h3", dt], ["h4", dt], ["h5", dt], ["h6", dt], ["select", da], ["input", da], ["output", da], ["button", da], ["datalist", da], ["textarea", da], ["option", new Set(["option"])], ["optgroup", new Set(["optgroup", "option"])], ["dd", F9], ["dt", F9], ["address", dt], ["article", dt], ["aside", dt], ["blockquote", dt], ["details", dt], ["div", dt], ["dl", dt], ["fieldset", dt], ["figcaption", dt], ["figure", dt], ["footer", dt], ["form", dt], ["header", dt], ["hr", dt], ["main", dt], ["nav", dt], ["ol", dt], ["pre", dt], ["section", dt], ["table", dt], ["ul", dt], ["rt", H9], ["rp", H9], ["tbody", z9], ["tfoot", z9]]), Rb = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]), j9 = new Set(["math", "svg"]), U9 = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignobject", "desc", "title"]), zb = /\s|\//, Fb = function() {
      function t2(r6, s) {
        s === void 0 && (s = {});
        var c, p, w, T, k;
        this.options = s, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.cbs = r6 ?? {}, this.lowerCaseTagNames = (c = s.lowerCaseTags) !== null && c !== void 0 ? c : !s.xmlMode, this.lowerCaseAttributeNames = (p = s.lowerCaseAttributeNames) !== null && p !== void 0 ? p : !s.xmlMode, this.tokenizer = new ((w = s.Tokenizer) !== null && w !== void 0 ? w : Lb.default)(this.options, this), (k = (T = this.cbs).onparserinit) === null || k === void 0 || k.call(T, this);
      }
      return t2.prototype.ontext = function(r6) {
        var s, c, p = this.tokenizer.getAbsoluteIndex();
        this.endIndex = p - 1, (c = (s = this.cbs).ontext) === null || c === void 0 || c.call(s, r6), this.startIndex = p;
      }, t2.prototype.isVoidElement = function(r6) {
        return !this.options.xmlMode && Rb.has(r6);
      }, t2.prototype.onopentagname = function(r6) {
        this.endIndex = this.tokenizer.getAbsoluteIndex(), this.lowerCaseTagNames && (r6 = r6.toLowerCase()), this.emitOpenTag(r6);
      }, t2.prototype.emitOpenTag = function(r6) {
        var s, c, p, w;
        this.openTagStart = this.startIndex, this.tagname = r6;
        var T = !this.options.xmlMode && Ib.get(r6);
        if (T)
          for (; this.stack.length > 0 && T.has(this.stack[this.stack.length - 1]); ) {
            var k = this.stack.pop();
            (c = (s = this.cbs).onclosetag) === null || c === void 0 || c.call(s, k, true);
          }
        this.isVoidElement(r6) || (this.stack.push(r6), j9.has(r6) ? this.foreignContext.push(true) : U9.has(r6) && this.foreignContext.push(false)), (w = (p = this.cbs).onopentagname) === null || w === void 0 || w.call(p, r6), this.cbs.onopentag && (this.attribs = {});
      }, t2.prototype.endOpenTag = function(r6) {
        var s, c;
        this.startIndex = this.openTagStart, this.endIndex = this.tokenizer.getAbsoluteIndex(), this.attribs && ((c = (s = this.cbs).onopentag) === null || c === void 0 || c.call(s, this.tagname, this.attribs, r6), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, true), this.tagname = "";
      }, t2.prototype.onopentagend = function() {
        this.endOpenTag(false), this.startIndex = this.endIndex + 1;
      }, t2.prototype.onclosetag = function(r6) {
        var s, c, p, w, T, k;
        if (this.endIndex = this.tokenizer.getAbsoluteIndex(), this.lowerCaseTagNames && (r6 = r6.toLowerCase()), (j9.has(r6) || U9.has(r6)) && this.foreignContext.pop(), this.isVoidElement(r6))
          !this.options.xmlMode && r6 === "br" && ((c = (s = this.cbs).onopentagname) === null || c === void 0 || c.call(s, r6), (w = (p = this.cbs).onopentag) === null || w === void 0 || w.call(p, r6, {}, true), (k = (T = this.cbs).onclosetag) === null || k === void 0 || k.call(T, r6, false));
        else {
          var P = this.stack.lastIndexOf(r6);
          if (P !== -1)
            if (this.cbs.onclosetag)
              for (var j = this.stack.length - P; j--; )
                this.cbs.onclosetag(this.stack.pop(), j !== 0);
            else
              this.stack.length = P;
          else
            !this.options.xmlMode && r6 === "p" && (this.emitOpenTag(r6), this.closeCurrentTag(true));
        }
        this.startIndex = this.endIndex + 1;
      }, t2.prototype.onselfclosingtag = function() {
        this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(false), this.startIndex = this.endIndex + 1) : this.onopentagend();
      }, t2.prototype.closeCurrentTag = function(r6) {
        var s, c, p = this.tagname;
        this.endOpenTag(r6), this.stack[this.stack.length - 1] === p && ((c = (s = this.cbs).onclosetag) === null || c === void 0 || c.call(s, p, !r6), this.stack.pop());
      }, t2.prototype.onattribname = function(r6) {
        this.startIndex = this.tokenizer.getAbsoluteSectionStart(), this.lowerCaseAttributeNames && (r6 = r6.toLowerCase()), this.attribname = r6;
      }, t2.prototype.onattribdata = function(r6) {
        this.attribvalue += r6;
      }, t2.prototype.onattribend = function(r6) {
        var s, c;
        this.endIndex = this.tokenizer.getAbsoluteIndex(), (c = (s = this.cbs).onattribute) === null || c === void 0 || c.call(s, this.attribname, this.attribvalue, r6), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribname = "", this.attribvalue = "";
      }, t2.prototype.getInstructionName = function(r6) {
        var s = r6.search(zb), c = s < 0 ? r6 : r6.substr(0, s);
        return this.lowerCaseTagNames && (c = c.toLowerCase()), c;
      }, t2.prototype.ondeclaration = function(r6) {
        if (this.endIndex = this.tokenizer.getAbsoluteIndex(), this.cbs.onprocessinginstruction) {
          var s = this.getInstructionName(r6);
          this.cbs.onprocessinginstruction("!" + s, "!" + r6);
        }
        this.startIndex = this.endIndex + 1;
      }, t2.prototype.onprocessinginstruction = function(r6) {
        if (this.endIndex = this.tokenizer.getAbsoluteIndex(), this.cbs.onprocessinginstruction) {
          var s = this.getInstructionName(r6);
          this.cbs.onprocessinginstruction("?" + s, "?" + r6);
        }
        this.startIndex = this.endIndex + 1;
      }, t2.prototype.oncomment = function(r6) {
        var s, c, p, w;
        this.endIndex = this.tokenizer.getAbsoluteIndex(), (c = (s = this.cbs).oncomment) === null || c === void 0 || c.call(s, r6), (w = (p = this.cbs).oncommentend) === null || w === void 0 || w.call(p), this.startIndex = this.endIndex + 1;
      }, t2.prototype.oncdata = function(r6) {
        var s, c, p, w, T, k, P, j, U, ee;
        this.endIndex = this.tokenizer.getAbsoluteIndex(), this.options.xmlMode || this.options.recognizeCDATA ? ((c = (s = this.cbs).oncdatastart) === null || c === void 0 || c.call(s), (w = (p = this.cbs).ontext) === null || w === void 0 || w.call(p, r6), (k = (T = this.cbs).oncdataend) === null || k === void 0 || k.call(T)) : ((j = (P = this.cbs).oncomment) === null || j === void 0 || j.call(P, "[CDATA[" + r6 + "]]"), (ee = (U = this.cbs).oncommentend) === null || ee === void 0 || ee.call(U)), this.startIndex = this.endIndex + 1;
      }, t2.prototype.onerror = function(r6) {
        var s, c;
        (c = (s = this.cbs).onerror) === null || c === void 0 || c.call(s, r6);
      }, t2.prototype.onend = function() {
        var r6, s;
        if (this.cbs.onclosetag) {
          this.endIndex = this.startIndex;
          for (var c = this.stack.length; c > 0; this.cbs.onclosetag(this.stack[--c], true))
            ;
        }
        (s = (r6 = this.cbs).onend) === null || s === void 0 || s.call(r6);
      }, t2.prototype.reset = function() {
        var r6, s, c, p;
        (s = (r6 = this.cbs).onreset) === null || s === void 0 || s.call(r6), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack = [], this.startIndex = 0, this.endIndex = 0, (p = (c = this.cbs).onparserinit) === null || p === void 0 || p.call(c, this);
      }, t2.prototype.parseComplete = function(r6) {
        this.reset(), this.end(r6);
      }, t2.prototype.write = function(r6) {
        this.tokenizer.write(r6);
      }, t2.prototype.end = function(r6) {
        this.tokenizer.end(r6);
      }, t2.prototype.pause = function() {
        this.tokenizer.pause();
      }, t2.prototype.resume = function() {
        this.tokenizer.resume();
      }, t2.prototype.parseChunk = function(r6) {
        this.write(r6);
      }, t2.prototype.done = function(r6) {
        this.end(r6);
      }, t2;
    }();
    ma.Parser = Fb;
  });
  var pa = J((St) => {
    "use strict";
    Object.defineProperty(St, "__esModule", { value: true });
    St.Doctype = St.CDATA = St.Tag = St.Style = St.Script = St.Comment = St.Directive = St.Text = St.Root = St.isTag = St.ElementType = void 0;
    var h1;
    (function(t2) {
      t2.Root = "root", t2.Text = "text", t2.Directive = "directive", t2.Comment = "comment", t2.Script = "script", t2.Style = "style", t2.Tag = "tag", t2.CDATA = "cdata", t2.Doctype = "doctype";
    })(h1 = St.ElementType || (St.ElementType = {}));
    function Hb(t2) {
      return t2.type === h1.Tag || t2.type === h1.Script || t2.type === h1.Style;
    }
    St.isTag = Hb;
    St.Root = h1.Root;
    St.Text = h1.Text;
    St.Directive = h1.Directive;
    St.Comment = h1.Comment;
    St.Script = h1.Script;
    St.Style = h1.Style;
    St.Tag = h1.Tag;
    St.CDATA = h1.CDATA;
    St.Doctype = h1.Doctype;
  });
  var f5 = J((Ve) => {
    "use strict";
    var fi = Ve && Ve.__extends || function() {
      var t2 = function(r6, s) {
        return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, p) {
          c.__proto__ = p;
        } || function(c, p) {
          for (var w in p)
            Object.prototype.hasOwnProperty.call(p, w) && (c[w] = p[w]);
        }, t2(r6, s);
      };
      return function(r6, s) {
        if (typeof s != "function" && s !== null)
          throw new TypeError("Class extends value " + String(s) + " is not a constructor or null");
        t2(r6, s);
        function c() {
          this.constructor = r6;
        }
        r6.prototype = s === null ? Object.create(s) : (c.prototype = s.prototype, new c());
      };
    }(), Ro = Ve && Ve.__assign || function() {
      return Ro = Object.assign || function(t2) {
        for (var r6, s = 1, c = arguments.length; s < c; s++) {
          r6 = arguments[s];
          for (var p in r6)
            Object.prototype.hasOwnProperty.call(r6, p) && (t2[p] = r6[p]);
        }
        return t2;
      }, Ro.apply(this, arguments);
    };
    Object.defineProperty(Ve, "__esModule", { value: true });
    Ve.cloneNode = Ve.hasChildren = Ve.isDocument = Ve.isDirective = Ve.isComment = Ve.isText = Ve.isCDATA = Ve.isTag = Ve.Element = Ve.Document = Ve.NodeWithChildren = Ve.ProcessingInstruction = Ve.Comment = Ve.Text = Ve.DataNode = Ve.Node = void 0;
    var Pt = pa(), jb = new Map([[Pt.ElementType.Tag, 1], [Pt.ElementType.Script, 1], [Pt.ElementType.Style, 1], [Pt.ElementType.Directive, 1], [Pt.ElementType.Text, 3], [Pt.ElementType.CDATA, 4], [Pt.ElementType.Comment, 8], [Pt.ElementType.Root, 9]]), l5 = function() {
      function t2(r6) {
        this.type = r6, this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
      }
      return Object.defineProperty(t2.prototype, "nodeType", { get: function() {
        var r6;
        return (r6 = jb.get(this.type)) !== null && r6 !== void 0 ? r6 : 1;
      }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "parentNode", { get: function() {
        return this.parent;
      }, set: function(r6) {
        this.parent = r6;
      }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "previousSibling", { get: function() {
        return this.prev;
      }, set: function(r6) {
        this.prev = r6;
      }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "nextSibling", { get: function() {
        return this.next;
      }, set: function(r6) {
        this.next = r6;
      }, enumerable: false, configurable: true }), t2.prototype.cloneNode = function(r6) {
        return r6 === void 0 && (r6 = false), u5(this, r6);
      }, t2;
    }();
    Ve.Node = l5;
    var Cl = function(t2) {
      fi(r6, t2);
      function r6(s, c) {
        var p = t2.call(this, s) || this;
        return p.data = c, p;
      }
      return Object.defineProperty(r6.prototype, "nodeValue", { get: function() {
        return this.data;
      }, set: function(s) {
        this.data = s;
      }, enumerable: false, configurable: true }), r6;
    }(l5);
    Ve.DataNode = Cl;
    var W9 = function(t2) {
      fi(r6, t2);
      function r6(s) {
        return t2.call(this, Pt.ElementType.Text, s) || this;
      }
      return r6;
    }(Cl);
    Ve.Text = W9;
    var G9 = function(t2) {
      fi(r6, t2);
      function r6(s) {
        return t2.call(this, Pt.ElementType.Comment, s) || this;
      }
      return r6;
    }(Cl);
    Ve.Comment = G9;
    var V9 = function(t2) {
      fi(r6, t2);
      function r6(s, c) {
        var p = t2.call(this, Pt.ElementType.Directive, c) || this;
        return p.name = s, p;
      }
      return r6;
    }(Cl);
    Ve.ProcessingInstruction = V9;
    var kl = function(t2) {
      fi(r6, t2);
      function r6(s, c) {
        var p = t2.call(this, s) || this;
        return p.children = c, p;
      }
      return Object.defineProperty(r6.prototype, "firstChild", { get: function() {
        var s;
        return (s = this.children[0]) !== null && s !== void 0 ? s : null;
      }, enumerable: false, configurable: true }), Object.defineProperty(r6.prototype, "lastChild", { get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      }, enumerable: false, configurable: true }), Object.defineProperty(r6.prototype, "childNodes", { get: function() {
        return this.children;
      }, set: function(s) {
        this.children = s;
      }, enumerable: false, configurable: true }), r6;
    }(l5);
    Ve.NodeWithChildren = kl;
    var $9 = function(t2) {
      fi(r6, t2);
      function r6(s) {
        return t2.call(this, Pt.ElementType.Root, s) || this;
      }
      return r6;
    }(kl);
    Ve.Document = $9;
    var X9 = function(t2) {
      fi(r6, t2);
      function r6(s, c, p, w) {
        p === void 0 && (p = []), w === void 0 && (w = s === "script" ? Pt.ElementType.Script : s === "style" ? Pt.ElementType.Style : Pt.ElementType.Tag);
        var T = t2.call(this, w, p) || this;
        return T.name = s, T.attribs = c, T;
      }
      return Object.defineProperty(r6.prototype, "tagName", { get: function() {
        return this.name;
      }, set: function(s) {
        this.name = s;
      }, enumerable: false, configurable: true }), Object.defineProperty(r6.prototype, "attributes", { get: function() {
        var s = this;
        return Object.keys(this.attribs).map(function(c) {
          var p, w;
          return { name: c, value: s.attribs[c], namespace: (p = s["x-attribsNamespace"]) === null || p === void 0 ? void 0 : p[c], prefix: (w = s["x-attribsPrefix"]) === null || w === void 0 ? void 0 : w[c] };
        });
      }, enumerable: false, configurable: true }), r6;
    }(kl);
    Ve.Element = X9;
    function Y9(t2) {
      return (0, Pt.isTag)(t2);
    }
    Ve.isTag = Y9;
    function K9(t2) {
      return t2.type === Pt.ElementType.CDATA;
    }
    Ve.isCDATA = K9;
    function Z9(t2) {
      return t2.type === Pt.ElementType.Text;
    }
    Ve.isText = Z9;
    function J9(t2) {
      return t2.type === Pt.ElementType.Comment;
    }
    Ve.isComment = J9;
    function Q9(t2) {
      return t2.type === Pt.ElementType.Directive;
    }
    Ve.isDirective = Q9;
    function e3(t2) {
      return t2.type === Pt.ElementType.Root;
    }
    Ve.isDocument = e3;
    function Ub(t2) {
      return Object.prototype.hasOwnProperty.call(t2, "children");
    }
    Ve.hasChildren = Ub;
    function u5(t2, r6) {
      r6 === void 0 && (r6 = false);
      var s;
      if (Z9(t2))
        s = new W9(t2.data);
      else if (J9(t2))
        s = new G9(t2.data);
      else if (Y9(t2)) {
        var c = r6 ? c5(t2.children) : [], p = new X9(t2.name, Ro({}, t2.attribs), c);
        c.forEach(function(P) {
          return P.parent = p;
        }), t2["x-attribsNamespace"] && (p["x-attribsNamespace"] = Ro({}, t2["x-attribsNamespace"])), t2["x-attribsPrefix"] && (p["x-attribsPrefix"] = Ro({}, t2["x-attribsPrefix"])), s = p;
      } else if (K9(t2)) {
        var c = r6 ? c5(t2.children) : [], w = new kl(Pt.ElementType.CDATA, c);
        c.forEach(function(j) {
          return j.parent = w;
        }), s = w;
      } else if (e3(t2)) {
        var c = r6 ? c5(t2.children) : [], T = new $9(c);
        c.forEach(function(j) {
          return j.parent = T;
        }), t2["x-mode"] && (T["x-mode"] = t2["x-mode"]), s = T;
      } else if (Q9(t2)) {
        var k = new V9(t2.name, t2.data);
        t2["x-name"] != null && (k["x-name"] = t2["x-name"], k["x-publicId"] = t2["x-publicId"], k["x-systemId"] = t2["x-systemId"]), s = k;
      } else
        throw new Error("Not implemented yet: " + t2.type);
      return s.startIndex = t2.startIndex, s.endIndex = t2.endIndex, s;
    }
    Ve.cloneNode = u5;
    function c5(t2) {
      for (var r6 = t2.map(function(c) {
        return u5(c, true);
      }), s = 1; s < r6.length; s++)
        r6[s].prev = r6[s - 1], r6[s - 1].next = r6[s];
      return r6;
    }
  });
  var h0 = J((f0) => {
    "use strict";
    var Wb = f0 && f0.__createBinding || (Object.create ? function(t2, r6, s, c) {
      c === void 0 && (c = s), Object.defineProperty(t2, c, { enumerable: true, get: function() {
        return r6[s];
      } });
    } : function(t2, r6, s, c) {
      c === void 0 && (c = s), t2[c] = r6[s];
    }), Gb = f0 && f0.__exportStar || function(t2, r6) {
      for (var s in t2)
        s !== "default" && !Object.prototype.hasOwnProperty.call(r6, s) && Wb(r6, t2, s);
    };
    Object.defineProperty(f0, "__esModule", { value: true });
    f0.DomHandler = void 0;
    var Ml = pa(), An = f5();
    Gb(f5(), f0);
    var t3 = /\s+/g, r32 = { normalizeWhitespace: false, withStartIndices: false, withEndIndices: false, xmlMode: false }, n3 = function() {
      function t2(r6, s, c) {
        this.dom = [], this.root = new An.Document(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof s == "function" && (c = s, s = r32), typeof r6 == "object" && (s = r6, r6 = void 0), this.callback = r6 ?? null, this.options = s ?? r32, this.elementCB = c ?? null;
      }
      return t2.prototype.onparserinit = function(r6) {
        this.parser = r6;
      }, t2.prototype.onreset = function() {
        this.dom = [], this.root = new An.Document(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, t2.prototype.onend = function() {
        this.done || (this.done = true, this.parser = null, this.handleCallback(null));
      }, t2.prototype.onerror = function(r6) {
        this.handleCallback(r6);
      }, t2.prototype.onclosetag = function() {
        this.lastNode = null;
        var r6 = this.tagStack.pop();
        this.options.withEndIndices && (r6.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(r6);
      }, t2.prototype.onopentag = function(r6, s) {
        var c = this.options.xmlMode ? Ml.ElementType.Tag : void 0, p = new An.Element(r6, s, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, t2.prototype.ontext = function(r6) {
        var s = this.options.normalizeWhitespace, c = this.lastNode;
        if (c && c.type === Ml.ElementType.Text)
          s ? c.data = (c.data + r6).replace(t3, " ") : c.data += r6, this.options.withEndIndices && (c.endIndex = this.parser.endIndex);
        else {
          s && (r6 = r6.replace(t3, " "));
          var p = new An.Text(r6);
          this.addNode(p), this.lastNode = p;
        }
      }, t2.prototype.oncomment = function(r6) {
        if (this.lastNode && this.lastNode.type === Ml.ElementType.Comment) {
          this.lastNode.data += r6;
          return;
        }
        var s = new An.Comment(r6);
        this.addNode(s), this.lastNode = s;
      }, t2.prototype.oncommentend = function() {
        this.lastNode = null;
      }, t2.prototype.oncdatastart = function() {
        var r6 = new An.Text(""), s = new An.NodeWithChildren(Ml.ElementType.CDATA, [r6]);
        this.addNode(s), r6.parent = s, this.lastNode = r6;
      }, t2.prototype.oncdataend = function() {
        this.lastNode = null;
      }, t2.prototype.onprocessinginstruction = function(r6, s) {
        var c = new An.ProcessingInstruction(r6, s);
        this.addNode(c);
      }, t2.prototype.handleCallback = function(r6) {
        if (typeof this.callback == "function")
          this.callback(r6, this.dom);
        else if (r6)
          throw r6;
      }, t2.prototype.addNode = function(r6) {
        var s = this.tagStack[this.tagStack.length - 1], c = s.children[s.children.length - 1];
        this.options.withStartIndices && (r6.startIndex = this.parser.startIndex), this.options.withEndIndices && (r6.endIndex = this.parser.endIndex), s.children.push(r6), c && (r6.prev = c, c.next = r6), r6.parent = s, this.lastNode = null;
      }, t2;
    }();
    f0.DomHandler = n3;
    f0.default = n3;
  });
  var h5 = J((HE, Vb) => {
    Vb.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  });
  var i3 = J((jE, $b) => {
    $b.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  });
  var d5 = J((UE, Xb) => {
    Xb.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  });
  var a3 = J((WE, Yb) => {
    Yb.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  });
  var s3 = J((zo) => {
    "use strict";
    var Kb = zo && zo.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(zo, "__esModule", { value: true });
    var o3 = Kb(a3()), Zb = String.fromCodePoint || function(t2) {
      var r6 = "";
      return t2 > 65535 && (t2 -= 65536, r6 += String.fromCharCode(t2 >>> 10 & 1023 | 55296), t2 = 56320 | t2 & 1023), r6 += String.fromCharCode(t2), r6;
    };
    function Jb(t2) {
      return t2 >= 55296 && t2 <= 57343 || t2 > 1114111 ? "\uFFFD" : (t2 in o3.default && (t2 = o3.default[t2]), Zb(t2));
    }
    zo.default = Jb;
  });
  var p5 = J((d0) => {
    "use strict";
    var Dl = d0 && d0.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(d0, "__esModule", { value: true });
    d0.decodeHTML = d0.decodeHTMLStrict = d0.decodeXML = void 0;
    var m5 = Dl(h5()), Qb = Dl(i3()), ex = Dl(d5()), l3 = Dl(s3()), tx = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    d0.decodeXML = u3(ex.default);
    d0.decodeHTMLStrict = u3(m5.default);
    function u3(t2) {
      var r6 = f3(t2);
      return function(s) {
        return String(s).replace(tx, r6);
      };
    }
    var c3 = function(t2, r6) {
      return t2 < r6 ? 1 : -1;
    };
    d0.decodeHTML = function() {
      for (var t2 = Object.keys(Qb.default).sort(c3), r6 = Object.keys(m5.default).sort(c3), s = 0, c = 0; s < r6.length; s++)
        t2[c] === r6[s] ? (r6[s] += ";?", c++) : r6[s] += ";";
      var p = new RegExp("&(?:" + r6.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), w = f3(m5.default);
      function T(k) {
        return k.substr(-1) !== ";" && (k += ";"), w(k);
      }
      return function(k) {
        return String(k).replace(p, T);
      };
    }();
    function f3(t2) {
      return function(s) {
        if (s.charAt(1) === "#") {
          var c = s.charAt(2);
          return c === "X" || c === "x" ? l3.default(parseInt(s.substr(3), 16)) : l3.default(parseInt(s.substr(2), 10));
        }
        return t2[s.slice(1, -1)] || s;
      };
    }
  });
  var v5 = J((Qr) => {
    "use strict";
    var h3 = Qr && Qr.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(Qr, "__esModule", { value: true });
    Qr.escapeUTF8 = Qr.escape = Qr.encodeNonAsciiHTML = Qr.encodeHTML = Qr.encodeXML = void 0;
    var rx = h3(d5()), d3 = p3(rx.default), m3 = g3(d3);
    Qr.encodeXML = b3(d3);
    var nx = h3(h5()), g5 = p3(nx.default), ix = g3(g5);
    Qr.encodeHTML = ox(g5, ix);
    Qr.encodeNonAsciiHTML = b3(g5);
    function p3(t2) {
      return Object.keys(t2).sort().reduce(function(r6, s) {
        return r6[t2[s]] = "&" + s + ";", r6;
      }, {});
    }
    function g3(t2) {
      for (var r6 = [], s = [], c = 0, p = Object.keys(t2); c < p.length; c++) {
        var w = p[c];
        w.length === 1 ? r6.push("\\" + w) : s.push(w);
      }
      r6.sort();
      for (var T = 0; T < r6.length - 1; T++) {
        for (var k = T; k < r6.length - 1 && r6[k].charCodeAt(1) + 1 === r6[k + 1].charCodeAt(1); )
          k += 1;
        var P = 1 + k - T;
        P < 3 || r6.splice(T, P, r6[T] + "-" + r6[k]);
      }
      return s.unshift("[" + r6.join("") + "]"), new RegExp(s.join("|"), "g");
    }
    var v3 = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, ax = String.prototype.codePointAt != null ? function(t2) {
      return t2.codePointAt(0);
    } : function(t2) {
      return (t2.charCodeAt(0) - 55296) * 1024 + t2.charCodeAt(1) - 56320 + 65536;
    };
    function Bl(t2) {
      return "&#x" + (t2.length > 1 ? ax(t2) : t2.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function ox(t2, r6) {
      return function(s) {
        return s.replace(r6, function(c) {
          return t2[c];
        }).replace(v3, Bl);
      };
    }
    var y3 = new RegExp(m3.source + "|" + v3.source, "g");
    function sx(t2) {
      return t2.replace(y3, Bl);
    }
    Qr.escape = sx;
    function lx(t2) {
      return t2.replace(m3, Bl);
    }
    Qr.escapeUTF8 = lx;
    function b3(t2) {
      return function(r6) {
        return r6.replace(y3, function(s) {
          return t2[s] || Bl(s);
        });
      };
    }
  });
  var w3 = J(($e) => {
    "use strict";
    Object.defineProperty($e, "__esModule", { value: true });
    $e.decodeXMLStrict = $e.decodeHTML5Strict = $e.decodeHTML4Strict = $e.decodeHTML5 = $e.decodeHTML4 = $e.decodeHTMLStrict = $e.decodeHTML = $e.decodeXML = $e.encodeHTML5 = $e.encodeHTML4 = $e.escapeUTF8 = $e.escape = $e.encodeNonAsciiHTML = $e.encodeHTML = $e.encodeXML = $e.encode = $e.decodeStrict = $e.decode = void 0;
    var Nl = p5(), x3 = v5();
    function ux(t2, r6) {
      return (!r6 || r6 <= 0 ? Nl.decodeXML : Nl.decodeHTML)(t2);
    }
    $e.decode = ux;
    function cx(t2, r6) {
      return (!r6 || r6 <= 0 ? Nl.decodeXML : Nl.decodeHTMLStrict)(t2);
    }
    $e.decodeStrict = cx;
    function fx(t2, r6) {
      return (!r6 || r6 <= 0 ? x3.encodeXML : x3.encodeHTML)(t2);
    }
    $e.encode = fx;
    var hi = v5();
    Object.defineProperty($e, "encodeXML", { enumerable: true, get: function() {
      return hi.encodeXML;
    } });
    Object.defineProperty($e, "encodeHTML", { enumerable: true, get: function() {
      return hi.encodeHTML;
    } });
    Object.defineProperty($e, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return hi.encodeNonAsciiHTML;
    } });
    Object.defineProperty($e, "escape", { enumerable: true, get: function() {
      return hi.escape;
    } });
    Object.defineProperty($e, "escapeUTF8", { enumerable: true, get: function() {
      return hi.escapeUTF8;
    } });
    Object.defineProperty($e, "encodeHTML4", { enumerable: true, get: function() {
      return hi.encodeHTML;
    } });
    Object.defineProperty($e, "encodeHTML5", { enumerable: true, get: function() {
      return hi.encodeHTML;
    } });
    var Tn = p5();
    Object.defineProperty($e, "decodeXML", { enumerable: true, get: function() {
      return Tn.decodeXML;
    } });
    Object.defineProperty($e, "decodeHTML", { enumerable: true, get: function() {
      return Tn.decodeHTML;
    } });
    Object.defineProperty($e, "decodeHTMLStrict", { enumerable: true, get: function() {
      return Tn.decodeHTMLStrict;
    } });
    Object.defineProperty($e, "decodeHTML4", { enumerable: true, get: function() {
      return Tn.decodeHTML;
    } });
    Object.defineProperty($e, "decodeHTML5", { enumerable: true, get: function() {
      return Tn.decodeHTML;
    } });
    Object.defineProperty($e, "decodeHTML4Strict", { enumerable: true, get: function() {
      return Tn.decodeHTMLStrict;
    } });
    Object.defineProperty($e, "decodeHTML5Strict", { enumerable: true, get: function() {
      return Tn.decodeHTMLStrict;
    } });
    Object.defineProperty($e, "decodeXMLStrict", { enumerable: true, get: function() {
      return Tn.decodeXML;
    } });
  });
  var _32 = J((ga) => {
    "use strict";
    Object.defineProperty(ga, "__esModule", { value: true });
    ga.attributeNames = ga.elementNames = void 0;
    ga.elementNames = new Map([["altglyph", "altGlyph"], ["altglyphdef", "altGlyphDef"], ["altglyphitem", "altGlyphItem"], ["animatecolor", "animateColor"], ["animatemotion", "animateMotion"], ["animatetransform", "animateTransform"], ["clippath", "clipPath"], ["feblend", "feBlend"], ["fecolormatrix", "feColorMatrix"], ["fecomponenttransfer", "feComponentTransfer"], ["fecomposite", "feComposite"], ["feconvolvematrix", "feConvolveMatrix"], ["fediffuselighting", "feDiffuseLighting"], ["fedisplacementmap", "feDisplacementMap"], ["fedistantlight", "feDistantLight"], ["fedropshadow", "feDropShadow"], ["feflood", "feFlood"], ["fefunca", "feFuncA"], ["fefuncb", "feFuncB"], ["fefuncg", "feFuncG"], ["fefuncr", "feFuncR"], ["fegaussianblur", "feGaussianBlur"], ["feimage", "feImage"], ["femerge", "feMerge"], ["femergenode", "feMergeNode"], ["femorphology", "feMorphology"], ["feoffset", "feOffset"], ["fepointlight", "fePointLight"], ["fespecularlighting", "feSpecularLighting"], ["fespotlight", "feSpotLight"], ["fetile", "feTile"], ["feturbulence", "feTurbulence"], ["foreignobject", "foreignObject"], ["glyphref", "glyphRef"], ["lineargradient", "linearGradient"], ["radialgradient", "radialGradient"], ["textpath", "textPath"]]);
    ga.attributeNames = new Map([["definitionurl", "definitionURL"], ["attributename", "attributeName"], ["attributetype", "attributeType"], ["basefrequency", "baseFrequency"], ["baseprofile", "baseProfile"], ["calcmode", "calcMode"], ["clippathunits", "clipPathUnits"], ["diffuseconstant", "diffuseConstant"], ["edgemode", "edgeMode"], ["filterunits", "filterUnits"], ["glyphref", "glyphRef"], ["gradienttransform", "gradientTransform"], ["gradientunits", "gradientUnits"], ["kernelmatrix", "kernelMatrix"], ["kernelunitlength", "kernelUnitLength"], ["keypoints", "keyPoints"], ["keysplines", "keySplines"], ["keytimes", "keyTimes"], ["lengthadjust", "lengthAdjust"], ["limitingconeangle", "limitingConeAngle"], ["markerheight", "markerHeight"], ["markerunits", "markerUnits"], ["markerwidth", "markerWidth"], ["maskcontentunits", "maskContentUnits"], ["maskunits", "maskUnits"], ["numoctaves", "numOctaves"], ["pathlength", "pathLength"], ["patterncontentunits", "patternContentUnits"], ["patterntransform", "patternTransform"], ["patternunits", "patternUnits"], ["pointsatx", "pointsAtX"], ["pointsaty", "pointsAtY"], ["pointsatz", "pointsAtZ"], ["preservealpha", "preserveAlpha"], ["preserveaspectratio", "preserveAspectRatio"], ["primitiveunits", "primitiveUnits"], ["refx", "refX"], ["refy", "refY"], ["repeatcount", "repeatCount"], ["repeatdur", "repeatDur"], ["requiredextensions", "requiredExtensions"], ["requiredfeatures", "requiredFeatures"], ["specularconstant", "specularConstant"], ["specularexponent", "specularExponent"], ["spreadmethod", "spreadMethod"], ["startoffset", "startOffset"], ["stddeviation", "stdDeviation"], ["stitchtiles", "stitchTiles"], ["surfacescale", "surfaceScale"], ["systemlanguage", "systemLanguage"], ["tablevalues", "tableValues"], ["targetx", "targetX"], ["targety", "targetY"], ["textlength", "textLength"], ["viewbox", "viewBox"], ["viewtarget", "viewTarget"], ["xchannelselector", "xChannelSelector"], ["ychannelselector", "yChannelSelector"], ["zoomandpan", "zoomAndPan"]]);
  });
  var E3 = J(($1) => {
    "use strict";
    var va = $1 && $1.__assign || function() {
      return va = Object.assign || function(t2) {
        for (var r6, s = 1, c = arguments.length; s < c; s++) {
          r6 = arguments[s];
          for (var p in r6)
            Object.prototype.hasOwnProperty.call(r6, p) && (t2[p] = r6[p]);
        }
        return t2;
      }, va.apply(this, arguments);
    }, hx = $1 && $1.__createBinding || (Object.create ? function(t2, r6, s, c) {
      c === void 0 && (c = s), Object.defineProperty(t2, c, { enumerable: true, get: function() {
        return r6[s];
      } });
    } : function(t2, r6, s, c) {
      c === void 0 && (c = s), t2[c] = r6[s];
    }), dx = $1 && $1.__setModuleDefault || (Object.create ? function(t2, r6) {
      Object.defineProperty(t2, "default", { enumerable: true, value: r6 });
    } : function(t2, r6) {
      t2.default = r6;
    }), mx = $1 && $1.__importStar || function(t2) {
      if (t2 && t2.__esModule)
        return t2;
      var r6 = {};
      if (t2 != null)
        for (var s in t2)
          s !== "default" && Object.prototype.hasOwnProperty.call(t2, s) && hx(r6, t2, s);
      return dx(r6, t2), r6;
    };
    Object.defineProperty($1, "__esModule", { value: true });
    var F0 = mx(pa()), S3 = w3(), A3 = _32(), px = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
    function gx(t2, r6) {
      if (!!t2)
        return Object.keys(t2).map(function(s) {
          var c, p, w = (c = t2[s]) !== null && c !== void 0 ? c : "";
          return r6.xmlMode === "foreign" && (s = (p = A3.attributeNames.get(s)) !== null && p !== void 0 ? p : s), !r6.emptyAttrs && !r6.xmlMode && w === "" ? s : s + '="' + (r6.decodeEntities !== false ? S3.encodeXML(w) : w.replace(/"/g, "&quot;")) + '"';
        }).join(" ");
    }
    var T3 = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
    function y5(t2, r6) {
      r6 === void 0 && (r6 = {});
      for (var s = ("length" in t2) ? t2 : [t2], c = "", p = 0; p < s.length; p++)
        c += vx(s[p], r6);
      return c;
    }
    $1.default = y5;
    function vx(t2, r6) {
      switch (t2.type) {
        case F0.Root:
          return y5(t2.children, r6);
        case F0.Directive:
        case F0.Doctype:
          return wx(t2);
        case F0.Comment:
          return Ax(t2);
        case F0.CDATA:
          return Sx(t2);
        case F0.Script:
        case F0.Style:
        case F0.Tag:
          return xx(t2, r6);
        case F0.Text:
          return _x(t2, r6);
      }
    }
    var yx = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]), bx = new Set(["svg", "math"]);
    function xx(t2, r6) {
      var s;
      r6.xmlMode === "foreign" && (t2.name = (s = A3.elementNames.get(t2.name)) !== null && s !== void 0 ? s : t2.name, t2.parent && yx.has(t2.parent.name) && (r6 = va(va({}, r6), { xmlMode: false }))), !r6.xmlMode && bx.has(t2.name) && (r6 = va(va({}, r6), { xmlMode: "foreign" }));
      var c = "<" + t2.name, p = gx(t2.attribs, r6);
      return p && (c += " " + p), t2.children.length === 0 && (r6.xmlMode ? r6.selfClosingTags !== false : r6.selfClosingTags && T3.has(t2.name)) ? (r6.xmlMode || (c += " "), c += "/>") : (c += ">", t2.children.length > 0 && (c += y5(t2.children, r6)), (r6.xmlMode || !T3.has(t2.name)) && (c += "</" + t2.name + ">")), c;
    }
    function wx(t2) {
      return "<" + t2.data + ">";
    }
    function _x(t2, r6) {
      var s = t2.data || "";
      return r6.decodeEntities !== false && !(!r6.xmlMode && t2.parent && px.has(t2.parent.name)) && (s = S3.encodeXML(s)), s;
    }
    function Sx(t2) {
      return "<![CDATA[" + t2.children[0].data + "]]>";
    }
    function Ax(t2) {
      return "<!--" + t2.data + "-->";
    }
  });
  var w5 = J((e1) => {
    "use strict";
    var Tx = e1 && e1.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(e1, "__esModule", { value: true });
    e1.innerText = e1.textContent = e1.getText = e1.getInnerHTML = e1.getOuterHTML = void 0;
    var m0 = h0(), Ex = Tx(E3()), Cx = pa();
    function C3(t2, r6) {
      return (0, Ex.default)(t2, r6);
    }
    e1.getOuterHTML = C3;
    function kx(t2, r6) {
      return (0, m0.hasChildren)(t2) ? t2.children.map(function(s) {
        return C3(s, r6);
      }).join("") : "";
    }
    e1.getInnerHTML = kx;
    function Ol(t2) {
      return Array.isArray(t2) ? t2.map(Ol).join("") : (0, m0.isTag)(t2) ? t2.name === "br" ? `
` : Ol(t2.children) : (0, m0.isCDATA)(t2) ? Ol(t2.children) : (0, m0.isText)(t2) ? t2.data : "";
    }
    e1.getText = Ol;
    function b5(t2) {
      return Array.isArray(t2) ? t2.map(b5).join("") : (0, m0.hasChildren)(t2) && !(0, m0.isComment)(t2) ? b5(t2.children) : (0, m0.isText)(t2) ? t2.data : "";
    }
    e1.textContent = b5;
    function x5(t2) {
      return Array.isArray(t2) ? t2.map(x5).join("") : (0, m0.hasChildren)(t2) && (t2.type === Cx.ElementType.Tag || (0, m0.isCDATA)(t2)) ? x5(t2.children) : (0, m0.isText)(t2) ? t2.data : "";
    }
    e1.innerText = x5;
  });
  var B3 = J((tr) => {
    "use strict";
    Object.defineProperty(tr, "__esModule", { value: true });
    tr.prevElementSibling = tr.nextElementSibling = tr.getName = tr.hasAttrib = tr.getAttributeValue = tr.getSiblings = tr.getParent = tr.getChildren = void 0;
    var k3 = h0(), Mx = [];
    function M3(t2) {
      var r6;
      return (r6 = t2.children) !== null && r6 !== void 0 ? r6 : Mx;
    }
    tr.getChildren = M3;
    function D3(t2) {
      return t2.parent || null;
    }
    tr.getParent = D3;
    function Dx(t2) {
      var r6, s, c = D3(t2);
      if (c != null)
        return M3(c);
      for (var p = [t2], w = t2.prev, T = t2.next; w != null; )
        p.unshift(w), r6 = w, w = r6.prev;
      for (; T != null; )
        p.push(T), s = T, T = s.next;
      return p;
    }
    tr.getSiblings = Dx;
    function Bx(t2, r6) {
      var s;
      return (s = t2.attribs) === null || s === void 0 ? void 0 : s[r6];
    }
    tr.getAttributeValue = Bx;
    function Nx(t2, r6) {
      return t2.attribs != null && Object.prototype.hasOwnProperty.call(t2.attribs, r6) && t2.attribs[r6] != null;
    }
    tr.hasAttrib = Nx;
    function Ox(t2) {
      return t2.name;
    }
    tr.getName = Ox;
    function qx(t2) {
      for (var r6, s = t2.next; s !== null && !(0, k3.isTag)(s); )
        r6 = s, s = r6.next;
      return s;
    }
    tr.nextElementSibling = qx;
    function Px(t2) {
      for (var r6, s = t2.prev; s !== null && !(0, k3.isTag)(s); )
        r6 = s, s = r6.prev;
      return s;
    }
    tr.prevElementSibling = Px;
  });
  var N3 = J((t1) => {
    "use strict";
    Object.defineProperty(t1, "__esModule", { value: true });
    t1.prepend = t1.prependChild = t1.append = t1.appendChild = t1.replaceElement = t1.removeElement = void 0;
    function Fo(t2) {
      if (t2.prev && (t2.prev.next = t2.next), t2.next && (t2.next.prev = t2.prev), t2.parent) {
        var r6 = t2.parent.children;
        r6.splice(r6.lastIndexOf(t2), 1);
      }
    }
    t1.removeElement = Fo;
    function Lx(t2, r6) {
      var s = r6.prev = t2.prev;
      s && (s.next = r6);
      var c = r6.next = t2.next;
      c && (c.prev = r6);
      var p = r6.parent = t2.parent;
      if (p) {
        var w = p.children;
        w[w.lastIndexOf(t2)] = r6;
      }
    }
    t1.replaceElement = Lx;
    function Ix(t2, r6) {
      if (Fo(r6), r6.next = null, r6.parent = t2, t2.children.push(r6) > 1) {
        var s = t2.children[t2.children.length - 2];
        s.next = r6, r6.prev = s;
      } else
        r6.prev = null;
    }
    t1.appendChild = Ix;
    function Rx(t2, r6) {
      Fo(r6);
      var s = t2.parent, c = t2.next;
      if (r6.next = c, r6.prev = t2, t2.next = r6, r6.parent = s, c) {
        if (c.prev = r6, s) {
          var p = s.children;
          p.splice(p.lastIndexOf(c), 0, r6);
        }
      } else
        s && s.children.push(r6);
    }
    t1.append = Rx;
    function zx(t2, r6) {
      if (Fo(r6), r6.parent = t2, r6.prev = null, t2.children.unshift(r6) !== 1) {
        var s = t2.children[1];
        s.prev = r6, r6.next = s;
      } else
        r6.next = null;
    }
    t1.prependChild = zx;
    function Fx(t2, r6) {
      Fo(r6);
      var s = t2.parent;
      if (s) {
        var c = s.children;
        c.splice(c.indexOf(t2), 0, r6);
      }
      t2.prev && (t2.prev.next = r6), r6.parent = s, r6.prev = t2.prev, r6.next = t2, t2.prev = r6;
    }
    t1.prepend = Fx;
  });
  var S5 = J((r1) => {
    "use strict";
    Object.defineProperty(r1, "__esModule", { value: true });
    r1.findAll = r1.existsOne = r1.findOne = r1.findOneChild = r1.find = r1.filter = void 0;
    var Ho = h0();
    function Hx(t2, r6, s, c) {
      return s === void 0 && (s = true), c === void 0 && (c = Infinity), Array.isArray(r6) || (r6 = [r6]), _52(t2, r6, s, c);
    }
    r1.filter = Hx;
    function _52(t2, r6, s, c) {
      for (var p = [], w = 0, T = r6; w < T.length; w++) {
        var k = T[w];
        if (t2(k) && (p.push(k), --c <= 0))
          break;
        if (s && (0, Ho.hasChildren)(k) && k.children.length > 0) {
          var P = _52(t2, k.children, s, c);
          if (p.push.apply(p, P), c -= P.length, c <= 0)
            break;
        }
      }
      return p;
    }
    r1.find = _52;
    function jx(t2, r6) {
      return r6.find(t2);
    }
    r1.findOneChild = jx;
    function O3(t2, r6, s) {
      s === void 0 && (s = true);
      for (var c = null, p = 0; p < r6.length && !c; p++) {
        var w = r6[p];
        if ((0, Ho.isTag)(w))
          t2(w) ? c = w : s && w.children.length > 0 && (c = O3(t2, w.children));
        else
          continue;
      }
      return c;
    }
    r1.findOne = O3;
    function q3(t2, r6) {
      return r6.some(function(s) {
        return (0, Ho.isTag)(s) && (t2(s) || s.children.length > 0 && q3(t2, s.children));
      });
    }
    r1.existsOne = q3;
    function Ux(t2, r6) {
      for (var s, c = [], p = r6.filter(Ho.isTag), w; w = p.shift(); ) {
        var T = (s = w.children) === null || s === void 0 ? void 0 : s.filter(Ho.isTag);
        T && T.length > 0 && p.unshift.apply(p, T), t2(w) && c.push(w);
      }
      return c;
    }
    r1.findAll = Ux;
  });
  var A5 = J((E1) => {
    "use strict";
    Object.defineProperty(E1, "__esModule", { value: true });
    E1.getElementsByTagType = E1.getElementsByTagName = E1.getElementById = E1.getElements = E1.testElement = void 0;
    var di = h0(), ql = S5(), Pl = { tag_name: function(t2) {
      return typeof t2 == "function" ? function(r6) {
        return (0, di.isTag)(r6) && t2(r6.name);
      } : t2 === "*" ? di.isTag : function(r6) {
        return (0, di.isTag)(r6) && r6.name === t2;
      };
    }, tag_type: function(t2) {
      return typeof t2 == "function" ? function(r6) {
        return t2(r6.type);
      } : function(r6) {
        return r6.type === t2;
      };
    }, tag_contains: function(t2) {
      return typeof t2 == "function" ? function(r6) {
        return (0, di.isText)(r6) && t2(r6.data);
      } : function(r6) {
        return (0, di.isText)(r6) && r6.data === t2;
      };
    } };
    function P3(t2, r6) {
      return typeof r6 == "function" ? function(s) {
        return (0, di.isTag)(s) && r6(s.attribs[t2]);
      } : function(s) {
        return (0, di.isTag)(s) && s.attribs[t2] === r6;
      };
    }
    function Wx(t2, r6) {
      return function(s) {
        return t2(s) || r6(s);
      };
    }
    function L3(t2) {
      var r6 = Object.keys(t2).map(function(s) {
        var c = t2[s];
        return Object.prototype.hasOwnProperty.call(Pl, s) ? Pl[s](c) : P3(s, c);
      });
      return r6.length === 0 ? null : r6.reduce(Wx);
    }
    function Gx(t2, r6) {
      var s = L3(t2);
      return s ? s(r6) : true;
    }
    E1.testElement = Gx;
    function Vx(t2, r6, s, c) {
      c === void 0 && (c = Infinity);
      var p = L3(t2);
      return p ? (0, ql.filter)(p, r6, s, c) : [];
    }
    E1.getElements = Vx;
    function $x(t2, r6, s) {
      return s === void 0 && (s = true), Array.isArray(r6) || (r6 = [r6]), (0, ql.findOne)(P3("id", t2), r6, s);
    }
    E1.getElementById = $x;
    function Xx(t2, r6, s, c) {
      return s === void 0 && (s = true), c === void 0 && (c = Infinity), (0, ql.filter)(Pl.tag_name(t2), r6, s, c);
    }
    E1.getElementsByTagName = Xx;
    function Yx(t2, r6, s, c) {
      return s === void 0 && (s = true), c === void 0 && (c = Infinity), (0, ql.filter)(Pl.tag_type(t2), r6, s, c);
    }
    E1.getElementsByTagType = Yx;
  });
  var z3 = J((En) => {
    "use strict";
    Object.defineProperty(En, "__esModule", { value: true });
    En.uniqueSort = En.compareDocumentPosition = En.removeSubsets = void 0;
    var I3 = h0();
    function Kx(t2) {
      for (var r6 = t2.length; --r6 >= 0; ) {
        var s = t2[r6];
        if (r6 > 0 && t2.lastIndexOf(s, r6 - 1) >= 0) {
          t2.splice(r6, 1);
          continue;
        }
        for (var c = s.parent; c; c = c.parent)
          if (t2.includes(c)) {
            t2.splice(r6, 1);
            break;
          }
      }
      return t2;
    }
    En.removeSubsets = Kx;
    function R3(t2, r6) {
      var s = [], c = [];
      if (t2 === r6)
        return 0;
      for (var p = (0, I3.hasChildren)(t2) ? t2 : t2.parent; p; )
        s.unshift(p), p = p.parent;
      for (p = (0, I3.hasChildren)(r6) ? r6 : r6.parent; p; )
        c.unshift(p), p = p.parent;
      for (var w = Math.min(s.length, c.length), T = 0; T < w && s[T] === c[T]; )
        T++;
      if (T === 0)
        return 1;
      var k = s[T - 1], P = k.children, j = s[T], U = c[T];
      return P.indexOf(j) > P.indexOf(U) ? k === r6 ? 4 | 16 : 4 : k === t2 ? 2 | 8 : 2;
    }
    En.compareDocumentPosition = R3;
    function Zx(t2) {
      return t2 = t2.filter(function(r6, s, c) {
        return !c.includes(r6, s + 1);
      }), t2.sort(function(r6, s) {
        var c = R3(r6, s);
        return c & 2 ? -1 : c & 4 ? 1 : 0;
      }), t2;
    }
    En.uniqueSort = Zx;
  });
  var H3 = J((Il) => {
    "use strict";
    Object.defineProperty(Il, "__esModule", { value: true });
    Il.getFeed = void 0;
    var Jx = w5(), jo = A5();
    function Qx(t2) {
      var r6 = Ll(iw, t2);
      return r6 ? r6.name === "feed" ? ew(r6) : tw(r6) : null;
    }
    Il.getFeed = Qx;
    function ew(t2) {
      var r6, s = t2.children, c = { type: "atom", items: (0, jo.getElementsByTagName)("entry", s).map(function(T) {
        var k, P = T.children, j = { media: F3(P) };
        n1(j, "id", "id", P), n1(j, "title", "title", P);
        var U = (k = Ll("link", P)) === null || k === void 0 ? void 0 : k.attribs.href;
        U && (j.link = U);
        var ee = mi("summary", P) || mi("content", P);
        ee && (j.description = ee);
        var G = mi("updated", P);
        return G && (j.pubDate = new Date(G)), j;
      }) };
      n1(c, "id", "id", s), n1(c, "title", "title", s);
      var p = (r6 = Ll("link", s)) === null || r6 === void 0 ? void 0 : r6.attribs.href;
      p && (c.link = p), n1(c, "description", "subtitle", s);
      var w = mi("updated", s);
      return w && (c.updated = new Date(w)), n1(c, "author", "email", s, true), c;
    }
    function tw(t2) {
      var r6, s, c = (s = (r6 = Ll("channel", t2.children)) === null || r6 === void 0 ? void 0 : r6.children) !== null && s !== void 0 ? s : [], p = { type: t2.name.substr(0, 3), id: "", items: (0, jo.getElementsByTagName)("item", t2.children).map(function(T) {
        var k = T.children, P = { media: F3(k) };
        n1(P, "id", "guid", k), n1(P, "title", "title", k), n1(P, "link", "link", k), n1(P, "description", "description", k);
        var j = mi("pubDate", k);
        return j && (P.pubDate = new Date(j)), P;
      }) };
      n1(p, "title", "title", c), n1(p, "link", "link", c), n1(p, "description", "description", c);
      var w = mi("lastBuildDate", c);
      return w && (p.updated = new Date(w)), n1(p, "author", "managingEditor", c, true), p;
    }
    var rw = ["url", "type", "lang"], nw = ["fileSize", "bitrate", "framerate", "samplingrate", "channels", "duration", "height", "width"];
    function F3(t2) {
      return (0, jo.getElementsByTagName)("media:content", t2).map(function(r6) {
        for (var s = r6.attribs, c = { medium: s.medium, isDefault: !!s.isDefault }, p = 0, w = rw; p < w.length; p++) {
          var T = w[p];
          s[T] && (c[T] = s[T]);
        }
        for (var k = 0, P = nw; k < P.length; k++) {
          var T = P[k];
          s[T] && (c[T] = parseInt(s[T], 10));
        }
        return s.expression && (c.expression = s.expression), c;
      });
    }
    function Ll(t2, r6) {
      return (0, jo.getElementsByTagName)(t2, r6, true, 1)[0];
    }
    function mi(t2, r6, s) {
      return s === void 0 && (s = false), (0, Jx.textContent)((0, jo.getElementsByTagName)(t2, r6, s, 1)).trim();
    }
    function n1(t2, r6, s, c, p) {
      p === void 0 && (p = false);
      var w = mi(s, c, p);
      w && (t2[r6] = w);
    }
    function iw(t2) {
      return t2 === "rss" || t2 === "feed" || t2 === "rdf:RDF";
    }
  });
  var T5 = J((At) => {
    "use strict";
    var aw = At && At.__createBinding || (Object.create ? function(t2, r6, s, c) {
      c === void 0 && (c = s), Object.defineProperty(t2, c, { enumerable: true, get: function() {
        return r6[s];
      } });
    } : function(t2, r6, s, c) {
      c === void 0 && (c = s), t2[c] = r6[s];
    }), pi = At && At.__exportStar || function(t2, r6) {
      for (var s in t2)
        s !== "default" && !Object.prototype.hasOwnProperty.call(r6, s) && aw(r6, t2, s);
    };
    Object.defineProperty(At, "__esModule", { value: true });
    At.hasChildren = At.isDocument = At.isComment = At.isText = At.isCDATA = At.isTag = void 0;
    pi(w5(), At);
    pi(B3(), At);
    pi(N3(), At);
    pi(S5(), At);
    pi(A5(), At);
    pi(z3(), At);
    pi(H3(), At);
    var ya = h0();
    Object.defineProperty(At, "isTag", { enumerable: true, get: function() {
      return ya.isTag;
    } });
    Object.defineProperty(At, "isCDATA", { enumerable: true, get: function() {
      return ya.isCDATA;
    } });
    Object.defineProperty(At, "isText", { enumerable: true, get: function() {
      return ya.isText;
    } });
    Object.defineProperty(At, "isComment", { enumerable: true, get: function() {
      return ya.isComment;
    } });
    Object.defineProperty(At, "isDocument", { enumerable: true, get: function() {
      return ya.isDocument;
    } });
    Object.defineProperty(At, "hasChildren", { enumerable: true, get: function() {
      return ya.hasChildren;
    } });
  });
  var C5 = J((C1) => {
    "use strict";
    var ow = C1 && C1.__extends || function() {
      var t2 = function(r6, s) {
        return t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, p) {
          c.__proto__ = p;
        } || function(c, p) {
          for (var w in p)
            Object.prototype.hasOwnProperty.call(p, w) && (c[w] = p[w]);
        }, t2(r6, s);
      };
      return function(r6, s) {
        if (typeof s != "function" && s !== null)
          throw new TypeError("Class extends value " + String(s) + " is not a constructor or null");
        t2(r6, s);
        function c() {
          this.constructor = r6;
        }
        r6.prototype = s === null ? Object.create(s) : (c.prototype = s.prototype, new c());
      };
    }(), sw = C1 && C1.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(C1, "__esModule", { value: true });
    C1.parseFeed = C1.FeedHandler = C1.getFeed = void 0;
    var j3 = sw(h0()), E5 = T5();
    Object.defineProperty(C1, "getFeed", { enumerable: true, get: function() {
      return E5.getFeed;
    } });
    var lw = s5(), uw = function(t2) {
      ow(r6, t2);
      function r6(s, c) {
        var p = this;
        return typeof s == "object" && (s = void 0, c = s), p = t2.call(this, s, c) || this, p;
      }
      return r6.prototype.onend = function() {
        var s = (0, E5.getFeed)(this.dom);
        s ? (this.feed = s, this.handleCallback(null)) : this.handleCallback(new Error("couldn't find root of feed"));
      }, r6;
    }(j3.default);
    C1.FeedHandler = uw;
    function cw(t2, r6) {
      r6 === void 0 && (r6 = { xmlMode: true });
      var s = new j3.default(null, r6);
      return new lw.Parser(s, r6).end(t2), (0, E5.getFeed)(s.dom);
    }
    C1.parseFeed = cw;
  });
  var V3 = J((it) => {
    "use strict";
    var U3 = it && it.__createBinding || (Object.create ? function(t2, r6, s, c) {
      c === void 0 && (c = s), Object.defineProperty(t2, c, { enumerable: true, get: function() {
        return r6[s];
      } });
    } : function(t2, r6, s, c) {
      c === void 0 && (c = s), t2[c] = r6[s];
    }), fw = it && it.__setModuleDefault || (Object.create ? function(t2, r6) {
      Object.defineProperty(t2, "default", { enumerable: true, value: r6 });
    } : function(t2, r6) {
      t2.default = r6;
    }), W3 = it && it.__importStar || function(t2) {
      if (t2 && t2.__esModule)
        return t2;
      var r6 = {};
      if (t2 != null)
        for (var s in t2)
          s !== "default" && Object.prototype.hasOwnProperty.call(t2, s) && U3(r6, t2, s);
      return fw(r6, t2), r6;
    }, hw = it && it.__exportStar || function(t2, r6) {
      for (var s in t2)
        s !== "default" && !Object.prototype.hasOwnProperty.call(r6, s) && U3(r6, t2, s);
    }, dw = it && it.__importDefault || function(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    };
    Object.defineProperty(it, "__esModule", { value: true });
    it.RssHandler = it.DefaultHandler = it.DomUtils = it.ElementType = it.Tokenizer = it.createDomStream = it.parseDOM = it.parseDocument = it.DomHandler = it.Parser = void 0;
    var k5 = s5();
    Object.defineProperty(it, "Parser", { enumerable: true, get: function() {
      return k5.Parser;
    } });
    var Rl = h0();
    Object.defineProperty(it, "DomHandler", { enumerable: true, get: function() {
      return Rl.DomHandler;
    } });
    Object.defineProperty(it, "DefaultHandler", { enumerable: true, get: function() {
      return Rl.DomHandler;
    } });
    function G3(t2, r6) {
      var s = new Rl.DomHandler(void 0, r6);
      return new k5.Parser(s, r6).end(t2), s.root;
    }
    it.parseDocument = G3;
    function mw(t2, r6) {
      return G3(t2, r6).children;
    }
    it.parseDOM = mw;
    function pw(t2, r6, s) {
      var c = new Rl.DomHandler(t2, r6, s);
      return new k5.Parser(c, r6);
    }
    it.createDomStream = pw;
    var gw = o5();
    Object.defineProperty(it, "Tokenizer", { enumerable: true, get: function() {
      return dw(gw).default;
    } });
    var vw = W3(pa());
    it.ElementType = vw;
    hw(C5(), it);
    it.DomUtils = W3(T5());
    var yw = C5();
    Object.defineProperty(it, "RssHandler", { enumerable: true, get: function() {
      return yw.FeedHandler;
    } });
  });
  var X3 = J((sC, $3) => {
    "use strict";
    function bw(t2) {
      return true;
    }
    $3.exports = { shouldProcessEveryNode: bw };
  });
  var b4 = J((lC, y4) => {
    var xw = 1 / 0, ww = "[object Symbol]", _w = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Sw = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, zl = "\\ud800-\\udfff", Y3 = "\\u0300-\\u036f\\ufe20-\\ufe23", K3 = "\\u20d0-\\u20f0", Z3 = "\\u2700-\\u27bf", J3 = "a-z\\xdf-\\xf6\\xf8-\\xff", Aw = "\\xac\\xb1\\xd7\\xf7", Tw = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ew = "\\u2000-\\u206f", Cw = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Q3 = "A-Z\\xc0-\\xd6\\xd8-\\xde", e4 = "\\ufe0e\\ufe0f", t4 = Aw + Tw + Ew + Cw, M5 = "['\u2019]", kw = "[" + zl + "]", r42 = "[" + t4 + "]", Fl = "[" + Y3 + K3 + "]", n4 = "\\d+", Mw = "[" + Z3 + "]", i4 = "[" + J3 + "]", a4 = "[^" + zl + t4 + n4 + Z3 + J3 + Q3 + "]", D5 = "\\ud83c[\\udffb-\\udfff]", Dw = "(?:" + Fl + "|" + D5 + ")", o4 = "[^" + zl + "]", B5 = "(?:\\ud83c[\\udde6-\\uddff]){2}", N5 = "[\\ud800-\\udbff][\\udc00-\\udfff]", ba = "[" + Q3 + "]", s4 = "\\u200d", l4 = "(?:" + i4 + "|" + a4 + ")", Bw = "(?:" + ba + "|" + a4 + ")", u4 = "(?:" + M5 + "(?:d|ll|m|re|s|t|ve))?", c4 = "(?:" + M5 + "(?:D|LL|M|RE|S|T|VE))?", f4 = Dw + "?", h4 = "[" + e4 + "]?", Nw = "(?:" + s4 + "(?:" + [o4, B5, N5].join("|") + ")" + h4 + f4 + ")*", d4 = h4 + f4 + Nw, Ow = "(?:" + [Mw, B5, N5].join("|") + ")" + d4, qw = "(?:" + [o4 + Fl + "?", Fl, B5, N5, kw].join("|") + ")", Pw = RegExp(M5, "g"), Lw = RegExp(Fl, "g"), Iw = RegExp(D5 + "(?=" + D5 + ")|" + qw + d4, "g"), Rw = RegExp([ba + "?" + i4 + "+" + u4 + "(?=" + [r42, ba, "$"].join("|") + ")", Bw + "+" + c4 + "(?=" + [r42, ba + l4, "$"].join("|") + ")", ba + "?" + l4 + "+" + u4, ba + "+" + c4, n4, Ow].join("|"), "g"), zw = RegExp("[" + s4 + zl + Y3 + K3 + e4 + "]"), Fw = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Hw = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "ss" }, jw = typeof global == "object" && global && global.Object === Object && global, Uw = typeof self == "object" && self && self.Object === Object && self, Ww = jw || Uw || Function("return this")();
    function Gw(t2, r6, s, c) {
      var p = -1, w = t2 ? t2.length : 0;
      for (c && w && (s = t2[++p]); ++p < w; )
        s = r6(s, t2[p], p, t2);
      return s;
    }
    function Vw(t2) {
      return t2.split("");
    }
    function $w(t2) {
      return t2.match(_w) || [];
    }
    function Xw(t2) {
      return function(r6) {
        return t2 == null ? void 0 : t2[r6];
      };
    }
    var Yw = Xw(Hw);
    function m4(t2) {
      return zw.test(t2);
    }
    function Kw(t2) {
      return Fw.test(t2);
    }
    function Zw(t2) {
      return m4(t2) ? Jw(t2) : Vw(t2);
    }
    function Jw(t2) {
      return t2.match(Iw) || [];
    }
    function Qw(t2) {
      return t2.match(Rw) || [];
    }
    var e_ = Object.prototype, t_ = e_.toString, p4 = Ww.Symbol, g4 = p4 ? p4.prototype : void 0, v4 = g4 ? g4.toString : void 0;
    function r_(t2, r6, s) {
      var c = -1, p = t2.length;
      r6 < 0 && (r6 = -r6 > p ? 0 : p + r6), s = s > p ? p : s, s < 0 && (s += p), p = r6 > s ? 0 : s - r6 >>> 0, r6 >>>= 0;
      for (var w = Array(p); ++c < p; )
        w[c] = t2[c + r6];
      return w;
    }
    function n_(t2) {
      if (typeof t2 == "string")
        return t2;
      if (l_(t2))
        return v4 ? v4.call(t2) : "";
      var r6 = t2 + "";
      return r6 == "0" && 1 / t2 == -xw ? "-0" : r6;
    }
    function i_(t2, r6, s) {
      var c = t2.length;
      return s = s === void 0 ? c : s, !r6 && s >= c ? t2 : r_(t2, r6, s);
    }
    function a_(t2) {
      return function(r6) {
        r6 = Hl(r6);
        var s = m4(r6) ? Zw(r6) : void 0, c = s ? s[0] : r6.charAt(0), p = s ? i_(s, 1).join("") : r6.slice(1);
        return c[t2]() + p;
      };
    }
    function o_(t2) {
      return function(r6) {
        return Gw(d_(f_(r6).replace(Pw, "")), t2, "");
      };
    }
    function s_(t2) {
      return !!t2 && typeof t2 == "object";
    }
    function l_(t2) {
      return typeof t2 == "symbol" || s_(t2) && t_.call(t2) == ww;
    }
    function Hl(t2) {
      return t2 == null ? "" : n_(t2);
    }
    var u_ = o_(function(t2, r6, s) {
      return r6 = r6.toLowerCase(), t2 + (s ? c_(r6) : r6);
    });
    function c_(t2) {
      return h_(Hl(t2).toLowerCase());
    }
    function f_(t2) {
      return t2 = Hl(t2), t2 && t2.replace(Sw, Yw).replace(Lw, "");
    }
    var h_ = a_("toUpperCase");
    function d_(t2, r6, s) {
      return t2 = Hl(t2), r6 = s ? void 0 : r6, r6 === void 0 ? Kw(t2) ? Qw(t2) : $w(t2) : t2.match(r6) || [];
    }
    y4.exports = u_;
  });
  var w4 = J((uC, x4) => {
    var m_ = z0(), p_ = qo(), g_ = m_(function(r6) {
      var s = [];
      for (var c in r6)
        p_(c, r6) && (s[s.length] = [c, r6[c]]);
      return s;
    });
    x4.exports = g_;
  });
  var O5 = J((cC, _42) => {
    var jl = z0(), xa = fr(), hr = Do();
    function v_(t2) {
      return function r6(s, c, p) {
        switch (arguments.length) {
          case 0:
            return r6;
          case 1:
            return hr(s) ? r6 : xa(function(w, T) {
              return t2(s, w, T);
            });
          case 2:
            return hr(s) && hr(c) ? r6 : hr(s) ? xa(function(w, T) {
              return t2(w, c, T);
            }) : hr(c) ? xa(function(w, T) {
              return t2(s, w, T);
            }) : jl(function(w) {
              return t2(s, c, w);
            });
          default:
            return hr(s) && hr(c) && hr(p) ? r6 : hr(s) && hr(c) ? xa(function(w, T) {
              return t2(w, T, p);
            }) : hr(s) && hr(p) ? xa(function(w, T) {
              return t2(w, c, T);
            }) : hr(c) && hr(p) ? xa(function(w, T) {
              return t2(s, w, T);
            }) : hr(s) ? jl(function(w) {
              return t2(w, c, p);
            }) : hr(c) ? jl(function(w) {
              return t2(s, w, p);
            }) : hr(p) ? jl(function(w) {
              return t2(s, c, w);
            }) : t2(s, c, p);
        }
      };
    }
    _42.exports = v_;
  });
  var A4 = J((fC, S4) => {
    var y_ = O5(), b_ = Tl(), x_ = y_(b_);
    S4.exports = x_;
  });
  var E4 = J((hC, T4) => {
    function w_(t2) {
      for (var r6 = [], s; !(s = t2.next()).done; )
        r6.push(s.value);
      return r6;
    }
    T4.exports = w_;
  });
  var k4 = J((dC, C4) => {
    function __(t2, r6, s) {
      for (var c = 0, p = s.length; c < p; ) {
        if (t2(r6, s[c]))
          return true;
        c += 1;
      }
      return false;
    }
    C4.exports = __;
  });
  var D4 = J((mC, M4) => {
    function S_(t2) {
      var r6 = String(t2).match(/^function (\w*)/);
      return r6 == null ? "" : r6[1];
    }
    M4.exports = S_;
  });
  var N4 = J((pC, B4) => {
    function A_(t2, r6) {
      return t2 === r6 ? t2 !== 0 || 1 / t2 == 1 / r6 : t2 !== t2 && r6 !== r6;
    }
    B4.exports = typeof Object.is == "function" ? Object.is : A_;
  });
  var q4 = J((gC, O4) => {
    var T_ = z0(), E_ = T_(function(r6) {
      return r6 === null ? "Null" : r6 === void 0 ? "Undefined" : Object.prototype.toString.call(r6).slice(8, -1);
    });
    O4.exports = E_;
  });
  var H4 = J((vC, F4) => {
    var P4 = E4(), L4 = k4(), C_ = D4(), k_ = qo(), q5 = N4(), I4 = El(), R4 = q4();
    function z4(t2, r6, s, c) {
      var p = P4(t2), w = P4(r6);
      function T(k, P) {
        return P5(k, P, s.slice(), c.slice());
      }
      return !L4(function(k, P) {
        return !L4(T, P, k);
      }, w, p);
    }
    function P5(t2, r6, s, c) {
      if (q5(t2, r6))
        return true;
      var p = R4(t2);
      if (p !== R4(r6) || t2 == null || r6 == null)
        return false;
      if (typeof t2["fantasy-land/equals"] == "function" || typeof r6["fantasy-land/equals"] == "function")
        return typeof t2["fantasy-land/equals"] == "function" && t2["fantasy-land/equals"](r6) && typeof r6["fantasy-land/equals"] == "function" && r6["fantasy-land/equals"](t2);
      if (typeof t2.equals == "function" || typeof r6.equals == "function")
        return typeof t2.equals == "function" && t2.equals(r6) && typeof r6.equals == "function" && r6.equals(t2);
      switch (p) {
        case "Arguments":
        case "Array":
        case "Object":
          if (typeof t2.constructor == "function" && C_(t2.constructor) === "Promise")
            return t2 === r6;
          break;
        case "Boolean":
        case "Number":
        case "String":
          if (!(typeof t2 == typeof r6 && q5(t2.valueOf(), r6.valueOf())))
            return false;
          break;
        case "Date":
          if (!q5(t2.valueOf(), r6.valueOf()))
            return false;
          break;
        case "Error":
          return t2.name === r6.name && t2.message === r6.message;
        case "RegExp":
          if (!(t2.source === r6.source && t2.global === r6.global && t2.ignoreCase === r6.ignoreCase && t2.multiline === r6.multiline && t2.sticky === r6.sticky && t2.unicode === r6.unicode))
            return false;
          break;
      }
      for (var w = s.length - 1; w >= 0; ) {
        if (s[w] === t2)
          return c[w] === r6;
        w -= 1;
      }
      switch (p) {
        case "Map":
          return t2.size !== r6.size ? false : z4(t2.entries(), r6.entries(), s.concat([t2]), c.concat([r6]));
        case "Set":
          return t2.size !== r6.size ? false : z4(t2.values(), r6.values(), s.concat([t2]), c.concat([r6]));
        case "Arguments":
        case "Array":
        case "Object":
        case "Boolean":
        case "Number":
        case "String":
        case "Date":
        case "Error":
        case "RegExp":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "ArrayBuffer":
          break;
        default:
          return false;
      }
      var T = I4(t2);
      if (T.length !== I4(r6).length)
        return false;
      var k = s.concat([t2]), P = c.concat([r6]);
      for (w = T.length - 1; w >= 0; ) {
        var j = T[w];
        if (!(k_(j, r6) && P5(r6[j], t2[j], k, P)))
          return false;
        w -= 1;
      }
      return true;
    }
    F4.exports = P5;
  });
  var L5 = J((yC, j4) => {
    var M_ = fr(), D_ = H4(), B_ = M_(function(r6, s) {
      return D_(r6, s, [], []);
    });
    j4.exports = B_;
  });
  var G4 = J((bC, W4) => {
    var N_ = fr(), O_ = Q2(), U4 = Oo(), q_ = function() {
      function t2(r6, s) {
        this.xf = s, this.n = r6, this.i = 0;
      }
      return t2.prototype["@@transducer/init"] = U4.init, t2.prototype["@@transducer/result"] = U4.result, t2.prototype["@@transducer/step"] = function(r6, s) {
        this.i += 1;
        var c = this.n === 0 ? r6 : this.xf["@@transducer/step"](r6, s);
        return this.n >= 0 && this.i >= this.n ? O_(c) : c;
      }, t2;
    }(), P_ = N_(function(r6, s) {
      return new q_(r6, s);
    });
    W4.exports = P_;
  });
  var $4 = J((xC, V4) => {
    var L_ = Z2(), I_ = O5(), R_ = I_(L_("slice", function(r6, s, c) {
      return Array.prototype.slice.call(c, r6, s);
    }));
    V4.exports = R_;
  });
  var Y4 = J((wC, X4) => {
    var z_ = fr(), F_ = No(), H_ = G4(), j_ = $4(), U_ = z_(F_(["take"], H_, function(r6, s) {
      return j_(0, r6 < 0 ? Infinity : r6, s);
    }));
    X4.exports = U_;
  });
  var Z4 = J((_C, K4) => {
    var W_ = fr(), G_ = L5(), V_ = Y4(), $_ = W_(function(t2, r6) {
      return G_(V_(t2.length, r6), t2);
    });
    K4.exports = $_;
  });
  var Q4 = J((SC, J4) => {
    var X_ = L5();
    function Y_(t2, r6, s) {
      var c, p;
      if (typeof t2.indexOf == "function")
        switch (typeof r6) {
          case "number":
            if (r6 === 0) {
              for (c = 1 / r6; s < t2.length; ) {
                if (p = t2[s], p === 0 && 1 / p === c)
                  return s;
                s += 1;
              }
              return -1;
            } else if (r6 !== r6) {
              for (; s < t2.length; ) {
                if (p = t2[s], typeof p == "number" && p !== p)
                  return s;
                s += 1;
              }
              return -1;
            }
            return t2.indexOf(r6, s);
          case "string":
          case "boolean":
          case "function":
          case "undefined":
            return t2.indexOf(r6, s);
          case "object":
            if (r6 === null)
              return t2.indexOf(r6, s);
        }
      for (; s < t2.length; ) {
        if (X_(t2[s], r6))
          return s;
        s += 1;
      }
      return -1;
    }
    J4.exports = Y_;
  });
  var tc = J((AC, ec) => {
    var K_ = Q4();
    function Z_(t2, r6) {
      return K_(r6, t2, 0) >= 0;
    }
    ec.exports = Z_;
  });
  var nc = J((TC, rc) => {
    var J_ = tc(), Q_ = fr(), eS = Q_(J_);
    rc.exports = eS;
  });
  var ac = J((EC, ic) => {
    "use strict";
    var tS = ["accept", "acceptCharset", "accessKey", "action", "allowFullScreen", "allowTransparency", "alt", "async", "autoComplete", "autoFocus", "autoPlay", "capture", "cellPadding", "cellSpacing", "challenge", "charSet", "checked", "cite", "classID", "className", "colSpan", "cols", "content", "contentEditable", "contextMenu", "controls", "coords", "crossOrigin", "data", "dateTime", "default", "defer", "dir", "disabled", "download", "draggable", "encType", "form", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "headers", "height", "hidden", "high", "href", "hrefLang", "htmlFor", "httpEquiv", "icon", "id", "inputMode", "integrity", "is", "keyParams", "keyType", "kind", "label", "lang", "list", "loop", "low", "manifest", "marginHeight", "marginWidth", "max", "maxLength", "media", "mediaGroup", "method", "min", "minLength", "multiple", "muted", "name", "noValidate", "nonce", "open", "optimum", "pattern", "placeholder", "poster", "preload", "profile", "radioGroup", "readOnly", "rel", "required", "reversed", "role", "rowSpan", "rows", "sandbox", "scope", "scoped", "scrolling", "seamless", "selected", "shape", "size", "sizes", "span", "spellCheck", "src", "srcDoc", "srcLang", "srcSet", "start", "step", "style", "summary", "tabIndex", "target", "title", "type", "useMap", "value", "width", "wmode", "wrap", "onClick"], rS = ["autoCapitalize", "autoCorrect", "color", "itemProp", "itemScope", "itemType", "itemRef", "itemID", "security", "unselectable", "results", "autoSave"], nS = ["accentHeight", "accumulate", "additive", "alignmentBaseline", "allowReorder", "alphabetic", "amplitude", "arabicForm", "ascent", "attributeName", "attributeType", "autoReverse", "azimuth", "baseFrequency", "baseProfile", "baselineShift", "bbox", "begin", "bias", "by", "calcMode", "capHeight", "clip", "clipPath", "clipPathUnits", "clipRule", "colorInterpolation", "colorInterpolationFilters", "colorProfile", "colorRendering", "contentScriptType", "contentStyleType", "cursor", "cx", "cy", "d", "decelerate", "descent", "diffuseConstant", "direction", "display", "divisor", "dominantBaseline", "dur", "dx", "dy", "edgeMode", "elevation", "enableBackground", "end", "exponent", "externalResourcesRequired", "fill", "fillOpacity", "fillRule", "filter", "filterRes", "filterUnits", "floodColor", "floodOpacity", "focusable", "fontFamily", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontWeight", "format", "from", "fx", "fy", "g1", "g2", "glyphName", "glyphOrientationHorizontal", "glyphOrientationVertical", "glyphRef", "gradientTransform", "gradientUnits", "hanging", "horizAdvX", "horizOriginX", "ideographic", "imageRendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kernelMatrix", "kernelUnitLength", "kerning", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "letterSpacing", "lightingColor", "limitingConeAngle", "local", "markerEnd", "markerHeight", "markerMid", "markerStart", "markerUnits", "markerWidth", "mask", "maskContentUnits", "maskUnits", "mathematical", "mode", "numOctaves", "offset", "opacity", "operator", "order", "orient", "orientation", "origin", "overflow", "overlinePosition", "overlineThickness", "paintOrder", "panose1", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointerEvents", "points", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "r", "radius", "refX", "refY", "renderingIntent", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "restart", "result", "rotate", "rx", "ry", "scale", "seed", "shapeRendering", "slope", "spacing", "specularConstant", "specularExponent", "speed", "spreadMethod", "startOffset", "stdDeviation", "stemh", "stemv", "stitchTiles", "stopColor", "stopOpacity", "strikethroughPosition", "strikethroughThickness", "string", "stroke", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textAnchor", "textDecoration", "textLength", "textRendering", "to", "transform", "u1", "u2", "underlinePosition", "underlineThickness", "unicode", "unicodeBidi", "unicodeRange", "unitsPerEm", "vAlphabetic", "vHanging", "vIdeographic", "vMathematical", "values", "vectorEffect", "version", "vertAdvY", "vertOriginX", "vertOriginY", "viewBox", "viewTarget", "visibility", "widths", "wordSpacing", "writingMode", "x", "x1", "x2", "xChannelSelector", "xHeight", "xlinkActuate", "xlinkArcrole", "xlinkHref", "xlinkRole", "xlinkShow", "xlinkTitle", "xlinkType", "xmlns", "xmlnsXlink", "xmlBase", "xmlLang", "xmlSpace", "y", "y1", "y2", "yChannelSelector", "z", "zoomAndPan"], iS = tS.concat(rS).concat(nS).reduce(function(t2, r6) {
      let s = r6.toLowerCase();
      return s !== r6 && (t2[s] = r6), t2;
    }, {});
    ic.exports = iS;
  });
  var I5 = J((CC, oc) => {
    "use strict";
    var aS = b4(), oS = w4(), sS = A4(), lS = Z4(), uS = (Ge(), F), cS = nc(), fS = ac();
    function hS(t2) {
      t2 = t2 || "";
      let r6 = t2.split(/;(?!base64)/), s, c, p, w = {};
      for (let T = 0; T < r6.length; ++T)
        s = r6[T].split(":"), s.length > 2 && (s[1] = s.slice(1).join(":")), c = s[0], p = s[1], typeof p == "string" && (p = p.trim()), c != null && p != null && c.length > 0 && p.length > 0 && (w[aS(c)] = p);
      return w;
    }
    var dS = ["allowFullScreen", "allowpaymentrequest", "async", "autoFocus", "autoPlay", "checked", "controls", "default", "disabled", "formNoValidate", "hidden", "ismap", "itemScope", "loop", "multiple", "muted", "nomodule", "noValidate", "open", "playsinline", "readOnly", "required", "reversed", "selected", "truespeed"];
    function mS(t2, r6, s, c) {
      let p = { key: r6 };
      t2.attribs && (p = sS(function(T, k) {
        let P = k[0], j = k[1];
        return P = fS[P.replace(/[-:]/, "")] || P, P === "style" ? j = hS(j) : P === "class" ? P = "className" : P === "for" ? P = "htmlFor" : lS("on", P) && (j = Function(j)), cS(P, dS) && (j || "") === "" && (j = P), T[P] = j, T;
      }, p, oS(t2.attribs))), c = c || [];
      let w = s != null ? [s].concat(c) : c;
      return uS.createElement.apply(null, [t2.name, p].concat(w));
    }
    oc.exports = { createElement: mS };
  });
  var R5 = J((kC, lc) => {
    "use strict";
    var sc = I5(), pS = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr", "menuitem", "textarea"];
    function gS() {
      function t2(r6, s, c) {
        return r6.type === "text" ? r6.data : r6.type === "comment" ? false : pS.indexOf(r6.name) > -1 ? sc.createElement(r6, c) : sc.createElement(r6, c, r6.data, s);
      }
      return { processDefaultNode: t2 };
    }
    lc.exports = gS;
  });
  var z5 = J((MC, uc) => {
    "use strict";
    var vS = X3(), yS = R5();
    function bS() {
      let t2 = new yS();
      return { defaultProcessingInstructions: [{ shouldProcessNode: vS.shouldProcessEveryNode, processNode: t2.processDefaultNode }] };
    }
    uc.exports = bS;
  });
  var F5 = J((DC, cc) => {
    "use strict";
    function xS() {
      return true;
    }
    cc.exports = { alwaysValid: xS };
  });
  var hc = J((BC, fc) => {
    "use strict";
    var wS = A7(), _S = O7(), SS = m9(), AS = S9(), TS = D9(), ES = V3().Parser, CS = h0().DomHandler, kS = z5(), MS = F5(), DS = I5();
    function BS(t2) {
      function r6(w) {
        t2 = t2 || {}, t2.decodeEntities = true;
        let T = new CS();
        return new ES(T, t2).parseComplete(w), T.dom.filter(function(P) {
          return P.type !== "directive";
        });
      }
      function s(w, T, k, P, j) {
        if (T(w)) {
          wS(function(ee) {
            ee.shouldPreprocessNode(w) && ee.preprocessNode(w, j);
          }, P || []);
          let U = _S(function(ee) {
            return ee.shouldProcessNode(w);
          }, k || []);
          if (U != null) {
            let ee = SS(function(G) {
              return G == null || G === false;
            }, AS(TS)(function(G, ae) {
              return s(G, T, k, P, ae);
            }, w.children || []));
            return U.replaceChildren ? DS.createElement(w, j, w.data, [U.processNode(w, ee, j)]) : U.processNode(w, ee, j);
          } else
            return false;
        } else
          return false;
      }
      function c(w, T, k, P) {
        let U = r6(w).map(function(ee, G) {
          return s(ee, T, k, P, G);
        });
        return U.length <= 1 ? U[0] : U;
      }
      function p(w) {
        let T = new kS();
        return c(w, MS.alwaysValid, T.defaultProcessingInstructions);
      }
      return { parse: p, parseWithInstructions: c };
    }
    fc.exports = BS;
  });
  var mc = J((NC, dc) => {
    "use strict";
    var NS = hc(), OS = z5(), qS = F5(), PS = R5();
    dc.exports = { Parser: NS, ProcessingInstructions: OS, IsValidNodeDefinitions: qS, ProcessNodeDefinitions: PS };
  });
  var rf = J((ON, tf) => {
    "use strict";
    var ZA = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    tf.exports = ZA;
  });
  var sf = J((qN, of) => {
    "use strict";
    var JA = rf();
    function nf() {
    }
    function af() {
    }
    af.resetWarningCache = nf;
    of.exports = function() {
      function t2(c, p, w, T, k, P) {
        if (P !== JA) {
          var j = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
          throw j.name = "Invariant Violation", j;
        }
      }
      t2.isRequired = t2;
      function r6() {
        return t2;
      }
      var s = { array: t2, bool: t2, func: t2, number: t2, object: t2, string: t2, symbol: t2, any: t2, arrayOf: r6, element: t2, elementType: t2, instanceOf: r6, node: t2, objectOf: r6, oneOf: r6, oneOfType: r6, shape: r6, exact: r6, checkPropTypes: af, resetWarningCache: nf };
      return s.PropTypes = s, s;
    };
  });
  var Gt = J((IN, lf) => {
    lf.exports = sf()();
    var PN, LN;
  });
  var _f = J((ou) => {
    "use strict";
    Object.defineProperty(ou, "__esModule", { value: true });
    ou.Circles = void 0;
    var as = wf((Ge(), F)), Nn = wf(Gt());
    function wf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var T8 = function(r6) {
      return as.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 135 135", xmlns: "http://www.w3.org/2000/svg", fill: r6.color, "aria-label": r6.label }, as.default.createElement("path", { d: "M67.447 58c5.523 0 10-4.477 10-10s-4.477-10-10-10-10 4.477-10 10 4.477 10 10 10zm9.448 9.447c0 5.523 4.477 10 10 10 5.522 0 10-4.477 10-10s-4.478-10-10-10c-5.523 0-10 4.477-10 10zm-9.448 9.448c-5.523 0-10 4.477-10 10 0 5.522 4.477 10 10 10s10-4.478 10-10c0-5.523-4.477-10-10-10zM58 67.447c0-5.523-4.477-10-10-10s-10 4.477-10 10 4.477 10 10 10 10-4.477 10-10z" }, as.default.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 67 67", to: "-360 67 67", dur: "2.5s", repeatCount: "indefinite" })), as.default.createElement("path", { d: "M28.19 40.31c6.627 0 12-5.374 12-12 0-6.628-5.373-12-12-12-6.628 0-12 5.372-12 12 0 6.626 5.372 12 12 12zm30.72-19.825c4.686 4.687 12.284 4.687 16.97 0 4.686-4.686 4.686-12.284 0-16.97-4.686-4.687-12.284-4.687-16.97 0-4.687 4.686-4.687 12.284 0 16.97zm35.74 7.705c0 6.627 5.37 12 12 12 6.626 0 12-5.373 12-12 0-6.628-5.374-12-12-12-6.63 0-12 5.372-12 12zm19.822 30.72c-4.686 4.686-4.686 12.284 0 16.97 4.687 4.686 12.285 4.686 16.97 0 4.687-4.686 4.687-12.284 0-16.97-4.685-4.687-12.283-4.687-16.97 0zm-7.704 35.74c-6.627 0-12 5.37-12 12 0 6.626 5.373 12 12 12s12-5.374 12-12c0-6.63-5.373-12-12-12zm-30.72 19.822c-4.686-4.686-12.284-4.686-16.97 0-4.686 4.687-4.686 12.285 0 16.97 4.686 4.687 12.284 4.687 16.97 0 4.687-4.685 4.687-12.283 0-16.97zm-35.74-7.704c0-6.627-5.372-12-12-12-6.626 0-12 5.373-12 12s5.374 12 12 12c6.628 0 12-5.373 12-12zm-19.823-30.72c4.687-4.686 4.687-12.284 0-16.97-4.686-4.686-12.284-4.686-16.97 0-4.687 4.686-4.687 12.284 0 16.97 4.686 4.687 12.284 4.687 16.97 0z" }, as.default.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 67 67", to: "360 67 67", dur: "8s", repeatCount: "indefinite" })));
    };
    ou.Circles = T8;
    T8.propTypes = { height: Nn.default.oneOfType([Nn.default.string, Nn.default.number]), width: Nn.default.oneOfType([Nn.default.string, Nn.default.number]), color: Nn.default.string, label: Nn.default.string };
    T8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading" };
  });
  var Af = J((su) => {
    "use strict";
    Object.defineProperty(su, "__esModule", { value: true });
    su.Watch = void 0;
    var Ea = Sf((Ge(), F)), V0 = Sf(Gt());
    function Sf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var E8 = function(r6) {
      return Ea.default.createElement("svg", { width: r6.width, height: r6.height, version: "1.1", id: "L2", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", viewBox: "0 0 100 100", enableBackground: "new 0 0 100 100", xmlSpace: "preserve", "aria-label": r6.label }, Ea.default.createElement("circle", { fill: "none", stroke: r6.color, strokeWidth: "4", strokeMiterlimit: "10", cx: "50", cy: "50", r: r6.radius }), Ea.default.createElement("line", { fill: "none", strokeLinecap: "round", stroke: r6.color, strokeWidth: "4", strokeMiterlimit: "10", x1: "50", y1: "50", x2: "85", y2: "50.5" }, Ea.default.createElement("animateTransform", { attributeName: "transform", dur: "2s", type: "rotate", from: "0 50 50", to: "360 50 50", repeatCount: "indefinite" })), Ea.default.createElement("line", { fill: "none", strokeLinecap: "round", stroke: r6.color, strokeWidth: "4", strokeMiterlimit: "10", x1: "50", y1: "50", x2: "49.5", y2: "74" }, Ea.default.createElement("animateTransform", { attributeName: "transform", dur: "15s", type: "rotate", from: "0 50 50", to: "360 50 50", repeatCount: "indefinite" })));
    };
    su.Watch = E8;
    E8.propTypes = { height: V0.default.oneOfType([V0.default.string, V0.default.number]), width: V0.default.oneOfType([V0.default.string, V0.default.number]), color: V0.default.string, label: V0.default.string, radius: V0.default.number };
    E8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading", radius: 48 };
  });
  var Ef = J((lu) => {
    "use strict";
    Object.defineProperty(lu, "__esModule", { value: true });
    lu.Audio = void 0;
    var g0 = Tf((Ge(), F)), On = Tf(Gt());
    function Tf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var C8 = function(r6) {
      return g0.default.createElement("svg", { height: r6.height, width: r6.width, fill: r6.color, viewBox: "0 0 55 80", xmlns: "http://www.w3.org/2000/svg", "aria-label": r6.label }, g0.default.createElement("g", { transform: "matrix(1 0 0 -1 0 80)" }, g0.default.createElement("rect", { width: "10", height: "20", rx: "3" }, g0.default.createElement("animate", { attributeName: "height", begin: "0s", dur: "4.3s", values: "20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20", calcMode: "linear", repeatCount: "indefinite" })), g0.default.createElement("rect", { x: "15", width: "10", height: "80", rx: "3" }, g0.default.createElement("animate", { attributeName: "height", begin: "0s", dur: "2s", values: "80;55;33;5;75;23;73;33;12;14;60;80", calcMode: "linear", repeatCount: "indefinite" })), g0.default.createElement("rect", { x: "30", width: "10", height: "50", rx: "3" }, g0.default.createElement("animate", { attributeName: "height", begin: "0s", dur: "1.4s", values: "50;34;78;23;56;23;34;76;80;54;21;50", calcMode: "linear", repeatCount: "indefinite" })), g0.default.createElement("rect", { x: "45", width: "10", height: "30", rx: "3" }, g0.default.createElement("animate", { attributeName: "height", begin: "0s", dur: "2s", values: "30;45;13;80;56;72;45;76;34;23;67;30", calcMode: "linear", repeatCount: "indefinite" }))));
    };
    lu.Audio = C8;
    C8.propTypes = { height: On.default.oneOfType([On.default.string, On.default.number]), width: On.default.oneOfType([On.default.string, On.default.number]), color: On.default.string, label: On.default.string };
    C8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading" };
  });
  var kf = J((uu) => {
    "use strict";
    Object.defineProperty(uu, "__esModule", { value: true });
    uu.BallTriangle = void 0;
    var O1 = Cf((Ge(), F)), $0 = Cf(Gt());
    function Cf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var k8 = function(r6) {
      return O1.default.createElement("svg", { height: r6.height, width: r6.width, stroke: r6.color, viewBox: "0 0 57 57", xmlns: "http://www.w3.org/2000/svg", "aria-label": r6.label }, O1.default.createElement("g", { fill: "none", fillRule: "evenodd" }, O1.default.createElement("g", { transform: "translate(1 1)", strokeWidth: "2" }, O1.default.createElement("circle", { cx: "5", cy: "50", r: r6.radius }, O1.default.createElement("animate", { attributeName: "cy", begin: "0s", dur: "2.2s", values: "50;5;50;50", calcMode: "linear", repeatCount: "indefinite" }), O1.default.createElement("animate", { attributeName: "cx", begin: "0s", dur: "2.2s", values: "5;27;49;5", calcMode: "linear", repeatCount: "indefinite" })), O1.default.createElement("circle", { cx: "27", cy: "5", r: r6.radius }, O1.default.createElement("animate", { attributeName: "cy", begin: "0s", dur: "2.2s", from: "5", to: "5", values: "5;50;50;5", calcMode: "linear", repeatCount: "indefinite" }), O1.default.createElement("animate", { attributeName: "cx", begin: "0s", dur: "2.2s", from: "27", to: "27", values: "27;49;5;27", calcMode: "linear", repeatCount: "indefinite" })), O1.default.createElement("circle", { cx: "49", cy: "50", r: r6.radius }, O1.default.createElement("animate", { attributeName: "cy", begin: "0s", dur: "2.2s", values: "50;50;5;50", calcMode: "linear", repeatCount: "indefinite" }), O1.default.createElement("animate", { attributeName: "cx", from: "49", to: "49", begin: "0s", dur: "2.2s", values: "49;5;27;49", calcMode: "linear", repeatCount: "indefinite" })))));
    };
    uu.BallTriangle = k8;
    k8.propTypes = { height: $0.default.oneOfType([$0.default.string, $0.default.number]), width: $0.default.oneOfType([$0.default.string, $0.default.number]), color: $0.default.string, label: $0.default.string, radius: $0.default.number };
    k8.defaultProps = { height: 80, width: 80, color: "green", radius: 5, label: "audio-loading" };
  });
  var Df = J((cu) => {
    "use strict";
    Object.defineProperty(cu, "__esModule", { value: true });
    cu.Bars = void 0;
    var _r2 = Mf((Ge(), F)), qn = Mf(Gt());
    function Mf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var M8 = function(r6) {
      return _r2.default.createElement("svg", { width: r6.width, height: r6.height, fill: r6.color, viewBox: "0 0 135 140", xmlns: "http://www.w3.org/2000/svg", "aria-label": r6.label }, _r2.default.createElement("rect", { y: "10", width: "15", height: "120", rx: "6" }, _r2.default.createElement("animate", { attributeName: "height", begin: "0.5s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), _r2.default.createElement("animate", { attributeName: "y", begin: "0.5s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })), _r2.default.createElement("rect", { x: "30", y: "10", width: "15", height: "120", rx: "6" }, _r2.default.createElement("animate", { attributeName: "height", begin: "0.25s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), _r2.default.createElement("animate", { attributeName: "y", begin: "0.25s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })), _r2.default.createElement("rect", { x: "60", width: "15", height: "140", rx: "6" }, _r2.default.createElement("animate", { attributeName: "height", begin: "0s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), _r2.default.createElement("animate", { attributeName: "y", begin: "0s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })), _r2.default.createElement("rect", { x: "90", y: "10", width: "15", height: "120", rx: "6" }, _r2.default.createElement("animate", { attributeName: "height", begin: "0.25s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), _r2.default.createElement("animate", { attributeName: "y", begin: "0.25s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })), _r2.default.createElement("rect", { x: "120", y: "10", width: "15", height: "120", rx: "6" }, _r2.default.createElement("animate", { attributeName: "height", begin: "0.5s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), _r2.default.createElement("animate", { attributeName: "y", begin: "0.5s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })));
    };
    cu.Bars = M8;
    M8.propTypes = { height: qn.default.oneOfType([qn.default.string, qn.default.number]), width: qn.default.oneOfType([qn.default.string, qn.default.number]), color: qn.default.string, label: qn.default.string };
    M8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading" };
  });
  var Nf = J((fu) => {
    "use strict";
    Object.defineProperty(fu, "__esModule", { value: true });
    fu.CradleLoader = void 0;
    var mr = Bf((Ge(), F)), pT = Bf(Gt());
    function Bf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var D8 = function(r6) {
      return mr.default.createElement("div", { "aria-label": r6.label, role: "presentation", className: "container" }, mr.default.createElement("div", { className: "react-spinner-loader-swing" }, mr.default.createElement("div", { className: "react-spinner-loader-swing-l" }), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", { className: "react-spinner-loader-swing-r" })), mr.default.createElement("div", { className: "react-spinner-loader-shadow" }, mr.default.createElement("div", { className: "react-spinner-loader-shadow-l" }), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", null), mr.default.createElement("div", { className: "react-spinner-loader-shadow-r" })));
    };
    fu.CradleLoader = D8;
    D8.propTypes = { label: pT.default.string };
    D8.defaultProps = { label: "audio-loading" };
  });
  var qf = J((hu) => {
    "use strict";
    Object.defineProperty(hu, "__esModule", { value: true });
    hu.Grid = void 0;
    var Kt = Of((Ge(), F)), X0 = Of(Gt());
    function Of(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var B8 = function(r6) {
      return Kt.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 105 105", fill: r6.color, "aria-label": r6.label }, Kt.default.createElement("circle", { cx: "12.5", cy: "12.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "0s", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "12.5", cy: "52.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "100ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "52.5", cy: "12.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "300ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "52.5", cy: "52.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "600ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "92.5", cy: "12.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "800ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "92.5", cy: "52.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "400ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "12.5", cy: "92.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "700ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "52.5", cy: "92.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "500ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })), Kt.default.createElement("circle", { cx: "92.5", cy: "92.5", r: r6.radius }, Kt.default.createElement("animate", { attributeName: "fill-opacity", begin: "200ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })));
    };
    hu.Grid = B8;
    B8.propTypes = { height: X0.default.oneOfType([X0.default.string, X0.default.number]), width: X0.default.oneOfType([X0.default.string, X0.default.number]), color: X0.default.string, label: X0.default.string, radius: X0.default.number };
    B8.defaultProps = { height: 80, width: 80, color: "green", radius: 12.5, label: "audio-loading" };
  });
  var Lf = J((du) => {
    "use strict";
    Object.defineProperty(du, "__esModule", { value: true });
    du.Hearts = void 0;
    var Ca = Pf((Ge(), F)), Pn = Pf(Gt());
    function Pf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var N8 = function(r6) {
      return Ca.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 140 64", xmlns: "http://www.w3.org/2000/svg", fill: r6.color, "aria-label": r6.label }, Ca.default.createElement("path", { d: "M30.262 57.02L7.195 40.723c-5.84-3.976-7.56-12.06-3.842-18.063 3.715-6 11.467-7.65 17.306-3.68l4.52 3.76 2.6-5.274c3.717-6.002 11.47-7.65 17.305-3.68 5.84 3.97 7.56 12.054 3.842 18.062L34.49 56.118c-.897 1.512-2.793 1.915-4.228.9z", attributeName: "fill-opacity", from: "0", to: ".5" }, Ca.default.createElement("animate", { attributeName: "fill-opacity", begin: "0s", dur: "1.4s", values: "0.5;1;0.5", calcMode: "linear", repeatCount: "indefinite" })), Ca.default.createElement("path", { d: "M105.512 56.12l-14.44-24.272c-3.716-6.008-1.996-14.093 3.843-18.062 5.835-3.97 13.588-2.322 17.306 3.68l2.6 5.274 4.52-3.76c5.84-3.97 13.592-2.32 17.307 3.68 3.718 6.003 1.998 14.088-3.842 18.064L109.74 57.02c-1.434 1.014-3.33.61-4.228-.9z", attributeName: "fill-opacity", from: "0", to: ".5" }, Ca.default.createElement("animate", { attributeName: "fill-opacity", begin: "0.7s", dur: "1.4s", values: "0.5;1;0.5", calcMode: "linear", repeatCount: "indefinite" })), Ca.default.createElement("path", { d: "M67.408 57.834l-23.01-24.98c-5.864-6.15-5.864-16.108 0-22.248 5.86-6.14 15.37-6.14 21.234 0L70 16.168l4.368-5.562c5.863-6.14 15.375-6.14 21.235 0 5.863 6.14 5.863 16.098 0 22.247l-23.007 24.98c-1.43 1.556-3.757 1.556-5.188 0z" }));
    };
    du.Hearts = N8;
    N8.propTypes = { height: Pn.default.oneOfType([Pn.default.string, Pn.default.number]), width: Pn.default.oneOfType([Pn.default.string, Pn.default.number]), color: Pn.default.string, label: Pn.default.string };
    N8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading" };
  });
  var Rf = J((mu) => {
    "use strict";
    Object.defineProperty(mu, "__esModule", { value: true });
    mu.MutatingDots = void 0;
    var Z1 = If((Ge(), F)), ka = If(Gt());
    function If(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var O8 = function(r6) {
      return Z1.default.createElement("svg", { id: "goo-loader", width: r6.width, height: r6.height, "aria-label": r6.label }, Z1.default.createElement("filter", { id: "fancy-goo" }, Z1.default.createElement("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "6", result: "blur" }), Z1.default.createElement("feColorMatrix", { in: "blur", mode: "matrix", values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9", result: "goo" }), Z1.default.createElement("feComposite", { in: "SourceGraphic", in2: "goo", operator: "atop" })), Z1.default.createElement("g", { filter: "url(#fancy-goo)" }, Z1.default.createElement("animateTransform", { id: "mainAnim", attributeName: "transform", attributeType: "XML", type: "rotate", from: "0 50 50", to: "359 50 50", dur: "1.2s", repeatCount: "indefinite" }), Z1.default.createElement("circle", { cx: "50%", cy: "40", r: r6.radius, fill: r6.color }, Z1.default.createElement("animate", { id: "cAnim1", attributeType: "XML", attributeName: "cy", dur: "0.6s", begin: "0;cAnim1.end+0.2s", calcMode: "spline", values: "40;20;40", keyTimes: "0;0.3;1", keySplines: "0.09, 0.45, 0.16, 1;0.09, 0.45, 0.16, 1" })), Z1.default.createElement("circle", { cx: "50%", cy: "60", r: r6.radius, fill: r6.secondaryColor }, Z1.default.createElement("animate", { id: "cAnim2", attributeType: "XML", attributeName: "cy", dur: "0.6s", begin: "0.4s;cAnim2.end+0.2s", calcMode: "spline", values: "60;80;60", keyTimes: "0;0.3;1", keySplines: "0.09, 0.45, 0.16, 1;0.09, 0.45, 0.16, 1" }))));
    };
    mu.MutatingDots = O8;
    O8.propTypes = { width: ka.default.number, secondaryColor: ka.default.string, height: ka.default.number, color: ka.default.string, radius: ka.default.number, label: ka.default.string };
    O8.defaultProps = { width: 80, height: 90, color: "green", radius: 11, secondaryColor: "green", label: "audio-loading" };
  });
  var Ff = J((pu) => {
    "use strict";
    Object.defineProperty(pu, "__esModule", { value: true });
    pu.Oval = void 0;
    var Ma = zf((Ge(), F)), Y0 = zf(Gt());
    function zf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var q8 = function(r6) {
      return Ma.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 38 38", xmlns: "http://www.w3.org/2000/svg", stroke: r6.color, "aria-label": r6.label }, Ma.default.createElement("g", { fill: "none", fillRule: "evenodd" }, Ma.default.createElement("g", { transform: "translate(1 1)", strokeWidth: "2" }, Ma.default.createElement("circle", { strokeOpacity: ".5", cx: "18", cy: "18", r: r6.radius }), Ma.default.createElement("path", { d: "M36 18c0-9.94-8.06-18-18-18" }, Ma.default.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "1s", repeatCount: "indefinite" })))));
    };
    pu.Oval = q8;
    q8.propTypes = { height: Y0.default.oneOfType([Y0.default.string, Y0.default.number]), width: Y0.default.oneOfType([Y0.default.string, Y0.default.number]), color: Y0.default.string, label: Y0.default.string, radius: Y0.default.number };
    q8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading", radius: 18 };
  });
  var jf = J((vu) => {
    "use strict";
    Object.defineProperty(vu, "__esModule", { value: true });
    vu.Plane = void 0;
    var gu = Hf((Ge(), F)), P8 = Hf(Gt());
    function Hf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var L8 = function(r6) {
      return gu.default.createElement("svg", { className: "react-spinner-loader-svg-calLoader", xmlns: "http://www.w3.org/2000/svg", width: "230", height: "230", "aria-label": r6.label }, gu.default.createElement("desc", null, "Plane animation. Loading "), gu.default.createElement("path", { className: "react-spinner-loader-cal-loader__path", style: { stroke: r6.secondaryColor }, d: "M86.429 40c63.616-20.04 101.511 25.08 107.265 61.93 6.487 41.54-18.593 76.99-50.6 87.643-59.46 19.791-101.262-23.577-107.142-62.616C29.398 83.441 59.945 48.343 86.43 40z", fill: "none", stroke: "#0099cc", strokeWidth: "4", strokeLinecap: "round", strokeLinejoin: "round", strokeDasharray: "10 10 10 10 10 10 10 432", strokeDashoffset: "77" }), gu.default.createElement("path", { className: "cal-loader__plane", style: { fill: r6.color }, d: "M141.493 37.93c-1.087-.927-2.942-2.002-4.32-2.501-2.259-.824-3.252-.955-9.293-1.172-4.017-.146-5.197-.23-5.47-.37-.766-.407-1.526-1.448-7.114-9.773-4.8-7.145-5.344-7.914-6.327-8.976-1.214-1.306-1.396-1.378-3.79-1.473-1.036-.04-2-.043-2.153-.002-.353.1-.87.586-1 .952-.139.399-.076.71.431 2.22.241.72 1.029 3.386 1.742 5.918 1.644 5.844 2.378 8.343 2.863 9.705.206.601.33 1.1.275 1.125-.24.097-10.56 1.066-11.014 1.032a3.532 3.532 0 0 1-1.002-.276l-.487-.246-2.044-2.613c-2.234-2.87-2.228-2.864-3.35-3.309-.717-.287-2.82-.386-3.276-.163-.457.237-.727.644-.737 1.152-.018.39.167.805 1.916 4.373 1.06 2.166 1.964 4.083 1.998 4.27.04.179.004.521-.076.75-.093.228-1.109 2.064-2.269 4.088-1.921 3.34-2.11 3.711-2.123 4.107-.008.25.061.557.168.725.328.512.72.644 1.966.676 1.32.029 2.352-.236 3.05-.762.222-.171 1.275-1.313 2.412-2.611 1.918-2.185 2.048-2.32 2.45-2.505.241-.111.601-.232.82-.271.267-.058 2.213.201 5.912.8 3.036.48 5.525.894 5.518.914 0 .026-.121.306-.27.638-.54 1.198-1.515 3.842-3.35 9.021-1.029 2.913-2.107 5.897-2.4 6.62-.703 1.748-.725 1.833-.594 2.286.137.46.45.833.872 1.012.41.177 3.823.24 4.37.085.852-.25 1.44-.688 2.312-1.724 1.166-1.39 3.169-3.948 6.771-8.661 5.8-7.583 6.561-8.49 7.387-8.702.233-.065 2.828-.056 5.784.011 5.827.138 6.64.09 8.62-.5 2.24-.67 4.035-1.65 5.517-3.016 1.136-1.054 1.135-1.014.207-1.962-.357-.38-.767-.777-.902-.893z", fill: "#000033" }));
    };
    vu.Plane = L8;
    L8.propTypes = { secondaryColor: P8.default.string, color: P8.default.string, label: P8.default.string };
    L8.defaultProps = { secondaryColor: "grey", color: "#FFA500", label: "async-loading" };
  });
  var Wf = J((yu) => {
    "use strict";
    Object.defineProperty(yu, "__esModule", { value: true });
    yu.Puff = void 0;
    var Ln = Uf((Ge(), F)), K0 = Uf(Gt());
    function Uf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var I8 = function(r6) {
      return Ln.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 44 44", xmlns: "http://www.w3.org/2000/svg", stroke: r6.color, "aria-label": r6.label }, Ln.default.createElement("g", { fill: "none", fillRule: "evenodd", strokeWidth: "2" }, Ln.default.createElement("circle", { cx: "22", cy: "22", r: r6.radius }, Ln.default.createElement("animate", { attributeName: "r", begin: "0s", dur: "1.8s", values: "1; 20", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.165, 0.84, 0.44, 1", repeatCount: "indefinite" }), Ln.default.createElement("animate", { attributeName: "strokeOpacity", begin: "0s", dur: "1.8s", values: "1; 0", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.3, 0.61, 0.355, 1", repeatCount: "indefinite" })), Ln.default.createElement("circle", { cx: "22", cy: "22", r: r6.radius }, Ln.default.createElement("animate", { attributeName: "r", begin: "-0.9s", dur: "1.8s", values: "1; 20", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.165, 0.84, 0.44, 1", repeatCount: "indefinite" }), Ln.default.createElement("animate", { attributeName: "strokeOpacity", begin: "-0.9s", dur: "1.8s", values: "1; 0", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.3, 0.61, 0.355, 1", repeatCount: "indefinite" }))));
    };
    yu.Puff = I8;
    I8.propTypes = { height: K0.default.oneOfType([K0.default.string, K0.default.number]), width: K0.default.oneOfType([K0.default.string, K0.default.number]), color: K0.default.string, label: K0.default.string, radius: K0.default.number };
    I8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading", radius: 1 };
  });
  var Vf = J((xu) => {
    "use strict";
    Object.defineProperty(xu, "__esModule", { value: true });
    xu.RevolvingDot = void 0;
    var bu = Gf((Ge(), F)), Z0 = Gf(Gt());
    function Gf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var R8 = function(r6) {
      return bu.default.createElement("svg", { version: "1.1", width: r6.width, height: r6.height, xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", "aria-label": r6.label }, bu.default.createElement("circle", { fill: "none", stroke: r6.color, strokeWidth: "4", cx: "50", cy: "50", r: r6.radius + 38, style: { opacity: 0.5 } }), bu.default.createElement("circle", { fill: r6.color, stroke: r6.color, strokeWidth: "3", cx: "8", cy: "54", r: r6.radius }, bu.default.createElement("animateTransform", { attributeName: "transform", dur: "2s", type: "rotate", from: "0 50 48", to: "360 50 52", repeatCount: "indefinite" })));
    };
    xu.RevolvingDot = R8;
    R8.propTypes = { height: Z0.default.oneOfType([Z0.default.string, Z0.default.number]), width: Z0.default.oneOfType([Z0.default.string, Z0.default.number]), color: Z0.default.string, label: Z0.default.string, radius: Z0.default.number };
    R8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading", radius: 6 };
  });
  var Xf = J((wu) => {
    "use strict";
    Object.defineProperty(wu, "__esModule", { value: true });
    wu.Rings = void 0;
    var q1 = $f((Ge(), F)), J0 = $f(Gt());
    function $f(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var z8 = function(r6) {
      return q1.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 45 45", xmlns: "http://www.w3.org/2000/svg", stroke: r6.color, "aria-label": r6.label }, q1.default.createElement("g", { fill: "none", fillRule: "evenodd", transform: "translate(1 1)", strokeWidth: "2" }, q1.default.createElement("circle", { cx: "22", cy: "22", r: r6.radius, strokeOpacity: "0" }, q1.default.createElement("animate", { attributeName: "r", begin: "1.5s", dur: "3s", values: "6;22", calcMode: "linear", repeatCount: "indefinite" }), q1.default.createElement("animate", { attributeName: "stroke-opacity", begin: "1.5s", dur: "3s", values: "1;0", calcMode: "linear", repeatCount: "indefinite" }), q1.default.createElement("animate", { attributeName: "stroke-width", begin: "1.5s", dur: "3s", values: "2;0", calcMode: "linear", repeatCount: "indefinite" })), q1.default.createElement("circle", { cx: "22", cy: "22", r: r6.radius, strokeOpacity: "0" }, q1.default.createElement("animate", { attributeName: "r", begin: "3s", dur: "3s", values: "6;22", calcMode: "linear", repeatCount: "indefinite" }), q1.default.createElement("animate", { attributeName: "strokeOpacity", begin: "3s", dur: "3s", values: "1;0", calcMode: "linear", repeatCount: "indefinite" }), q1.default.createElement("animate", { attributeName: "strokeWidth", begin: "3s", dur: "3s", values: "2;0", calcMode: "linear", repeatCount: "indefinite" })), q1.default.createElement("circle", { cx: "22", cy: "22", r: r6.radius + 2 }, q1.default.createElement("animate", { attributeName: "r", begin: "0s", dur: "1.5s", values: "6;1;2;3;4;5;6", calcMode: "linear", repeatCount: "indefinite" }))));
    };
    wu.Rings = z8;
    z8.propTypes = { height: J0.default.oneOfType([J0.default.string, J0.default.number]), width: J0.default.oneOfType([J0.default.string, J0.default.number]), color: J0.default.string, label: J0.default.string, radius: J0.default.number };
    z8.defaultProps = { height: 80, width: 80, color: "green", radius: 6, label: "audio-loading" };
  });
  var Kf = J((_u) => {
    "use strict";
    Object.defineProperty(_u, "__esModule", { value: true });
    _u.TailSpin = void 0;
    var P1 = Yf((Ge(), F)), Q0 = Yf(Gt());
    function Yf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var F8 = function(r6) {
      return P1.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 38 38", xmlns: "http://www.w3.org/2000/svg", "aria-label": r6.label }, P1.default.createElement("defs", null, P1.default.createElement("linearGradient", { x1: "8.042%", y1: "0%", x2: "65.682%", y2: "23.865%", id: "a" }, P1.default.createElement("stop", { stopColor: r6.color, stopOpacity: "0", offset: "0%" }), P1.default.createElement("stop", { stopColor: r6.color, stopOpacity: ".631", offset: "63.146%" }), P1.default.createElement("stop", { stopColor: r6.color, offset: "100%" }))), P1.default.createElement("g", { fill: "none", fillRule: "evenodd" }, P1.default.createElement("g", { transform: "translate(1 1)" }, P1.default.createElement("path", { d: "M36 18c0-9.94-8.06-18-18-18", id: "Oval-2", stroke: r6.color, strokeWidth: "2" }, P1.default.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "0.9s", repeatCount: "indefinite" })), P1.default.createElement("circle", { fill: "#fff", cx: "36", cy: "18", r: r6.radius }, P1.default.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "0.9s", repeatCount: "indefinite" })))));
    };
    _u.TailSpin = F8;
    F8.propTypes = { height: Q0.default.oneOfType([Q0.default.string, Q0.default.number]), width: Q0.default.oneOfType([Q0.default.string, Q0.default.number]), color: Q0.default.string, label: Q0.default.string, radius: Q0.default.number };
    F8.defaultProps = { height: 80, width: 80, color: "green", radius: 1, label: "audio-loading" };
  });
  var Jf = J((Su) => {
    "use strict";
    Object.defineProperty(Su, "__esModule", { value: true });
    Su.ThreeDots = void 0;
    var v0 = Zf((Ge(), F)), en = Zf(Gt());
    function Zf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var H8 = function(r6) {
      return v0.default.createElement("svg", { width: r6.width, height: r6.height, viewBox: "0 0 120 30", xmlns: "http://www.w3.org/2000/svg", fill: r6.color, "aria-label": r6.label }, v0.default.createElement("circle", { cx: "15", cy: "15", r: r6.radius + 6 }, v0.default.createElement("animate", { attributeName: "r", from: "15", to: "15", begin: "0s", dur: "0.8s", values: "15;9;15", calcMode: "linear", repeatCount: "indefinite" }), v0.default.createElement("animate", { attributeName: "fillOpacity", from: "1", to: "1", begin: "0s", dur: "0.8s", values: "1;.5;1", calcMode: "linear", repeatCount: "indefinite" })), v0.default.createElement("circle", { cx: "60", cy: "15", r: r6.radius, attributeName: "fillOpacity", from: "1", to: "0.3" }, v0.default.createElement("animate", { attributeName: "r", from: "9", to: "9", begin: "0s", dur: "0.8s", values: "9;15;9", calcMode: "linear", repeatCount: "indefinite" }), v0.default.createElement("animate", { attributeName: "fillOpacity", from: "0.5", to: "0.5", begin: "0s", dur: "0.8s", values: ".5;1;.5", calcMode: "linear", repeatCount: "indefinite" })), v0.default.createElement("circle", { cx: "105", cy: "15", r: r6.radius + 6 }, v0.default.createElement("animate", { attributeName: "r", from: "15", to: "15", begin: "0s", dur: "0.8s", values: "15;9;15", calcMode: "linear", repeatCount: "indefinite" }), v0.default.createElement("animate", { attributeName: "fillOpacity", from: "1", to: "1", begin: "0s", dur: "0.8s", values: "1;.5;1", calcMode: "linear", repeatCount: "indefinite" })));
    };
    Su.ThreeDots = H8;
    H8.propTypes = { height: en.default.oneOfType([en.default.string, en.default.number]), width: en.default.oneOfType([en.default.string, en.default.number]), color: en.default.string, label: en.default.string, radius: en.default.number };
    H8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading", radius: 9 };
  });
  var eh = J((Au) => {
    "use strict";
    Object.defineProperty(Au, "__esModule", { value: true });
    Au.Triangle = void 0;
    var j8 = Qf((Ge(), F)), In = Qf(Gt());
    function Qf(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    var U8 = function(r6) {
      return j8.default.createElement("div", { className: "react-spinner-loader-svg" }, j8.default.createElement("svg", { id: "triangle", width: r6.width, height: r6.height, viewBox: "-3 -4 39 39", "aria-label": r6.label }, j8.default.createElement("polygon", { fill: "transparent", stroke: r6.color, strokeWidth: "1", points: "16,0 32,32 0,32" })));
    };
    Au.Triangle = U8;
    U8.propTypes = { height: In.default.oneOfType([In.default.string, In.default.number]), width: In.default.oneOfType([In.default.string, In.default.number]), color: In.default.string, label: In.default.string };
    U8.defaultProps = { height: 80, width: 80, color: "green", label: "audio-loading" };
  });
  var th = J((Tu) => {
    "use strict";
    Object.defineProperty(Tu, "__esModule", { value: true });
    Tu.Spinner = void 0;
    var gT = _f(), vT = Af(), yT = Ef(), bT = kf(), xT = Df(), wT = Nf(), _T = qf(), ST = Lf(), AT = Rf(), TT = Ff(), ET = jf(), CT = Wf(), kT = Vf(), MT = Xf(), DT = Kf(), BT = Jf(), NT = eh(), OT = { Circles: gT.Circles, Audio: yT.Audio, BallTriangle: bT.BallTriangle, Bars: xT.Bars, CradleLoader: wT.CradleLoader, Grid: _T.Grid, Hearts: ST.Hearts, MutatingDots: AT.MutatingDots, Oval: TT.Oval, Plane: ET.Plane, Puff: CT.Puff, RevolvingDot: kT.RevolvingDot, Rings: MT.Rings, TailSpin: DT.TailSpin, ThreeDots: BT.ThreeDots, Triangle: NT.Triangle, Watch: vT.Watch };
    Tu.Spinner = OT;
  });
  var sh = J((G8) => {
    "use strict";
    function Eu(t2) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Eu = function(s) {
        return typeof s;
      } : Eu = function(s) {
        return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
      }, Eu(t2);
    }
    Object.defineProperty(G8, "__esModule", { value: true });
    G8.default = W8;
    var Cu = PT((Ge(), F)), Rn = qT(Gt()), rh = th();
    function qT(t2) {
      return t2 && t2.__esModule ? t2 : { default: t2 };
    }
    function nh() {
      if (typeof WeakMap != "function")
        return null;
      var t2 = new WeakMap();
      return nh = function() {
        return t2;
      }, t2;
    }
    function PT(t2) {
      if (t2 && t2.__esModule)
        return t2;
      if (t2 === null || Eu(t2) !== "object" && typeof t2 != "function")
        return { default: t2 };
      var r6 = nh();
      if (r6 && r6.has(t2))
        return r6.get(t2);
      var s = {}, c = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var p in t2)
        if (Object.prototype.hasOwnProperty.call(t2, p)) {
          var w = c ? Object.getOwnPropertyDescriptor(t2, p) : null;
          w && (w.get || w.set) ? Object.defineProperty(s, p, w) : s[p] = t2[p];
        }
      return s.default = t2, r6 && r6.set(t2, s), s;
    }
    function ih(t2, r6) {
      var s = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var c = Object.getOwnPropertySymbols(t2);
        r6 && (c = c.filter(function(p) {
          return Object.getOwnPropertyDescriptor(t2, p).enumerable;
        })), s.push.apply(s, c);
      }
      return s;
    }
    function LT(t2) {
      for (var r6 = 1; r6 < arguments.length; r6++) {
        var s = arguments[r6] != null ? arguments[r6] : {};
        r6 % 2 ? ih(Object(s), true).forEach(function(c) {
          IT(t2, c, s[c]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(s)) : ih(Object(s)).forEach(function(c) {
          Object.defineProperty(t2, c, Object.getOwnPropertyDescriptor(s, c));
        });
      }
      return t2;
    }
    function IT(t2, r6, s) {
      return r6 in t2 ? Object.defineProperty(t2, r6, { value: s, enumerable: true, configurable: true, writable: true }) : t2[r6] = s, t2;
    }
    function RT(t2, r6) {
      return jT(t2) || HT(t2, r6) || FT(t2, r6) || zT();
    }
    function zT() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function FT(t2, r6) {
      if (!!t2) {
        if (typeof t2 == "string")
          return ah(t2, r6);
        var s = Object.prototype.toString.call(t2).slice(8, -1);
        if (s === "Object" && t2.constructor && (s = t2.constructor.name), s === "Map" || s === "Set")
          return Array.from(t2);
        if (s === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s))
          return ah(t2, r6);
      }
    }
    function ah(t2, r6) {
      (r6 == null || r6 > t2.length) && (r6 = t2.length);
      for (var s = 0, c = new Array(r6); s < r6; s++)
        c[s] = t2[s];
      return c;
    }
    function HT(t2, r6) {
      if (!(typeof Symbol == "undefined" || !(Symbol.iterator in Object(t2)))) {
        var s = [], c = true, p = false, w = void 0;
        try {
          for (var T = t2[Symbol.iterator](), k; !(c = (k = T.next()).done) && (s.push(k.value), !(r6 && s.length === r6)); c = true)
            ;
        } catch (P) {
          p = true, w = P;
        } finally {
          try {
            !c && T.return != null && T.return();
          } finally {
            if (p)
              throw w;
          }
        }
        return s;
      }
    }
    function jT(t2) {
      if (Array.isArray(t2))
        return t2;
    }
    var oh = ["Audio", "BallTriangle", "Bars", "Circles", "Grid", "Hearts", "Oval", "Puff", "Rings", "TailSpin", "ThreeDots", "Watch", "RevolvingDot", "Triangle", "Plane", "MutatingDots", "CradleLoader"];
    function UT(t2) {
      return oh.includes(t2) ? rh.Spinner[t2] : rh.Spinner.Audio;
    }
    function W8(t2) {
      var r6 = (0, Cu.useState)(true), s = RT(r6, 2), c = s[0], p = s[1];
      return (0, Cu.useEffect)(function() {
        var w;
        return t2.timeout && t2.timeout > 0 && (w = setTimeout(function() {
          p(false);
        }, t2.timeout)), function() {
          w && clearTimeout(w);
        };
      }), !t2.visible || t2.visible === "false" ? null : c ? Cu.default.createElement("div", { "aria-busy": "true", className: t2.className, style: t2.style }, Cu.default.createElement(UT(t2.type), LT({}, t2))) : null;
    }
    W8.propTypes = { type: Rn.default.oneOf([].concat(oh)), style: Rn.default.objectOf(Rn.default.string), className: Rn.default.string, visible: Rn.default.oneOfType([Rn.default.bool, Rn.default.string]), timeout: Rn.default.number };
    W8.defaultProps = { type: "Audio", style: {}, className: "", visible: true, timeout: 0 };
  });
  Ge();
  var Kc = cr(g7());
  var Ct = {};
  Sn(Ct, { default: () => mobxreact_esm_exports });
  bt(Ct, mobxreact_esm_exports);
  Ge();
  var ca = {};
  Sn(ca, { default: () => Co });
  bt(ca, YT);
  var Wc = cr(R0());
  var Ql = cr(ha());
  var ze = {};
  Sn(ze, { default: () => mobx_esm_exports });
  bt(ze, mobx_esm_exports);
  Ge();
  var o8 = cr(v7());
  var s8 = cr(mc());
  Ge();
  var i8 = cr(R0());
  var Rc = cr(ha());
  Ge();
  var H5 = cr(R0());
  var Ul = (t2, r6) => {
    if (t2.length != r6.length)
      throw `Cannot zip lists of length ${t2.length} and ${r6.length}`;
    return H5.default.zip(t2, r6);
  };
  var p0 = (0, F.forwardRef)(function({ block: r6, ...s }, c) {
    return r6 ? N.createElement("div", { ref: c, ...s }) : N.createElement("span", { ref: c, ...s });
  });
  var Uo = (t2, r6, s) => {
    let [c, p] = (0, F.useState)(t2);
    return (0, F.useEffect)(() => {
      let w = setInterval(() => {
        let T = s();
        H5.default.isEqual(T, c) || p(s);
      }, r6);
      return () => clearInterval(w);
    }, [s, r6]), c;
  };
  Ge();
  var xr = class {
    constructor() {
      this.stateful = false;
    }
    init() {
    }
  };
  var wr = class {
    constructor(r6) {
      this.Provide = ({ children: r7 }) => {
        let s = new this.ctor();
        return s.stateful && (s = (0, F.useState)(s)[0]), s.init && s.init(), N.createElement(this.context.Provider, { value: s }, r7);
      };
      this.ctor = r6, this.context = N.createContext(new r6());
    }
  };
  function kt(t2) {
    return (0, F.useContext)(t2.context);
  }
  function LS(t2) {
    var r6 = t2.getBoundingClientRect();
    return !(r6.bottom < 0 || r6.top - window.innerHeight >= 0);
  }
  var IS = (t2) => {
    let r6 = [];
    for (; t2.parentNode; )
      r6.push(t2.parentNode), t2 = t2.parentNode;
    return r6;
  };
  var Wo = new wr(class extends xr {
    constructor() {
      super(...arguments);
      this.scroll_hooks = {};
      this.stateful = true;
      this.register_scroll_hook = (t2, r6) => {
        this.scroll_hooks[t2] = r6;
      };
      this.scroll_to = (t2) => {
        let r6 = document.getElementById(t2), s = "#" + t2;
        window.location.hash == s, window.history.pushState(null, "", s), window.history.pushState(null, "", "#" + s), window.history.back();
        let c = IS(r6), p = false;
        c.forEach((w) => {
          w instanceof HTMLElement && w.id in this.scroll_hooks && (this.scroll_hooks[w.id](), p = true);
        }), !(!p && LS(r6)) && setTimeout(() => {
          let w = r6.offsetHeight > window.innerHeight ? "start" : "center";
          r6.scrollIntoView({ block: w, inline: "center" });
        }, 100);
      };
    }
  });
  Ge();
  var Ht = "top";
  var Yt = "bottom";
  var Ut = "right";
  var Wt = "left";
  var Wl = "auto";
  var Cn = [Ht, Yt, Ut, Wt];
  var H0 = "start";
  var gi = "end";
  var pc = "clippingParents";
  var Gl = "viewport";
  var wa = "popper";
  var gc = "reference";
  var j5 = Cn.reduce(function(t2, r6) {
    return t2.concat([r6 + "-" + H0, r6 + "-" + gi]);
  }, []);
  var Vl = [].concat(Cn, [Wl]).reduce(function(t2, r6) {
    return t2.concat([r6, r6 + "-" + H0, r6 + "-" + gi]);
  }, []);
  var RS = "beforeRead";
  var zS = "read";
  var FS = "afterRead";
  var HS = "beforeMain";
  var jS = "main";
  var US = "afterMain";
  var WS = "beforeWrite";
  var GS = "write";
  var VS = "afterWrite";
  var vc = [RS, zS, FS, HS, jS, US, WS, GS, VS];
  function rr(t2) {
    return t2 ? (t2.nodeName || "").toLowerCase() : null;
  }
  function jt(t2) {
    if (t2 == null)
      return window;
    if (t2.toString() !== "[object Window]") {
      var r6 = t2.ownerDocument;
      return r6 && r6.defaultView || window;
    }
    return t2;
  }
  function j0(t2) {
    var r6 = jt(t2).Element;
    return t2 instanceof r6 || t2 instanceof Element;
  }
  function nr(t2) {
    var r6 = jt(t2).HTMLElement;
    return t2 instanceof r6 || t2 instanceof HTMLElement;
  }
  function $l(t2) {
    if (typeof ShadowRoot == "undefined")
      return false;
    var r6 = jt(t2).ShadowRoot;
    return t2 instanceof r6 || t2 instanceof ShadowRoot;
  }
  function $S(t2) {
    var r6 = t2.state;
    Object.keys(r6.elements).forEach(function(s) {
      var c = r6.styles[s] || {}, p = r6.attributes[s] || {}, w = r6.elements[s];
      !nr(w) || !rr(w) || (Object.assign(w.style, c), Object.keys(p).forEach(function(T) {
        var k = p[T];
        k === false ? w.removeAttribute(T) : w.setAttribute(T, k === true ? "" : k);
      }));
    });
  }
  function XS(t2) {
    var r6 = t2.state, s = { popper: { position: r6.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    return Object.assign(r6.elements.popper.style, s.popper), r6.styles = s, r6.elements.arrow && Object.assign(r6.elements.arrow.style, s.arrow), function() {
      Object.keys(r6.elements).forEach(function(c) {
        var p = r6.elements[c], w = r6.attributes[c] || {}, T = Object.keys(r6.styles.hasOwnProperty(c) ? r6.styles[c] : s[c]), k = T.reduce(function(P, j) {
          return P[j] = "", P;
        }, {});
        !nr(p) || !rr(p) || (Object.assign(p.style, k), Object.keys(w).forEach(function(P) {
          p.removeAttribute(P);
        }));
      });
    };
  }
  var yc = { name: "applyStyles", enabled: true, phase: "write", fn: $S, effect: XS, requires: ["computeStyles"] };
  function ir(t2) {
    return t2.split("-")[0];
  }
  function k1(t2, r6) {
    r6 === void 0 && (r6 = false);
    var s = t2.getBoundingClientRect(), c = 1, p = 1;
    return { width: s.width / c, height: s.height / p, top: s.top / p, right: s.right / c, bottom: s.bottom / p, left: s.left / c, x: s.left / c, y: s.top / p };
  }
  function vi(t2) {
    var r6 = k1(t2), s = t2.offsetWidth, c = t2.offsetHeight;
    return Math.abs(r6.width - s) <= 1 && (s = r6.width), Math.abs(r6.height - c) <= 1 && (c = r6.height), { x: t2.offsetLeft, y: t2.offsetTop, width: s, height: c };
  }
  function Go(t2, r6) {
    var s = r6.getRootNode && r6.getRootNode();
    if (t2.contains(r6))
      return true;
    if (s && $l(s)) {
      var c = r6;
      do {
        if (c && t2.isSameNode(c))
          return true;
        c = c.parentNode || c.host;
      } while (c);
    }
    return false;
  }
  function Lr(t2) {
    return jt(t2).getComputedStyle(t2);
  }
  function U5(t2) {
    return ["table", "td", "th"].indexOf(rr(t2)) >= 0;
  }
  function dr(t2) {
    return ((j0(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
  }
  function U0(t2) {
    return rr(t2) === "html" ? t2 : t2.assignedSlot || t2.parentNode || ($l(t2) ? t2.host : null) || dr(t2);
  }
  function bc(t2) {
    return !nr(t2) || Lr(t2).position === "fixed" ? null : t2.offsetParent;
  }
  function YS(t2) {
    var r6 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, s = navigator.userAgent.indexOf("Trident") !== -1;
    if (s && nr(t2)) {
      var c = Lr(t2);
      if (c.position === "fixed")
        return null;
    }
    for (var p = U0(t2); nr(p) && ["html", "body"].indexOf(rr(p)) < 0; ) {
      var w = Lr(p);
      if (w.transform !== "none" || w.perspective !== "none" || w.contain === "paint" || ["transform", "perspective"].indexOf(w.willChange) !== -1 || r6 && w.willChange === "filter" || r6 && w.filter && w.filter !== "none")
        return p;
      p = p.parentNode;
    }
    return null;
  }
  function X1(t2) {
    for (var r6 = jt(t2), s = bc(t2); s && U5(s) && Lr(s).position === "static"; )
      s = bc(s);
    return s && (rr(s) === "html" || rr(s) === "body" && Lr(s).position === "static") ? r6 : s || YS(t2) || r6;
  }
  function yi(t2) {
    return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
  }
  var M1 = Math.max;
  var kn = Math.min;
  var Vo = Math.round;
  function bi(t2, r6, s) {
    return M1(t2, kn(r6, s));
  }
  function $o() {
    return { top: 0, right: 0, bottom: 0, left: 0 };
  }
  function Xo(t2) {
    return Object.assign({}, $o(), t2);
  }
  function Yo(t2, r6) {
    return r6.reduce(function(s, c) {
      return s[c] = t2, s;
    }, {});
  }
  var KS = function(r6, s) {
    return r6 = typeof r6 == "function" ? r6(Object.assign({}, s.rects, { placement: s.placement })) : r6, Xo(typeof r6 != "number" ? r6 : Yo(r6, Cn));
  };
  function ZS(t2) {
    var r6, s = t2.state, c = t2.name, p = t2.options, w = s.elements.arrow, T = s.modifiersData.popperOffsets, k = ir(s.placement), P = yi(k), j = [Wt, Ut].indexOf(k) >= 0, U = j ? "height" : "width";
    if (!(!w || !T)) {
      var ee = KS(p.padding, s), G = vi(w), ae = P === "y" ? Ht : Wt, ie3 = P === "y" ? Yt : Ut, V = s.rects.reference[U] + s.rects.reference[P] - T[P] - s.rects.popper[U], de = T[P] - s.rects.reference[P], ve = X1(w), _e2 = ve ? P === "y" ? ve.clientHeight || 0 : ve.clientWidth || 0 : 0, Me = V / 2 - de / 2, we = ee[ae], ye = _e2 - G[U] - ee[ie3], xe = _e2 / 2 - G[U] / 2 + Me, Se = bi(we, xe, ye), Je = P;
      s.modifiersData[c] = (r6 = {}, r6[Je] = Se, r6.centerOffset = Se - xe, r6);
    }
  }
  function JS(t2) {
    var r6 = t2.state, s = t2.options, c = s.element, p = c === void 0 ? "[data-popper-arrow]" : c;
    p != null && (typeof p == "string" && (p = r6.elements.popper.querySelector(p), !p) || !Go(r6.elements.popper, p) || (r6.elements.arrow = p));
  }
  var xc = { name: "arrow", enabled: true, phase: "main", fn: ZS, effect: JS, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
  function D1(t2) {
    return t2.split("-")[1];
  }
  var QS = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function eA(t2) {
    var r6 = t2.x, s = t2.y, c = window, p = c.devicePixelRatio || 1;
    return { x: Vo(Vo(r6 * p) / p) || 0, y: Vo(Vo(s * p) / p) || 0 };
  }
  function wc(t2) {
    var r6, s = t2.popper, c = t2.popperRect, p = t2.placement, w = t2.variation, T = t2.offsets, k = t2.position, P = t2.gpuAcceleration, j = t2.adaptive, U = t2.roundOffsets, ee = U === true ? eA(T) : typeof U == "function" ? U(T) : T, G = ee.x, ae = G === void 0 ? 0 : G, ie3 = ee.y, V = ie3 === void 0 ? 0 : ie3, de = T.hasOwnProperty("x"), ve = T.hasOwnProperty("y"), _e2 = Wt, Me = Ht, we = window;
    if (j) {
      var ye = X1(s), xe = "clientHeight", Se = "clientWidth";
      ye === jt(s) && (ye = dr(s), Lr(ye).position !== "static" && k === "absolute" && (xe = "scrollHeight", Se = "scrollWidth")), ye = ye, (p === Ht || (p === Wt || p === Ut) && w === gi) && (Me = Yt, V -= ye[xe] - c.height, V *= P ? 1 : -1), (p === Wt || (p === Ht || p === Yt) && w === gi) && (_e2 = Ut, ae -= ye[Se] - c.width, ae *= P ? 1 : -1);
    }
    var Je = Object.assign({ position: k }, j && QS);
    if (P) {
      var Ae;
      return Object.assign({}, Je, (Ae = {}, Ae[Me] = ve ? "0" : "", Ae[_e2] = de ? "0" : "", Ae.transform = (we.devicePixelRatio || 1) <= 1 ? "translate(" + ae + "px, " + V + "px)" : "translate3d(" + ae + "px, " + V + "px, 0)", Ae));
    }
    return Object.assign({}, Je, (r6 = {}, r6[Me] = ve ? V + "px" : "", r6[_e2] = de ? ae + "px" : "", r6.transform = "", r6));
  }
  function tA(t2) {
    var r6 = t2.state, s = t2.options, c = s.gpuAcceleration, p = c === void 0 ? true : c, w = s.adaptive, T = w === void 0 ? true : w, k = s.roundOffsets, P = k === void 0 ? true : k;
    if (false)
      var j;
    var U = { placement: ir(r6.placement), variation: D1(r6.placement), popper: r6.elements.popper, popperRect: r6.rects.popper, gpuAcceleration: p };
    r6.modifiersData.popperOffsets != null && (r6.styles.popper = Object.assign({}, r6.styles.popper, wc(Object.assign({}, U, { offsets: r6.modifiersData.popperOffsets, position: r6.options.strategy, adaptive: T, roundOffsets: P })))), r6.modifiersData.arrow != null && (r6.styles.arrow = Object.assign({}, r6.styles.arrow, wc(Object.assign({}, U, { offsets: r6.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: P })))), r6.attributes.popper = Object.assign({}, r6.attributes.popper, { "data-popper-placement": r6.placement });
  }
  var _c = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: tA, data: {} };
  var Xl = { passive: true };
  function rA(t2) {
    var r6 = t2.state, s = t2.instance, c = t2.options, p = c.scroll, w = p === void 0 ? true : p, T = c.resize, k = T === void 0 ? true : T, P = jt(r6.elements.popper), j = [].concat(r6.scrollParents.reference, r6.scrollParents.popper);
    return w && j.forEach(function(U) {
      U.addEventListener("scroll", s.update, Xl);
    }), k && P.addEventListener("resize", s.update, Xl), function() {
      w && j.forEach(function(U) {
        U.removeEventListener("scroll", s.update, Xl);
      }), k && P.removeEventListener("resize", s.update, Xl);
    };
  }
  var Sc = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
  }, effect: rA, data: {} };
  var nA = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function _a2(t2) {
    return t2.replace(/left|right|bottom|top/g, function(r6) {
      return nA[r6];
    });
  }
  var iA = { start: "end", end: "start" };
  function Yl(t2) {
    return t2.replace(/start|end/g, function(r6) {
      return iA[r6];
    });
  }
  function xi(t2) {
    var r6 = jt(t2), s = r6.pageXOffset, c = r6.pageYOffset;
    return { scrollLeft: s, scrollTop: c };
  }
  function wi(t2) {
    return k1(dr(t2)).left + xi(t2).scrollLeft;
  }
  function W5(t2) {
    var r6 = jt(t2), s = dr(t2), c = r6.visualViewport, p = s.clientWidth, w = s.clientHeight, T = 0, k = 0;
    return c && (p = c.width, w = c.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (T = c.offsetLeft, k = c.offsetTop)), { width: p, height: w, x: T + wi(t2), y: k };
  }
  function G5(t2) {
    var r6, s = dr(t2), c = xi(t2), p = (r6 = t2.ownerDocument) == null ? void 0 : r6.body, w = M1(s.scrollWidth, s.clientWidth, p ? p.scrollWidth : 0, p ? p.clientWidth : 0), T = M1(s.scrollHeight, s.clientHeight, p ? p.scrollHeight : 0, p ? p.clientHeight : 0), k = -c.scrollLeft + wi(t2), P = -c.scrollTop;
    return Lr(p || s).direction === "rtl" && (k += M1(s.clientWidth, p ? p.clientWidth : 0) - w), { width: w, height: T, x: k, y: P };
  }
  function _i(t2) {
    var r6 = Lr(t2), s = r6.overflow, c = r6.overflowX, p = r6.overflowY;
    return /auto|scroll|overlay|hidden/.test(s + p + c);
  }
  function Kl(t2) {
    return ["html", "body", "#document"].indexOf(rr(t2)) >= 0 ? t2.ownerDocument.body : nr(t2) && _i(t2) ? t2 : Kl(U0(t2));
  }
  function Mn(t2, r6) {
    var s;
    r6 === void 0 && (r6 = []);
    var c = Kl(t2), p = c === ((s = t2.ownerDocument) == null ? void 0 : s.body), w = jt(c), T = p ? [w].concat(w.visualViewport || [], _i(c) ? c : []) : c, k = r6.concat(T);
    return p ? k : k.concat(Mn(U0(T)));
  }
  function Sa(t2) {
    return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
  }
  function aA(t2) {
    var r6 = k1(t2);
    return r6.top = r6.top + t2.clientTop, r6.left = r6.left + t2.clientLeft, r6.bottom = r6.top + t2.clientHeight, r6.right = r6.left + t2.clientWidth, r6.width = t2.clientWidth, r6.height = t2.clientHeight, r6.x = r6.left, r6.y = r6.top, r6;
  }
  function Ac(t2, r6) {
    return r6 === Gl ? Sa(W5(t2)) : nr(r6) ? aA(r6) : Sa(G5(dr(t2)));
  }
  function oA(t2) {
    var r6 = Mn(U0(t2)), s = ["absolute", "fixed"].indexOf(Lr(t2).position) >= 0, c = s && nr(t2) ? X1(t2) : t2;
    return j0(c) ? r6.filter(function(p) {
      return j0(p) && Go(p, c) && rr(p) !== "body";
    }) : [];
  }
  function V5(t2, r6, s) {
    var c = r6 === "clippingParents" ? oA(t2) : [].concat(r6), p = [].concat(c, [s]), w = p[0], T = p.reduce(function(k, P) {
      var j = Ac(t2, P);
      return k.top = M1(j.top, k.top), k.right = kn(j.right, k.right), k.bottom = kn(j.bottom, k.bottom), k.left = M1(j.left, k.left), k;
    }, Ac(t2, w));
    return T.width = T.right - T.left, T.height = T.bottom - T.top, T.x = T.left, T.y = T.top, T;
  }
  function Ko(t2) {
    var r6 = t2.reference, s = t2.element, c = t2.placement, p = c ? ir(c) : null, w = c ? D1(c) : null, T = r6.x + r6.width / 2 - s.width / 2, k = r6.y + r6.height / 2 - s.height / 2, P;
    switch (p) {
      case Ht:
        P = { x: T, y: r6.y - s.height };
        break;
      case Yt:
        P = { x: T, y: r6.y + r6.height };
        break;
      case Ut:
        P = { x: r6.x + r6.width, y: k };
        break;
      case Wt:
        P = { x: r6.x - s.width, y: k };
        break;
      default:
        P = { x: r6.x, y: r6.y };
    }
    var j = p ? yi(p) : null;
    if (j != null) {
      var U = j === "y" ? "height" : "width";
      switch (w) {
        case H0:
          P[j] = P[j] - (r6[U] / 2 - s[U] / 2);
          break;
        case gi:
          P[j] = P[j] + (r6[U] / 2 - s[U] / 2);
          break;
        default:
      }
    }
    return P;
  }
  function Y1(t2, r6) {
    r6 === void 0 && (r6 = {});
    var s = r6, c = s.placement, p = c === void 0 ? t2.placement : c, w = s.boundary, T = w === void 0 ? pc : w, k = s.rootBoundary, P = k === void 0 ? Gl : k, j = s.elementContext, U = j === void 0 ? wa : j, ee = s.altBoundary, G = ee === void 0 ? false : ee, ae = s.padding, ie3 = ae === void 0 ? 0 : ae, V = Xo(typeof ie3 != "number" ? ie3 : Yo(ie3, Cn)), de = U === wa ? gc : wa, ve = t2.rects.popper, _e2 = t2.elements[G ? de : U], Me = V5(j0(_e2) ? _e2 : _e2.contextElement || dr(t2.elements.popper), T, P), we = k1(t2.elements.reference), ye = Ko({ reference: we, element: ve, strategy: "absolute", placement: p }), xe = Sa(Object.assign({}, ve, ye)), Se = U === wa ? xe : we, Je = { top: Me.top - Se.top + V.top, bottom: Se.bottom - Me.bottom + V.bottom, left: Me.left - Se.left + V.left, right: Se.right - Me.right + V.right }, Ae = t2.modifiersData.offset;
    if (U === wa && Ae) {
      var Ue = Ae[p];
      Object.keys(Je).forEach(function(Ye) {
        var Dt = [Ut, Yt].indexOf(Ye) >= 0 ? 1 : -1, mt = [Ht, Yt].indexOf(Ye) >= 0 ? "y" : "x";
        Je[Ye] += Ue[mt] * Dt;
      });
    }
    return Je;
  }
  function $5(t2, r6) {
    r6 === void 0 && (r6 = {});
    var s = r6, c = s.placement, p = s.boundary, w = s.rootBoundary, T = s.padding, k = s.flipVariations, P = s.allowedAutoPlacements, j = P === void 0 ? Vl : P, U = D1(c), ee = U ? k ? j5 : j5.filter(function(ie3) {
      return D1(ie3) === U;
    }) : Cn, G = ee.filter(function(ie3) {
      return j.indexOf(ie3) >= 0;
    });
    G.length === 0 && (G = ee);
    var ae = G.reduce(function(ie3, V) {
      return ie3[V] = Y1(t2, { placement: V, boundary: p, rootBoundary: w, padding: T })[ir(V)], ie3;
    }, {});
    return Object.keys(ae).sort(function(ie3, V) {
      return ae[ie3] - ae[V];
    });
  }
  function sA(t2) {
    if (ir(t2) === Wl)
      return [];
    var r6 = _a2(t2);
    return [Yl(t2), r6, Yl(r6)];
  }
  function lA(t2) {
    var r6 = t2.state, s = t2.options, c = t2.name;
    if (!r6.modifiersData[c]._skip) {
      for (var p = s.mainAxis, w = p === void 0 ? true : p, T = s.altAxis, k = T === void 0 ? true : T, P = s.fallbackPlacements, j = s.padding, U = s.boundary, ee = s.rootBoundary, G = s.altBoundary, ae = s.flipVariations, ie3 = ae === void 0 ? true : ae, V = s.allowedAutoPlacements, de = r6.options.placement, ve = ir(de), _e2 = ve === de, Me = P || (_e2 || !ie3 ? [_a2(de)] : sA(de)), we = [de].concat(Me).reduce(function(Rr, zr) {
        return Rr.concat(ir(zr) === Wl ? $5(r6, { placement: zr, boundary: U, rootBoundary: ee, padding: j, flipVariations: ie3, allowedAutoPlacements: V }) : zr);
      }, []), ye = r6.rects.reference, xe = r6.rects.popper, Se = new Map(), Je = true, Ae = we[0], Ue = 0; Ue < we.length; Ue++) {
        var Ye = we[Ue], Dt = ir(Ye), mt = D1(Ye) === H0, m1 = [Ht, Yt].indexOf(Dt) >= 0, $t = m1 ? "width" : "height", Bt = Y1(r6, { placement: Ye, boundary: U, rootBoundary: ee, altBoundary: G, padding: j }), pe = m1 ? mt ? Ut : Wt : mt ? Yt : Ht;
        ye[$t] > xe[$t] && (pe = _a2(pe));
        var Sr = _a2(pe), Pe = [];
        if (w && Pe.push(Bt[Dt] <= 0), k && Pe.push(Bt[pe] <= 0, Bt[Sr] <= 0), Pe.every(function(Rr) {
          return Rr;
        })) {
          Ae = Ye, Je = false;
          break;
        }
        Se.set(Ye, Pe);
      }
      if (Je)
        for (var pt = ie3 ? 3 : 1, J1 = function(zr) {
          var p1 = we.find(function(L1) {
            var Q1 = Se.get(L1);
            if (Q1)
              return Q1.slice(0, zr).every(function(e0) {
                return e0;
              });
          });
          if (p1)
            return Ae = p1, "break";
        }, ar = pt; ar > 0; ar--) {
          var i1 = J1(ar);
          if (i1 === "break")
            break;
        }
      r6.placement !== Ae && (r6.modifiersData[c]._skip = true, r6.placement = Ae, r6.reset = true);
    }
  }
  var Tc = { name: "flip", enabled: true, phase: "main", fn: lA, requiresIfExists: ["offset"], data: { _skip: false } };
  function Ec(t2, r6, s) {
    return s === void 0 && (s = { x: 0, y: 0 }), { top: t2.top - r6.height - s.y, right: t2.right - r6.width + s.x, bottom: t2.bottom - r6.height + s.y, left: t2.left - r6.width - s.x };
  }
  function Cc(t2) {
    return [Ht, Ut, Yt, Wt].some(function(r6) {
      return t2[r6] >= 0;
    });
  }
  function uA(t2) {
    var r6 = t2.state, s = t2.name, c = r6.rects.reference, p = r6.rects.popper, w = r6.modifiersData.preventOverflow, T = Y1(r6, { elementContext: "reference" }), k = Y1(r6, { altBoundary: true }), P = Ec(T, c), j = Ec(k, p, w), U = Cc(P), ee = Cc(j);
    r6.modifiersData[s] = { referenceClippingOffsets: P, popperEscapeOffsets: j, isReferenceHidden: U, hasPopperEscaped: ee }, r6.attributes.popper = Object.assign({}, r6.attributes.popper, { "data-popper-reference-hidden": U, "data-popper-escaped": ee });
  }
  var kc = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: uA };
  function cA(t2, r6, s) {
    var c = ir(t2), p = [Wt, Ht].indexOf(c) >= 0 ? -1 : 1, w = typeof s == "function" ? s(Object.assign({}, r6, { placement: t2 })) : s, T = w[0], k = w[1];
    return T = T || 0, k = (k || 0) * p, [Wt, Ut].indexOf(c) >= 0 ? { x: k, y: T } : { x: T, y: k };
  }
  function fA(t2) {
    var r6 = t2.state, s = t2.options, c = t2.name, p = s.offset, w = p === void 0 ? [0, 0] : p, T = Vl.reduce(function(U, ee) {
      return U[ee] = cA(ee, r6.rects, w), U;
    }, {}), k = T[r6.placement], P = k.x, j = k.y;
    r6.modifiersData.popperOffsets != null && (r6.modifiersData.popperOffsets.x += P, r6.modifiersData.popperOffsets.y += j), r6.modifiersData[c] = T;
  }
  var Mc = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: fA };
  function hA(t2) {
    var r6 = t2.state, s = t2.name;
    r6.modifiersData[s] = Ko({ reference: r6.rects.reference, element: r6.rects.popper, strategy: "absolute", placement: r6.placement });
  }
  var Dc = { name: "popperOffsets", enabled: true, phase: "read", fn: hA, data: {} };
  function X5(t2) {
    return t2 === "x" ? "y" : "x";
  }
  function dA(t2) {
    var r6 = t2.state, s = t2.options, c = t2.name, p = s.mainAxis, w = p === void 0 ? true : p, T = s.altAxis, k = T === void 0 ? false : T, P = s.boundary, j = s.rootBoundary, U = s.altBoundary, ee = s.padding, G = s.tether, ae = G === void 0 ? true : G, ie3 = s.tetherOffset, V = ie3 === void 0 ? 0 : ie3, de = Y1(r6, { boundary: P, rootBoundary: j, padding: ee, altBoundary: U }), ve = ir(r6.placement), _e2 = D1(r6.placement), Me = !_e2, we = yi(ve), ye = X5(we), xe = r6.modifiersData.popperOffsets, Se = r6.rects.reference, Je = r6.rects.popper, Ae = typeof V == "function" ? V(Object.assign({}, r6.rects, { placement: r6.placement })) : V, Ue = { x: 0, y: 0 };
    if (!!xe) {
      if (w || k) {
        var Ye = we === "y" ? Ht : Wt, Dt = we === "y" ? Yt : Ut, mt = we === "y" ? "height" : "width", m1 = xe[we], $t = xe[we] + de[Ye], Bt = xe[we] - de[Dt], pe = ae ? -Je[mt] / 2 : 0, Sr = _e2 === H0 ? Se[mt] : Je[mt], Pe = _e2 === H0 ? -Je[mt] : -Se[mt], pt = r6.elements.arrow, J1 = ae && pt ? vi(pt) : { width: 0, height: 0 }, ar = r6.modifiersData["arrow#persistent"] ? r6.modifiersData["arrow#persistent"].padding : $o(), i1 = ar[Ye], Rr = ar[Dt], zr = bi(0, Se[mt], J1[mt]), p1 = Me ? Se[mt] / 2 - pe - zr - i1 - Ae : Sr - zr - i1 - Ae, L1 = Me ? -Se[mt] / 2 + pe + zr + Rr + Ae : Pe + zr + Rr + Ae, Q1 = r6.elements.arrow && X1(r6.elements.arrow), e0 = Q1 ? we === "y" ? Q1.clientTop || 0 : Q1.clientLeft || 0 : 0, y0 = r6.modifiersData.offset ? r6.modifiersData.offset[r6.placement][we] : 0, zn = xe[we] + p1 - y0 - e0, or = xe[we] + L1 - y0;
        if (w) {
          var Fr = bi(ae ? kn($t, zn) : $t, m1, ae ? M1(Bt, or) : Bt);
          xe[we] = Fr, Ue[we] = Fr - m1;
        }
        if (k) {
          var g1 = we === "x" ? Ht : Wt, Hr = we === "x" ? Yt : Ut, t0 = xe[ye], Fn = t0 + de[g1], jr = t0 - de[Hr], Zt = bi(ae ? kn(Fn, zn) : Fn, t0, ae ? M1(jr, or) : jr);
          xe[ye] = Zt, Ue[ye] = Zt - t0;
        }
      }
      r6.modifiersData[c] = Ue;
    }
  }
  var Bc = { name: "preventOverflow", enabled: true, phase: "main", fn: dA, requiresIfExists: ["offset"] };
  function Y5(t2) {
    return { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop };
  }
  function K5(t2) {
    return t2 === jt(t2) || !nr(t2) ? xi(t2) : Y5(t2);
  }
  function mA(t2) {
    var r6 = t2.getBoundingClientRect(), s = r6.width / t2.offsetWidth || 1, c = r6.height / t2.offsetHeight || 1;
    return s !== 1 || c !== 1;
  }
  function Z5(t2, r6, s) {
    s === void 0 && (s = false);
    var c = nr(r6), p = nr(r6) && mA(r6), w = dr(r6), T = k1(t2, p), k = { scrollLeft: 0, scrollTop: 0 }, P = { x: 0, y: 0 };
    return (c || !c && !s) && ((rr(r6) !== "body" || _i(w)) && (k = K5(r6)), nr(r6) ? (P = k1(r6, true), P.x += r6.clientLeft, P.y += r6.clientTop) : w && (P.x = wi(w))), { x: T.left + k.scrollLeft - P.x, y: T.top + k.scrollTop - P.y, width: T.width, height: T.height };
  }
  function pA(t2) {
    var r6 = new Map(), s = new Set(), c = [];
    t2.forEach(function(w) {
      r6.set(w.name, w);
    });
    function p(w) {
      s.add(w.name);
      var T = [].concat(w.requires || [], w.requiresIfExists || []);
      T.forEach(function(k) {
        if (!s.has(k)) {
          var P = r6.get(k);
          P && p(P);
        }
      }), c.push(w);
    }
    return t2.forEach(function(w) {
      s.has(w.name) || p(w);
    }), c;
  }
  function J5(t2) {
    var r6 = pA(t2);
    return vc.reduce(function(s, c) {
      return s.concat(r6.filter(function(p) {
        return p.phase === c;
      }));
    }, []);
  }
  function Q5(t2) {
    var r6;
    return function() {
      return r6 || (r6 = new Promise(function(s) {
        Promise.resolve().then(function() {
          r6 = void 0, s(t2());
        });
      })), r6;
    };
  }
  function e8(t2) {
    var r6 = t2.reduce(function(s, c) {
      var p = s[c.name];
      return s[c.name] = p ? Object.assign({}, p, c, { options: Object.assign({}, p.options, c.options), data: Object.assign({}, p.data, c.data) }) : c, s;
    }, {});
    return Object.keys(r6).map(function(s) {
      return r6[s];
    });
  }
  var Nc = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function Oc() {
    for (var t2 = arguments.length, r6 = new Array(t2), s = 0; s < t2; s++)
      r6[s] = arguments[s];
    return !r6.some(function(c) {
      return !(c && typeof c.getBoundingClientRect == "function");
    });
  }
  function qc(t2) {
    t2 === void 0 && (t2 = {});
    var r6 = t2, s = r6.defaultModifiers, c = s === void 0 ? [] : s, p = r6.defaultOptions, w = p === void 0 ? Nc : p;
    return function(k, P, j) {
      j === void 0 && (j = w);
      var U = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Nc, w), modifiersData: {}, elements: { reference: k, popper: P }, attributes: {}, styles: {} }, ee = [], G = false, ae = { state: U, setOptions: function(ve) {
        var _e2 = typeof ve == "function" ? ve(U.options) : ve;
        V(), U.options = Object.assign({}, w, U.options, _e2), U.scrollParents = { reference: j0(k) ? Mn(k) : k.contextElement ? Mn(k.contextElement) : [], popper: Mn(P) };
        var Me = J5(e8([].concat(c, U.options.modifiers)));
        if (U.orderedModifiers = Me.filter(function(Ye) {
          return Ye.enabled;
        }), false) {
          var we;
          if (getBasePlacement(U.options.placement) === auto)
            var ye;
          var xe, Se, Je, Ae, Ue;
        }
        return ie3(), ae.update();
      }, forceUpdate: function() {
        if (!G) {
          var ve = U.elements, _e2 = ve.reference, Me = ve.popper;
          if (!!Oc(_e2, Me)) {
            U.rects = { reference: Z5(_e2, X1(Me), U.options.strategy === "fixed"), popper: vi(Me) }, U.reset = false, U.placement = U.options.placement, U.orderedModifiers.forEach(function(Ye) {
              return U.modifiersData[Ye.name] = Object.assign({}, Ye.data);
            });
            for (var we = 0, ye = 0; ye < U.orderedModifiers.length; ye++) {
              if (U.reset === true) {
                U.reset = false, ye = -1;
                continue;
              }
              var xe = U.orderedModifiers[ye], Se = xe.fn, Je = xe.options, Ae = Je === void 0 ? {} : Je, Ue = xe.name;
              typeof Se == "function" && (U = Se({ state: U, options: Ae, name: Ue, instance: ae }) || U);
            }
          }
        }
      }, update: Q5(function() {
        return new Promise(function(de) {
          ae.forceUpdate(), de(U);
        });
      }), destroy: function() {
        V(), G = true;
      } };
      if (!Oc(k, P))
        return ae;
      ae.setOptions(j).then(function(de) {
        !G && j.onFirstUpdate && j.onFirstUpdate(de);
      });
      function ie3() {
        U.orderedModifiers.forEach(function(de) {
          var ve = de.name, _e2 = de.options, Me = _e2 === void 0 ? {} : _e2, we = de.effect;
          if (typeof we == "function") {
            var ye = we({ state: U, name: ve, instance: ae, options: Me }), xe = function() {
            };
            ee.push(ye || xe);
          }
        });
      }
      function V() {
        ee.forEach(function(de) {
          return de();
        }), ee = [];
      }
      return ae;
    };
  }
  var gA = [Sc, Dc, _c, yc, Mc, Tc, Bc, xc, kc];
  var t8 = qc({ defaultModifiers: gA });
  var r8 = cr(R0());
  var Pc = class extends xr {
    constructor() {
      super(...arguments);
      this.elts = {};
      this.queue = [];
      this.flushed = false;
      this.in_event = false;
      this.stateful = true;
      this.queue_update = (r6) => {
        this.queue.push(r6);
      };
      this.check_queue = () => {
        if (!r8.default.every(this.queue, (s) => s in this.elts))
          return;
        let r6 = null;
        this.queue.forEach((s) => {
          let { popperElement: c, referenceElement: p, instance: w, set_show: T } = this.elts[s], k = r6 === null ? p : r6;
          w.state.elements.reference = k, w.update(), T(true), r6 = c;
        }), Object.keys(this.elts).forEach((s) => {
          this.queue.indexOf(s) == -1 && this.elts[s].set_show(false);
        }), this.queue = [], this.in_event && (this.flushed = true);
      };
      this.on_click = () => {
        this.flushed || this.check_queue(), this.flushed = false, this.in_event = false;
      };
      this.on_click_capture = () => {
        this.in_event = true;
      };
      this.init = () => {
        (0, F.useEffect)(() => (window.addEventListener("click", this.on_click), window.addEventListener("click", this.on_click_capture, true), () => {
          window.removeEventListener("click", this.on_click), window.removeEventListener("click", this.on_click_capture, true);
        }), []);
      };
    }
  };
  var n8 = new wr(Pc);
  var Lc = (0, Ct.observer)(({ Inner: t2, Popup: r6 }) => {
    let [s, c] = (0, F.useState)(null), [p, w] = (0, F.useState)(null), [T, k] = (0, F.useState)(null), [P, j] = (0, F.useState)(null), U = kt(n8), [ee] = (0, F.useState)(r8.default.uniqueId()), [G, ae] = (0, F.useState)("start"), [ie3, V] = (0, F.useState)(false), de = () => {
      G == "start" && ae("mount"), U.queue_update(ee);
    };
    return (0, F.useEffect)(() => {
      if (G == "mount" && s && p) {
        ae("done");
        let ve = { getBoundingClientRect: () => s.getBoundingClientRect() }, _e2 = t8(ve, p, { placement: "top", modifiers: [{ name: "offset", options: { offset: [0, 10] } }, { name: "arrow", options: { element: T } }] });
        j(_e2), console.log(p, s), U.elts[ee] = { popperElement: p, referenceElement: ve, instance: _e2, set_show: V }, U.check_queue();
      }
    }, [G, s, p]), N.createElement(N.Fragment, null, N.createElement(t2, { ref: c, onClick: de }), G != "start" ? N.createElement(Ic, null, N.createElement("div", { className: "tooltip", ref: w, style: { ...G == "done" ? P.state.styles.popper : {}, visibility: ie3 ? "visible" : "hidden" }, ...G == "done" ? P.state.attributes.popper : {} }, N.createElement("div", { className: "arrow", ref: k, style: { display: ie3 ? "block" : "none" } }), N.createElement(r6, null))) : null);
  });
  var Zo = class extends xr {
    constructor() {
      super();
      this.defs = {};
      this.def_mode = false;
      this.used_definitions = new Set();
      this.stateful = true;
      this.register_use = (0, ze.action)((r6) => {
        this.used_definitions.add(r6);
      });
      this.get_definition = (r6) => this.defs[r6];
      this.add_definition = (0, ze.action)((r6, s) => {
        r6 in this.defs || (this.defs[r6] = s);
      });
      this.all_definitions = (r6) => i8.default.fromPairs(Object.keys(this.defs).filter((s) => r6 ? s.startsWith(r6) : true).map((s) => [s, this.defs[s]]));
      (0, ze.makeObservable)(this);
    }
    init() {
      let r6 = (0, ze.action)(({ key: c }) => {
        c === "Alt" && (this.def_mode = true);
      }), s = (0, ze.action)(({ key: c }) => {
        c == "Alt" && (this.def_mode = false);
      });
      (0, F.useEffect)(() => (window.addEventListener("keydown", r6), window.addEventListener("keyup", s), () => {
        window.removeEventListener("keydown", r6), window.removeEventListener("keyup", s);
      }), []);
    }
  };
  T1([ze.observable.shallow], Zo.prototype, "defs", 2), T1([ze.observable], Zo.prototype, "def_mode", 2), T1([ze.observable], Zo.prototype, "used_definitions", 2);
  var W0 = new wr(Zo);
  var zc = (t2) => `def-${t2.replace(":", "-")}`;
  var a8 = (t2) => N.createElement(p0, { block: t2.block, id: zc(t2.name) }, t2.children);
  var G0 = (t2) => {
    let r6 = kt(W0), [s] = (0, F.useState)(t2.name || i8.default.uniqueId());
    return (0, F.useEffect)(() => {
      let c = typeof t2.Tooltip != "undefined" ? t2.Tooltip : () => N.createElement(N.Fragment, null, t2.children), p = t2.Label || null;
      r6.add_definition(s, { Tooltip: c, Label: p });
    }, []), t2.children ? N.createElement(a8, { block: t2.block, name: s }, t2.children) : null;
  };
  var Jo = (0, Ct.observer)(({ block: t2, nolink: r6, children: s, ...c }) => {
    let p = c.name, w = kt(W0), T = kt(Wo);
    (0, F.useEffect)(() => {
      w.register_use(p);
    }, []);
    let k = w.get_definition(p);
    if (!k)
      return N.createElement("span", { className: "error" }, p);
    let P = (ae) => {
      ae.preventDefault(), ae.stopPropagation(), T.scroll_to(zc(p));
    }, j = s ? N.createElement(N.Fragment, null, s) : k.Label ? N.createElement(k.Label, { ...c }) : N.createElement("span", { className: "error" }, "No children or label for \u201C", p, "\u201D"), ee = { [k.Tooltip ? "onDoubleClick" : "onClick"]: P }, G = (0, F.forwardRef)(function(ie3, V) {
      return N.createElement(p0, { ref: V, block: t2, className: (0, Rc.default)("ref", { nolink: r6 }), ...ie3, ...ee }, j);
    });
    return k.Tooltip ? N.createElement(Lc, { Inner: G, Popup: k.Tooltip }) : N.createElement(G, null);
  });
  var vA = String.raw;
  var Zl = (t2, r6, s, c = []) => {
    if (c.length > 0)
      throw "KaTeX currently doesn't support default arguments to newcommand. Check on this issue: https://github.com/KaTeX/KaTeX/issues/2228";
    let p = c.map((w) => `[${w}]`).join("");
    return vA`\newcommand{${"\\" + t2}}[${r6}]${p}{\htmlData{cmd=${t2}}{${s}}}`;
  };
  var Qo = new wr(class extends xr {
    constructor() {
      super();
      this.macros = {};
    }
    async dimensions(t2, r6, s) {
      let c = this.render(t2, r6, true), p = document.createElement("div");
      p.style.display = "inline-block", p.style.position = "absolute", p.style.left = "-99999px", Co.render(c, p);
      let w = new Promise((k, P) => {
        let j = new MutationObserver((U) => {
          U.forEach((ee) => {
            Array.from(ee.addedNodes).forEach((G) => {
              G == p && (j.disconnect(), k(void 0));
            });
          });
        });
        j.observe(s, { childList: true, subtree: false });
      });
      s.appendChild(p), await w;
      let T = p.getBoundingClientRect();
      return s.removeChild(p), T;
    }
    render(t2, r6 = false, s = false, c = {}, p) {
      let w;
      try {
        w = o8.default.renderToString(t2, { macros: this.macros, globalGroup: true, trust: true, strict: false, output: "html", displayMode: r6 });
      } catch (U) {
        if (U instanceof o8.default.ParseError)
          return console.error(U), N.createElement(p0, { ref: p, className: "error", block: r6, ...c }, N.createElement(p0, { block: r6 }, U.message), r6 ? N.createElement("pre", null, t2) : null);
        throw U;
      }
      if (s)
        return N.createElement(p0, { ref: p, block: r6, dangerouslySetInnerHTML: { __html: w }, ...c });
      let T = new s8.default.ProcessNodeDefinitions(N), k = [{ shouldProcessNode: (U) => U.attribs && "data-cmd" in U.attribs, processNode: (U, ee, G) => {
        let ae = U.attribs["data-cmd"], ie3 = T.processDefaultNode(U, ee, G);
        return N.createElement(Jo, { name: `tex:${ae}`, nolink: true }, ie3);
      } }, { shouldProcessNode: (U) => U.attribs && "data-def" in U.attribs, processNode: (U, ee, G) => {
        let ae = U.attribs["data-def"], ie3 = T.processDefaultNode(U, ee, G);
        return N.createElement(a8, { name: `tex:${ae}` }, ie3);
      } }, { shouldProcessNode: (U) => true, processNode: T.processDefaultNode }], j = new s8.default.Parser().parseWithInstructions(w, (U) => true, k);
      return N.createElement(p0, { ref: p, block: r6, ...c }, j);
    }
  });
  var l8 = N.memo(function({ children: r6, raw: s, block: c, ...p }) {
    return kt(Qo).render(r6, c, s, p);
  }, (t2, r6) => t2.children == r6.children);
  var yA = (t2) => N.createElement(l8, { block: false, ...t2 });
  var Aa = (t2) => N.createElement(l8, { block: true, ...t2 });
  Ge();
  var d1 = {};
  Sn(d1, { default: () => dist_exports2 });
  bt(d1, dist_exports2);
  var Si = {};
  Sn(Si, { default: () => dist_exports3 });
  bt(Si, dist_exports3);
  var Ai = {};
  Sn(Ai, { default: () => dist_exports4 });
  bt(Ai, dist_exports4);
  var B1 = {};
  Sn(B1, { default: () => dist_exports });
  bt(B1, dist_exports);
  var Fc = cr(R0());
  var Hc = B1.StateEffect.define();
  var jc = B1.StateEffect.define();
  var SA = B1.StateField.define({ create() {
    return d1.Decoration.none;
  }, update(t2, r6) {
    t2 = t2.map(r6.changes);
    for (let s of r6.effects)
      if (s.is(Hc)) {
        let { to: c, from: p, color: w } = s.value, T = d1.Decoration.mark({ class: `cm-highlight bgcolor-${w}` });
        t2 = t2.update({ add: [T.range(p, c)] });
      } else if (s.is(jc))
        return t2.update({ filter: (c) => false });
    return t2;
  }, provide: (t2) => d1.EditorView.decorations.from(t2) });
  var AA = d1.EditorView.theme({ ".cm-scroller": { fontFamily: "Inconsolata, monospace" }, ".cm-gutters": { background: "none", border: "none" }, ".cm-lineNumbers .cm-gutterElement": { fontSize: "10px", paddingTop: "3px", paddingRight: "7px", minWidth: "10px" }, ".cm-highlight": { padding: "0 2px", margin: "-1px -2px", borderRadius: "2px" } });
  var TA = (t2, { line: r6, col: s }) => t2.state.doc.line(r6).from + s;
  var EA = (t2, r6) => {
    let s = t2.state.doc.lineAt(r6);
    return { line: s.number, col: r6 - s.from };
  };
  var es = new wr(class extends xr {
  });
  var CA = ({ language: t2 }) => {
    let r6 = kt(es);
    return r6.language = t2, null;
  };
  var kA = (t2, r6) => {
    let [s, c] = Fc.default.unzip(r6), p = (G) => {
      let ae = new RegExp(`^${G.join("|")}`);
      return (ie3) => {
        let V = ie3.match(ae);
        return V ? V[0].length : null;
      };
    }, [w, T] = [p(s), p(c)], k = 0, P = null, j = [], U = [], ee = 0;
    for (; ee < t2.length; ) {
      if (P === null) {
        let G = w(t2.substring(ee));
        if (G) {
          ee += G, P = k;
          continue;
        }
      } else {
        let G = T(t2.substring(ee));
        if (G) {
          ee += G, j.push([P, k]), P = null;
          continue;
        }
      }
      k += 1, U.push(t2[ee]), ee += 1;
    }
    return { output_code: U.join(""), ranges: j };
  };
  var MA = (t2) => {
    let r6 = kt(es), s = (0, F.useRef)(null);
    return (0, F.useEffect)(() => {
      let c = t2.language || r6.language, p = t2.code, w = null;
      if (t2.delimiters) {
        if (w = kA(p, t2.delimiters.delimiters), w.error)
          throw w.error;
        p = w.output_code;
      }
      let T = new d1.EditorView({ state: B1.EditorState.create({ doc: p, extensions: [(0, Si.lineNumbers)(), Ai.defaultHighlightStyle, AA, d1.EditorView.editable.of(t2.editable || false), SA].concat(c ? [c] : []).concat(t2.extensions || []) }), parent: s.current });
      t2.onLoad && t2.onLoad(T), t2.delimiters && t2.delimiters.onParse(w.ranges);
    }, []), N.createElement("div", { ref: s });
  };
  Ge();
  var u8 = cr(R0());
  var c8 = class extends xr {
    constructor() {
      super();
      this.queue = [];
      this.log = (0, ze.action)((r6, s = 5e3) => {
        let c = u8.default.uniqueId("log");
        this.queue.push({ Message: r6, duration: s, id: c }), setTimeout((0, ze.action)(() => {
          u8.default.remove(this.queue, { id: c });
        }), s);
      });
      (0, ze.makeObservable)(this);
    }
  };
  T1([ze.observable], c8.prototype, "queue", 2);
  var Jl = new wr(c8);
  var Uc = (0, Ct.observer)(() => {
    let t2 = kt(Jl);
    return N.createElement("div", { className: "logger" }, t2.queue.map(({ Message: r6, duration: s, id: c }) => N.createElement("div", { className: "log", key: c, style: { animation: `fade ${s}ms` } }, N.createElement(r6, null))));
  });
  var eu = class {
    constructor(r6 = ["1"]) {
      this.stylize = (r7, s) => {
        if (s == "1")
          return r7.toString();
        if (s == "a") {
          let c = "a".charCodeAt(0) + r7 - 1;
          return String.fromCharCode(c);
        } else
          throw `Bad style ${s}`;
      };
      this.top = () => this.stack.slice(0, -1).map((r7, s) => this.stylize(r7, this.styles[s % this.styles.length]));
      this.push = () => (this.stack[this.stack.length - 1] += 1, this.stack.push(0), this.top());
      this.Pop = () => (this.stack.pop(), null);
      this.stack = [0], this.styles = r6;
    }
  };
  var f8 = class {
    constructor() {
      this.sections = new eu();
      this.figures = new eu(["1", "a"]);
      this.theorems = new eu();
      this.footnotes = [];
      this.anonymous = false;
    }
  };
  var K1 = N.createContext(new f8());
  var h8 = ({ children: t2, plain: r6 }) => {
    let c = (0, F.useContext)(K1).sections.top(), p = c.length, w = c.join("."), T;
    return !p || p == 1 ? T = (k) => N.createElement("h2", { ...k }) : p == 2 ? T = (k) => N.createElement("h3", { ...k }) : T = (k) => N.createElement("h4", { ...k }), T.displayName = "Header", N.createElement(T, { className: "section-title" }, r6 ? null : N.createElement("span", { className: "section-number" }, w), " ", t2);
  };
  var d8 = ({ name: t2, children: r6 }) => {
    let s = (0, F.useContext)(K1), c = s.sections.stack.length == 1;
    c && s.theorems.push();
    let w = s.sections.push().join(".");
    return N.createElement(G0, { name: t2, Label: () => N.createElement(N.Fragment, null, "Section ", w), Tooltip: null, block: true }, N.createElement("section", null, r6, N.createElement(s.sections.Pop, null), c ? N.createElement(s.theorems.Pop, null) : null));
  };
  var DA = d8;
  var BA = d8;
  var m8 = class {
  };
  var Gc = N.createContext(new m8());
  var Vc = (t2) => {
    let r6 = (0, F.useContext)(K1), s = r6.figures.push(), c = s.length, p = s.join("-"), w = new m8(), T = () => N.createElement(G0, { name: t2.name, Label: () => N.createElement(N.Fragment, null, `Figure ${p}`), Tooltip: null, block: true }, N.createElement("div", { className: "caption" }, c > 1 ? `(${s[s.length - 1]})` : `Figure ${p}:`, " ", w.caption));
    return N.createElement(Gc.Provider, { value: w }, N.createElement("div", { className: `figure level-${c}` }, t2.children, N.createElement(T, null)), N.createElement(r6.figures.Pop, null));
  };
  var NA = Vc;
  var OA = (t2) => {
    let r6 = (0, F.useContext)(Gc);
    return r6.caption = N.createElement(N.Fragment, null, t2.children), null;
  };
  var qA = ({ align: t2, children: r6 }) => {
    let s = "1rem", c;
    return t2 == "left" ? c = { marginRight: s } : t2 == "right" ? c = { marginLeft: s } : c = {}, N.createElement("div", { style: { float: t2, ...c } }, r6);
  };
  var p8 = ({ children: t2 }) => N.createElement("span", { className: "smallcaps" }, t2);
  var $c = ({ style: t2, className: r6, ...s }) => {
    let c = (0, F.useRef)(null), [p, w] = (0, F.useState)(0);
    return (0, F.useEffect)(() => {
      let { left: T } = c.current.getBoundingClientRect();
      w(-T);
    }, []), N.createElement("div", { ref: c, className: `full-width-container ${r6}`, style: { width: document.documentElement.clientWidth, left: p, ...t2 }, ...s });
  };
  var g8 = ({ children: t2, className: r6, ...s }) => N.createElement("div", { ...s, className: (0, Ql.default)("row", r6) }, t2);
  var tu = class {
    constructor() {
      this.portal = null;
    }
  };
  T1([ze.observable], tu.prototype, "portal", 2);
  var Xc = N.createContext(new tu());
  var Ic = (0, Ct.observer)(({ children: t2 }) => {
    let r6 = (0, F.useContext)(Xc);
    return r6.portal !== null ? Co.createPortal(t2, r6.portal) : null;
  });
  var PA = ({ children: t2 }) => N.createElement("div", { style: { margin: "0 auto", width: "max-content" } }, t2);
  var LA = ({ children: t2, prompt: r6 }) => {
    let s = kt(Wo), c = (0, F.useRef)(null), [p, w] = (0, F.useState)(false), [T, k] = (0, F.useState)(0), [P] = (0, F.useState)(() => Wc.default.uniqueId());
    return (0, F.useEffect)(() => {
      let j = new ResizeObserver((U) => {
        let ee = U[0].borderBoxSize[0].blockSize;
        k(ee);
      });
      return j.observe(c.current), console.log("registering", P, "to", s), s.register_scroll_hook(P, () => {
        w(true);
      }), () => {
        j.disconnect();
      };
    }, []), N.createElement("div", { className: (0, Ql.default)("expandable", { expanded: p }) }, N.createElement("div", { style: { textAlign: "center" } }, N.createElement("span", { className: "expand", onClick: () => w(!p) }, p ? "Hide..." : r6, N.createElement("span", { style: { fontSize: "0.7em" } }, "\xA0 ", p ? "\u2B06" : "\u2B07"))), N.createElement("div", { className: "inner nomargin", style: { height: p ? T : 0 } }, N.createElement("div", { id: P, ref: c }, t2)));
  };
  var Yc = ({ children: t2 }) => ((0, F.useContext)(K1).footnotes.push(t2), null);
  var IA = ({ children: t2 }) => {
    let s = (0, F.useContext)(K1).footnotes.length;
    return N.createElement(N.Fragment, null, N.createElement(Yc, null, t2), N.createElement(Jo, { name: `footnote:${s}` }));
  };
  var RA = (t2) => {
    let r6 = (0, F.useContext)(K1);
    return r6.footnotes.length == 0 ? null : N.createElement("div", { className: "footnotes" }, r6.footnotes.map((s, c) => (c += 1, N.createElement("div", { className: "footnote", id: `footnote-${c}`, key: c }, N.createElement("div", { className: "footnote-number" }, c), N.createElement(G0, { name: `footnote:${c}`, Label: () => N.createElement("sup", { className: "footnote" }, c), block: true }, N.createElement("div", { className: "footnote-body" }, s))))));
  };
  var zA = (0, Ct.observer)(({ children: t2 }) => {
    let r6 = kt(W0);
    return N.createElement(N.Fragment, null, N.createElement("div", { className: (0, Ql.default)("document", { "def-mode": r6.def_mode }) }, t2), N.createElement(RA, null), N.createElement(Uc, null));
  });
  var FA = () => [W0, Qo, ru, n8, es, Wo, Jl];
  var HA = ({ children: t2, onLoad: r6 }) => {
    let s = new tu();
    r6 && (0, F.useEffect)(r6, []);
    let c = FA().reduce((p, w) => N.createElement(w.Provide, null, p), N.createElement(zA, null, t2));
    return N.createElement(N.Fragment, null, N.createElement(K1.Provider, { value: new f8() }, N.createElement(Xc.Provider, { value: s }, c)), N.createElement("div", { className: "portal", ref: (p) => {
      s.portal = p;
    } }));
  };
  function v8(t2) {
    return typeof t2 == "string";
  }
  var Zc = class {
    constructor(r6) {
      this.key = r6.citationKey;
      let s = r6.entryTags;
      v8(s.author) && (this.authors = s.author.split(" and ").map((c) => c.split(", "))), v8(s.year) && (this.year = parseInt(s.year)), v8(s.title) && (this.title = s.title), this.tags = s;
    }
    display_author() {
      if (this.authors) {
        if (this.authors.length > 2)
          return `${this.authors[0][0]} et al.`;
        if (this.authors.length > 1)
          return `${this.authors[0][0]} and ${this.authors[1][0]}`;
        if (this.authors.length > 0)
          return this.authors[0][0];
        throw "Empty author list";
      } else
        return "??";
    }
    bib_cite() {
      let r6 = this.authors?.map((c) => [...c.slice(1), c[0]].join(" ")), s = this.tags.journal || this.tags.booktitle;
      return N.createElement("div", { className: "bib-reference" }, r6 ? (r6.length > 1 ? r6.slice(0, -1).join(", ") + ", and " + r6[r6.length - 1] : r6[0]) + ". " : null, this.year ? this.year + ". " : null, this.title ? this.title + ". " : null, s ? N.createElement("i", null, s, this.tags.number ? ` (${this.tags.number})` : null, ". ") : null, this.tags.note);
    }
  };
  function Jc(t2, r6) {
    return t2.length === 0 ? [] : t2.slice(1).reduce(function(s, c, p) {
      return s.concat([N.createElement(r6, { key: p }), c]);
    }, [t2[0]]);
  }
  var y8 = class extends xr {
    constructor() {
      super();
      this.citations = {};
      this.stateful = true;
      this.import_bibtex = (0, ze.action)((r6) => {
        Kc.default.toJSON(r6).forEach((c) => {
          this.citations[c.citationKey] = new Zc(c);
        });
      });
      (0, ze.makeObservable)(this);
    }
    cite(r6, s, c, p) {
      let w = p ? `, ${p}` : "";
      for (let T of r6)
        if (!this.citations[T])
          return N.createElement("span", { className: "error" }, T);
      return s ? Jc(r6.map((T) => {
        let k = this.citations[T], P = k.display_author();
        return N.createElement("span", { key: T }, `${P} [${k.year}${w}]`);
      }), (T) => N.createElement("span", { ...T }, "; ")) : N.createElement("span", null, "[", Jc(r6.map((T) => {
        let k = this.citations[T];
        if (c)
          return N.createElement("span", { key: T }, `${k.year}${w}`);
        {
          let P = k.display_author();
          return N.createElement("span", { key: T }, `${P} ${k.year}${w}`);
        }
      }), (T) => N.createElement("span", { ...T }, "; ")), "]");
    }
  };
  T1([ze.observable], y8.prototype, "citations", 2);
  var ru = new wr(y8);
  var jA = (0, Ct.observer)(({ bibtex: t2 }) => {
    let r6 = kt(ru), s = kt(W0);
    (0, F.useEffect)(() => {
      r6.import_bibtex(t2);
    }, []);
    let c = Object.keys(r6.citations).filter((p) => s.used_definitions.has(p));
    return N.createElement("section", null, N.createElement(h8, { plain: true }, "References"), N.createElement("div", { className: "bib-references" }, c.filter((p) => p in r6.citations).map((p) => N.createElement(G0, { key: p, name: p, Label: Qc, block: true }, r6.citations[p].bib_cite()))));
  });
  var Qc = (0, Ct.observer)(({ name: t2, full: r6, year: s, extra: c }) => {
    let p = kt(ru), w = typeof t2 == "string" ? [t2] : t2;
    return N.createElement(N.Fragment, null, p.cite(w, r6 || false, s || false, c));
  });
  Ge();
  Ge();
  var ef = (0, F.createContext)({});
  var UA = ({ children: t2 }) => N.createElement("span", { className: "inline-error" }, t2);
  var b8 = (0, F.createContext)({});
  var WA = ({ value: t2 }) => {
    let r6 = (0, F.useContext)(ef);
    return r6.institution = t2, N.createElement(N.Fragment, null);
  };
  var GA = ({ children: t2 }) => {
    let r6 = (0, F.useContext)(b8), s = {}, c = () => (r6.affiliations || (r6.affiliations = []), r6.affiliations.push(s), N.createElement(N.Fragment, null));
    return N.createElement(N.Fragment, null, N.createElement(ef.Provider, { value: s }, t2), N.createElement(c, null));
  };
  var VA = ({ value: t2 }) => {
    let r6 = (0, F.useContext)(b8);
    return r6.name = t2, N.createElement(N.Fragment, null);
  };
  var $A = ({ children: t2 }) => {
    let r6 = {}, s = () => N.createElement("div", { className: "author" }, r6.name ? N.createElement("span", { className: "author-name" }, r6.name) : N.createElement(UA, null, "No author name!"), r6.affiliations ? N.createElement("span", { className: "author-affiliation" }, ",", " ", r6.affiliations.map((c, p) => N.createElement("span", { key: p }, c.institution ? c.institution : null, c.country ? N.createElement(N.Fragment, null, ", ", c.country) : null))) : null);
    return N.createElement(N.Fragment, null, N.createElement(b8.Provider, { value: r6 }, t2), N.createElement(s, null));
  };
  var XA = ({ children: t2 }) => {
    let r6 = (0, F.useContext)(K1);
    return N.createElement("div", { className: "authors" }, r6.anonymous ? N.createElement("div", { className: "author" }, N.createElement("span", { className: "author-name" }, "Anonymous author(s)")) : t2);
  };
  var YA = ({ children: t2 }) => N.createElement("h1", { className: "document-title" }, t2);
  var KA = ({ children: t2 }) => N.createElement("div", { className: "abstract" }, t2);
  Ge();
  Ge();
  var Dn = (() => typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global || typeof global == "object" && global.GLOBAL === global ? global : {})();
  Dn.__REACT_ASYNC__ = Dn.__REACT_ASYNC__ || {};
  var x8 = () => {
  };
  var w8 = class {
    constructor() {
      this.abort = x8, this.signal = {};
    }
  };
  var qe;
  try {
    qe = Gt();
  } catch (t2) {
  }
  var Ta = qe && qe.oneOfType([qe.node, qe.func]);
  var ts = qe && qe.shape({ initialValue: qe.any, data: qe.any, error: qe.instanceOf(Error), value: qe.any, startedAt: qe.instanceOf(Date), finishedAt: qe.instanceOf(Date), status: qe.oneOf(["initial", "pending", "fulfilled", "rejected"]), isInitial: qe.bool, isPending: qe.bool, isLoading: qe.bool, isFulfilled: qe.bool, isResolved: qe.bool, isRejected: qe.bool, isSettled: qe.bool, counter: qe.number, promise: qe.instanceOf(Promise), run: qe.func, reload: qe.func, cancel: qe.func, setData: qe.func, setError: qe.func });
  var Bn = qe && { Async: { children: Ta, promise: qe.instanceOf(Promise), promiseFn: qe.func, deferFn: qe.func, watch: qe.any, watchFn: qe.func, initialValue: qe.any, onResolve: qe.func, onReject: qe.func, reducer: qe.func, dispatcher: qe.func, debugLabel: qe.string, suspense: qe.bool }, Initial: { children: Ta, state: ts.isRequired, persist: qe.bool }, Pending: { children: Ta, state: ts.isRequired, initial: qe.bool }, Fulfilled: { children: Ta, state: ts.isRequired, persist: qe.bool }, Rejected: { children: Ta, state: ts.isRequired, persist: qe.bool }, Settled: { children: Ta, state: ts.isRequired, persist: qe.bool } };
  var rs = (t2, ...r6) => typeof t2 == "function" ? t2(...r6) : t2;
  var uf = ({ children: t2, persist: r6, state: s = {} }) => N.createElement(N.Fragment, null, s.isInitial || r6 && !s.data ? rs(t2, s) : null);
  var cf = ({ children: t2, initial: r6, state: s = {} }) => N.createElement(N.Fragment, null, s.isPending && (!r6 || !s.value) ? rs(t2, s) : null);
  var ff = ({ children: t2, persist: r6, state: s = {} }) => N.createElement(N.Fragment, null, s.isFulfilled || r6 && s.data ? rs(t2, s.data, s) : null);
  var hf = ({ children: t2, persist: r6, state: s = {} }) => N.createElement(N.Fragment, null, s.isRejected || r6 && s.error ? rs(t2, s.error, s) : null);
  var df = ({ children: t2, persist: r6, state: s = {} }) => N.createElement(N.Fragment, null, s.isSettled || r6 && s.value ? rs(t2, s) : null);
  Bn && (uf.propTypes = Bn.Initial, cf.propTypes = Bn.Pending, ff.propTypes = Bn.Fulfilled, hf.propTypes = Bn.Rejected, df.propTypes = Bn.Settled);
  var Vt;
  (function(t2) {
    t2.initial = "initial", t2.pending = "pending", t2.fulfilled = "fulfilled", t2.rejected = "rejected";
  })(Vt || (Vt = {}));
  var QA = (t2, r6) => t2 instanceof Error ? Vt.rejected : t2 !== void 0 ? Vt.fulfilled : r6 ? Vt.pending : Vt.initial;
  var eT = (t2) => t2 instanceof Error ? Vt.rejected : t2 !== void 0 ? Vt.fulfilled : Vt.initial;
  var ns = (t2) => ({ status: t2, isInitial: t2 === Vt.initial, isPending: t2 === Vt.pending, isLoading: t2 === Vt.pending, isFulfilled: t2 === Vt.fulfilled, isResolved: t2 === Vt.fulfilled, isRejected: t2 === Vt.rejected, isSettled: t2 === Vt.fulfilled || t2 === Vt.rejected });
  var nu = function() {
  };
  Object.setPrototypeOf ? Object.setPrototypeOf(nu, Promise) : nu.__proto__ = Promise;
  nu.prototype = Object.assign(Object.create(Promise.prototype), { finally() {
    return this;
  }, catch() {
    return this;
  }, then() {
    return this;
  } });
  var is2 = new nu();
  var Ir;
  (function(t2) {
    t2.start = "start", t2.cancel = "cancel", t2.fulfill = "fulfill", t2.reject = "reject";
  })(Ir || (Ir = {}));
  var mf = ({ initialValue: t2, promise: r6, promiseFn: s }) => ({ initialValue: t2, data: t2 instanceof Error ? void 0 : t2, error: t2 instanceof Error ? t2 : void 0, value: t2, startedAt: r6 || s ? new Date() : void 0, finishedAt: t2 ? new Date() : void 0, ...ns(QA(t2, r6 || s)), counter: 0, promise: is2 });
  var iu = (t2, r6) => {
    switch (r6.type) {
      case Ir.start:
        return { ...t2, startedAt: new Date(), finishedAt: void 0, ...ns(Vt.pending), counter: r6.meta.counter, promise: r6.meta.promise };
      case Ir.cancel:
        return { ...t2, startedAt: void 0, finishedAt: void 0, ...ns(eT(t2.error || t2.data)), counter: r6.meta.counter, promise: r6.meta.promise };
      case Ir.fulfill:
        return { ...t2, data: r6.payload, value: r6.payload, error: void 0, finishedAt: new Date(), ...ns(Vt.fulfilled), promise: r6.meta.promise };
      case Ir.reject:
        return { ...t2, error: r6.payload, value: r6.payload, finishedAt: new Date(), ...ns(Vt.rejected), promise: r6.meta.promise };
      default:
        return t2;
    }
  };
  var _82 = (t2) => (r6, ...s) => {
    t2(r6, ...s), r6.type === Ir.start && typeof r6.payload == "function" && r6.payload();
  };
  function rT(t2 = {}, r6 = "Async") {
    let { Consumer: s, Provider: c } = N.createContext(void 0);
    function p({ children: ee }) {
      return N.createElement(s, null, (G) => {
        if (!G)
          throw new Error("this component should only be used within an associated <Async> component!");
        return ee(G);
      });
    }
    class w extends N.Component {
      constructor(G) {
        super(G);
        this.mounted = false, this.counter = 0, this.args = [], this.promise = is2, this.abortController = new w8(), this.start = this.start.bind(this), this.load = this.load.bind(this), this.run = this.run.bind(this), this.cancel = this.cancel.bind(this), this.onResolve = this.onResolve.bind(this), this.onReject = this.onReject.bind(this), this.setData = this.setData.bind(this), this.setError = this.setError.bind(this);
        let ae = G.promise, ie3 = G.promiseFn || t2.promiseFn, V = G.initialValue || t2.initialValue;
        this.state = { ...mf({ initialValue: V, promise: ae, promiseFn: ie3 }), cancel: this.cancel, run: this.run, reload: () => {
          this.load(), this.run(...this.args);
        }, setData: this.setData, setError: this.setError }, this.debugLabel = G.debugLabel || t2.debugLabel;
        let { devToolsDispatcher: de } = Dn.__REACT_ASYNC__, ve = G.reducer || t2.reducer, _e2 = G.dispatcher || t2.dispatcher || de, Me = ve ? (ye, xe) => ve(ye, xe, iu) : iu, we = _82((ye, xe) => {
          this.setState((Se) => Me(Se, ye), xe);
        });
        this.dispatch = _e2 ? (ye) => _e2(ye, we, G) : we;
      }
      componentDidMount() {
        this.mounted = true, (this.props.promise || !this.state.initialValue) && this.load();
      }
      componentDidUpdate(G) {
        let { watch: ae, watchFn: ie3 = t2.watchFn, promise: V, promiseFn: de } = this.props;
        if (ae !== G.watch)
          return this.counter && this.cancel(), this.load();
        if (ie3 && ie3({ ...t2, ...this.props }, { ...t2, ...G }))
          return this.counter && this.cancel(), this.load();
        if (V !== G.promise && (this.counter && this.cancel(), V))
          return this.load();
        if (de !== G.promiseFn && (this.counter && this.cancel(), de))
          return this.load();
      }
      componentWillUnmount() {
        this.cancel(), this.mounted = false;
      }
      getMeta(G) {
        return { counter: this.counter, promise: this.promise, debugLabel: this.debugLabel, ...G };
      }
      start(G) {
        return "AbortController" in Dn && (this.abortController.abort(), this.abortController = new Dn.AbortController()), this.counter++, this.promise = new Promise((ae, ie3) => {
          if (!this.mounted)
            return;
          let V = () => G().then(ae, ie3);
          this.dispatch({ type: Ir.start, payload: V, meta: this.getMeta() });
        });
      }
      load() {
        let G = this.props.promise, ae = this.props.promiseFn || t2.promiseFn;
        if (G)
          this.start(() => G).then(this.onResolve(this.counter)).catch(this.onReject(this.counter));
        else if (ae) {
          let ie3 = { ...t2, ...this.props };
          this.start(() => ae(ie3, this.abortController)).then(this.onResolve(this.counter)).catch(this.onReject(this.counter));
        }
      }
      run(...G) {
        let ae = this.props.deferFn || t2.deferFn;
        if (ae) {
          this.args = G;
          let ie3 = { ...t2, ...this.props };
          return this.start(() => ae(G, ie3, this.abortController)).then(this.onResolve(this.counter), this.onReject(this.counter));
        }
      }
      cancel() {
        let G = this.props.onCancel || t2.onCancel;
        G && G(), this.counter++, this.abortController.abort(), this.mounted && this.dispatch({ type: Ir.cancel, meta: this.getMeta() });
      }
      onResolve(G) {
        return (ae) => {
          if (this.counter === G) {
            let ie3 = this.props.onResolve || t2.onResolve;
            this.setData(ae, () => ie3 && ie3(ae));
          }
          return ae;
        };
      }
      onReject(G) {
        return (ae) => {
          if (this.counter === G) {
            let ie3 = this.props.onReject || t2.onReject;
            this.setError(ae, () => ie3 && ie3(ae));
          }
          return ae;
        };
      }
      setData(G, ae) {
        return this.mounted && this.dispatch({ type: Ir.fulfill, payload: G, meta: this.getMeta() }, ae), G;
      }
      setError(G, ae) {
        return this.mounted && this.dispatch({ type: Ir.reject, payload: G, error: true, meta: this.getMeta() }, ae), G;
      }
      render() {
        let { children: G, suspense: ae } = this.props;
        if (ae && this.state.isPending && this.promise !== is2)
          throw this.promise;
        if (typeof G == "function") {
          let ie3 = G;
          return N.createElement(c, { value: this.state }, ie3(this.state));
        }
        return G != null ? N.createElement(c, { value: this.state }, G) : null;
      }
    }
    Bn && (w.propTypes = Bn.Async);
    let T = (ee) => N.createElement(p, null, (G) => N.createElement(uf, Object.assign({}, ee, { state: G }))), k = (ee) => N.createElement(p, null, (G) => N.createElement(cf, Object.assign({}, ee, { state: G }))), P = (ee) => N.createElement(p, null, (G) => N.createElement(ff, Object.assign({}, ee, { state: G }))), j = (ee) => N.createElement(p, null, (G) => N.createElement(hf, Object.assign({}, ee, { state: G }))), U = (ee) => N.createElement(p, null, (G) => N.createElement(df, Object.assign({}, ee, { state: G })));
    return T.displayName = `${r6}.Initial`, k.displayName = `${r6}.Pending`, P.displayName = `${r6}.Fulfilled`, j.displayName = `${r6}.Rejected`, U.displayName = `${r6}.Settled`, Object.assign(w, { displayName: r6, Initial: T, Pending: k, Loading: k, Fulfilled: P, Resolved: P, Rejected: j, Settled: U });
  }
  var zN = rT();
  function nT(t2, r6) {
    let s = typeof t2 == "function" ? { ...r6, promiseFn: t2 } : t2, c = (0, F.useRef)(0), p = (0, F.useRef)(true), w = (0, F.useRef)(void 0), T = (0, F.useRef)(s), k = (0, F.useRef)(is2), P = (0, F.useRef)(new w8()), { devToolsDispatcher: j } = Dn.__REACT_ASYNC__, { reducer: U, dispatcher: ee = j } = s, [G, ae] = (0, F.useReducer)(U ? (Pe, pt) => U(Pe, pt, iu) : iu, s, mf), ie3 = (0, F.useCallback)(ee ? (Pe) => ee(Pe, _82(ae), T.current) : _82(ae), [ee]), { debugLabel: V } = s, de = (0, F.useCallback)((Pe) => ({ counter: c.current, promise: k.current, debugLabel: V, ...Pe }), [V]), ve = (0, F.useCallback)((Pe, pt = x8) => (p.current && (ie3({ type: Ir.fulfill, payload: Pe, meta: de() }), pt()), Pe), [ie3, de]), _e2 = (0, F.useCallback)((Pe, pt = x8) => (p.current && (ie3({ type: Ir.reject, payload: Pe, error: true, meta: de() }), pt()), Pe), [ie3, de]), { onResolve: Me, onReject: we } = s, ye = (0, F.useCallback)((Pe) => (pt) => Pe === c.current && ve(pt, () => Me && Me(pt)), [ve, Me]), xe = (0, F.useCallback)((Pe) => (pt) => Pe === c.current && _e2(pt, () => we && we(pt)), [_e2, we]), Se = (0, F.useCallback)((Pe) => ("AbortController" in Dn && (P.current.abort(), P.current = new Dn.AbortController()), c.current++, k.current = new Promise((pt, J1) => {
      if (!p.current)
        return;
      let ar = () => Pe().then(pt, J1);
      ie3({ type: Ir.start, payload: ar, meta: de() });
    })), [ie3, de]), { promise: Je, promiseFn: Ae, initialValue: Ue } = s, Ye = (0, F.useCallback)(() => {
      let Pe = Ue && c.current === 0;
      Je ? Se(() => Je).then(ye(c.current)).catch(xe(c.current)) : Ae && !Pe && Se(() => Ae(T.current, P.current)).then(ye(c.current)).catch(xe(c.current));
    }, [Se, Je, Ae, Ue, ye, xe]), { deferFn: Dt } = s, mt = (0, F.useCallback)((...Pe) => {
      Dt && (w.current = Pe, Se(() => Dt(Pe, T.current, P.current)).then(ye(c.current)).catch(xe(c.current)));
    }, [Se, Dt, ye, xe]), m1 = (0, F.useCallback)(() => {
      w.current ? mt(...w.current) : Ye();
    }, [mt, Ye]), { onCancel: $t } = s, Bt = (0, F.useCallback)(() => {
      $t && $t(), c.current++, P.current.abort(), p.current && ie3({ type: Ir.cancel, meta: de() });
    }, [$t, ie3, de]), { watch: pe, watchFn: Sr } = s;
    if ((0, F.useEffect)(() => {
      Sr && T.current && Sr(s, T.current) && (T.current = s, Ye());
    }), (0, F.useEffect)(() => {
      T.current = s;
    }, [s]), (0, F.useEffect)(() => {
      c.current && Bt(), (Je || Ae) && Ye();
    }, [Je, Ae, pe]), (0, F.useEffect)(() => () => {
      p.current = false;
    }, []), (0, F.useEffect)(() => () => Bt(), []), (0, F.useDebugValue)(G, ({ status: Pe }) => `[${c.current}] ${Pe}`), s.suspense && G.isPending && k.current !== is2)
      throw k.current;
    return (0, F.useMemo)(() => ({ ...G, run: mt, reload: m1, cancel: Bt, setData: ve, setError: _e2 }), [G, mt, m1, Bt, ve, _e2]);
  }
  var iT = () => {
    throw new Error("useAsync requires React v16.8 or up. Upgrade your React version or use the <Async> component instead.");
  };
  var pf = F.useEffect ? nT : iT;
  var S8 = cr(R0());
  var N1 = String.raw;
  var gf = class {
    constructor(r6) {
      this.Commands = () => {
        let r7 = this.grammar.map(({ cmd: s, metavar: c, branches: p }) => {
          let w = Zl(`${s}`, 0, c), T = p.map(({ subcmd: k, nargs: P, body: j }) => Zl(s + k, P, j));
          return [w].concat(T).join(`
`);
        }).join(`
`);
        return N.createElement(Aa, null, r7);
      };
      this.BnfInner = (r7) => {
        let s = kt(W0), c = kt(Qo), p = (V) => ({ subcmd: de, args: ve }) => {
          let _e2 = ve.map((Me) => `{${Me}}`).join("");
          return N1`\htmlData{def=${V}${de}}{${"\\" + V}${de}${_e2}}`;
        }, { data: w, isPending: T, error: k } = pf((0, F.useCallback)(async () => await Promise.all(this.grammar.map(({ cmd: de, branches: ve }) => Promise.all(ve.map(p(de)).map((_e2) => c.dimensions(_e2, false, r7.container_ref))))), [])), P = [];
        if ((0, F.useEffect)(() => {
          w && P.forEach(([V, de]) => s.add_definition(V, de));
        }, [w]), T)
          return null;
        if (!w)
          return console.error(k), null;
        let j = 350, U = Ul(this.grammar, w).map(([{ kind: V, cmd: de, metavar: ve, branches: _e2 }, Me]) => {
          let we = (xe) => {
            if (_e2.length == 0)
              return "";
            let [Se] = Ul(_e2, Me).reduce(([Ae, Ue], [Ye, Dt]) => {
              let mt = Ae[Ae.length - 1];
              return Ue + Dt.width > j && mt.length > 0 ? (Ae.push([Ye]), Ue = Dt.width) : (mt.push(Ye), Ue += Dt.width), [Ae, Ue];
            }, [[[]], 0]);
            return `::= ~ &&${Se.filter((Ae) => !xe || S8.default.some(Ae, (Ue) => Ue.subcmd == xe)).map((Ae) => Ae.map((Ue) => {
              let Ye = p(de)(Ue);
              return xe && Ue.subcmd == xe && (Ye = N1`\htmlClass{tex-highlight}{${Ye}}`), Ye;
            }).join(N1`
  \mid `) + (xe && Se.length > 1 ? N1`\mid \ldots` : "")).join(N1`\\& & & && &&\mid`)}`;
          };
          V = V.replace(/ /g, N1`\ `), _e2.forEach(({ subcmd: xe }) => {
            let Se = we(xe);
            P.push([`tex:${de}${xe}`, { Tooltip: () => N.createElement(Aa, { className: "nomargin" }, N1`\begin{aligned}&\mathsf{${V}}& ~ &${ve} &&${Se}\end{aligned}`), Label: null }]);
          });
          let ye = we();
          return P.push([`tex:${de}`, { Tooltip: () => N.createElement(Aa, { className: "nomargin" }, N1`\begin{aligned}&\mathsf{${V}}& ~ &\htmlClass{tex-highlight}{${ve}} &&${ye}\end{aligned}`), Label: null }]), N1`&\htmlData{def=${de}}{\mathsf{${V}}}& ~ &${ve} &&${ye}`;
        }), ee = r7.layout || { columns: 1, cutoff: 0 }, G = ee.columns > 1 ? S8.default.chunk(U, ee.cutoff) : [U], ae = N1`
%
\hspace{2em}
%
`, ie3 = G.map((V) => N1`\begin{aligned}${V.join(N1`\\`)}\end{aligned}`).join(ae);
        return N.createElement(Aa, null, ie3);
      };
      this.Bnf = (r7) => {
        let s = (0, F.useRef)(null), [c, p] = (0, F.useState)(false);
        return (0, F.useEffect)(() => p(true), []), N.createElement("div", { ref: s }, s.current ? N.createElement(this.BnfInner, { container_ref: s.current, ...r7 }) : null);
      };
      this.grammar = r6.map(([s, c, p, w]) => {
        let T = w.map(([k, P, j, U]) => ({ subcmd: k, nargs: P, body: j, args: U }));
        return { kind: s, cmd: c, metavar: p, branches: T };
      });
    }
  };
  Ge();
  var vf = cr(ha());
  var au = ({ on: t2, big: r6, onClick: s }) => N.createElement("span", { className: (0, vf.default)("toggle-button", { big: r6 }), onClick: s }, t2 ? "A" : "\u2211");
  var aT = ({ Inside: t2, Outside: r6, resize: s, registerToggle: c }) => {
    let p = (0, F.useRef)(null), w = (0, F.useRef)(null), [T, k] = (0, F.useState)(false);
    c && (0, F.useEffect)(() => {
      c(k);
    }, [c]);
    let P = Uo({}, 1e3, () => {
      if (s || !p.current || !w.current)
        return {};
      let U = (ae) => ae.current.getBoundingClientRect(), ee = U(p), G = U(w);
      return { width: Math.max(ee.width, G.width), height: Math.max(ee.height, G.height) };
    }), j = (U) => U ? {} : { visibility: "hidden", position: "absolute" };
    return N.createElement("div", { className: "togglebox-grandparent" }, N.createElement("div", { className: "togglebox-parent" }, N.createElement("div", { className: "togglebox", style: P }, N.createElement("div", { ref: p, style: j(!T) }, N.createElement(r6, null)), N.createElement("div", { ref: w, style: j(T) }, N.createElement(t2, null)))), N.createElement(au, { on: T, onClick: () => k(!T) }));
  };
  Ge();
  var oT = ({ children: t2 }) => N.createElement("div", { className: "premise" }, t2);
  var sT = ({ children: t2 }) => N.createElement("div", { className: "premise-row" }, t2);
  var yf = ({ Top: t2, Bot: r6, Right: s, ...c }) => {
    let [p, w] = (0, F.useState)(0), T = (0, F.useRef)(null);
    return s && (0, F.useEffect)(() => {
      let k = T.current;
      w(k.getBoundingClientRect().height);
    }, []), N.createElement("table", { className: "inferrule", ...c }, N.createElement("tbody", null, N.createElement("tr", null, N.createElement("td", null, t2)), N.createElement("tr", null, N.createElement("td", null, N.createElement("div", { className: "divider" })), N.createElement("td", null, N.createElement("div", { className: "right" }, N.createElement("div", { style: { bottom: p / 2 }, ref: T }, s || null)))), N.createElement("tr", null, N.createElement("td", null, r6))));
  };
  var lT = ({ Top: t2, Bot: r6, ...s }) => {
    let [c] = (0, F.useState)([]), p = (P) => {
      c.push(P);
    }, [w, T] = (0, F.useState)(false);
    return N.createElement(yf, { Right: N.createElement(au, { big: true, on: w, onClick: () => {
      c.forEach((P) => P(!w)), T(!w);
    } }), Top: N.createElement(t2, { reg: p }), Bot: N.createElement(r6, { reg: p }), ...s });
  };
  var uT = ({ name: t2, title: r6, children: s }) => {
    let c = (0, F.useContext)(K1), w = `Theorem ${c.theorems.push().join(".")}`, T = r6 ? `: ${r6}` : "";
    return N.createElement(G0, { name: t2, Label: () => N.createElement(N.Fragment, null, w, T) }, N.createElement("div", { className: "theorem" }, N.createElement(p8, null, w, T), N.createElement("div", { className: "theorem-body" }, s)), N.createElement(c.theorems.Pop, null));
  };
  Ge();
  var A8 = cr(ha());
  var bf = cr(R0());
  var cT = ({ children: t2, ...r6 }) => {
    let s = (0, F.useRef)(null), [c, p] = (0, F.useState)(null);
    return (0, F.useEffect)(() => {
      let w = s.current.querySelectorAll(".link"), T = Array.from(w).map((k) => {
        let P = bf.default.find(k.className.split(" "), (ee) => ee.startsWith("type")), j = () => {
          p(`hover-${P}`);
        }, U = () => {
          p(null);
        };
        return k.addEventListener("mouseenter", j), k.addEventListener("mouseleave", U), () => {
          k.removeEventListener("mouseenter", j), k.removeEventListener("mouseleave", U);
        };
      });
      return () => T.forEach((k) => k());
    }, []), N.createElement("div", { ref: s, className: (0, A8.default)("correspondence", c), ...r6 }, t2);
  };
  var fT = ({ name: t2, block: r6, children: s }) => N.createElement(p0, { className: (0, A8.default)("link", `type-${t2}`), block: r6 }, s);
  Ge();
  var hT = 800;
  var xf = N.createContext(null);
  var dT = ({ selector: t2, children: r6 }) => {
    let s = (0, F.useContext)(xf), [c, p] = (0, F.useState)(null), w = Uo(0, 1e3, () => {
      if (c) {
        let k = s.document.current.getBoundingClientRect();
        return c.getBoundingClientRect().top - k.top;
      }
    });
    return (0, F.useEffect)(() => {
      if (!s)
        throw "Missing CommentaryContext in Comment";
      if (!s.document_ready)
        return;
      let T = s.document.current, k = T.querySelector(t2);
      if (!k)
        throw console.error(T), `Missing selector "${t2}"`;
      p(k);
    }, [t2, s.document_ready]), N.createElement("div", { className: "comment", style: { top: w } }, r6);
  };
  var mT = ({ Document: t2, children: r6, comment_width: s }) => {
    let c = (0, F.useRef)(null), [p, w] = (0, F.useState)(false);
    return N.createElement(xf.Provider, { value: { document: c, document_ready: p } }, N.createElement($c, { className: "commentary", style: { background: "#f4f4f4", padding: "1rem 0" } }, N.createElement(g8, null, N.createElement("div", { ref: c, className: "object", style: { width: hT } }, N.createElement(t2, { onLoad: (0, F.useCallback)(() => w(true), []) })), N.createElement("div", { className: "comments", style: { width: s } }, p ? r6 : null))));
  };
  Ge();
  var lh = cr(sh());
  var uh = cr(ha());
  var ku = class {
    constructor(r6) {
      this.set_loaded = (0, ze.action)((r7) => {
        this.loaded = r7;
      });
      this.loaded = r6, (0, ze.makeObservable)(this);
    }
  };
  T1([ze.observable], ku.prototype, "loaded", 2);
  var ch = N.createContext(new ku(false));
  var WT = (0, Ct.observer)(({ children: t2, initial: r6 }) => {
    let [s] = (0, F.useState)(new ku(r6 || true)), c = s.loaded;
    return N.createElement(ch.Provider, { value: s }, N.createElement("div", { className: (0, uh.default)("loader", { loaded: c }) }, c ? null : N.createElement("div", { className: "loader-overlay" }, N.createElement("div", { className: "loader-spinner" }, N.createElement(lh.default, { type: "Oval", color: "#aaa", width: "100%", height: "100%" }))), N.createElement(t2, null)));
  });

  // ../../node_modules/@mdx-js/react/dist/esm.js
  var import_react8 = __toModule(require_react());
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys3(object2, enumerableOnly) {
    var keys2 = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose2(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var isFunction2 = function isFunction3(obj) {
    return typeof obj === "function";
  };
  var MDXContext = /* @__PURE__ */ import_react8.default.createContext({});
  var useMDXComponents = function useMDXComponents2(components) {
    var contextComponents = import_react8.default.useContext(MDXContext);
    var allComponents = contextComponents;
    if (components) {
      allComponents = isFunction2(components) ? components(contextComponents) : _objectSpread2(_objectSpread2({}, contextComponents), components);
    }
    return allComponents;
  };
  var MDXProvider = function MDXProvider2(props) {
    var allComponents = useMDXComponents(props.components);
    return /* @__PURE__ */ import_react8.default.createElement(MDXContext.Provider, {
      value: allComponents
    }, props.children);
  };
  var DEFAULTS = {
    inlineCode: "code",
    wrapper: function wrapper2(_ref) {
      var children = _ref.children;
      return /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, {}, children);
    }
  };
  var MDXCreateElement = /* @__PURE__ */ import_react8.default.forwardRef(function(props, ref) {
    var propComponents = props.components, mdxType = props.mdxType, originalType = props.originalType, parentName = props.parentName, etc = _objectWithoutProperties(props, ["components", "mdxType", "originalType", "parentName"]);
    var components = useMDXComponents(propComponents);
    var type = mdxType;
    var Component2 = components["".concat(parentName, ".").concat(type)] || components[type] || DEFAULTS[type] || originalType;
    if (propComponents) {
      return /* @__PURE__ */ import_react8.default.createElement(Component2, _objectSpread2(_objectSpread2({
        ref
      }, etc), {}, {
        components: propComponents
      }));
    }
    return /* @__PURE__ */ import_react8.default.createElement(Component2, _objectSpread2({
      ref
    }, etc));
  });
  MDXCreateElement.displayName = "MDXCreateElement";

  // hatra-paper.mdx
  var import_jsx_runtime2 = __toModule(require_jsx_runtime());

  // ../slicing-paper/dist/document/document.js
  var import_jsx_runtime = __toModule(require_jsx_runtime());
  var import_react10 = __toModule(require_react());
  var import_react11 = __toModule(require_react());
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
  var __commonJS2 = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport2 = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames2(module))
        if (!__hasOwnProp2.call(target, key) && key !== "default")
          __defProp2(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc2(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule2 = (module) => {
    return __reExport2(__markAsModule2(__defProp2(module != null ? __create2(__getProtoOf2(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var require_bind = __commonJS2({
    "../../node_modules/axios/lib/helpers/bind.js"(exports, module) {
      "use strict";
      module.exports = function bind(fn, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          return fn.apply(thisArg, args);
        };
      };
    }
  });
  var require_utils = __commonJS2({
    "../../node_modules/axios/lib/utils.js"(exports, module) {
      "use strict";
      var bind = require_bind();
      var toString2 = Object.prototype.toString;
      function isArray(val) {
        return toString2.call(val) === "[object Array]";
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString2.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return typeof FormData !== "undefined" && val instanceof FormData;
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject2(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject2(val) {
        if (toString2.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate(val) {
        return toString2.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString2.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString2.call(val) === "[object Blob]";
      }
      function isFunction4(val) {
        return toString2.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject2(val) && isFunction4(val.pipe);
      }
      function isURLSearchParams(val) {
        return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i = 0, l = obj.length; i < l; i++) {
            fn.call(null, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject2(result[key]) && isPlainObject2(val)) {
            result[key] = merge(result[key], val);
          } else if (isPlainObject2(val)) {
            result[key] = merge({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i = 0, l = arguments.length; i < l; i++) {
          forEach(arguments[i], assignValue);
        }
        return result;
      }
      function extend2(a, b, thisArg) {
        forEach(b, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        });
        return a;
      }
      function stripBOM(content2) {
        if (content2.charCodeAt(0) === 65279) {
          content2 = content2.slice(1);
        }
        return content2;
      }
      module.exports = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isObject: isObject2,
        isPlainObject: isPlainObject2,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isFunction: isFunction4,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge,
        extend: extend2,
        trim,
        stripBOM
      };
    }
  });
  var require_buildURL = __commonJS2({
    "../../node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v) {
              if (utils.isDate(v)) {
                v = v.toISOString();
              } else if (utils.isObject(v)) {
                v = JSON.stringify(v);
              }
              parts.push(encode(key) + "=" + encode(v));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });
  var require_InterceptorManager = __commonJS2({
    "../../node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      };
      module.exports = InterceptorManager;
    }
  });
  var require_normalizeHeaderName = __commonJS2({
    "../../node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name2) {
          if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name2];
          }
        });
      };
    }
  });
  var require_enhanceError = __commonJS2({
    "../../node_modules/axios/lib/core/enhanceError.js"(exports, module) {
      "use strict";
      module.exports = function enhanceError(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON2() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
    }
  });
  var require_createError = __commonJS2({
    "../../node_modules/axios/lib/core/createError.js"(exports, module) {
      "use strict";
      var enhanceError = require_enhanceError();
      module.exports = function createError(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError(error, config, code, request, response);
      };
    }
  });
  var require_settle = __commonJS2({
    "../../node_modules/axios/lib/core/settle.js"(exports, module) {
      "use strict";
      var createError = require_createError();
      module.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
        }
      };
    }
  });
  var require_cookies = __commonJS2({
    "../../node_modules/axios/lib/helpers/cookies.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name2, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name2 + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name2) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove4(name2) {
            this.write(name2, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove4() {
          }
        };
      }();
    }
  });
  var require_isAbsoluteURL = __commonJS2({
    "../../node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
      "use strict";
      module.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };
    }
  });
  var require_combineURLs = __commonJS2({
    "../../node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
      "use strict";
      module.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });
  var require_buildFullPath = __commonJS2({
    "../../node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });
  var require_parseHeaders = __commonJS2({
    "../../node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser2(line) {
          i = line.indexOf(":");
          key = utils.trim(line.substr(0, i)).toLowerCase();
          val = utils.trim(line.substr(i + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });
  var require_isURLSameOrigin = __commonJS2({
    "../../node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });
  var require_Cancel = __commonJS2({
    "../../node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
      "use strict";
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      module.exports = Cancel;
    }
  });
  var require_xhr = __commonJS2({
    "../../node_modules/axios/lib/adapters/xhr.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var createError = require_createError();
      var defaults2 = require_defaults();
      var Cancel = require_Cancel();
      module.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || defaults2.transitional;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken || config.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
    }
  });
  var require_defaults = __commonJS2({
    "../../node_modules/axios/lib/defaults.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var normalizeHeaderName = require_normalizeHeaderName();
      var enhanceError = require_enhanceError();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser2, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser2 || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e) {
            if (e.name !== "SyntaxError") {
              throw e;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults2 = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional || defaults2.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw enhanceError(e, this, "E_JSON_PARSE");
                }
                throw e;
              }
            }
          }
          return data;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults2.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module.exports = defaults2;
    }
  });
  var require_transformData = __commonJS2({
    "../../node_modules/axios/lib/core/transformData.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var defaults2 = require_defaults();
      module.exports = function transformData(data, headers, fns) {
        var context = this || defaults2;
        utils.forEach(fns, function transform(fn) {
          data = fn.call(context, data, headers);
        });
        return data;
      };
    }
  });
  var require_isCancel = __commonJS2({
    "../../node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
      "use strict";
      module.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });
  var require_dispatchRequest = __commonJS2({
    "../../node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults2 = require_defaults();
      var Cancel = require_Cancel();
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new Cancel("canceled");
        }
      }
      module.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
        config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
        utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
          delete config.headers[method];
        });
        var adapter = config.adapter || defaults2.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });
  var require_mergeConfig = __commonJS2({
    "../../node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      module.exports = function mergeConfig(config1, config2) {
        config2 = config2 || {};
        var config = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge(prop);
          utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      };
    }
  });
  var require_data = __commonJS2({
    "../../node_modules/axios/lib/env/data.js"(exports, module) {
      module.exports = {
        "version": "0.23.0"
      };
    }
  });
  var require_validator = __commonJS2({
    "../../node_modules/axios/lib/helpers/validator.js"(exports, module) {
      "use strict";
      var VERSION = require_data().version;
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys2 = Object.keys(options);
        var i = keys2.length;
        while (i-- > 0) {
          var opt = keys2[i];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      module.exports = {
        assertOptions,
        validators
      };
    }
  });
  var require_Axios = __commonJS2({
    "../../node_modules/axios/lib/core/Axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig = require_mergeConfig();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(config) {
        if (typeof config === "string") {
          config = arguments[1] || {};
          config.url = arguments[0];
        } else {
          config = config || {};
        }
        config = mergeConfig(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios.prototype[method] = function(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            url,
            data
          }));
        };
      });
      module.exports = Axios;
    }
  });
  var require_CancelToken = __commonJS2({
    "../../node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
      "use strict";
      var Cancel = require_Cancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i;
          var l = token._listeners.length;
          for (i = 0; i < l; i++) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new Cancel(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      };
      module.exports = CancelToken;
    }
  });
  var require_spread = __commonJS2({
    "../../node_modules/axios/lib/helpers/spread.js"(exports, module) {
      "use strict";
      module.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });
  var require_isAxiosError = __commonJS2({
    "../../node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
      "use strict";
      module.exports = function isAxiosError(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
    }
  });
  var require_axios = __commonJS2({
    "../../node_modules/axios/lib/axios.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig = require_mergeConfig();
      var defaults2 = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios2 = createInstance(defaults2);
      axios2.Axios = Axios;
      axios2.Cancel = require_Cancel();
      axios2.CancelToken = require_CancelToken();
      axios2.isCancel = require_isCancel();
      axios2.VERSION = require_data().version;
      axios2.all = function all(promises) {
        return Promise.all(promises);
      };
      axios2.spread = require_spread();
      axios2.isAxiosError = require_isAxiosError();
      module.exports = axios2;
      module.exports.default = axios2;
    }
  });
  var require_axios2 = __commonJS2({
    "../../node_modules/axios/index.js"(exports, module) {
      module.exports = require_axios();
    }
  });
  var require_lodash = __commonJS2({
    "../../node_modules/lodash/lodash.js"(exports, module) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule && freeModule.require && freeModule.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array2, setter, iteratee, accumulator) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            var value = array2[index];
            setter(accumulator, value, iteratee(value), array2);
          }
          return accumulator;
        }
        function arrayEach(array2, iteratee) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (iteratee(array2[index], index, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEachRight(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          while (length--) {
            if (iteratee(array2[length], length, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEvery(array2, predicate) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (!predicate(array2[index], index, array2)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array2, predicate) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          return !!length && baseIndexOf(array2, value, 0) > -1;
        }
        function arrayIncludesWith(array2, value, comparator) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (comparator(value, array2[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array2, iteratee) {
          var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array2[index], index, array2);
          }
          return result;
        }
        function arrayPush(array2, values2) {
          var index = -1, length = values2.length, offset = array2.length;
          while (++index < length) {
            array2[offset + index] = values2[index];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee, accumulator, initAccum) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array2[index], index, array2);
          }
          return accumulator;
        }
        function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
          var length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array2[length], length, array2);
          }
          return accumulator;
        }
        function arraySome(array2, predicate) {
          var index = -1, length = array2 == null ? 0 : array2.length;
          while (++index < length) {
            if (predicate(array2[index], index, array2)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string2) {
          return string2.split("");
        }
        function asciiWords(string2) {
          return string2.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array2[index], index, array2)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array2, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array2.length;
          while (++index < length) {
            if (comparator(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSum(array2, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function basePropertyOf(object2) {
          return function(key) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array2, comparer2) {
          var length = array2.length;
          array2.sort(comparer2);
          while (length--) {
            array2[length] = array2[length].value;
          }
          return array2;
        }
        function baseSum(array2, iteratee) {
          var result, index = -1, length = array2.length;
          while (++index < length) {
            var current = iteratee(array2[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object2, props) {
          return arrayMap(props, function(key) {
            return [key, object2[key]];
          });
        }
        function baseTrim(string2) {
          return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object2, props) {
          return arrayMap(props, function(key) {
            return object2[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array2, placeholder2) {
          var length = array2.length, result = 0;
          while (length--) {
            if (array2[length] === placeholder2) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object2, key) {
          return object2 == null ? undefined2 : object2[key];
        }
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        function hasUnicodeWord(string2) {
          return reHasUnicodeWord.test(string2);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array2, placeholder2) {
          var index = -1, length = array2.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array2[index];
            if (value === placeholder2 || value === PLACEHOLDER) {
              array2[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set5) {
          var index = -1, result = Array(set5.size);
          set5.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set5) {
          var index = -1, result = Array(set5.size);
          set5.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index = fromIndex - 1, length = array2.length;
          while (++index < length) {
            if (array2[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array2, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array2[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string2) {
          return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function trimmedEndIndex(string2) {
          var index = string2.length;
          while (index-- && reWhitespace.test(string2.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string2) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string2)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function unicodeWords(string2) {
          return string2.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root : _22.defaults(root.Object(), context, _22.pick(root, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty2 = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty3 = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty2.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object2() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object2.prototype = proto;
              var result2 = new object2();
              object2.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            "escape": reEscape,
            "evaluate": reEvaluate,
            "interpolate": reInterpolate,
            "variable": "",
            "imports": {
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array2, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array2[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed3 = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed3;
                  } else if (!computed3) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash2(entries2) {
            var index = -1, length = entries2 == null ? 0 : entries2.length;
            this.clear();
            while (++index < length) {
              var entry = entries2[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash2.prototype.clear = hashClear;
          Hash2.prototype["delete"] = hashDelete;
          Hash2.prototype.get = hashGet;
          Hash2.prototype.has = hashHas;
          Hash2.prototype.set = hashSet;
          function ListCache(entries2) {
            var index = -1, length = entries2 == null ? 0 : entries2.length;
            this.clear();
            while (++index < length) {
              var entry = entries2[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice2.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries2) {
            var index = -1, length = entries2 == null ? 0 : entries2.length;
            this.clear();
            while (++index < length) {
              var entry = entries2[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash2(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash2()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values22) {
            var index = -1, length = values22 == null ? 0 : values22.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values22[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack2(entries2) {
            var data = this.__data__ = new ListCache(entries2);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack2.prototype.clear = stackClear;
          Stack2.prototype["delete"] = stackDelete;
          Stack2.prototype.get = stackGet;
          Stack2.prototype.has = stackHas;
          Stack2.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array2) {
            var length = array2.length;
            return length ? array2[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array2, n) {
            return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
          }
          function arrayShuffle(array2) {
            return shuffleSelf(copyArray(array2));
          }
          function assignMergeValue(object2, key, value) {
            if (value !== undefined2 && !eq2(object2[key], value) || value === undefined2 && !(key in object2)) {
              baseAssignValue(object2, key, value);
            }
          }
          function assignValue(object2, key, value) {
            var objValue = object2[key];
            if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === undefined2 && !(key in object2)) {
              baseAssignValue(object2, key, value);
            }
          }
          function assocIndexOf(array2, key) {
            var length = array2.length;
            while (length--) {
              if (eq2(array2[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object2, source) {
            return object2 && copyObject(source, keys2(source), object2);
          }
          function baseAssignIn(object2, source) {
            return object2 && copyObject(source, keysIn(source), object2);
          }
          function baseAssignValue(object2, key, value) {
            if (key == "__proto__" && defineProperty3) {
              defineProperty3(object2, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object2[key] = value;
            }
          }
          function baseAt(object2, paths) {
            var index = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
            while (++index < length) {
              result2[index] = skip ? undefined2 : get4(object2, paths[index]);
            }
            return result2;
          }
          function baseClamp(number2, lower, upper) {
            if (number2 === number2) {
              if (upper !== undefined2) {
                number2 = number2 <= upper ? number2 : upper;
              }
              if (lower !== undefined2) {
                number2 = number2 >= lower ? number2 : lower;
              }
            }
            return number2;
          }
          function baseClone(value, bitmask, customizer, key, object2, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object2) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object2 ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object2) {
              return baseConformsTo(object2, source, props);
            };
          }
          function baseConformsTo(object2, source, props) {
            var length = props.length;
            if (object2 == null) {
              return !length;
            }
            object2 = Object2(object2);
            while (length--) {
              var key = props[length], predicate = source[key], value = object2[key];
              if (value === undefined2 && !(key in object2) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array2, values22, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values22.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values22 = arrayMap(values22, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values22.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values22 = new SetCache(values22);
            }
            outer:
              while (++index < length) {
                var value = array2[index], computed3 = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed3 === computed3) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values22[valuesIndex] === computed3) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values22, computed3, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array2, iteratee2, comparator) {
            var index = -1, length = array2.length;
            while (++index < length) {
              var value = array2[index], current = iteratee2(value);
              if (current != null && (computed3 === undefined2 ? current === current && !isSymbol2(current) : comparator(current, computed3))) {
                var computed3 = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array2, value, start2, end) {
            var length = array2.length;
            start2 = toInteger(start2);
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start2 > end ? 0 : toLength(end);
            while (start2 < end) {
              array2[start2++] = value;
            }
            return array2;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array2, depth, predicate, isStrict, result2) {
            var index = -1, length = array2.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length) {
              var value = array2[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object2, iteratee2) {
            return object2 && baseFor(object2, iteratee2, keys2);
          }
          function baseForOwnRight(object2, iteratee2) {
            return object2 && baseForRight(object2, iteratee2, keys2);
          }
          function baseFunctions(object2, props) {
            return arrayFilter(props, function(key) {
              return isFunction4(object2[key]);
            });
          }
          function baseGet(object2, path) {
            path = castPath(path, object2);
            var index = 0, length = path.length;
            while (object2 != null && index < length) {
              object2 = object2[toKey(path[index++])];
            }
            return index && index == length ? object2 : undefined2;
          }
          function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object2);
            return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object2, key) {
            return object2 != null && hasOwnProperty2.call(object2, key);
          }
          function baseHasIn(object2, key) {
            return object2 != null && key in Object2(object2);
          }
          function baseInRange(number2, start2, end) {
            return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array2 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array2 = arrayMap(array2, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array2.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
            }
            array2 = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length && result2.length < maxLength) {
                var value = array2[index], computed3 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed3) : includes2(result2, computed3, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed3) : includes2(arrays[othIndex], computed3, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object2, setter, iteratee2, accumulator) {
            baseForOwn(object2, function(value, key, object22) {
              setter(accumulator, iteratee2(value), key, object22);
            });
            return accumulator;
          }
          function baseInvoke(object2, path, args) {
            path = castPath(path, object2);
            object2 = parent(object2, path);
            var func = object2 == null ? object2 : object2[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object2, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object2)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object2, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (object2 == null) {
              return !length;
            }
            object2 = Object2(object2);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object2[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object2)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object2, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction4(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object2) {
            if (!isPrototype(object2)) {
              return nativeKeys(object2);
            }
            var result2 = [];
            for (var key in Object2(object2)) {
              if (hasOwnProperty2.call(object2, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object2) {
            if (!isObject2(object2)) {
              return nativeKeysIn(object2);
            }
            var isProto = isPrototype(object2), result2 = [];
            for (var key in object2) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object2) {
              return object2 === source || baseIsMatch(object2, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object2) {
              var objValue = get4(object2, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object2, source, srcIndex, customizer, stack) {
            if (object2 === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack2());
              if (isObject2(srcValue)) {
                baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object2, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object2, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction4(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object2, key, newValue);
          }
          function baseNth(array2, n) {
            var length = array2.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array2[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object2, other) {
              return compareMultiple(object2, other, orders);
            });
          }
          function basePick(object2, paths) {
            return basePickBy(object2, paths, function(value, path) {
              return hasIn(object2, path);
            });
          }
          function basePickBy(object2, paths, predicate) {
            var index = -1, length = paths.length, result2 = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object2, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object2), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object2) {
              return baseGet(object2, path);
            };
          }
          function basePullAll(array2, values22, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values22.length, seen = array2;
            if (array2 === values22) {
              values22 = copyArray(values22);
            }
            if (iteratee2) {
              seen = arrayMap(array2, baseUnary(iteratee2));
            }
            while (++index < length) {
              var fromIndex = 0, value = values22[index], computed3 = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed3, fromIndex, comparator)) > -1) {
                if (seen !== array2) {
                  splice2.call(seen, fromIndex, 1);
                }
                splice2.call(array2, fromIndex, 1);
              }
            }
            return array2;
          }
          function basePullAt(array2, indexes) {
            var length = array2 ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice2.call(array2, index, 1);
                } else {
                  baseUnset(array2, index);
                }
              }
            }
            return array2;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start2, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index] = start2;
              start2 += step;
            }
            return result2;
          }
          function baseRepeat(string2, n) {
            var result2 = "";
            if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string2;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string2 += string2;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start2) {
            return setToString(overRest(func, start2, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values2(collection));
          }
          function baseSampleSize(collection, n) {
            var array2 = values2(collection);
            return shuffleSelf(array2, baseClamp(n, 0, array2.length));
          }
          function baseSet(object2, path, value, customizer) {
            if (!isObject2(object2)) {
              return object2;
            }
            path = castPath(path, object2);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object2;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object2;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty3 ? identity : function(func, string2) {
            return defineProperty3(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string2),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values2(collection));
          }
          function baseSlice(array2, start2, end) {
            var index = -1, length = array2.length;
            if (start2 < 0) {
              start2 = -start2 > length ? 0 : length + start2;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start2 > end ? 0 : end - start2 >>> 0;
            start2 >>>= 0;
            var result2 = Array2(length);
            while (++index < length) {
              result2[index] = array2[index + start2];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array2, value, retHighest) {
            var low = 0, high = array2 == null ? low : array2.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed3 = array2[mid];
                if (computed3 !== null && !isSymbol2(computed3) && (retHighest ? computed3 <= value : computed3 < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array2, value, identity, retHighest);
          }
          function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
            var low = 0, high = array2 == null ? 0 : array2.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed3 = iteratee2(array2[mid]), othIsDefined = computed3 !== undefined2, othIsNull = computed3 === null, othIsReflexive = computed3 === computed3, othIsSymbol = isSymbol2(computed3);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed3 <= value : computed3 < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array2, iteratee2) {
            var index = -1, length = array2.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array2[index], computed3 = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq2(computed3, seen)) {
                var seen = computed3;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol2(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array2, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set22 = iteratee2 ? null : createSet(array2);
              if (set22) {
                return setToArray(set22);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length) {
                var value = array2[index], computed3 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed3 === computed3) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed3) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed3, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object2, path) {
            path = castPath(path, object2);
            object2 = parent(object2, path);
            return object2 == null || delete object2[toKey(last(path))];
          }
          function baseUpdate(object2, path, updater, customizer) {
            return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
          }
          function baseWhile(array2, predicate, isDrop, fromRight) {
            var length = array2.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
            }
            return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action2) {
              return action2.func.apply(action2.thisArg, arrayPush([result3], action2.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length);
            while (++index < length) {
              var array2 = arrays[index], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values22, assignFunc) {
            var index = -1, length = props.length, valsLength = values22.length, result2 = {};
            while (++index < length) {
              var value = index < valsLength ? values22[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object2) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object2) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array2, start2, end) {
            var length = array2.length;
            end = end === undefined2 ? length : end;
            return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object2, other, orders) {
            var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order = orders[index];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object2.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array2) {
            var index = -1, length = source.length;
            array2 || (array2 = Array2(length));
            while (++index < length) {
              array2[index] = source[index];
            }
            return array2;
          }
          function copyObject(source, props, object2, customizer) {
            var isNew = !object2;
            object2 || (object2 = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object2, key, newValue);
              } else {
                assignValue(object2, key, newValue);
              }
            }
            return object2;
          }
          function copySymbols(source, object2) {
            return copyObject(source, getSymbols(source), object2);
          }
          function copySymbolsIn(source, object2) {
            return copyObject(source, getSymbolsIn(source), object2);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object2, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object2 = Object2(object2);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object2, source, index, customizer);
                }
              }
              return object2;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object2, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object2;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper3() {
              var fn = this && this !== root && this instanceof wrapper3 ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper3;
          }
          function createCaseFirst(methodName) {
            return function(string2) {
              string2 = toString2(string2);
              var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string2) {
              return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper3() {
              var length = arguments.length, args = Array2(length), index = length, placeholder2 = getHolder(wrapper3);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder2 && args[length - 1] !== placeholder2 ? [] : replaceHolders(args, placeholder2);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(func, bitmask, createHybrid, wrapper3.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
              }
              var fn = this && this !== root && this instanceof wrapper3 ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper3;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper3 && getFuncName(func) == "wrapper") {
                  var wrapper3 = new LodashWrapper([], true);
                }
              }
              index = wrapper3 ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper3 = wrapper3[getFuncName(data[0])].apply(wrapper3, data[3]);
                } else {
                  wrapper3 = func.length == 1 && isLaziable(func) ? wrapper3[funcName]() : wrapper3.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper3 && args.length == 1 && isArray(value)) {
                  return wrapper3.plant(value).value();
                }
                var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                while (++index2 < length) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper3() {
              var length = arguments.length, args = Array2(length), index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder2 = getHolder(wrapper3), holdersCount = countHolders(args, placeholder2);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder2);
                return createRecurry(func, bitmask, createHybrid, wrapper3.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper3) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper3;
          }
          function createInverter(setter, toIteratee) {
            return function(object2, iteratee2) {
              return baseInverter(object2, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator2, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator2(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper3() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper3 ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper3;
          }
          function createRange(fromRight) {
            return function(start2, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
                end = step = undefined2;
              }
              start2 = toFinite(start2);
              if (end === undefined2) {
                end = start2;
                start2 = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
              return baseRange(start2, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator2) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator2(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder2, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder2;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number2, precision) {
              number2 = toNumber(number2);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number2)) {
                var pair2 = (toString2(number2) + "e").split("e"), value = func(pair2[0] + "e" + (+pair2[1] + precision));
                pair2 = (toString2(value) + "e").split("e");
                return +(pair2[0] + "e" + (+pair2[1] - precision));
              }
              return func(number2);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values22) {
            return new Set2(values22);
          };
          function createToPairs(keysFunc) {
            return function(object2) {
              var tag = getTag(object2);
              if (tag == mapTag) {
                return mapToArray(object2);
              }
              if (tag == setTag) {
                return setToPairs(object2);
              }
              return baseToPairs(object2, keysFunc(object2));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object2) {
            if (objValue === undefined2 || eq2(objValue, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject2(value) ? undefined2 : value;
          }
          function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array2);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array2;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array2, other);
            stack.set(other, array2);
            while (++index < arrLength) {
              var arrValue = array2[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array2);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                  return false;
                }
                object2 = object2.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq2(+object2, +other);
              case errorTag:
                return object2.name == other.name && object2.message == other.message;
              case regexpTag:
              case stringTag:
                return object2 == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object2.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object2);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object2, other);
                var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object2);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object2) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object2);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object2;
            }
            var result2 = true;
            stack.set(object2, other);
            stack.set(other, object2);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object2[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object2.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object2);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten2), func + "");
          }
          function getAllKeys(object2) {
            return baseGetAllKeys(object2, keys2, getSymbols);
          }
          function getAllKeysIn(object2) {
            return baseGetAllKeys(object2, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop3 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
            while (length--) {
              var data = array2[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object2 = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
            return object2.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map22, key) {
            var data = map22.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object2) {
            var result2 = keys2(object2), length = result2.length;
            while (length--) {
              var key = result2[length], value = object2[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object2, key) {
            var value = getValue(object2, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
            if (object2 == null) {
              return [];
            }
            object2 = Object2(object2);
            return arrayFilter(nativeGetSymbols(object2), function(symbol) {
              return propertyIsEnumerable.call(object2, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
            var result2 = [];
            while (object2) {
              arrayPush(result2, getSymbols(object2));
              object2 = getPrototype(object2);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start2, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start2 += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start2 + size2);
                  break;
                case "takeRight":
                  start2 = nativeMax(start2, end - size2);
                  break;
              }
            }
            return { "start": start2, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object2, path, hasFunc) {
            path = castPath(path, object2);
            var index = -1, length = path.length, result2 = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result2 = object2 != null && hasFunc(object2, key))) {
                break;
              }
              object2 = object2[key];
            }
            if (result2 || ++index != length) {
              return result2;
            }
            length = object2 == null ? 0 : object2.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
          }
          function initCloneArray(array2) {
            var length = array2.length, result2 = new array2.constructor(length);
            if (length && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
              result2.index = array2.index;
              result2.input = array2.input;
            }
            return result2;
          }
          function initCloneObject(object2) {
            return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
          }
          function initCloneByTag(object2, tag, isDeep) {
            var Ctor = object2.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object2);
              case boolTag:
              case dateTag:
                return new Ctor(+object2);
              case dataViewTag:
                return cloneDataView(object2, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object2, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object2);
              case regexpTag:
                return cloneRegExp(object2);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object2);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index, object2) {
            if (!isObject2(object2)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
              return eq2(object2[index], value);
            }
            return false;
          }
          function isKey(value, object2) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction4 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object2) {
              if (object2 == null) {
                return false;
              }
              return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object2) {
            var result2 = [];
            if (object2 != null) {
              for (var key in Object2(object2)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start2, transform2) {
            start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array2 = Array2(length);
              while (++index < length) {
                array2[index] = args[start2 + index];
              }
              index = -1;
              var otherArgs = Array2(start2 + 1);
              while (++index < start2) {
                otherArgs[index] = args[index];
              }
              otherArgs[start2] = transform2(array2);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object2, path) {
            return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
          }
          function reorder(array2, indexes) {
            var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
            while (length--) {
              var index = indexes[length];
              array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array2;
          }
          function safeGet(object2, key) {
            if (key === "constructor" && typeof object2[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object2[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper3, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper3, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array2, size2) {
            var index = -1, length = array2.length, lastIndex = length - 1;
            size2 = size2 === undefined2 ? length : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array2[rand];
              array2[rand] = array2[index];
              array2[index] = value;
            }
            array2.length = size2;
            return array2;
          }
          var stringToPath = memoizeCapped(function(string2) {
            var result2 = [];
            if (string2.charCodeAt(0) === 46) {
              result2.push("");
            }
            string2.replace(rePropName, function(match, number2, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol2(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair2) {
              var value = "_." + pair2[0];
              if (bitmask & pair2[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper3) {
            if (wrapper3 instanceof LazyWrapper) {
              return wrapper3.clone();
            }
            var result2 = new LodashWrapper(wrapper3.__wrapped__, wrapper3.__chain__);
            result2.__actions__ = copyArray(wrapper3.__actions__);
            result2.__index__ = wrapper3.__index__;
            result2.__values__ = wrapper3.__values__;
            return result2;
          }
          function chunk(array2, size2, guard) {
            if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length = array2 == null ? 0 : array2.length;
            if (!length || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
            while (index < length) {
              result2[resIndex++] = baseSlice(array2, index, index += size2);
            }
            return result2;
          }
          function compact(array2) {
            var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
            while (++index < length) {
              var value = array2[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array2 = arguments[0], index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array2, values22) {
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values22, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array2, values22) {
            var iteratee2 = last(values22);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values22, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array2, values22) {
            var comparator = last(values22);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values22, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function dropRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
          }
          function fill(array2, value, start2, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
              start2 = 0;
              end = length;
            }
            return baseFill(array2, value, start2, end);
          }
          function findIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
          }
          function flatten2(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, 1) : [];
          }
          function flattenDeep(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, INFINITY) : [];
          }
          function flattenDepth(array2, depth) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array2, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length) {
              var pair2 = pairs[index];
              result2[pair2[0]] = pair2[1];
            }
            return result2;
          }
          function head(array2) {
            return array2 && array2.length ? array2[0] : undefined2;
          }
          function indexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array2, value, index);
          }
          function initial(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array2, separator) {
            return array2 == null ? "" : nativeJoin.call(array2, separator);
          }
          function last(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? array2[length - 1] : undefined2;
          }
          function lastIndexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
          }
          function nth(array2, n) {
            return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array2, values22) {
            return array2 && array2.length && values22 && values22.length ? basePullAll(array2, values22) : array2;
          }
          function pullAllBy(array2, values22, iteratee2) {
            return array2 && array2.length && values22 && values22.length ? basePullAll(array2, values22, getIteratee(iteratee2, 2)) : array2;
          }
          function pullAllWith(array2, values22, comparator) {
            return array2 && array2.length && values22 && values22.length ? basePullAll(array2, values22, undefined2, comparator) : array2;
          }
          var pullAt = flatRest(function(array2, indexes) {
            var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
            basePullAt(array2, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove4(array2, predicate) {
            var result2 = [];
            if (!(array2 && array2.length)) {
              return result2;
            }
            var index = -1, indexes = [], length = array2.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array2[index];
              if (predicate(value, index, array2)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array2, indexes);
            return result2;
          }
          function reverse2(array2) {
            return array2 == null ? array2 : nativeReverse.call(array2);
          }
          function slice(array2, start2, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array2, start2, end)) {
              start2 = 0;
              end = length;
            } else {
              start2 = start2 == null ? 0 : toInteger(start2);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array2, start2, end);
          }
          function sortedIndex(array2, value) {
            return baseSortedIndex(array2, value);
          }
          function sortedIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index = baseSortedIndex(array2, value);
              if (index < length && eq2(array2[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array2, value) {
            return baseSortedIndex(array2, value, true);
          }
          function sortedLastIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index = baseSortedIndex(array2, value, true) - 1;
              if (eq2(array2[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array2) {
            return array2 && array2.length ? baseSortedUniq(array2) : [];
          }
          function sortedUniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 1, length) : [];
          }
          function take(array2, n, guard) {
            if (!(array2 && array2.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array2, 0, n < 0 ? 0 : n);
          }
          function takeRight(array2, n, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array2, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array2) {
            return array2 && array2.length ? baseUniq(array2) : [];
          }
          function uniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array2, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
          }
          function unzip(array2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var length = 0;
            array2 = arrayFilter(array2, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array2, baseProperty(index));
            });
          }
          function unzipWith(array2, iteratee2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var result2 = unzip(array2);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array2, values22) {
            return isArrayLikeObject(array2) ? baseDifference(array2, values22) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values22) {
            return baseZipObject(props || [], values22 || [], assignValue);
          }
          function zipObjectDeep(props, values22) {
            return baseZipObject(props || [], values22 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
              return baseAt(object2, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
              return this.thru(interceptor);
            }
            value = value.slice(start2, +start2 + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array2) {
              if (length && !array2.length) {
                array2.push(undefined2);
              }
              return array2;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse2],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse2);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find2 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map2(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values2(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map2(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object2, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object2, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 === undefined2 ? start2 : toInteger(start2);
            return baseRest(func, start2);
          }
          function spread(func, start2) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
            return baseRest(function(args) {
              var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
              if (array2) {
                arrayPush(otherArgs, array2);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper3) {
            return partial(castFunction(wrapper3), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object2, source) {
            return source == null || baseConformsTo(object2, source, keys2(source));
          }
          function eq2(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction4(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty2.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction4(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object2, source) {
            return object2 === source || baseIsMatch(object2, source, getMatchData(source));
          }
          function isMatchWith(object2, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object2, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject2(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol2(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol2(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object2, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys2(source), object2);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                assignValue(object2, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object2, source) {
            copyObject(source, keysIn(source), object2);
          });
          var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object2, customizer);
          });
          var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
            copyObject(source, keys2(source), object2, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults2 = baseRest(function(object2, sources) {
            object2 = Object2(object2);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object2[key];
                if (value === undefined2 || eq2(value, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
                  object2[key] = source[key];
                }
              }
            }
            return object2;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object2, predicate) {
            return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object2, predicate) {
            return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object2, iteratee2) {
            return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object2, iteratee2) {
            return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object2, iteratee2) {
            return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object2, iteratee2) {
            return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
          }
          function functions(object2) {
            return object2 == null ? [] : baseFunctions(object2, keys2(object2));
          }
          function functionsIn(object2) {
            return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
          }
          function get4(object2, path, defaultValue) {
            var result2 = object2 == null ? undefined2 : baseGet(object2, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has3(object2, path) {
            return object2 != null && hasPath(object2, path, baseHas);
          }
          function hasIn(object2, path) {
            return object2 != null && hasPath(object2, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty2.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys2(object2) {
            return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
          }
          function keysIn(object2) {
            return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
          }
          function mapKeys(object2, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object2, function(value, key, object22) {
              baseAssignValue(result2, iteratee2(value, key, object22), value);
            });
            return result2;
          }
          function mapValues(object2, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object2, function(value, key, object22) {
              baseAssignValue(result2, key, iteratee2(value, key, object22));
            });
            return result2;
          }
          var merge = createAssigner(function(object2, source, srcIndex) {
            baseMerge(object2, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
            baseMerge(object2, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object2, paths) {
            var result2 = {};
            if (object2 == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object2);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object2, getAllKeysIn(object2), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object2, predicate) {
            return pickBy(object2, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object2, paths) {
            return object2 == null ? {} : basePick(object2, paths);
          });
          function pickBy(object2, predicate) {
            if (object2 == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object2), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object2, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object2, path, defaultValue) {
            path = castPath(path, object2);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object2 = undefined2;
            }
            while (++index < length) {
              var value = object2 == null ? undefined2 : object2[toKey(path[index])];
              if (value === undefined2) {
                index = length;
                value = defaultValue;
              }
              object2 = isFunction4(value) ? value.call(object2) : value;
            }
            return object2;
          }
          function set5(object2, path, value) {
            return object2 == null ? object2 : baseSet(object2, path, value);
          }
          function setWith(object2, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object2 == null ? object2 : baseSet(object2, path, value, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn);
          function transform(object2, iteratee2, accumulator) {
            var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object2 && object2.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object2)) {
                accumulator = isFunction4(Ctor) ? baseCreate(getPrototype(object2)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object22) {
              return iteratee2(accumulator, value, index, object22);
            });
            return accumulator;
          }
          function unset(object2, path) {
            return object2 == null ? true : baseUnset(object2, path);
          }
          function update(object2, path, updater) {
            return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
          }
          function updateWith(object2, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
          }
          function values2(object2) {
            return object2 == null ? [] : baseValues(object2, keys2(object2));
          }
          function valuesIn(object2) {
            return object2 == null ? [] : baseValues(object2, keysIn(object2));
          }
          function clamp(number2, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number2), lower, upper);
          }
          function inRange(number2, start2, end) {
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            number2 = toNumber(number2);
            return baseInRange(number2, start2, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize(word) : word);
          });
          function capitalize(string2) {
            return upperFirst(toString2(string2).toLowerCase());
          }
          function deburr(string2) {
            string2 = toString2(string2);
            return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string2, target, position) {
            string2 = toString2(string2);
            target = baseToString(target);
            var length = string2.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string2.slice(position, end) == target;
          }
          function escape(string2) {
            string2 = toString2(string2);
            return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
          }
          function escapeRegExp(string2) {
            string2 = toString2(string2);
            return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string2, length, chars) {
            string2 = toString2(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            if (!length || strLength >= length) {
              return string2;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string2, length, chars) {
            string2 = toString2(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
          }
          function padStart(string2, length, chars) {
            string2 = toString2(string2);
            length = toInteger(length);
            var strLength = length ? stringSize(string2) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
          }
          function parseInt2(string2, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string2, n, guard) {
            if (guard ? isIterateeCall(string2, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString2(string2), n);
          }
          function replace2() {
            var args = arguments, string2 = toString2(args[0]);
            return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string2, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string2 = toString2(string2);
            if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string2)) {
                return castSlice(stringToArray(string2), 0, limit);
              }
            }
            return string2.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string2, target, position) {
            string2 = toString2(string2);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
            target = baseToString(target);
            return string2.slice(position, position + target.length) == target;
          }
          function template(string2, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string2, options, guard)) {
              options = undefined2;
            }
            string2 = toString2(string2);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined2)) {
              return baseTrim(string2);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start2, end).join("");
          }
          function trimEnd(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined2)) {
              return string2.slice(0, trimmedEndIndex(string2) + 1);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined2)) {
              return string2.replace(reTrimStart, "");
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start2).join("");
          }
          function truncate(string2, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string2 = toString2(string2);
            var strLength = string2.length;
            if (hasUnicode(string2)) {
              var strSymbols = stringToArray(string2);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string2;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string2.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string2.indexOf(baseToString(separator), end) != end) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape2(string2) {
            string2 = toString2(string2);
            return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string2, pattern, guard) {
            string2 = toString2(string2);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
            }
            return string2.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object2, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object2, key, bind(object2[key], object2));
            });
            return object2;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair2) {
              if (typeof pair2[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair2[0]), pair2[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair2 = pairs[index];
                if (apply(pair2[0], this, args)) {
                  return apply(pair2[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow3 = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object2) {
              return baseInvoke(object2, path, args);
            };
          });
          var methodOf = baseRest(function(object2, args) {
            return function(path) {
              return baseInvoke(object2, path, args);
            };
          });
          function mixin(object2, source, options) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object2;
              object2 = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction4(object2);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object2[methodName] = func;
              if (isFunc) {
                object2.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object2, arrayPush([this.value()], arguments));
                };
              }
            });
            return object2;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop3() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object2) {
            return function(path) {
              return object2 == null ? undefined2 : baseGet(object2, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString2(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined2;
          }
          function maxBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array2) {
            return baseMean(array2, identity);
          }
          function meanBy(array2, iteratee2) {
            return baseMean(array2, getIteratee(iteratee2, 2));
          }
          function min(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined2;
          }
          function minBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array2) {
            return array2 && array2.length ? baseSum(array2, identity) : 0;
          }
          function sumBy(array2, iteratee2) {
            return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults2;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten2;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow3;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys2;
          lodash.keysIn = keysIn;
          lodash.map = map2;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once2;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove4;
          lodash.rest = rest;
          lodash.reverse = reverse2;
          lodash.sampleSize = sampleSize;
          lodash.set = set5;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values2;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq2;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find2;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get4;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has3;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction4;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject2;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol2;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop3;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace2;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString2;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start2, end) {
            start2 = toInteger(start2);
            var result2 = this;
            if (result2.__filtered__ && (start2 > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start2 < 0) {
              result2 = result2.takeRight(-start2);
            } else if (start2) {
              result2 = result2.drop(start2);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _22 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _22;
          define(function() {
            return _22;
          });
        } else if (freeModule) {
          (freeModule.exports = _22)._ = _22;
          freeExports._ = _22;
        } else {
          root._ = _22;
        }
      }).call(exports);
    }
  });
  var DefaultBufferLength2 = 1024;
  var nextPropID2 = 0;
  var Range3 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp2 = class {
    constructor(config = {}) {
      this.id = nextPropID2++;
      this.perNode = !!config.perNode;
      this.deserialize = config.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType2.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp2.closedBy = new NodeProp2({ deserialize: (str) => str.split(" ") });
  NodeProp2.openedBy = new NodeProp2({ deserialize: (str) => str.split(" ") });
  NodeProp2.group = new NodeProp2({ deserialize: (str) => str.split(" ") });
  NodeProp2.contextHash = new NodeProp2({ perNode: true });
  NodeProp2.lookAhead = new NodeProp2({ perNode: true });
  NodeProp2.mounted = new NodeProp2({ perNode: true });
  var noProps2 = Object.create(null);
  var NodeType2 = class {
    constructor(name2, props, id, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? Object.create(null) : noProps2;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType2(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2)
          return true;
        let group = this.prop(NodeProp2.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map2) {
      let direct = Object.create(null);
      for (let prop in map2)
        for (let name2 of prop.split(" "))
          direct[name2] = map2[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp2.group), i = -1; i < (groups ? groups.length : 0); i++) {
          let found = direct[i < 0 ? node.name : groups[i]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType2.none = new NodeType2("", Object.create(null), 0, 8);
  var NodeSet = class {
    constructor(types2) {
      this.types = types2;
      for (let i = 0; i < types2.length; i++)
        if (types2[i].id != i)
          throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source of props) {
          let add = source(type);
          if (add) {
            if (!newProps)
              newProps = Object.assign({}, type.props);
            newProps[add[0].id] = add[1];
          }
        }
        newTypes.push(newProps ? new NodeType2(type.name, newProps, type.id, type.flags) : type);
      }
      return new NodeSet(newTypes);
    }
  };
  var CachedNode2 = new WeakMap();
  var Tree2 = class {
    constructor(type, children, positions, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp2.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch2 of this.children) {
        let str = ch2.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(pos, side = 0) {
      let scope = pos != null && CachedNode2.get(this) || this.topNode;
      let cursor = new TreeCursor2(scope);
      if (pos != null) {
        cursor.moveTo(pos, side);
        CachedNode2.set(this, cursor._tree);
      }
      return cursor;
    }
    fullCursor() {
      return new TreeCursor2(this.topNode, 1);
    }
    get topNode() {
      return new TreeNode2(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      return this.cursor(pos, side).node;
    }
    resolveInner(pos, side = 0) {
      let result = this.topNode;
      for (; ; ) {
        let inner = result.enter(pos, side);
        if (!inner)
          return result;
        result = inner;
      }
    }
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      for (let c = this.cursor(), get4 = () => c.node; ; ) {
        let mustLeave = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get4) !== false)) {
          if (c.firstChild())
            continue;
          if (!c.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(c.type, c.from, c.to, get4);
          mustLeave = c.type.isAnonymous;
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          mustLeave = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id in this.props)
          result.push([+id, this.props[id]]);
      return result;
    }
    balance(config = {}) {
      return this.children.length <= 8 ? this : balanceRange2(this.type, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree2(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree2(NodeType2.none, children, positions, length)));
    }
    static build(data) {
      return buildTree2(data);
    }
  };
  Tree2.empty = new Tree2(NodeType2.none, [], [], 0);
  var FlatBufferCursor2 = class {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor2(this.buffer, this.index);
    }
  };
  var TreeBuffer2 = class {
    constructor(buffer, length, set5) {
      this.buffer = buffer;
      this.length = length;
      this.set = set5;
    }
    get type() {
      return NodeType2.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id = this.buffer[index], endIndex = this.buffer[index + 3];
      let type = this.set.types[id], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
        if (checkSide2(side, pos, buffer[i + 1], buffer[i + 2])) {
          pick = i;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from, to) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI);
      for (let i = startI, j = 0; i < endI; ) {
        copy[j++] = b[i++];
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - from;
        copy[j++] = b[i++] - startI;
      }
      return new TreeBuffer2(copy, to - from, this.set);
    }
  };
  function checkSide2(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore2(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  var TreeNode2 = class {
    constructor(node, _from, index, _parent) {
      this.node = node;
      this._from = _from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this.node.type;
    }
    get name() {
      return this.node.type.name;
    }
    get from() {
      return this._from;
    }
    get to() {
      return this._from + this.node.length;
    }
    nextChild(i, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
          let next = children[i], start2 = positions[i] + parent._from;
          if (!checkSide2(side, pos, start2, start2 + next.length))
            continue;
          if (next instanceof TreeBuffer2) {
            if (mode & 2)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start2, side);
            if (index > -1)
              return new BufferNode2(new BufferContext2(parent, next, i, start2), null, index);
          } else if (mode & 1 || (!next.type.isAnonymous || hasChild2(next))) {
            let mounted;
            if (next.props && (mounted = next.prop(NodeProp2.mounted)) && !mounted.overlay)
              return new TreeNode2(mounted.tree, start2, i, parent);
            let inner = new TreeNode2(next, start2, i, parent);
            return mode & 1 || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & 1 || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i = parent.index + dir;
        else
          i = dir < 0 ? -1 : parent._parent.node.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this.node.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this.node.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, overlays = true, buffers = true) {
      let mounted;
      if (overlays && (mounted = this.node.prop(NodeProp2.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode2(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, buffers ? 0 : 2);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get cursor() {
      return new TreeCursor2(this);
    }
    get tree() {
      return this.node;
    }
    toTree() {
      return this.node;
    }
    resolve(pos, side = 0) {
      return this.cursor.moveTo(pos, side).node;
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore2(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r42 = getChildren2(this, type, before, after);
      return r42.length ? r42[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren2(this, type, before, after);
    }
    toString() {
      return this.node.toString();
    }
  };
  function getChildren2(node, type, before, after) {
    let cur = node.cursor, result = [];
    if (!cur.firstChild())
      return result;
    if (before != null) {
      while (!cur.type.is(before))
        if (!cur.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur.type.is(after))
        return result;
      if (cur.type.is(type))
        result.push(cur.node);
      if (!cur.nextSibling())
        return after == null ? result : [];
    }
  }
  var BufferContext2 = class {
    constructor(parent, buffer, index, start2) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start2;
    }
  };
  var BufferNode2 = class {
    constructor(context, _parent, index) {
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode2(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, overlays, buffers = true) {
      if (!buffers)
        return null;
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode2(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode2(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode2(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    get cursor() {
      return new TreeCursor2(this);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
        children.push(buffer.slice(startI, endI, from, to));
        positions.push(0);
      }
      return new Tree2(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return this.cursor.moveTo(pos, side).node;
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore2(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r42 = getChildren2(this, type, before, after);
      return r42.length ? r42[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren2(this, type, before, after);
    }
  };
  var TreeCursor2 = class {
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode2) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      let { start: start2, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start2 + buffer.buffer[index + 1];
      this.to = start2 + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode2) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, overlays = true, buffers = true) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, overlays, buffers));
      return buffers ? this.enterChild(1, pos, side) : false;
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & 1 ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & 1 ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i = 0; i < this.index; i++)
            if (buffer.buffer.buffer[i + 3] < this.index)
              return false;
        }
        ({ index, parent } = buffer);
      } else {
        ({ index, _parent: parent } = this._tree);
      }
      for (; parent; { index, _parent: parent } = parent) {
        if (index > -1)
          for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
            let child = parent.node.children[i];
            if (this.mode & 1 || child instanceof TreeBuffer2 || !child.type.isAnonymous || hasChild2(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache2 = this.bufferNode, result = null, depth = 0;
      if (cache2 && cache2.context == this.buffer) {
        scan:
          for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache2; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index = this.stack[--d];
          }
      }
      for (let i = depth; i < this.stack.length; i++)
        result = new BufferNode2(this.buffer, result, this.stack[i]);
      return this.bufferNode = new BufferNode2(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree.node;
    }
  };
  function hasChild2(tree) {
    return tree.children.some((ch2) => ch2 instanceof TreeBuffer2 || !ch2.type.isAnonymous || hasChild2(ch2));
  }
  function buildTree2(data) {
    var _a3;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength2, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor2(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let { id, start: start2, end, size } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size < 0) {
        cursor.next();
        if (size == -1) {
          let node2 = reused[id];
          children2.push(node2);
          positions2.push(start2 - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id;
          return;
        } else if (size == -4) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id], node, buffer2;
      let startPos = start2 - parentStart;
      if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index = data2.length;
        while (cursor.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer2(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id >= minRepeatType ? id : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange2(type, localChildren, localPositions, 0, localChildren.length, 0, end - start2, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start2, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree2) {
          if (!lastI && last.type == type && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp2.lookAhead))
            lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i, from, to, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair2 = [NodeProp2.contextHash, contextHash];
        props = props ? [pair2].concat(props) : [pair2];
      }
      if (lookAhead2 > 25) {
        let pair2 = [NodeProp2.lookAhead, lookAhead2];
        props = props ? [pair2].concat(props) : [pair2];
      }
      return new Tree2(type, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize22 = fork.size;
          if (fork.id == inRepeat && nodeSize22 >= 0) {
            result.size = size;
            result.start = start2;
            result.skip = skip;
            skip += 4;
            size += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize22;
          if (nodeSize22 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start2 = nodeStart;
          size += nodeSize22;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start2;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let { id, start: start2, end, size } = cursor;
      cursor.next();
      if (size >= 0 && id < minRepeatType) {
        let startIndex = index;
        if (size > 4) {
          let endPos = cursor.pos - (size - 4);
          while (cursor.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start2 - bufferStart;
        buffer2[--index] = id;
      } else if (size == -3) {
        contextHash = id;
      } else if (size == -4) {
        lookAhead = id;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a3 = data.length) !== null && _a3 !== void 0 ? _a3 : children.length ? positions[0] + children[0].length : 0;
    return new Tree2(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache2 = new WeakMap();
  function nodeSize2(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer2 || node.type != balanceType)
      return 1;
    let size = nodeSizeCache2.get(node);
    if (size == null) {
      size = node.children.reduce((s, ch2) => s + nodeSize2(balanceType, ch2), 1);
      nodeSizeCache2.set(node, size);
    }
    return size;
  }
  function balanceRange2(type, children, positions, from, to, start2, length, mkTop, mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
      total += nodeSize2(type, children[i]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i = from2; i < to2; ) {
        let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize2(type, children2[i]);
        i++;
        for (; i < to2; i++) {
          let nextSize = nodeSize2(type, children2[i]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
          localChildren.push(balanceRange2(type, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start2);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var Parser2 = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput2(input);
      ranges = !ranges ? [new Range3(0, input.length)] : ranges.length ? ranges.map((r42) => new Range3(r42.from, r42.to)) : [new Range3(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput2 = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  var Stack = class {
    constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
      this.p = p;
      this.stack = stack;
      this.state = state;
      this.reducePos = reducePos;
      this.pos = pos;
      this.score = score;
      this.buffer = buffer;
      this.bufferBase = bufferBase;
      this.curContext = curContext;
      this.lookAhead = lookAhead;
      this.parent = parent;
    }
    toString() {
      return `[${this.stack.filter((_22, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    static start(p, state, pos = 0) {
      let cx = p.parser.context;
      return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    get context() {
      return this.curContext ? this.curContext.context : null;
    }
    pushState(state, start2) {
      this.stack.push(this.state, start2, this.bufferBase + this.buffer.length);
      this.state = state;
    }
    reduce(action2) {
      let depth = action2 >> 19, type = action2 & 65535;
      let { parser: parser2 } = this.p;
      let dPrec = parser2.dynamicPrecedence(type);
      if (dPrec)
        this.score += dPrec;
      if (depth == 0) {
        if (type < parser2.minRepeatTerm)
          this.storeNode(type, this.reducePos, this.reducePos, 4, true);
        this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
        this.reduceContext(type, this.reducePos);
        return;
      }
      let base2 = this.stack.length - (depth - 1) * 3 - (action2 & 262144 ? 6 : 0);
      let start2 = this.stack[base2 - 2];
      let bufferBase = this.stack[base2 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
      if (type < parser2.minRepeatTerm || action2 & 131072) {
        let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
        this.storeNode(type, start2, pos, count + 4, true);
      }
      if (action2 & 262144) {
        this.state = this.stack[base2];
      } else {
        let baseStateID = this.stack[base2 - 3];
        this.state = parser2.getGoto(baseStateID, type, true);
      }
      while (this.stack.length > base2)
        this.stack.pop();
      this.reduceContext(type, start2);
    }
    storeNode(term, start2, end, size = 4, isReduce = false) {
      if (term == 0) {
        let cur = this, top2 = this.buffer.length;
        if (top2 == 0 && cur.parent) {
          top2 = cur.bufferBase - cur.parent.bufferBase;
          cur = cur.parent;
        }
        if (top2 > 0 && cur.buffer[top2 - 4] == 0 && cur.buffer[top2 - 1] > -1) {
          if (start2 == end)
            return;
          if (cur.buffer[top2 - 2] >= start2) {
            cur.buffer[top2 - 2] = end;
            return;
          }
        }
      }
      if (!isReduce || this.pos == end) {
        this.buffer.push(term, start2, end, size);
      } else {
        let index = this.buffer.length;
        if (index > 0 && this.buffer[index - 4] != 0)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
        this.buffer[index] = term;
        this.buffer[index + 1] = start2;
        this.buffer[index + 2] = end;
        this.buffer[index + 3] = size;
      }
    }
    shift(action2, next, nextEnd) {
      let start2 = this.pos;
      if (action2 & 131072) {
        this.pushState(action2 & 65535, this.pos);
      } else if ((action2 & 262144) == 0) {
        let nextState = action2, { parser: parser2 } = this.p;
        if (nextEnd > this.pos || next <= parser2.maxNode) {
          this.pos = nextEnd;
          if (!parser2.stateFlag(nextState, 1))
            this.reducePos = nextEnd;
        }
        this.pushState(nextState, start2);
        this.shiftContext(next, start2);
        if (next <= parser2.maxNode)
          this.buffer.push(next, start2, nextEnd, 4);
      } else {
        this.pos = nextEnd;
        this.shiftContext(next, start2);
        if (next <= this.p.parser.maxNode)
          this.buffer.push(next, start2, nextEnd, 4);
      }
    }
    apply(action2, next, nextEnd) {
      if (action2 & 65536)
        this.reduce(action2);
      else
        this.shift(action2, next, nextEnd);
    }
    useNode(value, next) {
      let index = this.p.reused.length - 1;
      if (index < 0 || this.p.reused[index] != value) {
        this.p.reused.push(value);
        index++;
      }
      let start2 = this.pos;
      this.reducePos = this.pos = start2 + value.length;
      this.pushState(next, start2);
      this.buffer.push(index, start2, this.reducePos, -1);
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    split() {
      let parent = this;
      let off = parent.buffer.length;
      while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
        off -= 4;
      let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
      while (parent && base2 == parent.bufferBase)
        parent = parent.parent;
      return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
    }
    recoverByDelete(next, nextEnd) {
      let isNode = next <= this.p.parser.maxNode;
      if (isNode)
        this.storeNode(next, this.pos, nextEnd, 4);
      this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
      this.pos = this.reducePos = nextEnd;
      this.score -= 190;
    }
    canShift(term) {
      for (let sim = new SimulatedStack(this); ; ) {
        let action2 = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
        if ((action2 & 65536) == 0)
          return true;
        if (action2 == 0)
          return false;
        sim.reduce(action2);
      }
    }
    recoverByInsert(next) {
      if (this.stack.length >= 300)
        return [];
      let nextStates = this.p.parser.nextStates(this.state);
      if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
        let best = [];
        for (let i = 0, s; i < nextStates.length; i += 2) {
          if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
            best.push(nextStates[i], s);
        }
        if (this.stack.length < 120)
          for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
            let s = nextStates[i + 1];
            if (!best.some((v, i2) => i2 & 1 && v == s))
              best.push(nextStates[i], s);
          }
        nextStates = best;
      }
      let result = [];
      for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
        let s = nextStates[i + 1];
        if (s == this.state)
          continue;
        let stack = this.split();
        stack.storeNode(0, stack.pos, stack.pos, 4, true);
        stack.pushState(s, this.pos);
        stack.shiftContext(nextStates[i], this.pos);
        stack.score -= 200;
        result.push(stack);
      }
      return result;
    }
    forceReduce() {
      let reduce = this.p.parser.stateSlot(this.state, 5);
      if ((reduce & 65536) == 0)
        return false;
      let { parser: parser2 } = this.p;
      if (!parser2.validAction(this.state, reduce)) {
        let depth = reduce >> 19, term = reduce & 65535;
        let target = this.stack.length - depth * 3;
        if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0)
          return false;
        this.storeNode(0, this.reducePos, this.reducePos, 4, true);
        this.score -= 100;
      }
      this.reduce(reduce);
      return true;
    }
    forceAll() {
      while (!this.p.parser.stateFlag(this.state, 2) && this.forceReduce()) {
      }
      return this;
    }
    get deadEnd() {
      if (this.stack.length != 3)
        return false;
      let { parser: parser2 } = this.p;
      return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
    }
    restart() {
      this.state = this.stack[0];
      this.stack.length = 0;
    }
    sameState(other) {
      if (this.state != other.state || this.stack.length != other.stack.length)
        return false;
      for (let i = 0; i < this.stack.length; i += 3)
        if (this.stack[i] != other.stack[i])
          return false;
      return true;
    }
    get parser() {
      return this.p.parser;
    }
    dialectEnabled(dialectID) {
      return this.p.parser.dialect.flags[dialectID];
    }
    shiftContext(term, start2) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start2)));
    }
    reduceContext(term, start2) {
      if (this.curContext)
        this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start2)));
    }
    emitContext() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -3)
        this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
    }
    emitLookAhead() {
      let last = this.buffer.length - 1;
      if (last < 0 || this.buffer[last] != -4)
        this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
    }
    updateContext(context) {
      if (context != this.curContext.context) {
        let newCx = new StackContext(this.curContext.tracker, context);
        if (newCx.hash != this.curContext.hash)
          this.emitContext();
        this.curContext = newCx;
      }
    }
    setLookAhead(lookAhead) {
      if (lookAhead > this.lookAhead) {
        this.emitLookAhead();
        this.lookAhead = lookAhead;
      }
    }
    close() {
      if (this.curContext && this.curContext.tracker.strict)
        this.emitContext();
      if (this.lookAhead > 0)
        this.emitLookAhead();
    }
  };
  var StackContext = class {
    constructor(tracker, context) {
      this.tracker = tracker;
      this.context = context;
      this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
  };
  var Recover;
  (function(Recover2) {
    Recover2[Recover2["Insert"] = 200] = "Insert";
    Recover2[Recover2["Delete"] = 190] = "Delete";
    Recover2[Recover2["Reduce"] = 100] = "Reduce";
    Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
    Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
    Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
  })(Recover || (Recover = {}));
  var SimulatedStack = class {
    constructor(start2) {
      this.start = start2;
      this.state = start2.state;
      this.stack = start2.stack;
      this.base = this.stack.length;
    }
    reduce(action2) {
      let term = action2 & 65535, depth = action2 >> 19;
      if (depth == 0) {
        if (this.stack == this.start.stack)
          this.stack = this.stack.slice();
        this.stack.push(this.state, 0, 0);
        this.base += 3;
      } else {
        this.base -= (depth - 1) * 3;
      }
      let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
      this.state = goto;
    }
  };
  var StackBufferCursor = class {
    constructor(stack, pos, index) {
      this.stack = stack;
      this.pos = pos;
      this.index = index;
      this.buffer = stack.buffer;
      if (this.index == 0)
        this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
      return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
      let next = this.stack.parent;
      if (next != null) {
        this.index = this.stack.bufferBase - next.bufferBase;
        this.stack = next;
        this.buffer = next.buffer;
      }
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    next() {
      this.index -= 4;
      this.pos -= 4;
      if (this.index == 0)
        this.maybeNext();
    }
    fork() {
      return new StackBufferCursor(this.stack, this.pos, this.index);
    }
  };
  var CachedToken = class {
    constructor() {
      this.start = -1;
      this.value = -1;
      this.end = -1;
      this.extended = -1;
      this.lookAhead = 0;
      this.mask = 0;
      this.context = 0;
    }
  };
  var nullToken = new CachedToken();
  var InputStream = class {
    constructor(input, ranges) {
      this.input = input;
      this.ranges = ranges;
      this.chunk = "";
      this.chunkOff = 0;
      this.chunk2 = "";
      this.chunk2Pos = 0;
      this.next = -1;
      this.token = nullToken;
      this.rangeIndex = 0;
      this.pos = this.chunkPos = ranges[0].from;
      this.range = ranges[0];
      this.end = ranges[ranges.length - 1].to;
      this.readNext();
    }
    resolveOffset(offset, assoc) {
      let range = this.range, index = this.rangeIndex;
      let pos = this.pos + offset;
      while (pos < range.from) {
        if (!index)
          return null;
        let next = this.ranges[--index];
        pos -= range.from - next.to;
        range = next;
      }
      while (assoc < 0 ? pos > range.to : pos >= range.to) {
        if (index == this.ranges.length - 1)
          return null;
        let next = this.ranges[++index];
        pos += next.from - range.to;
        range = next;
      }
      return pos;
    }
    peek(offset) {
      let idx = this.chunkOff + offset, pos, result;
      if (idx >= 0 && idx < this.chunk.length) {
        pos = this.pos + offset;
        result = this.chunk.charCodeAt(idx);
      } else {
        let resolved = this.resolveOffset(offset, 1);
        if (resolved == null)
          return -1;
        pos = resolved;
        if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
          result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
        } else {
          let i = this.rangeIndex, range = this.range;
          while (range.to <= pos)
            range = this.ranges[++i];
          this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
          if (pos + this.chunk2.length > range.to)
            this.chunk2 = this.chunk2.slice(0, range.to - pos);
          result = this.chunk2.charCodeAt(0);
        }
      }
      if (pos > this.token.lookAhead)
        this.token.lookAhead = pos;
      return result;
    }
    acceptToken(token, endOffset = 0) {
      let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
      if (end == null || end < this.token.start)
        throw new RangeError("Token end out of bounds");
      this.token.value = token;
      this.token.end = end;
    }
    getChunk() {
      if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
        let { chunk, chunkPos } = this;
        this.chunk = this.chunk2;
        this.chunkPos = this.chunk2Pos;
        this.chunk2 = chunk;
        this.chunk2Pos = chunkPos;
        this.chunkOff = this.pos - this.chunkPos;
      } else {
        this.chunk2 = this.chunk;
        this.chunk2Pos = this.chunkPos;
        let nextChunk = this.input.chunk(this.pos);
        let end = this.pos + nextChunk.length;
        this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
        this.chunkPos = this.pos;
        this.chunkOff = 0;
      }
    }
    readNext() {
      if (this.chunkOff >= this.chunk.length) {
        this.getChunk();
        if (this.chunkOff == this.chunk.length)
          return this.next = -1;
      }
      return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    advance(n = 1) {
      this.chunkOff += n;
      while (this.pos + n >= this.range.to) {
        if (this.rangeIndex == this.ranges.length - 1)
          return this.setDone();
        n -= this.range.to - this.pos;
        this.range = this.ranges[++this.rangeIndex];
        this.pos = this.range.from;
      }
      this.pos += n;
      if (this.pos > this.token.lookAhead)
        this.token.lookAhead = this.pos;
      return this.readNext();
    }
    setDone() {
      this.pos = this.chunkPos = this.end;
      this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
      this.chunk = "";
      return this.next = -1;
    }
    reset(pos, token) {
      if (token) {
        this.token = token;
        token.start = token.lookAhead = pos;
        token.value = token.extended = -1;
      } else {
        this.token = nullToken;
      }
      if (this.pos != pos) {
        this.pos = pos;
        if (pos == this.end) {
          this.setDone();
          return this;
        }
        while (pos < this.range.from)
          this.range = this.ranges[--this.rangeIndex];
        while (pos >= this.range.to)
          this.range = this.ranges[++this.rangeIndex];
        if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
          this.chunkOff = pos - this.chunkPos;
        } else {
          this.chunk = "";
          this.chunkOff = 0;
        }
        this.readNext();
      }
      return this;
    }
    read(from, to) {
      if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
        return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
      if (from >= this.range.from && to <= this.range.to)
        return this.input.read(from, to);
      let result = "";
      for (let r42 of this.ranges) {
        if (r42.from >= to)
          break;
        if (r42.to > from)
          result += this.input.read(Math.max(r42.from, from), Math.min(r42.to, to));
      }
      return result;
    }
  };
  var TokenGroup = class {
    constructor(data, id) {
      this.data = data;
      this.id = id;
    }
    token(input, stack) {
      readToken(this.data, input, stack, this.id);
    }
  };
  TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
  var ExternalTokenizer = class {
    constructor(token, options = {}) {
      this.token = token;
      this.contextual = !!options.contextual;
      this.fallback = !!options.fallback;
      this.extend = !!options.extend;
    }
  };
  function readToken(data, input, stack, group) {
    let state = 0, groupMask = 1 << group, { parser: parser2 } = stack.p, { dialect } = parser2;
    scan:
      for (; ; ) {
        if ((groupMask & data[state]) == 0)
          break;
        let accEnd = data[state + 1];
        for (let i = state + 3; i < accEnd; i += 2)
          if ((data[i + 1] & groupMask) > 0) {
            let term = data[i];
            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
              input.acceptToken(term);
              break;
            }
          }
        for (let next = input.next, low = 0, high = data[state + 2]; low < high; ) {
          let mid = low + high >> 1;
          let index = accEnd + mid + (mid << 1);
          let from = data[index], to = data[index + 1];
          if (next < from)
            high = mid;
          else if (next >= to)
            low = mid + 1;
          else {
            state = data[index + 2];
            input.advance();
            continue scan;
          }
        }
        break;
      }
  }
  function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
      return input;
    let array2 = null;
    for (let pos = 0, out = 0; pos < input.length; ) {
      let value = 0;
      for (; ; ) {
        let next = input.charCodeAt(pos++), stop = false;
        if (next == 126) {
          value = 65535;
          break;
        }
        if (next >= 92)
          next--;
        if (next >= 34)
          next--;
        let digit = next - 32;
        if (digit >= 46) {
          digit -= 46;
          stop = true;
        }
        value += digit;
        if (stop)
          break;
        value *= 46;
      }
      if (array2)
        array2[out++] = value;
      else
        array2 = new Type(value);
    }
    return array2;
  }
  var verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
  var stackIDs = null;
  var Safety;
  (function(Safety2) {
    Safety2[Safety2["Margin"] = 25] = "Margin";
  })(Safety || (Safety = {}));
  function cutAt(tree, pos, side) {
    let cursor = tree.fullCursor();
    cursor.moveTo(pos);
    for (; ; ) {
      if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
        for (; ; ) {
          if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
            return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
          if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
            break;
          if (!cursor.parent())
            return side < 0 ? 0 : tree.length;
        }
    }
  }
  var FragmentCursor = class {
    constructor(fragments, nodeSet) {
      this.fragments = fragments;
      this.nodeSet = nodeSet;
      this.i = 0;
      this.fragment = null;
      this.safeFrom = -1;
      this.safeTo = -1;
      this.trees = [];
      this.start = [];
      this.index = [];
      this.nextFragment();
    }
    nextFragment() {
      let fr2 = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
      if (fr2) {
        this.safeFrom = fr2.openStart ? cutAt(fr2.tree, fr2.from + fr2.offset, 1) - fr2.offset : fr2.from;
        this.safeTo = fr2.openEnd ? cutAt(fr2.tree, fr2.to + fr2.offset, -1) - fr2.offset : fr2.to;
        while (this.trees.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
        }
        this.trees.push(fr2.tree);
        this.start.push(-fr2.offset);
        this.index.push(0);
        this.nextStart = this.safeFrom;
      } else {
        this.nextStart = 1e9;
      }
    }
    nodeAt(pos) {
      if (pos < this.nextStart)
        return null;
      while (this.fragment && this.safeTo <= pos)
        this.nextFragment();
      if (!this.fragment)
        return null;
      for (; ; ) {
        let last = this.trees.length - 1;
        if (last < 0) {
          this.nextFragment();
          return null;
        }
        let top2 = this.trees[last], index = this.index[last];
        if (index == top2.children.length) {
          this.trees.pop();
          this.start.pop();
          this.index.pop();
          continue;
        }
        let next = top2.children[index];
        let start2 = this.start[last] + top2.positions[index];
        if (start2 > pos) {
          this.nextStart = start2;
          return null;
        }
        if (next instanceof Tree2) {
          if (start2 == pos) {
            if (start2 < this.safeFrom)
              return null;
            let end = start2 + next.length;
            if (end <= this.safeTo) {
              let lookAhead = next.prop(NodeProp2.lookAhead);
              if (!lookAhead || end + lookAhead < this.fragment.to)
                return next;
            }
          }
          this.index[last]++;
          if (start2 + next.length >= Math.max(this.safeFrom, pos)) {
            this.trees.push(next);
            this.start.push(start2);
            this.index.push(0);
          }
        } else {
          this.index[last]++;
          this.nextStart = start2 + next.length;
        }
      }
    }
  };
  var TokenCache = class {
    constructor(parser2, stream) {
      this.stream = stream;
      this.tokens = [];
      this.mainToken = null;
      this.actions = [];
      this.tokens = parser2.tokenizers.map((_22) => new CachedToken());
    }
    getActions(stack) {
      let actionIndex = 0;
      let main = null;
      let { parser: parser2 } = stack.p, { tokenizers } = parser2;
      let mask = parser2.stateSlot(stack.state, 3);
      let context = stack.curContext ? stack.curContext.hash : 0;
      let lookAhead = 0;
      for (let i = 0; i < tokenizers.length; i++) {
        if ((1 << i & mask) == 0)
          continue;
        let tokenizer = tokenizers[i], token = this.tokens[i];
        if (main && !tokenizer.fallback)
          continue;
        if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
          this.updateCachedToken(token, tokenizer, stack);
          token.mask = mask;
          token.context = context;
        }
        if (token.lookAhead > token.end + 25)
          lookAhead = Math.max(token.lookAhead, lookAhead);
        if (token.value != 0) {
          let startIndex = actionIndex;
          if (token.extended > -1)
            actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
          actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
          if (!tokenizer.extend) {
            main = token;
            if (actionIndex > startIndex)
              break;
          }
        }
      }
      while (this.actions.length > actionIndex)
        this.actions.pop();
      if (lookAhead)
        stack.setLookAhead(lookAhead);
      if (!main && stack.pos == this.stream.end) {
        main = new CachedToken();
        main.value = stack.p.parser.eofTerm;
        main.start = main.end = stack.pos;
        actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
      }
      this.mainToken = main;
      return this.actions;
    }
    getMainToken(stack) {
      if (this.mainToken)
        return this.mainToken;
      let main = new CachedToken(), { pos, p } = stack;
      main.start = pos;
      main.end = Math.min(pos + 1, p.stream.end);
      main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
      return main;
    }
    updateCachedToken(token, tokenizer, stack) {
      tokenizer.token(this.stream.reset(stack.pos, token), stack);
      if (token.value > -1) {
        let { parser: parser2 } = stack.p;
        for (let i = 0; i < parser2.specialized.length; i++)
          if (parser2.specialized[i] == token.value) {
            let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
            if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
              if ((result & 1) == 0)
                token.value = result >> 1;
              else
                token.extended = result >> 1;
              break;
            }
          }
      } else {
        token.value = 0;
        token.end = Math.min(stack.p.stream.end, stack.pos + 1);
      }
    }
    putAction(action2, token, end, index) {
      for (let i = 0; i < index; i += 3)
        if (this.actions[i] == action2)
          return index;
      this.actions[index++] = action2;
      this.actions[index++] = token;
      this.actions[index++] = end;
      return index;
    }
    addActions(stack, token, end, index) {
      let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
      for (let set5 = 0; set5 < 2; set5++) {
        for (let i = parser2.stateSlot(state, set5 ? 2 : 1); ; i += 3) {
          if (data[i] == 65535) {
            if (data[i + 1] == 1) {
              i = pair(data, i + 2);
            } else {
              if (index == 0 && data[i + 1] == 2)
                index = this.putAction(pair(data, i + 1), token, end, index);
              break;
            }
          }
          if (data[i] == token)
            index = this.putAction(pair(data, i + 1), token, end, index);
        }
      }
      return index;
    }
  };
  var Rec;
  (function(Rec2) {
    Rec2[Rec2["Distance"] = 5] = "Distance";
    Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
    Rec2[Rec2["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
    Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
  })(Rec || (Rec = {}));
  var Parse = class {
    constructor(parser2, input, fragments, ranges) {
      this.parser = parser2;
      this.input = input;
      this.ranges = ranges;
      this.recovering = 0;
      this.nextStackID = 9812;
      this.minStackPos = 0;
      this.reused = [];
      this.stoppedAt = null;
      this.stream = new InputStream(input, ranges);
      this.tokens = new TokenCache(parser2, this.stream);
      this.topTerm = parser2.top[1];
      let { from } = ranges[0];
      this.stacks = [Stack.start(this, parser2.top[0], from)];
      this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
    }
    get parsedPos() {
      return this.minStackPos;
    }
    advance() {
      let stacks = this.stacks, pos = this.minStackPos;
      let newStacks = this.stacks = [];
      let stopped, stoppedTokens;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i];
        for (; ; ) {
          this.tokens.mainToken = null;
          if (stack.pos > pos) {
            newStacks.push(stack);
          } else if (this.advanceStack(stack, newStacks, stacks)) {
            continue;
          } else {
            if (!stopped) {
              stopped = [];
              stoppedTokens = [];
            }
            stopped.push(stack);
            let tok = this.tokens.getMainToken(stack);
            stoppedTokens.push(tok.value, tok.end);
          }
          break;
        }
      }
      if (!newStacks.length) {
        let finished = stopped && findFinished(stopped);
        if (finished)
          return this.stackToTree(finished);
        if (this.parser.strict) {
          if (verbose && stopped)
            console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
          throw new SyntaxError("No parse at " + pos);
        }
        if (!this.recovering)
          this.recovering = 5;
      }
      if (this.recovering && stopped) {
        let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
        if (finished)
          return this.stackToTree(finished.forceAll());
      }
      if (this.recovering) {
        let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
        if (newStacks.length > maxRemaining) {
          newStacks.sort((a, b) => b.score - a.score);
          while (newStacks.length > maxRemaining)
            newStacks.pop();
        }
        if (newStacks.some((s) => s.reducePos > pos))
          this.recovering--;
      } else if (newStacks.length > 1) {
        outer:
          for (let i = 0; i < newStacks.length - 1; i++) {
            let stack = newStacks[i];
            for (let j = i + 1; j < newStacks.length; j++) {
              let other = newStacks[j];
              if (stack.sameState(other) || stack.buffer.length > 200 && other.buffer.length > 200) {
                if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                  newStacks.splice(j--, 1);
                } else {
                  newStacks.splice(i--, 1);
                  continue outer;
                }
              }
            }
          }
      }
      this.minStackPos = newStacks[0].pos;
      for (let i = 1; i < newStacks.length; i++)
        if (newStacks[i].pos < this.minStackPos)
          this.minStackPos = newStacks[i].pos;
      return null;
    }
    stopAt(pos) {
      if (this.stoppedAt != null && this.stoppedAt < pos)
        throw new RangeError("Can't move stoppedAt forward");
      this.stoppedAt = pos;
    }
    advanceStack(stack, stacks, split) {
      let start2 = stack.pos, { parser: parser2 } = this;
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (this.stoppedAt != null && start2 > this.stoppedAt)
        return stack.forceReduce() ? stack : null;
      if (this.fragments) {
        let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
        for (let cached = this.fragments.nodeAt(start2); cached; ) {
          let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
          if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp2.contextHash) || 0) == cxHash)) {
            stack.useNode(cached, match);
            if (verbose)
              console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
            return true;
          }
          if (!(cached instanceof Tree2) || cached.children.length == 0 || cached.positions[0] > 0)
            break;
          let inner = cached.children[0];
          if (inner instanceof Tree2 && cached.positions[0] == 0)
            cached = inner;
          else
            break;
        }
      }
      let defaultReduce = parser2.stateSlot(stack.state, 4);
      if (defaultReduce > 0) {
        stack.reduce(defaultReduce);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
        return true;
      }
      let actions = this.tokens.getActions(stack);
      for (let i = 0; i < actions.length; ) {
        let action2 = actions[i++], term = actions[i++], end = actions[i++];
        let last = i == actions.length || !split;
        let localStack = last ? stack : stack.split();
        localStack.apply(action2, term, end);
        if (verbose)
          console.log(base2 + this.stackID(localStack) + ` (via ${(action2 & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action2 & 65535)}`} for ${parser2.getName(term)} @ ${start2}${localStack == stack ? "" : ", split"})`);
        if (last)
          return true;
        else if (localStack.pos > start2)
          stacks.push(localStack);
        else
          split.push(localStack);
      }
      return false;
    }
    advanceFully(stack, newStacks) {
      let pos = stack.pos;
      for (; ; ) {
        if (!this.advanceStack(stack, null, null))
          return false;
        if (stack.pos > pos) {
          pushStackDedup(stack, newStacks);
          return true;
        }
      }
    }
    runRecovery(stacks, tokens, newStacks) {
      let finished = null, restarted = false;
      for (let i = 0; i < stacks.length; i++) {
        let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
        let base2 = verbose ? this.stackID(stack) + " -> " : "";
        if (stack.deadEnd) {
          if (restarted)
            continue;
          restarted = true;
          stack.restart();
          if (verbose)
            console.log(base2 + this.stackID(stack) + " (restarted)");
          let done = this.advanceFully(stack, newStacks);
          if (done)
            continue;
        }
        let force = stack.split(), forceBase = base2;
        for (let j = 0; force.forceReduce() && j < 10; j++) {
          if (verbose)
            console.log(forceBase + this.stackID(force) + " (via force-reduce)");
          let done = this.advanceFully(force, newStacks);
          if (done)
            break;
          if (verbose)
            forceBase = this.stackID(force) + " -> ";
        }
        for (let insert2 of stack.recoverByInsert(token)) {
          if (verbose)
            console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
          this.advanceFully(insert2, newStacks);
        }
        if (this.stream.end > stack.pos) {
          if (tokenEnd == stack.pos) {
            tokenEnd++;
            token = 0;
          }
          stack.recoverByDelete(token, tokenEnd);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
          pushStackDedup(stack, newStacks);
        } else if (!finished || finished.score < stack.score) {
          finished = stack;
        }
      }
      return finished;
    }
    stackToTree(stack) {
      stack.close();
      return Tree2.build({
        buffer: StackBufferCursor.create(stack),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: stack.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      });
    }
    stackID(stack) {
      let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
      if (!id)
        stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
      return id + stack;
    }
  };
  function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
      let other = newStacks[i];
      if (other.pos == stack.pos && other.sameState(stack)) {
        if (newStacks[i].score < stack.score)
          newStacks[i] = stack;
        return;
      }
    }
    newStacks.push(stack);
  }
  var Dialect = class {
    constructor(source, flags, disabled) {
      this.source = source;
      this.flags = flags;
      this.disabled = disabled;
    }
    allows(term) {
      return !this.disabled || this.disabled[term] == 0;
    }
  };
  var LRParser = class extends Parser2 {
    constructor(spec) {
      super();
      this.wrappers = [];
      if (spec.version != 13)
        throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13})`);
      let nodeNames = spec.nodeNames.split(" ");
      this.minRepeatTerm = nodeNames.length;
      for (let i = 0; i < spec.repeatNodeCount; i++)
        nodeNames.push("");
      let topTerms = Object.keys(spec.topRules).map((r42) => spec.topRules[r42][1]);
      let nodeProps = [];
      for (let i = 0; i < nodeNames.length; i++)
        nodeProps.push([]);
      function setProp(nodeID, prop, value) {
        nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
      }
      if (spec.nodeProps)
        for (let propSpec of spec.nodeProps) {
          let prop = propSpec[0];
          for (let i = 1; i < propSpec.length; ) {
            let next = propSpec[i++];
            if (next >= 0) {
              setProp(next, prop, propSpec[i++]);
            } else {
              let value = propSpec[i + -next];
              for (let j = -next; j > 0; j--)
                setProp(propSpec[i++], prop, value);
              i++;
            }
          }
        }
      this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType2.define({
        name: i >= this.minRepeatTerm ? void 0 : name2,
        id: i,
        props: nodeProps[i],
        top: topTerms.indexOf(i) > -1,
        error: i == 0,
        skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
      })));
      this.strict = false;
      this.bufferLength = DefaultBufferLength2;
      let tokenArray = decodeArray(spec.tokenData);
      this.context = spec.context;
      this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
      this.specializers = [];
      if (spec.specialized)
        for (let i = 0; i < spec.specialized.length; i++) {
          this.specialized[i] = spec.specialized[i].term;
          this.specializers[i] = spec.specialized[i].get;
        }
      this.states = decodeArray(spec.states, Uint32Array);
      this.data = decodeArray(spec.stateData);
      this.goto = decodeArray(spec.goto);
      this.maxTerm = spec.maxTerm;
      this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
      this.topRules = spec.topRules;
      this.dialects = spec.dialects || {};
      this.dynamicPrecedences = spec.dynamicPrecedences || null;
      this.tokenPrecTable = spec.tokenPrec;
      this.termNames = spec.termNames || null;
      this.maxNode = this.nodeSet.types.length - 1;
      this.dialect = this.parseDialect();
      this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
      let parse = new Parse(this, input, fragments, ranges);
      for (let w of this.wrappers)
        parse = w(parse, input, fragments, ranges);
      return parse;
    }
    getGoto(state, term, loose = false) {
      let table = this.goto;
      if (term >= table[0])
        return -1;
      for (let pos = table[term + 1]; ; ) {
        let groupTag = table[pos++], last = groupTag & 1;
        let target = table[pos++];
        if (last && loose)
          return target;
        for (let end = pos + (groupTag >> 1); pos < end; pos++)
          if (table[pos] == state)
            return target;
        if (last)
          return -1;
      }
    }
    hasAction(state, terminal) {
      let data = this.data;
      for (let set5 = 0; set5 < 2; set5++) {
        for (let i = this.stateSlot(state, set5 ? 2 : 1), next; ; i += 3) {
          if ((next = data[i]) == 65535) {
            if (data[i + 1] == 1)
              next = data[i = pair(data, i + 2)];
            else if (data[i + 1] == 2)
              return pair(data, i + 2);
            else
              break;
          }
          if (next == terminal || next == 0)
            return pair(data, i + 1);
        }
      }
      return 0;
    }
    stateSlot(state, slot) {
      return this.states[state * 6 + slot];
    }
    stateFlag(state, flag) {
      return (this.stateSlot(state, 0) & flag) > 0;
    }
    validAction(state, action2) {
      if (action2 == this.stateSlot(state, 4))
        return true;
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            return false;
        }
        if (action2 == pair(this.data, i + 1))
          return true;
      }
    }
    nextStates(state) {
      let result = [];
      for (let i = this.stateSlot(state, 1); ; i += 3) {
        if (this.data[i] == 65535) {
          if (this.data[i + 1] == 1)
            i = pair(this.data, i + 2);
          else
            break;
        }
        if ((this.data[i + 2] & 65536 >> 16) == 0) {
          let value = this.data[i + 1];
          if (!result.some((v, i2) => i2 & 1 && v == value))
            result.push(this.data[i], value);
        }
      }
      return result;
    }
    overrides(token, prev) {
      let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
      return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
    }
    configure(config) {
      let copy = Object.assign(Object.create(LRParser.prototype), this);
      if (config.props)
        copy.nodeSet = this.nodeSet.extend(...config.props);
      if (config.top) {
        let info = this.topRules[config.top];
        if (!info)
          throw new RangeError(`Invalid top rule name ${config.top}`);
        copy.top = info;
      }
      if (config.tokenizers)
        copy.tokenizers = this.tokenizers.map((t2) => {
          let found = config.tokenizers.find((r42) => r42.from == t2);
          return found ? found.to : t2;
        });
      if (config.contextTracker)
        copy.context = config.contextTracker;
      if (config.dialect)
        copy.dialect = this.parseDialect(config.dialect);
      if (config.strict != null)
        copy.strict = config.strict;
      if (config.wrap)
        copy.wrappers = copy.wrappers.concat(config.wrap);
      if (config.bufferLength != null)
        copy.bufferLength = config.bufferLength;
      return copy;
    }
    getName(term) {
      return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    get eofTerm() {
      return this.maxNode + 1;
    }
    get topNode() {
      return this.nodeSet.types[this.top[1]];
    }
    dynamicPrecedence(term) {
      let prec2 = this.dynamicPrecedences;
      return prec2 == null ? 0 : prec2[term] || 0;
    }
    parseDialect(dialect) {
      let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
      if (dialect)
        for (let part of dialect.split(" ")) {
          let id = values2.indexOf(part);
          if (id >= 0)
            flags[id] = true;
        }
      let disabled = null;
      for (let i = 0; i < values2.length; i++)
        if (!flags[i]) {
          for (let j = this.dialects[values2[i]], id; (id = this.data[j++]) != 65535; )
            (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
        }
      return new Dialect(dialect, flags, disabled);
    }
    static deserialize(spec) {
      return new LRParser(spec);
    }
  };
  function pair(data, off) {
    return data[off] | data[off + 1] << 16;
  }
  function findOffset(data, start2, term) {
    for (let i = start2, next; (next = data[i]) != 65535; i++)
      if (next == term)
        return i - start2;
    return -1;
  }
  function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
      let stopped = stack.p.stoppedAt;
      if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
        best = stack;
    }
    return best;
  }
  var closureParamDelim = 1;
  var tpOpen = 2;
  var tpClose = 3;
  var RawString = 4;
  var Float = 5;
  var _b = 98;
  var _e = 101;
  var _f2 = 102;
  var _r = 114;
  var _E = 69;
  var Zero = 48;
  var Dot = 46;
  var Plus = 43;
  var Minus = 45;
  var Hash = 35;
  var Quote = 34;
  var Pipe = 124;
  var LessThan = 60;
  var GreaterThan = 62;
  function isNum(ch2) {
    return ch2 >= 48 && ch2 <= 57;
  }
  function isNum_(ch2) {
    return isNum(ch2) || ch2 == 95;
  }
  var literalTokens = new ExternalTokenizer((input, stack) => {
    if (isNum(input.next)) {
      let isFloat = false;
      do {
        input.advance();
      } while (isNum_(input.next));
      if (input.next == Dot) {
        isFloat = true;
        input.advance();
        if (isNum(input.next)) {
          do {
            input.advance();
          } while (isNum_(input.next));
        } else if (input.next == Dot || input.next > 127 || /\w/.test(String.fromCharCode(input.next))) {
          return;
        }
      }
      if (input.next == _e || input.next == _E) {
        isFloat = true;
        input.advance();
        if (input.next == Plus || input.next == Minus)
          input.advance();
        if (!isNum_(input.next))
          return;
        do {
          input.advance();
        } while (isNum_(input.next));
      }
      if (input.next == _f2) {
        let after = input.peek(1);
        if (after == Zero + 3 && input.peek(2) == Zero + 2 || after == Zero + 6 && input.peek(2) == Zero + 4) {
          input.advance(3);
          isFloat = true;
        } else {
          return;
        }
      }
      if (isFloat)
        input.acceptToken(Float);
    } else if (input.next == _b || input.next == _r) {
      if (input.next == _b)
        input.advance();
      if (input.next != _r)
        return;
      input.advance();
      let count = 0;
      while (input.next == Hash) {
        count++;
        input.advance();
      }
      if (input.next != Quote)
        return;
      input.advance();
      content:
        for (; ; ) {
          if (input.next < 0)
            return;
          let isQuote = input.next == Quote;
          input.advance();
          if (isQuote) {
            for (let i = 0; i < count; i++) {
              if (input.next != Hash)
                continue content;
              input.advance();
            }
            input.acceptToken(RawString);
            return;
          }
        }
    }
  });
  var closureParam = new ExternalTokenizer((input) => {
    if (input.next == Pipe)
      input.acceptToken(closureParamDelim, 1);
  });
  var tpDelim = new ExternalTokenizer((input) => {
    if (input.next == LessThan)
      input.acceptToken(tpOpen, 1);
    else if (input.next == GreaterThan)
      input.acceptToken(tpClose, 1);
  });
  var spec_identifier = { __proto__: null, self: 28, super: 32, crate: 34, impl: 46, true: 72, false: 72, pub: 88, in: 92, const: 96, unsafe: 104, async: 108, move: 110, if: 114, let: 118, ref: 142, mut: 144, _: 198, else: 200, match: 204, as: 248, return: 252, await: 262, break: 270, continue: 276, while: 312, loop: 316, for: 320, macro_rules: 327, mod: 334, extern: 342, struct: 346, where: 364, union: 379, enum: 382, type: 390, default: 395, fn: 396, trait: 412, use: 420, static: 438, dyn: 476 };
  var parser = LRParser.deserialize({
    version: 13,
    states: "$3tQ]Q_OOP$wOWOOO&sQWO'#CnO)WQWO'#IaOOQP'#Ia'#IaOOQQ'#If'#IfO)hO`O'#C}OOQR'#Ii'#IiO)sQWO'#IvOOQO'#Hk'#HkO)xQWO'#DpOOQR'#Ix'#IxO)xQWO'#DpO*ZQWO'#DpOOQO'#Iw'#IwO,SQWO'#J`O,ZQWO'#EiOOQV'#Hp'#HpO,cQYO'#F{OOQV'#El'#ElOOQV'#Em'#EmOOQV'#En'#EnO.YQ_O'#EkO0_Q_O'#EoO2gQWOOO4QQ_O'#FPO7hQWO'#J`OOQV'#FY'#FYO7{Q_O'#F^O:WQ_O'#FaOOQO'#F`'#F`O=sQ_O'#FcO=}Q_O'#FbO@VQWO'#FgOOQO'#J`'#J`OOQV'#Ip'#IpOA]Q_O'#IoOEPQWO'#IoOOQV'#Fw'#FwOF[QWO'#JuOFcQWO'#F|OOQO'#IO'#IOOGrQWO'#GhOOQV'#In'#InOOQV'#Im'#ImOOQV'#Hj'#HjQGyQ_OOOKeQ_O'#DUOKlQYO'#CqOOQP'#I`'#I`OOQV'#Hg'#HgQ]Q_OOOLuQWO'#IaONsQYO'#DXO!!eQWO'#JuO!!lQWO'#JuO!!vQ_O'#DfO!%]Q_O'#E}O!(sQ_O'#FWO!,ZQWO'#FZO!.^QXO'#FbO!.cQ_O'#EeO!!vQ_O'#FmO!0uQWO'#FoO!0zQWO'#FoO!1PQ^O'#FqO!1WQWO'#JuO!1_QWO'#FtO!1dQWO'#FxO!2WQWO'#JjO!2_QWO'#GOO!2_QWO'#G`O!2_QWO'#GbO!2_QWO'#GsOOQO'#Ju'#JuO!2dQWO'#GhO!2lQYO'#GpO!2_QWO'#GqO!3uQ^O'#GtO!3|QWO'#GuO!4hQWO'#HOP!4sOpO'#CcPOOO)CDO)CDOOOOO'#Hi'#HiO!5OO`O,59iOOQV,59i,59iO!5ZQYO,5?bOOQO-E;i-E;iOOQO,5:[,5:[OOQP,59Z,59ZO)xQWO,5:[O)xQWO,5:[O!5oQWO,5?lO!5zQYO,5;qO!6PQYO,5;TO!6hQWO,59QO!7kQXO'#CnO!7rQXO'#IaO!8vQWO'#CoO,^QWO'#EiOOQV-E;n-E;nO!9XQWO'#FsOOQV,5<g,5<gO!8vQWO'#CoO!9^QWO'#CoO!9cQWO'#IaO! yQWO'#JuO!9mQWO'#J`O!:TQWO,5;VOOQO'#Io'#IoO!0zQWO'#DaO!<TQWO'#DcO!<]QWO,5;ZO.YQ_O,5;ZOOQO,5;[,5;[OOQV'#Er'#ErOOQV'#Es'#EsOOQV'#Et'#EtOOQV'#Eu'#EuOOQV'#Ev'#EvOOQV'#Ew'#EwOOQV'#Ex'#ExOOQV'#Ey'#EyO.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;fO!<sQ_O,5;kO!@ZQ_O'#FROOQO,5;l,5;lO!BfQWO,5;pO.YQ_O,5;wOKlQYO,5;gO!DRQWO,5;kO!DrQWO,5;xOOQO,5;x,5;xO!EPQWO,5;xO!EUQ_O,5;xO!GaQWO'#CfO!GfQWO,5<QO!GpQ_O,5<QOOQO,5;{,5;{O!J^QXO'#CnO!KoQXO'#IaOOQS'#Dk'#DkOOQP'#Is'#IsO!LiQ[O'#IsO!LqQXO'#DjO!MoQWO'#DnO!MoQWO'#DnO!NQQWO'#DnOOQP'#Iu'#IuO!NVQXO'#IuO# QQ^O'#DoO# [QWO'#DrO# dQ^O'#DzO# nQ^O'#D|O# uQWO'#EPO#!QQXO'#FdOOQP'#ES'#ESOOQP'#Ir'#IrO#!`QXO'#JfOOQP'#Je'#JeO#!hQXO,5;}O#!mQXO'#IaO!1PQ^O'#DyO!1PQ^O'#FdO##gQWO,5;|OOQO,5;|,5;|OKlQYO,5;|O##}QWO'#FhOOQO,5<R,5<ROOQV,5=l,5=lO#&SQYO'#FzOOQV,5<h,5<hO#&ZQWO,5<hO#&bQWO,5=SO!1WQWO,59rO!1dQWO,5<dO#&iQWO,5=iO!2_QWO,5<jO!2_QWO,5<zO!2_QWO,5<|O!2_QWO,5=QO#&pQWO,5=]O#&wQWO,5=SO!2_QWO,5=]O!3|QWO,5=aO#'PQWO,5=jOOQO-E;|-E;|O#'[QWO'#JjOOQV-E;h-E;hO#'sQWO'#HRO#'zQ_O,59pOOQV,59p,59pO#(RQWO,59pO#(WQ_O,59pO#(vQZO'#CuO#+OQZO'#CvOOQV'#C|'#C|O#-kQWO'#HTO#-rQYO'#IeOOQO'#Hh'#HhO#-zQWO'#CwO#-zQWO'#CwO#.]QWO'#CwOOQR'#Id'#IdO#.bQZO'#IcO#0wQYO'#HTO#1eQYO'#H[O#2qQYO'#H_OKlQYO'#H`OOQR'#Hb'#HbO#3}QWO'#HeO#4SQYO,59]OOQR'#Ic'#IcO#4sQZO'#CtO#7OQYO'#HUO#7TQWO'#HTO#7YQYO'#CrO#7yQWO'#H]O#7YQYO'#HcOOQV-E;e-E;eO#8RQWO,59sOOQV,59{,59{O#8aQYO,5=[OOQV,59},59}O!0zQWO,59}O#;TQWO'#IqOOQO'#Iq'#IqO!1PQ^O'#DhO!0zQWO,5:QO#;[QWO,5;iO#;rQWO,5;rO#<YQ_O,5;rOOQO,5;u,5;uO#?sQ_O,5;|O#A{QWO,5;PO!0zQWO,5<XO#BSQWO,5<ZOOQV,5<Z,5<ZO#B_QWO,5<]O!1PQ^O'#EOOOQQ'#D_'#D_O#BgQWO,59rO#BlQWO,5<`O#BqQWO,5<dOOQO,5@U,5@UO#ByQWO,5=iOOQQ'#Cv'#CvO#COQYO,5<jO#CaQYO,5<zO#ClQYO,5<|O#CwQYO,5=_O#DVQYO,5=SO#EoQYO'#GQO#E|QYO,5=[O#FaQWO,5=[O#FoQYO,5=[O#GxQYO,5=]O#HWQWO,5=`O!1PQ^O,5=`O#HfQWO'#CnO#HwQWO'#IaOOQO'#Jy'#JyO#IYQWO'#IQO#I_QWO'#GwOOQO'#Jz'#JzO#IvQWO'#GzOOQO'#G|'#G|OOQO'#Jx'#JxO#I_QWO'#GwO#I}QWO'#GxO#JSQWO,5=aO#JXQWO,5=jO!1dQWO,5=jO#'SQWO,5=jPOOO'#Hf'#HfP#J^OpO,58}POOO,58},58}OOOO-E;g-E;gOOQV1G/T1G/TO#JiQWO1G4|O#JnQ^O'#CyPOQQ'#Cx'#CxOOQO1G/v1G/vOOQP1G.u1G.uO)xQWO1G/vO#MwQ!fO'#EUO#NOQ!fO'#EVO#NVQ!fO'#ETO$ _QWO1G5WO$!RQ_O1G5WOOQO1G1]1G1]O$%uQWO1G0oO$%zQWO'#CiO!7rQXO'#IaO!6PQYO1G.lO!5oQWO,5<_O!8vQWO,59ZO!8vQWO,59ZO!5oQWO,5?lO$&]QWO1G0uO$(jQWO1G0wO$*bQWO1G0wO$*xQWO1G0wO$,|QWO1G0wO$-TQWO1G0wO$/UQWO1G0wO$/]QWO1G0wO$1^QWO1G0wO$1eQWO1G0wO$2|QWO1G1QO$4}QWO1G1VO$5nQ_O'#JcO$7vQWO'#JcOOQO'#Jb'#JbO$8QQWO,5;mOOQO'#Dw'#DwOOQO1G1[1G1[OOQO1G1Y1G1YO$8VQWO1G1cOOQO1G1R1G1RO$8^Q_O'#HrO$:lQWO,5@OO.YQ_O1G1dOOQO1G1d1G1dO$:tQWO1G1dO$;RQWO1G1dO$;WQWO1G1eOOQO1G1l1G1lO$;`QWO1G1lOOQP,5?_,5?_O$;jQ^O,5:kO$<TQXO,5:YO!MoQWO,5:YO!MoQWO,5:YO!1PQ^O,5:gO$=UQWO'#IzOOQO'#Iy'#IyO$=dQWO,5:ZO# QQ^O,5:ZO$=iQWO'#DsOOQP,5:^,5:^O$=zQWO,5:fOOQP,5:h,5:hO!1PQ^O,5:hO!1PQ^O,5:mO$>PQYO,5<OO$>ZQ_O'#HsO$>hQXO,5@QOOQV1G1i1G1iOOQP,5:e,5:eO$>pQXO,5<OO$?OQWO1G1hO$?WQWO'#CnO$?cQWO'#FiOOQO'#Fi'#FiO$?kQWO'#FjO.YQ_O'#FkOOQO'#Ji'#JiO$?pQWO'#JhOOQO'#Jg'#JgO$?xQWO,5<SOOQQ'#Hv'#HvO$?}QYO,5<fOOQV,5<f,5<fO$@UQYO,5<fOOQV1G2S1G2SO$@]QWO1G2nO$@eQWO1G/^O$@jQWO1G2OO#ByQWO1G3TO$@rQYO1G2UO#CaQYO1G2fO#ClQYO1G2hO$ATQYO1G2lO!2_QWO1G2wO#DVQYO1G2nO#GxQYO1G2wO$A]QWO1G2{O$AbQWO1G3UO!1dQWO1G3UO$AgQWO1G3UOOQV1G/[1G/[O$AoQWO1G/[O$AtQ_O1G/[O#7TQWO,5=oO$A{QYO,5?PO$BaQWO,5?PO$BfQZO'#IfOOQO-E;f-E;fOOQR,59c,59cO#-zQWO,59cO#-zQWO,59cOOQR,5=n,5=nO$ERQYO'#HVO$FkQZO,5=oO!5oQWO,5={O$H}QWO,5=oO$IUQZO,5=vO$KeQYO,5=vO$>PQYO,5=vO$KuQWO'#KRO$LQQWO,5=xOOQR,5=y,5=yO$LVQWO,5=zO$>PQYO,5>PO$>PQYO,5>POOQO1G.w1G.wO$>PQYO1G.wO$LbQYO,5=pO$LjQZO,59^OOQR,59^,59^O$>PQYO,5=wO$N|QZO,5=}OOQR,5=},5=}O%#`QWO1G/_O!6PQYO1G/_O#E|QYO1G2vO%#eQWO1G2vO%#sQYO1G2vOOQV1G/i1G/iO%$|QWO,5:SO%%UQ_O1G/lO%*_QWO1G1^O%*uQWO1G1hOOQO1G1h1G1hO$>PQYO1G1hO%+]Q^O'#EgOOQV1G0k1G0kOOQV1G1s1G1sO!!vQ_O1G1sO!0zQWO1G1uO!1PQ^O1G1wO!.cQ_O1G1wOOQP,5:j,5:jO$>PQYO1G/^OOQO'#Cn'#CnO%+jQWO1G1zOOQV1G2O1G2OO%+rQWO'#CnO%+zQWO1G3TO%,PQWO1G3TO%,UQYO'#GQO%,gQWO'#G]O%,xQYO'#G_O%.[QYO'#GXOOQV1G2U1G2UO%/kQWO1G2UO%/pQWO1G2UO$@uQWO1G2UOOQV1G2f1G2fO%/kQWO1G2fO#CdQWO1G2fO%/xQWO'#GdOOQV1G2h1G2hO%0ZQWO1G2hO#CoQWO1G2hO%0`QYO'#GSO$>PQYO1G2lO$AWQWO1G2lOOQV1G2y1G2yO%1lQWO1G2yO%3[Q^O'#GkO%3fQWO1G2nO#DYQWO1G2nO%3tQYO,5<lO%4OQYO,5<lO%4^QYO,5<lO%4{QYO,5<lOOQQ,5<l,5<lO!1WQWO'#JuO%5WQYO,5<lO%5`QWO1G2vOOQV1G2v1G2vO%5hQWO1G2vO$>PQYO1G2vOOQV1G2w1G2wO%5hQWO1G2wO%5mQWO1G2wO#G{QWO1G2wOOQV1G2z1G2zO.YQ_O1G2zO$>PQYO1G2zO%5uQWO1G2zOOQO,5>l,5>lOOQO-E<O-E<OOOQO,5=c,5=cOOQO,5=e,5=eOOQO,5=g,5=gOOQO,5=h,5=hO%6TQWO'#J|OOQO'#J{'#J{O%6]QWO,5=fO%6bQWO,5=cO!1dQWO,5=dOOQV1G2{1G2{O$>PQYO1G3UPOOO-E;d-E;dPOOO1G.i1G.iOOQO7+*h7+*hO%6yQYO'#IdO%7bQYO'#IgO%7mQYO'#IgO%7uQYO'#IgO%8QQYO,59eOOQO7+%b7+%bOOQP7+$a7+$aOOQV,5:p,5:pO%8VQ!fO,5:pO%8^Q!fO'#JTOOQS'#EZ'#EZOOQS'#E['#E[OOQS'#E]'#E]OOQS'#JT'#JTO%;PQWO'#EYOOQS'#Eb'#EbOOQS'#JR'#JROOQS'#Hn'#HnOOQV,5:q,5:qO%;UQ!fO,5:qO%;]Q!fO,5:oOOQV,5:o,5:oOOQV7+'e7+'eOOQV7+&Z7+&ZO%;dQ[O,59TO%;xQ^O,59TO%<cQWO7+$WO%<hQWO1G1yOOQV1G1y1G1yO!8vQWO1G.uOOQP1G5W1G5WO%<mQWO,5?}O%<wQ_O'#HqO%?SQWO,5?}OOQO1G1X1G1XOOQO7+&}7+&}O%?[QWO,5>^OOQO-E;p-E;pO%?iQWO7+'OO%?pQ_O7+'OOOQO7+'O7+'OOOQO7+'P7+'PO%ArQWO7+'POOQO7+'W7+'WOOQP1G0V1G0VO%AzQXO1G/tO!MoQWO1G/tO%B{QXO1G0RO%CsQ^O'#HlO%DTQWO,5?fOOQP1G/u1G/uO%D`QWO1G/uO%DeQWO'#D_OOQO'#Dt'#DtO%DpQWO'#DtO%DuQWO'#I|OOQO'#I{'#I{O%D}QWO,5:_O%ESQWO'#DtO%EXQWO'#DtOOQP1G0Q1G0QOOQP1G0S1G0SOOQP1G0X1G0XO%EaQXO1G1jO%ElQXO'#FeOOQP,5>_,5>_O!1PQ^O'#FeOOQP-E;q-E;qO$>PQYO1G1jOOQO7+'S7+'SOOQO,5<T,5<TO%EzQWO,5<UO%?pQ_O,5<UO%FPQWO,5<VO%FZQWO'#HtO%FlQWO,5@SOOQO1G1n1G1nOOQQ-E;t-E;tOOQV1G2Q1G2QO%FtQYO1G2QO#DVQYO7+(YO$>PQYO7+$xOOQV7+'j7+'jO%F{QWO7+(oO%GQQWO7+(oOOQV7+'p7+'pO%/kQWO7+'pO%GVQWO7+'pO%G_QWO7+'pOOQV7+(Q7+(QO%/kQWO7+(QO#CdQWO7+(QOOQV7+(S7+(SO%0ZQWO7+(SO#CoQWO7+(SO$>PQYO7+(WO%GmQWO7+(WO#GxQYO7+(cO%GrQWO7+(YO#DYQWO7+(YOOQV7+(c7+(cO%5hQWO7+(cO%5mQWO7+(cO#G{QWO7+(cOOQV7+(g7+(gO$>PQYO7+(pO%HQQWO7+(pO!1dQWO7+(pOOQV7+$v7+$vO%HVQWO7+$vO%H[QZO1G3ZO%JnQWO1G4kOOQO1G4k1G4kOOQR1G.}1G.}O#-zQWO1G.}O%JsQWO'#KQOOQO'#HW'#HWO%KUQWO'#HXO%KaQWO'#KQOOQO'#KP'#KPO%KiQWO,5=qO%KnQYO'#H[O%LzQWO'#GmO%MVQYO'#CtO%MaQWO'#GmO$>PQYO1G3ZOOQR1G3g1G3gO#7TQWO1G3ZO%MfQZO1G3bO$>PQYO1G3bO& uQYO'#IVO&!VQWO,5@mOOQR1G3d1G3dOOQR1G3f1G3fO%?pQ_O1G3fOOQR1G3k1G3kO&!_QYO7+$cO&!gQYO'#KOOOQQ'#J}'#J}O&!oQYO1G3[O&!tQZO1G3cOOQQ7+$y7+$yO&%TQWO7+$yO&%YQWO7+(bOOQV7+(b7+(bO%5hQWO7+(bO$>PQYO7+(bO#E|QYO7+(bO&%bQWO7+(bO!.cQ_O1G/nO&%pQWO7+%WO$?OQWO7+'SO&%xQWO'#EhO&&TQ^O'#EhOOQU'#Ho'#HoO&&TQ^O,5;ROOQV,5;R,5;RO&&_QWO,5;RO&&dQ^O,5;RO!0zQWO7+'_OOQV7+'a7+'aO&&qQWO7+'cO&&yQWO7+'cO&'QQWO7+$xO&)uQ!fO7+'fO&)|Q!fO7+'fOOQV7+(o7+(oO!1dQWO7+(oO&*TQYO,5<lO&*`QYO,5<lO!1dQWO'#GWO&*nQWO'#JpO&*|QWO'#G^O!BlQWO'#G^O&+RQWO'#JpOOQO'#Jo'#JoO&+ZQWO,5<wOOQO'#DX'#DXO&+`QYO'#JrO&,oQWO'#JrO$>PQYO'#JrOOQO'#Jq'#JqO&,zQWO,5<yO&-PQWO'#GZO#DQQWO'#G[O&-XQWO'#G[O&-aQWO'#JmOOQO'#Jl'#JlO&-lQYO'#GTOOQO,5<s,5<sO&-qQWO7+'pO&-vQWO'#JtO&.UQWO'#GeO#BlQWO'#GeO&.gQWO'#JtOOQO'#Js'#JsO&.oQWO,5=OO$>PQYO'#GUO&.tQYO'#JkOOQQ,5<n,5<nO&/]QWO7+(WOOQV7+(e7+(eO&/eQ^O'#D|O&0kQWO'#GlO&0sQ^O'#JwOOQO'#Gn'#GnO&0zQWO'#JwOOQO'#Jv'#JvO&1SQWO,5=VO&1XQWO'#IaO&1iQ^O'#GmO&2lQWO'#IrO&2zQWO'#GmOOQV7+(Y7+(YO&3SQWO7+(YO$>PQYO7+(YO&3[QYO'#HxO&3pQYO1G2WOOQQ1G2W1G2WOOQQ,5<m,5<mO$>PQYO,5<qO&3xQWO,5<rO&3}QWO7+(bO&4YQWO7+(fO&4aQWO7+(fOOQV7+(f7+(fO%?pQ_O7+(fO$>PQYO7+(fO&4lQWO'#IRO&4vQWO,5@hOOQO1G3Q1G3QOOQO1G2}1G2}OOQO1G3P1G3POOQO1G3R1G3ROOQO1G3S1G3SOOQO1G3O1G3OO&5OQWO7+(pO$>PQYO,59fO&5ZQ^O'#ISO&6QQYO,5?ROOQR1G/P1G/POOQV1G0[1G0[OOQS-E;l-E;lO&6YQ!bO,5:rO&6_Q!fO,5:tOOQV1G0]1G0]OOQV1G0Z1G0ZOOQO1G.o1G.oO&6fQWO'#KTOOQO'#KS'#KSO&6nQWO1G.oOOQV<<Gr<<GrO&6sQWO1G5iO&6{Q_O,5>]O&9QQWO,5>]OOQO-E;o-E;oOOQO<<Jj<<JjO&9[QWO<<JjOOQO<<Jk<<JkO&9cQXO7+%`O&:dQWO,5>WOOQO-E;j-E;jOOQP7+%a7+%aO!1PQ^O,5:`O&:rQWO'#HmO&;WQWO,5?hOOQP1G/y1G/yOOQO,5:`,5:`O&;`QWO,5:`O%ESQWO,5:`O$>PQYO,5<PO&;eQXO,5<PO&;sQXO7+'UO%?pQ_O1G1pO&<OQWO1G1pOOQO,5>`,5>`OOQO-E;r-E;rOOQV7+'l7+'lO&<YQWO<<KtO#DYQWO<<KtO&<hQWO<<HdOOQV<<LZ<<LZO!1dQWO<<LZOOQV<<K[<<K[O&<sQWO<<K[O%/kQWO<<K[O&<xQWO<<K[OOQV<<Kl<<KlO%/kQWO<<KlOOQV<<Kn<<KnO%0ZQWO<<KnO&=QQWO<<KrO$>PQYO<<KrOOQV<<K}<<K}O%5hQWO<<K}O%5mQWO<<K}O#G{QWO<<K}OOQV<<Kt<<KtO&=YQWO<<KtO$>PQYO<<KtO&=bQWO<<L[O$>PQYO<<L[O&=mQWO<<L[OOQV<<Hb<<HbO$>PQYO7+(uOOQO7+*V7+*VOOQR7+$i7+$iO&=rQWO,5@lOOQO'#Gm'#GmO&=zQWO'#GmO&>VQYO'#IUO&=rQWO,5@lOOQR1G3]1G3]O&?rQYO,5=vO&ARQYO,5=XO&A]QWO,5=XOOQO,5=X,5=XOOQR7+(u7+(uO&AbQZO7+(uO&CtQZO7+(|O&FTQWO,5>qOOQO-E<T-E<TO&F`QWO7+)QOOQO<<G}<<G}O&FgQYO'#ITO&FrQYO,5@jOOQQ7+(v7+(vOOQQ<<He<<HeO$>PQYO<<K|OOQV<<K|<<K|O&3}QWO<<K|O&FzQWO<<K|O%5hQWO<<K|O&GSQWO7+%YOOQV<<Hr<<HrOOQO<<Jn<<JnO%?pQ_O,5;SO&GZQWO,5;SO%?pQ_O'#EjO&G`QWO,5;SOOQU-E;m-E;mO&GkQWO1G0mOOQV1G0m1G0mO&&TQ^O1G0mOOQV<<Jy<<JyO!.cQ_O<<J}OOQV<<J}<<J}OOQV<<Hd<<HdO%?pQ_O<<HdO&GpQWO'#JTO&GxQWO'#FvO&G}QWO<<KQO&HVQ!fO<<KQO&H^QWO<<KQO&HcQWO<<KQO&HkQ!fO<<KQOOQV<<KQ<<KQO&HrQWO<<LZO&HwQWO,5@[O$>PQYO,5<xO&IPQWO,5<xO&IUQWO'#H{O&HwQWO,5@[OOQV1G2c1G2cO&IjQWO,5@^O$>PQYO,5@^O&IuQYO'#H|O&K[QWO,5@^OOQO1G2e1G2eO%,bQWO,5<uOOQO,5<v,5<vO&KdQYO'#HzO&LvQWO,5@XO%,UQYO,5=pO$>PQYO,5<oO&MRQWO,5@`O%?pQ_O,5=PO&MZQWO,5=PO&MfQWO,5=PO&MwQWO'#H}O&MRQWO,5@`OOQV1G2j1G2jO&N]QYO,5<pO%0`QYO,5>PO&NtQYO,5@VOOQV<<Kr<<KrO' ]QWO,5=XO' mQ^O,5:hO'!pQWO,5=XO$>PQYO,5=WO'!xQWO,5@cO'#QQWO,5@cO'#`Q^O'#IPO'!xQWO,5@cOOQO1G2q1G2qO'$rQWO,5=WO'$zQWO<<KtO'%YQYO,5>oO'%eQYO,5>dO'%sQYO,5>dOOQQ,5>d,5>dOOQQ-E;v-E;vOOQQ7+'r7+'rO'&OQYO1G2]O$>PQYO1G2^OOQV<<LQ<<LQO%?pQ_O<<LQO'&ZQWO<<LQO'&bQWO<<LQOOQO,5>m,5>mOOQO-E<P-E<POOQV<<L[<<L[O%?pQ_O<<L[O'&mQYO1G/QO'&xQYO,5>nOOQQ,5>n,5>nO''TQYO,5>nOOQQ-E<Q-E<QOOQS1G0^1G0^O')cQ!fO1G0`O')pQ!fO1G0`O')wQ^O'#IWO'*eQWO,5@oOOQO7+$Z7+$ZO'*mQWO1G3wOOQOAN@UAN@UO'*wQWO1G/zOOQO,5>X,5>XOOQO-E;k-E;kO!1PQ^O1G/zOOQO1G/z1G/zO'+SQWO1G/zO'+XQXO1G1kO$>PQYO1G1kO'+dQWO7+'[OOQVANA`ANA`O'+nQWOANA`O$>PQYOANA`O'+vQWOANA`OOQVAN>OAN>OO%?pQ_OAN>OO',UQWOANAuOOQVAN@vAN@vO',ZQWOAN@vOOQVANAWANAWOOQVANAYANAYOOQVANA^ANA^O',`QWOANA^OOQVANAiANAiO%5hQWOANAiO%5mQWOANAiO',hQWOANA`OOQVANAvANAvO%?pQ_OANAvO',vQWOANAvO$>PQYOANAvOOQR<<La<<LaO'-RQWO1G6WO%JsQWO,5>pOOQO'#HY'#HYO'-ZQWO'#HZOOQO,5>p,5>pOOQO-E<S-E<SO'-fQYO1G2sO'-pQWO1G2sOOQO1G2s1G2sO$>PQYO<<LaOOQR<<Ll<<LlOOQQ,5>o,5>oOOQQ-E<R-E<RO&3}QWOANAhOOQVANAhANAhO%5hQWOANAhO$>PQYOANAhO'-uQWO1G1rO'.iQ^O1G0nO%?pQ_O1G0nO'0_QWO,5;UO'0fQWO1G0nP'0kQWO'#ERP&&TQ^O'#HpOOQV7+&X7+&XO'0vQWO7+&XO&&yQWOAN@iO'0{QWOAN>OO!5oQWO,5<bOOQS,5>a,5>aO'1SQWOAN@lO'1XQWOAN@lOOQS-E;s-E;sOOQVAN@lAN@lO'1aQWOAN@lOOQVANAuANAuO'1iQWO1G5vO'1qQWO1G2dO$>PQYO1G2dO&*nQWO,5>gOOQO,5>g,5>gOOQO-E;y-E;yO'1|QWO1G5xO'2UQWO1G5xO&+`QYO,5>hO'2aQWO,5>hO$>PQYO,5>hOOQO-E;z-E;zO'2lQWO'#JnOOQO1G2a1G2aOOQO,5>f,5>fOOQO-E;x-E;xO&*TQYO,5<lO'2zQYO1G2ZO'3fQWO1G5zO'3nQWO1G2kO%?pQ_O1G2kO'3xQWO1G2kO&-vQWO,5>iOOQO,5>i,5>iOOQO-E;{-E;{OOQQ,5>c,5>cOOQQ-E;u-E;uO'4TQWO1G2sO'4eQWO1G2rO'4pQWO1G5}O'4xQ^O,5>kOOQO'#Go'#GoOOQO,5>k,5>kO'6UQWO,5>kOOQO-E;}-E;}O$>PQYO1G2rO'6dQYO7+'xO'6oQWOANAlOOQVANAlANAlO%?pQ_OANAlO'6vQWOANAvOOQS7+%z7+%zO'6}QWO7+%zO'7YQ!fO7+%zOOQO,5>r,5>rOOQO-E<U-E<UO'7gQWO7+%fO!1PQ^O7+%fO'7rQXO7+'VOOQVG26zG26zO'7}QWOG26zO'8]QWOG26zO$>PQYOG26zO'8eQWOG23jOOQVG27aG27aOOQVG26bG26bOOQVG26xG26xOOQVG27TG27TO%5hQWOG27TO'8lQWOG27bOOQVG27bG27bO%?pQ_OG27bO'8sQWOG27bOOQO1G4[1G4[OOQO7+(_7+(_OOQRANA{ANA{OOQVG27SG27SO%5hQWOG27SO&3}QWOG27SO'9OQ^O7+&YO':iQWO7+'^O';]Q^O7+&YO%?pQ_O7+&YP%?pQ_O,5;SP'<iQWO,5;SP'<nQWO,5;SOOQV<<Is<<IsOOQVG26TG26TOOQVG23jG23jOOQO1G1|1G1|OOQVG26WG26WO'<yQWOG26WP&HfQWO'#HuO'=OQWO7+(OOOQO1G4R1G4RO'=ZQWO7++dO'=cQWO1G4SO$>PQYO1G4SO%,bQWO'#HyO'=nQWO,5@YO'=|QWO7+(VO%?pQ_O7+(VOOQO1G4T1G4TOOQO1G4V1G4VO'>WQWO1G4VO'>fQWO7+(^OOQVG27WG27WO'>qQWOG27WOOQS<<If<<IfO'>xQWO<<IfO'?TQWO<<IQOOQVLD,fLD,fO'?`QWOLD,fO'?hQWOLD,fOOQVLD)ULD)UOOQVLD,oLD,oOOQVLD,|LD,|O'?vQWOLD,|O%?pQ_OLD,|OOQVLD,nLD,nO%5hQWOLD,nO'?}Q^O<<ItO'AhQWO<<JxO'B[Q^O<<ItP'ChQWO1G0nP'DXQ^O1G0nP%?pQ_O1G0nP'EzQWO1G0nOOQVLD+rLD+rO'FPQWO7+)nOOQO,5>e,5>eOOQO-E;w-E;wO'F[QWO<<KqOOQVLD,rLD,rOOQSAN?QAN?QOOQV!$(!Q!$(!QO'FfQWO!$(!QOOQV!$(!h!$(!hO'FnQWO!$(!hOOQV!$(!Y!$(!YO'FuQ^OAN?`POQU7+&Y7+&YP'H`QWO7+&YP'IPQ^O7+&YP%?pQ_O7+&YOOQV!)9El!)9ElOOQV!)9FS!)9FSPOQU<<It<<ItP'JrQWO<<ItP'KcQ^O<<ItPOQUAN?`AN?`O'MUQWO'#CnO'M]QXO'#CnO'NUQWO'#IaO( kQXO'#IaO(!bQWO'#DpO(!bQWO'#DpO!.cQ_O'#EkO(!sQ_O'#EoO(!zQ_O'#FPO(%{Q_O'#FbO(&SQXO'#IaO(&yQ_O'#E}O('|Q_O'#FWO(!bQWO,5:[O(!bQWO,5:[O!.cQ_O,5;ZO!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;fO()PQ_O,5;kO(,QQWO,5;kO(,bQWO,5;|O(,iQYO'#CuO(,tQYO'#CvO(-PQWO'#CwO(-PQWO'#CwO(-bQYO'#CtO(-mQWO,5;iO(-tQWO,5;rO(-{Q_O,5;rO(/RQ_O,5;|O(!bQWO1G/vO(/YQWO1G0uO(0wQWO1G0wO(1RQWO1G0wO(2vQWO1G0wO(2}QWO1G0wO(4oQWO1G0wO(4vQWO1G0wO(6hQWO1G0wO(6oQWO1G0wO(6vQWO1G1QO(7WQWO1G1VO(7hQYO'#IfO(-PQWO,59cO(-PQWO,59cO(7sQWO1G1^O(7zQWO1G1hO(-PQWO1G.}O(8RQWO'#DpO!.^QXO'#FbO(8WQWO,5;ZO(8_QWO'#Cw",
    stateData: "(8q~O&}OSUOS'OPQ~OPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R`O'UQO'[kO'_UO'hcO'riO(QdO~O'O!sO~OZbX[bXdbXdlXobXwjX}bX!lbX!qbX!tbX#QbX#RbX#pbX'hbX'rbX'sbX'xbX'ybX'zbX'{bX'|bX'}bX(ObX(PbX(QbX(RbX(TbX~OybXXbX!ebX!PbXvbX#TbX~P$|OZ'TX['TXd'TXd'YXo'TXw'lXy'TX}'TX!l'TX!q'TX!t'TX#Q'TX#R'TX#p'TX'h'TX'r'TX's'TX'x'TX'y'TX'z'TX'{'TX'|'TX'}'TX(O'TX(P'TX(Q'TX(R'TX(T'TXv'TX~OX'TX!e'TX!P'TX#T'TX~P'ZOr!uO'^!wO'`!uO~Od!xO~O^RO_RO`ROaRO'UQO~Od!}O~Od#PO[(SXo(SXy(SX}(SX!l(SX!q(SX!t(SX#Q(SX#R(SX#p(SX'h(SX'r(SX's(SX'x(SX'y(SX'z(SX'{(SX'|(SX'}(SX(O(SX(P(SX(Q(SX(R(SX(T(SXv(SX~OZ#OO~P*`OZ#RO[#QO~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R#VO'U#SO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!j#eO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xO[#}Oo#xO}#zO!l#yO!q#jO!t#yO#Q#xO#R#uO#p$OO'h#gO'r#yO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~OPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO[#sXo#sXy#sX}#sX!l#sX!q#sX!t#sX#Q#sX#R#sX#p#sX'h#sX'r#sX's#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sXX#sX!e#sX!P#sXv#sX#T#sX~P)xOX(SX!e(SX!P(SXw(SX#T(SX~P*`OPoOQ!QOSVOTVOX$ROZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!P$XO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOQ!QOSVOTVO[$gO^$pO_$ZO`:QOa:QOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'U$YO'_UO'h$[O~O!j$rOP(XP~P<cOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#S$uO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xOw$vO~Oo'cX#Q'cX#R'cX#p'cX's'cX'x'cX'y'cX'z'cX'{'cX'|'cX'}'cX(O'cX(P'cX(R'cX(T'cX~OP%tXQ%tXS%tXT%tXZ%tX[%tX^%tX_%tX`%tXa%tXd%tXg%tXs%tXt%tXu%tXw%tXy%tX|%tX}%tX!Q%tX!U%tX!W%tX!X%tX!Z%tX!]%tX!l%tX!q%tX!t%tX#Y%tX#r%tX#{%tX$O%tX$b%tX$d%tX$f%tX$i%tX$m%tX$q%tX$s%tX%T%tX%V%tX%Z%tX%]%tX%^%tX%f%tX%j%tX%s%tX&{%tX'R%tX'U%tX'[%tX'_%tX'h%tX'r%tX(Q%tXv%tX~P@[Oy$xO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cXv'cX~P@[Ow$yO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Oy$zO~PEsO!Q$}O!U%UO!W!lO$m%OO$q%PO$s%QO%T%RO%V%SO%Z%TO%]!lO%^%VO%f%WO%j%XO%s%YO~O!Q!lO!U!lO!W!lO$q%[O%]!lO~O%^%VO~PGaOPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R#VO'UQO'[kO'_UO'hcO'riO(QdO~Ov%`O~P]OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~P'ZO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~O}%}O'U{XQ{XZ{X[{X^{X_{X`{Xa{Xd{Xg{X!q{X$f{X&W{X'[{X(Q{X~PMuOg&PO%f%WO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Ow!PO~P! yOw!PO!X&RO~PEvOPoOQ!QOSVOTVOZeO[lO^9xO_9xO`9xOa9xOd9{OsVOtVOuVOw!PO}mO!U#bO!W#cO!X;RO!Z!YO!]&UO!l:OO!q9}O!t:OO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO'_UO'hcO'r:OO(QdO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOo#qXy#qX#Q#qX#R#qX#p#qX's#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qXX#qX!e#qX!P#qXv#qX#T#qX~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOo#zXy#zX#Q#zX#R#zX#p#zX's#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zXX#zX!e#zX!P#zXv#zX#T#zX~P)xO'[kO[#}Xo#}Xy#}X}#}X!l#}X!q#}X!t#}X#Q#}X#R#}X#p#}X'h#}X'r#}X's#}X'x#}X'y#}X'z#}X'{#}X'|#}X'}#}X(O#}X(P#}X(Q#}X(R#}X(T#}XX#}X!e#}X!P#}Xv#}Xw#}X#T#}X~OPoO~OPoOQ!QOSVOTVOZeO[lO^9xO_9xO`9xOa9xOd9{OsVOtVOuVOw!PO}mO!U#bO!W#cO!X;RO!Z!YO!l:OO!q9}O!t:OO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO'_UO'hcO'r:OO(QdO~O!S&_O~Ow!PO~O!j&bO~P<cO'U&cO~PEvOZ&eO~O'U&cO~O'_UOw(^Xy(^X!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Oa&hO~P!1iO'U&iO~O_&nO'U&cO~OQ&oOZ&pO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO!j&uO~P<cO^&wO_&wO`&wOa&wOd'POw&|O'U&vO(Q&}O~O!i'UO!j'TO'U&cO~O'O!sO'P'VO'Q'XO~Or!uO'^'ZO'`!uO~OQ']O^'ja_'ja`'jaa'ja'U'ja~O['bOw'cO}'dO~OQ']O~OQ!QO^#TO_#TO`#TOa'jOd#ZO'U#SO~O['kO~OZbXdlXXbXobXPbX!SbX!ebX'sbX!PbX!ObXybX!ZbX#TbXvbX~O}bX~P!6mOZ'TXd'YXX'TXo'TX}'TX#p'TXP'TX!S'TX!e'TX's'TX!P'TX!O'TXy'TX!Z'TX#T'TXv'TX~O^#TO_#TO`#TOa'jO'U#SO~OZ'lO~Od'nO~OZ'TXd'YX~PMuOZ'oOX(SX!e(SX!P(SXw(SX#T(SX~P*`O[#}O}#zO(O#|O(R#fOo#_ay#_a!l#_a!q#_a!t#_a#Q#_a#R#_a#p#_a'h#_a'r#_a's#_a'x#_a'y#_a'z#_a'{#_a'|#_a'}#_a(P#_a(Q#_a(T#_aX#_a!e#_a!P#_av#_aw#_a#T#_a~Ow!PO!X&RO~Oy#caX#ca!e#ca!P#cav#ca#T#ca~P2gOPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO[#sao#say#sa}#sa!l#sa!q#sa!t#sa#Q#sa#R#sa#p#sa'h#sa'r#sa's#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#saX#sa!e#sa!P#sav#sa#T#sa~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'[kO'_UO'hcO'riO(QdO!P(UP~P)xOu(RO#w(SO'U(QO~O[#}O}#zO!q#jO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#sa!t#sa#p#sa'r#sa~Oo#xO#Q#xO#R#uOy#saX#sa!e#sa!P#sav#sa#T#sa~P!BqOy(XO!e(VOX(WX~P2gOX(YO~OPoOQ!QOSVOTVOX(YOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOZ#RO~O!P(^O!e(VO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOZbXdlXwjX}jX!tbX'rbX~OP!RX!S!RX!e!RX'q!RX's!RX!O!RXo!RXy!RX!P!RXX!RX!Z!RX#T!RXv!RX~P!IxOZ'TXd'YXw'lX}'lX!t'TX'r'TX~OP!`X!S!`X!e!`X's!`X!O!`Xo!`Xy!`X!P!`XX!`X!Z!`X#T!`Xv!`X~P!KZOT(`Ou(`O~O!t(aO'r(aOP!^X!S!^X!e!^X's!^X!O!^Xo!^Xy!^X!P!^XX!^X!Z!^X#T!^Xv!^X~O^9yO_9yO`:QOa:QO'U9wO~Od(dO~O'q(eOP'iX!S'iX!e'iX's'iX!O'iXo'iXy'iX!P'iXX'iX!Z'iX#T'iXv'iX~O!j&bO!P'mP~P<cOw(jO}(iO~O!j&bOX'mP~P<cO!j(nO~P<cOZ'oO!t(aO'r(aO~O!S(pO's(oOP$WX!e$WX~O!e(qOP(YX~OP(sO~OP!aX!S!aX!e!aX's!aX!O!aXo!aXy!aX!P!aXX!aX!Z!aX#T!aXv!aX~P!KZOy$UaX$Ua!e$Ua!P$Uav$Ua#T$Ua~P2gO!l({O'R#VO'U(wOv(ZP~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R`O'U#SO~Ov)SO~P#$]Oy)UO~PEsO%^)VO~PGaOa)YO~P!1iO%f)_O~PEvO_)`O'U&cO~O!i)eO!j)dO'U&cO~O'_UO!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Ov%uX~P2gOv)fO~PGyOv)fO~Ov)fO~P]OQiXQ'YXZiXd'YX}iX#piX(PiX~ORiXwiX$fiX$|iX[iXoiXyiX!liX!qiX!tiX#QiX#RiX'hiX'riX'siX'xiX'yiX'ziX'{iX'|iX'}iX(OiX(QiX(RiX(TiX!PiX!eiXXiXPiXviX!SiX#TiX~P#(_OQjXQlXRjXZjXdlX}jX#pjX(PjXwjX$fjX$|jX[jXojXyjX!ljX!qjX!tjX#QjX#RjX'hjX'rjX'sjX'xjX'yjX'zjX'{jX'|jX'}jX(OjX(QjX(RjX(TjX!PjX!ejXXjX!SjXPjXvjX#TjX~O%^)iO~PGaOQ']Od)jO~O^)lO_)lO`)lOa)lO'U%dO~Od)pO~OQ']OZ)tO})rOR'VX#p'VX(P'VXw'VX$f'VX$|'VX['VXo'VXy'VX!l'VX!q'VX!t'VX#Q'VX#R'VX'h'VX'r'VX's'VX'x'VX'y'VX'z'VX'{'VX'|'VX'}'VX(O'VX(Q'VX(R'VX(T'VX!P'VX!e'VXX'VXP'VXv'VX!S'VX#T'VX~OQ!QO^:iO_:eO`TOaTOd:hO%^)iO'U:fO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!j)xO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!P){O!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO(P)}O~OR*PO#p*QO(P*OO~OQhXQ'YXZhXd'YX}hX(PhX~ORhX#phXwhX$fhX$|hX[hXohXyhX!lhX!qhX!thX#QhX#RhX'hhX'rhX'shX'xhX'yhX'zhX'{hX'|hX'}hX(OhX(QhX(RhX(ThX!PhX!ehXXhXPhXvhX!ShX#ThX~P#4_OQ*RO~O})rO~OQ!QO^%vO_%cO`TOaTOd%jO$f%wO%^%xO'U%dO~PGaO!Q*UO!j*UO~O^*XO`*XOa*XO!O*YO~OQ&oOZ*ZO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO[#}Oo:aO}#zO!l:bO!q#jO!t:bO#Q:aO#R:^O#p$OO'h#gO'r:bO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~Ow'eX~P#9jOy#qaX#qa!e#qa!P#qav#qa#T#qa~P2gOy#zaX#za!e#za!P#zav#za#T#za~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!S&_O!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOo#zay#za#Q#za#R#za#p#za's#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#zaX#za!e#za!P#zav#za#T#za~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#S*dO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xOw*eO~P#9jO$b*hO$d*iO$f*jO~O!O*kO's(oO~O!S*mO~O'U*nO~Ow$yOy*pO~O'U*qO~OQ*tOw*uOy*xO}*vO$|*wO~OQ*tOw*uO$|*wO~OQ*tOw+PO$|*wO~OQ*tOo+UOy+WO!S+TO~OQ*tO}+YO~OQ!QOZ%rO[%qO^%vO`TOaTOd%jOg%yO}%pO!U!lO!W!lO!q%oO$f%wO$q%[O%]!lO%^%xO&W%{O'U%dO'[%eO(Q%zO~OR+aO_+]O!Q+bO~P#D_O_%cO!Q!lOw&UX$|&UX(P&UX~P#D_Ow$yO$f+gO$|*wO(P*OO~OQ!QOZ*ZO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaOQ*tOw$yO!S+TO$|*wO~Oo+mOy+lO!S+nO's(oO~OdlXy!RX#pbXv!RX!e!RX~Od'YXy(mX#p'TXv(mX!e(mX~Od+pO~O^#TO_#TO`#TOa'jOw&|O'U&vO(Q+uO~Ov(oP~P!3|O#p+zO~Oy+{O~O!S+|O~O'O!sO'P'VO'Q,OO~Od,PO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'_UO~P#D_OS,_OT,_OZ,_O['bO_,ZOd,_Oo,_Os,_Ou,_Ow'cOy,_O}'dO!S,_O!e,_O!l,_O!q,]O!t,_O!{,_O#Q,_O#R,_O#S,_O#T,_O'R,_O'[%eO'_UO'h,[O's,]O'v,`O'x,[O'y,]O'z,]O'{,]O'|,^O'},^O(O,_O(P,aO(Q,aO(R,bO~OX,XO~P#K_Ov,dO~P#K_O!P,gO~P#K_Oo'ti#Q'ti#R'ti#p'ti's'ti'x'ti'y'ti'z'ti'{'ti'|'ti'}'ti(O'ti(P'ti(R'ti(T'ti~Oy,hO['ti}'ti!l'ti!q'ti!t'ti'h'ti'r'ti(Q'tiv'ti~P#N^OP$giQ$giS$giT$giZ$gi[$gi^$gi_$gi`$gia$gid$gig$gis$git$giu$giw$giy$gi|$gi}$gi!Q$gi!U$gi!W$gi!X$gi!Z$gi!]$gi!l$gi!q$gi!t$gi#Y$gi#r$gi#{$gi$O$gi$b$gi$d$gi$f$gi$i$gi$m$gi$q$gi$s$gi%T$gi%V$gi%Z$gi%]$gi%^$gi%f$gi%j$gi%s$gi&{$gi'R$gi'U$gi'[$gi'_$gi'h$gi'r$gi(Q$giv$gi~P#N^OX,iO~Oo,jO},kOX]X!P]X!e]X~Oy#ciX#ci!e#ci!P#civ#ci#T#ci~P2gO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!q#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O'h#ei(P#ei~P$&sO[#}O}#zO(O#|O(R#fOo#eiy#ei!l#ei!q#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O'h#ei'x#ei(P#ei(Q#ei(T#eiw#ei~P$(tO'h#gO(P#gO~P$&sO[#}O}#zO'h#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O!q#ei~P$+SO!q#jO~P$+SO[#}O}#zO!q#jO'h#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O's#ei~P$-[O's#lO~P$-[O[#}O}#zO!q#jO#R#uO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#Q#ei#p#ei'r#ei'|#eiX#ei!e#ei!P#eiv#ei#T#ei~O'}#ei~P$/dO'}#mO~P$/dO[#}O}#zO!q#jO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#ni!t#ni#p#ni'r#ni~Oo#xO#Q#xO#R#uOy#niX#ni!e#ni!P#niv#ni#T#ni~P$1lO[#}O}#zO!q#jO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#si!t#si#p#si'r#si~Oo#xO#Q#xO#R#uOy#siX#si!e#si!P#siv#si#T#si~P$3mOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'[kO'_UO'hcO'riO(QdO~P)xO!e,rO!P(VX~P2gO!P,tO~OX,uO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOX&fX!e&fX!P&fX~P)xO!e(VOX(Wa~Oy,yO!e(VOX(WX~P2gOX,zO~O!P,{O!e(VO~O!P,}O!e(VO~P2gOSVOTVOsVOtVOuVO'_UO'h$[O~P!6POP!baZca!S!ba!e!ba!tca'rca's!ba!O!bao!bay!ba!P!baX!ba!Z!ba#T!bav!ba~O!e-SO's(oO!P'nXX'nX~O!P-UO~O!i-_O!j-^O!l-ZO'U-WOv'oP~OX-`O~O_%cO!Q!lO~P#D_O!j-fOP&gX!e&gX~P<cO!e(qOP(Ya~O!S-hO's(oOP$Wa!e$Wa~Ow!PO(P*OO~OvbX!S!kX!ebX~O'R#VO'U(wO~O!S-lO~O!e-nOv([X~Ov-pO~Ov-rO~P,cOv-rO~P#$]O_-tO'U&cO~O!S-uO~Ow$yOy-vO~OQ*tOw*uOy-yO}*vO$|*wO~OQ*tOo.TO~Oy.^O~O!S._O~O!j.aO'U&cO~Ov.bO~Ov.bO~PGyOQ']O^'Xa_'Xa`'Xaa'Xa'U'Xa~Od.fO~OQ'YXQ'lXR'lXZ'lXd'YX}'lX#p'lX(P'lXw'lX$f'lX$|'lX['lXo'lXy'lX!l'lX!q'lX!t'lX#Q'lX#R'lX'h'lX'r'lX's'lX'x'lX'y'lX'z'lX'{'lX'|'lX'}'lX(O'lX(Q'lX(R'lX(T'lX!P'lX!e'lXX'lXP'lXv'lX!S'lX#T'lX~OQ!QOZ%rO[%qO^.qO_%cO`TOaTOd%jOg%yO}%pO!j.rO!q.oO!t.jO#V.lO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P(sP~PGaO#S.sOR%wa#p%wa(P%waw%wa$f%wa$|%wa[%wao%way%wa}%wa!l%wa!q%wa!t%wa#Q%wa#R%wa'h%wa'r%wa's%wa'x%wa'y%wa'z%wa'{%wa'|%wa'}%wa(O%wa(Q%wa(R%wa(T%wa!P%wa!e%waX%waP%wav%wa!S%wa#T%wa~O%^.uO~PGaO(P*OOR&Oa#p&Oaw&Oa$f&Oa$|&Oa[&Oao&Oay&Oa}&Oa!l&Oa!q&Oa!t&Oa#Q&Oa#R&Oa'h&Oa'r&Oa's&Oa'x&Oa'y&Oa'z&Oa'{&Oa'|&Oa'}&Oa(O&Oa(Q&Oa(R&Oa(T&Oa!P&Oa!e&OaX&OaP&Oav&Oa!S&Oa#T&Oa~O_%cO!Q!lO!j.wO(P)}O~P#D_O!e.xO(P*OO!P(uX~O!P.zO~OX.{Oy.|O(P*OO~O'[%eOR(qP~OQ']O})rORfa#pfa(Pfawfa$ffa$|fa[faofayfa!lfa!qfa!tfa#Qfa#Rfa'hfa'rfa'sfa'xfa'yfa'zfa'{fa'|fa'}fa(Ofa(Qfa(Rfa(Tfa!Pfa!efaXfaPfavfa!Sfa#Tfa~OQ']O})rOR&Va#p&Va(P&Vaw&Va$f&Va$|&Va[&Vao&Vay&Va!l&Va!q&Va!t&Va#Q&Va#R&Va'h&Va'r&Va's&Va'x&Va'y&Va'z&Va'{&Va'|&Va'}&Va(O&Va(Q&Va(R&Va(T&Va!P&Va!e&VaX&VaP&Vav&Va!S&Va#T&Va~O!P/TO~Ow$yO$f/YO$|*wO(P*OO~OQ!QOZ/ZO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaOo/]O's(oO~O#W/^OP!YiQ!YiS!YiT!YiZ!Yi[!Yi^!Yi_!Yi`!Yia!Yid!Yig!Yio!Yis!Yit!Yiu!Yiw!Yiy!Yi|!Yi}!Yi!Q!Yi!U!Yi!W!Yi!X!Yi!Z!Yi!]!Yi!l!Yi!q!Yi!t!Yi#Q!Yi#R!Yi#Y!Yi#p!Yi#r!Yi#{!Yi$O!Yi$b!Yi$d!Yi$f!Yi$i!Yi$m!Yi$q!Yi$s!Yi%T!Yi%V!Yi%Z!Yi%]!Yi%^!Yi%f!Yi%j!Yi%s!Yi&{!Yi'R!Yi'U!Yi'[!Yi'_!Yi'h!Yi'r!Yi's!Yi'x!Yi'y!Yi'z!Yi'{!Yi'|!Yi'}!Yi(O!Yi(P!Yi(Q!Yi(R!Yi(T!YiX!Yi!e!Yi!P!Yiv!Yi!i!Yi!j!Yi#V!Yi#T!Yi~Oy#ziX#zi!e#zi!P#ziv#zi#T#zi~P2gOy$UiX$Ui!e$Ui!P$Uiv$Ui#T$Ui~P2gOv/dO!j&bO'R`O~P<cOw/mO}/lO~Oy!RX#pbX~Oy/nO~O#p/oO~OR+aO_+cO!Q/rO'U&iO'[%eO~Oa/yO|!VO'R#VO'U(QOv(cP~OQ!QOZ%rO[%qO^%vO_%cO`TOa/yOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P(eP~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0UO%^%xO&W%{O'U%dO'[%eO(Q%zOw(`Py(`P~PGaOw*uO~Oy-yO$|*wO~Oa/yO|!VO'R#VO'U*nOv(gP~Ow+PO~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0UO%^%xO&W%{O'U%dO'[%eO(Q%zO(R0_O~PGaOy0cO~OQ!QOSVOTVO[$gO^0kO_$ZO`:QOa:QOd$aOsVOtVOuVO}$eO!i$qO!j0lO!l$lO!q0dO!t0gO'R#VO'U$YO'[%eO'_UO'h$[O~O#V0mO!P(jP~P%1qOw!POy0oO#S0qO$|*wO~OR0tO!e0rO~P#(_OR0tO!S+TO!e0rO(P)}O~OR0tOo0vO!S+TO!e0rOQ'WXZ'WX}'WX#p'WX(P'WX~OR0tOo0vO!e0rO~OR0tO!e0rO~O$f/YO(P*OO~Ow$yO~Ow$yO$|*wO~Oo0|Oy0{O!S0}O's(oO~O!e1OOv(pX~Ov1QO~O^#TO_#TO`#TOa'jOw&|O'U&vO(Q1UO~Oo1XOQ'WXR'WXZ'WX}'WX!e'WX(P'WX~O!e1YO(P*OOR'ZX~O!e1YOR'ZX~O!e1YO(P)}OR'ZX~OR1[O~OX1]O~P#K_O!S1_OS'wXT'wXX'wXZ'wX['wX_'wXd'wXo'wXs'wXu'wXw'wXy'wX}'wX!e'wX!l'wX!q'wX!t'wX!{'wX#Q'wX#R'wX#S'wX#T'wX'R'wX'['wX'_'wX'h'wX's'wX'v'wX'x'wX'y'wX'z'wX'{'wX'|'wX'}'wX(O'wX(P'wX(Q'wX(R'wXv'wX!P'wX~O}1`O~Ov1aO~P#K_O!P1bO~P#K_OSVOTVOsVOtVOuVO'_UO~OSVOTVOsVOtVOuVO'_UO!P(vP~P!6POX1gO~Oy,hO~O!e,rO!P(Va~P2gOPoOQ!QOZeO[lO^RO_RO`ROaROd[Ow!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'UQO'[kO'hcO'riO(QdO!P&eX!e&eX~P%;dO!e,rO!P(Va~OX&fa!e&fa!P&fa~P2gOX1lO~P2gOPoOQ!QOZeO[lO^RO_RO`ROaROd[Ow!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'UQO'[kO'hcO'riO(QdO~P%;dO!P1nO!e(VO~OP!biZci!S!bi!e!bi!tci'rci's!bi!O!bio!biy!bi!P!biX!bi!Z!bi#T!biv!bi~O's(oOP!oi!S!oi!e!oi!O!oio!oiy!oi!P!oiX!oi!Z!oi#T!oiv!oi~O!j&bO!P&`X!e&`XX&`X~P<cO!e-SO!P'naX'na~O!P1rO~Ov!RX!S!kX!e!RX~O!S1sO~O!e1tOv'pX~Ov1vO~O'U-WO~O!j1yO'U-WO~O(P*OOP$Wi!e$Wi~O!S1zO's(oOP$XX!e$XX~O!S1}O~Ov$_a!e$_a~P2gO!l({O'R#VO'U(wOv&hX!e&hX~O!e-nOv([a~Ov2RO~P,cOy2VO~O#p2WO~Oy2XO$|*wO~Ow*uOy2XO}*vO$|*wO~Oo2bO~Ow!POy2gO#S2iO$|*wO~O!S2kO~Ov2mO~O#S2nOR%wi#p%wi(P%wiw%wi$f%wi$|%wi[%wio%wiy%wi}%wi!l%wi!q%wi!t%wi#Q%wi#R%wi'h%wi'r%wi's%wi'x%wi'y%wi'z%wi'{%wi'|%wi'}%wi(O%wi(Q%wi(R%wi(T%wi!P%wi!e%wiX%wiP%wiv%wi!S%wi#T%wi~Od2oO~O^2rO!j.rO!q2sO'R#VO'[%eO~O(P*OO!P%{X!e%{X~O!e2tO!P(tX~O!P2vO~OQ!QOZ%rO[%qO^2xO_%cO`TOaTOd%jOg%yO}%pO!j2yO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO^2zO!j2yO(P)}O~O!P%aX!e%aX~P#4_O^2zO~O(P*OOR&Oi#p&Oiw&Oi$f&Oi$|&Oi[&Oio&Oiy&Oi}&Oi!l&Oi!q&Oi!t&Oi#Q&Oi#R&Oi'h&Oi'r&Oi's&Oi'x&Oi'y&Oi'z&Oi'{&Oi'|&Oi'}&Oi(O&Oi(Q&Oi(R&Oi(T&Oi!P&Oi!e&OiX&OiP&Oiv&Oi!S&Oi#T&Oi~O_%cO!Q!lO!P&yX!e&yX~P#D_O!e.xO!P(ua~OR3RO(P*OO~O!e3SOR(rX~OR3UO~O(P*OOR&Pi#p&Piw&Pi$f&Pi$|&Pi[&Pio&Piy&Pi}&Pi!l&Pi!q&Pi!t&Pi#Q&Pi#R&Pi'h&Pi'r&Pi's&Pi'x&Pi'y&Pi'z&Pi'{&Pi'|&Pi'}&Pi(O&Pi(Q&Pi(R&Pi(T&Pi!P&Pi!e&PiX&PiP&Piv&Pi!S&Pi#T&Pi~O!P3VO~O$f3WO(P*OO~Ow$yO$f3WO$|*wO(P*OO~Ow!PO!Z!YO~O!Z3bO#T3`O's(oO~O!j&bO'R#VO~P<cOv3fO~Ov3fO!j&bO'R`O~P<cO!O3iO's(oO~Ow!PO~P#9jOo3lOy3kO(P*OO~OS,_OT,_OZ,_O['bO_3mOd,_Oo,_Os,_Ou,_Ow'cOy,_O}'dO!S,_O!e,_O!l,_O!q,]O!t,_O!{,_O#Q,_O#R,_O#S,_O#T,_O'R,_O'[%eO'_UO'h,[O's,]O'v,`O'x,[O'y,]O'z,]O'{,]O'|,^O'},^O(O,_O(P,aO(Q,aO(R,bO~O!P3qO~P&']Ov3tO~P&']OR0tO!S+TO!e0rO~OR0tOo0vO!S+TO!e0rO~Oa/yO|!VO'R#VO'U(QO~O!S3wO~O!e3yOv(dX~Ov3{O~OQ!QOZ%rO[%qO^%vO_%cO`TOa/yOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO~PGaO!e4OO(P*OO!P(fX~O!P4QO~O!S4RO(P)}O~O!S+TO(P*OO~O!e4TOw(aXy(aX~OQ4VO~Oy2XO~Oa/yO|!VO'R#VO'U*nO~Oo4YOw*uO}*vOv%XX!e%XX~O!e4]Ov(hX~Ov4_O~O(P4aOy(_Xw(_X$|(_XR(_Xo(_X!e(_X~Oy4cO(P*OO~OQ!QO[$gO^4dO_$ZO`:QOa:QOd$aO}$eO!i$qO!j4eO!l$lO!q$hO#V$lO'U$YO'[%eO'h$[O~P%;dO!S4gO's(oO~O#V4iO~P%1qO!e4jO!P(kX~O!P4lO~O!P%aX!S!aX!e%aX's!aX~P!KZOQ!QO[$gO^4dO_$ZO`:QOa:QOd$aO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'U$YO'h$[O~P%;dO!e4jO!P(kX!S'fX's'fX~O^2zO!j2yO~Ow!POy2gO~O_4rO!Q/rO'U&iO'[%eOR&lX!e&lX~OR4tO!e0rO~O!S4vO~Ow$yO$|*wO(P*OO~Oy4wO~P2gOo4xOy4wO(P*OO~Ov&uX!e&uX~P!3|O!e1OOv(pa~Oo5OOy4}O(P*OO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'_UOR&vX!e&vX~P#D_O!e1YOR'Za~O!{5UO~O!P5VO~P#K_O!e5XO!P(wX~O!P5ZO~O!e,rO!P(Vi~OPoOQ!QOZeO[lO^RO_RO`ROaROd[Ow!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'UQO'[kO'hcO'riO(QdO~P%;dO!P&ea!e&ea~P2gOX5]O~P2gOP!bqZcq!S!bq!e!bq!tcq'rcq's!bq!O!bqo!bqy!bq!P!bqX!bq!Z!bq#T!bqv!bq~O's(oO!P&`a!e&`aX&`a~O!i-_O!j-^O!l5_O'U-WOv&aX!e&aX~O!e1tOv'pa~O!S5aO~O!S5eO's(oOP$Xa!e$Xa~O(P*OOP$Wq!e$Wq~Ov$^i!e$^i~P2gOw!POy5gO#S5iO$|*wO~Oo5lOy5kO(P*OO~Oy5nO~Oy5nO$|*wO~Oy5rO(P*OO~Ow!POy5gO~Oo5yOy5xO(P*OO~O!S5{O~O!e2tO!P(ta~O^2zO!j2yO'[%eO~OQ!QOZ%rO[%qO^.qO_%cO`TOaTOd%jOg%yO}%pO!j.rO!q.oO!t6PO#V6RO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P&xX!e&xX~PGaOQ!QOZ%rO[%qO^6TO_%cO`TOaTOd%jOg%yO}%pO!j6UO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(P)}O(Q%zO~PGaO!P%aa!e%aa~P#4_O^6VO~O#S6WOR%wq#p%wq(P%wqw%wq$f%wq$|%wq[%wqo%wqy%wq}%wq!l%wq!q%wq!t%wq#Q%wq#R%wq'h%wq'r%wq's%wq'x%wq'y%wq'z%wq'{%wq'|%wq'}%wq(O%wq(Q%wq(R%wq(T%wq!P%wq!e%wqX%wqP%wqv%wq!S%wq#T%wq~O(P*OOR&Oq#p&Oqw&Oq$f&Oq$|&Oq[&Oqo&Oqy&Oq}&Oq!l&Oq!q&Oq!t&Oq#Q&Oq#R&Oq'h&Oq'r&Oq's&Oq'x&Oq'y&Oq'z&Oq'{&Oq'|&Oq'}&Oq(O&Oq(Q&Oq(R&Oq(T&Oq!P&Oq!e&OqX&OqP&Oqv&Oq!S&Oq#T&Oq~O(P*OO!P&ya!e&ya~OX6XO~P2gO'[%eOR&wX!e&wX~O!e3SOR(ra~O$f6_O(P*OO~Ow![q~P#9jO#T6bO~O!Z3bO#T6bO's(oO~Ov6gO~O!S1_O#T'wX~O#T6kO~Oy6lO!P6mO~O!P6mO~P&']Oy6pO~Ov6pOy6lO~Ov6pO~P&']Oy6rO~O!e3yOv(da~O!S6uO~Oa/yO|!VO'R#VO'U(QOv&oX!e&oX~O!e4OO(P*OO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOa/yOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P&pX!e&pX~PGaO!e4OO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0UO%^%xO&W%{O'U%dO'[%eO(Q%zOw&nX!e&nXy&nX~PGaO!e4TOw(aay(aa~O!e4]Ov(ha~Oo7XOv%Xa!e%Xa~Oo7XOw*uO}*vOv%Xa!e%Xa~Oa/yO|!VO'R#VO'U*nOv&qX!e&qX~O(P*OOy$xaw$xa$|$xaR$xao$xa!e$xa~O(P4aOy(_aw(_a$|(_aR(_ao(_a!e(_a~O!P%aa!S!aX!e%aa's!aX~P!KZOQ!QO[$gO^7`O_$ZO`:QOa:QOd$aO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'U$YO'h$[O~P%;dO^6VO!j6UO~O!e4jO!P(ka~O!e4jO!P(ka!S'fX's'fX~OQ!QO[$gO^0kO_$ZO`:QOa:QOd$aO}$eO!i$qO!j0lO!l$lO!q0dO!t7dO#V7fO'R#VO'U$YO'[%eO'h$[O!P&sX!e&sX~P%;dO!S7hO's(oO~Ow!POy5gO$|*wO(P*OO~O!S+TOR&la!e&la~Oo0vO!S+TOR&la!e&la~Oo0vOR&la!e&la~O(P*OOR$yi!e$yi~Oy7kO~P2gOo7lOy7kO(P*OO~O(P*OORni!eni~O(P*OOR&va!e&va~O(P)}OR&va!e&va~OS,_OT,_OZ,_O_,_Od,_Oo,_Os,_Ou,_Oy,_O!S,_O!e,_O!l,_O!q,]O!t,_O!{,_O#Q,_O#R,_O#S,_O#T,_O'R,_O'[%eO'_UO'h,[O's,]O'x,[O'y,]O'z,]O'{,]O'|,^O'},^O(O,_O~O(P7nO(Q7nO(R7nO~P''`O!P7pO~P#K_OSVOTVOsVOtVOuVO'_UO!P&zX!e&zX~P!6PO!e5XO!P(wa~O!P&ei!e&ei~P2gO's(oOv!hi!e!hi~O!S7tO~O(P*OOP$Xi!e$Xi~Ov$^q!e$^q~P2gOw!POy7vO~Ow!POy7vO#S7yO$|*wO~Oy7{O~Oy7|O~Oy7}O(P*OO~Ow!POy7vO$|*wO(P*OO~Oo8SOy8RO(P*OO~O!e2tO!P(ti~O(P*OO!P%}X!e%}X~O!P%ai!e%ai~P#4_O^8VO~O!e8[O['cXv$`i}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[iv$`i}#[i!i#[i!j#[i!l#[i!q#[i!t'cX#V#[i'R#[i'U#[i'_#[i'h#[i'r'cX(Q'cX~P@[O#T#^a~P2gO#T8_O~O!Z3bO#T8`O's(oO~Ov8cO~Oy8eO~P2gOy8gO~Oy6lO!P8hO~Ov8gOy6lO~O!e3yOv(di~O(P*OOv%Qi!e%Qi~O!e4OO!P(fi~O!e4OO(P*OO!P(fi~O(P*OO!P&pa!e&pa~O(P8oOw(bX!e(bXy(bX~O(P*OO!S$wiy$wiw$wi$|$wiR$wio$wi!e$wi~O!e4]Ov(hi~Ov%Xi!e%Xi~P2gOo8rOv%Xi!e%Xi~O!P%ai!S!aX!e%ai's!aX~P!KZO(P*OO!P%`i!e%`i~O!e4jO!P(ki~OQ!QO[$gO^0kO_$ZO`:QOa:QOd$aO}$eO!i$qO!j0lO!l$lO!q0dO!t7dO#V8uO'R#VO'U$YO'[%eO'h$[O~P%;dO!P&sa!S'fX!e&sa's'fX~O(P*OOR$zq!e$zq~Oy8wO~P2gOy8RO~P2gO(P8yO(Q8yO(R8yO~O(P8yO(Q8yO(R8yO~P''`O's(oOv!hq!e!hq~O(P*OOP$Xq!e$Xq~Ow!POy8|O$|*wO(P*OO~Ow!POy8|O~Oy9PO~P2gOy9RO~P2gOo9TOy9RO(P*OO~OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[qv$`q}#[q!i#[q!j#[q!l#[q!q#[q#V#[q'R#[q'U#[q'_#[q'h#[q~O!e9WO['cXv$`q}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[Oo'cX!t'cX#Q'cX#R'cX#p'cX'r'cX's'cX'x'cX'y'cX'z'cX'{'cX'|'cX'}'cX(O'cX(P'cX(Q'cX(R'cX(T'cX~P'9OO#T9]O~O!Z3bO#T9]O's(oO~Oy9_O~O(P*OOv%Qq!e%Qq~O!e4OO!P(fq~O(P*OO!P&pi!e&pi~O(P8oOw(ba!e(bay(ba~Ov%Xq!e%Xq~P2gO!P&si!S'fX!e&si's'fX~O(P*OO!P%`q!e%`q~Oy9dO~P2gO(P9eO(Q9eO(R9eO~O's(oOv!hy!e!hy~Ow!POy9fO~Ow!POy9fO$|*wO(P*OO~Oy9hO~P2gOQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[yv$`y}#[y!i#[y!j#[y!l#[y!q#[y#V#[y'R#[y'U#[y'_#[y'h#[y~O!e9kO['cXv$`y}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[Oo'cX!t'cX#Q'cX#R'cX#p'cX'r'cX's'cX'x'cX'y'cX'z'cX'{'cX'|'cX'}'cX(O'cX(P'cX(Q'cX(R'cX(T'cX~P'?}O!e9lO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[i}#[i!i#[i!j#[i!l#[i!q#[i!t'cX#V#[i'R#[i'U#[i'_#[i'h#[i'r'cX(Q'cX~P@[O#T9oO~O(P*OO!P&pq!e&pq~Ov%Xy!e%Xy~P2gOw!POy9pO~Oy9qO~P2gOQ#[!RS#[!RT#[!R[#[!R^#[!R_#[!R`#[!Ra#[!Rd#[!Rs#[!Rt#[!Ru#[!Rv$`!R}#[!R!i#[!R!j#[!R!l#[!R!q#[!R#V#[!R'R#[!R'U#[!R'_#[!R'h#[!R~O!e9rO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[q}#[q!i#[q!j#[q!l#[q!q#[q!t'cX#V#[q'R#[q'U#[q'_#[q'h#[q'r'cX(Q'cX~P@[O!e9uO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[y}#[y!i#[y!j#[y!l#[y!q#[y!t'cX#V#[y'R#[y'U#[y'_#[y'h#[y'r'cX(Q'cX~P@[OwbX~P$|OwjX}jX!tbX'rbX~P!6mOZ'TXd'YXo'TXw'lX!t'TX'r'TX's'TX~O['TXd'TXw'TX}'TX!l'TX!q'TX#Q'TX#R'TX#p'TX'h'TX'x'TX'y'TX'z'TX'{'TX'|'TX'}'TX(O'TX(P'TX(Q'TX(R'TX(T'TX~P'MmOP'TX}'lX!S'TX!e'TX!O'TXy'TX!P'TXX'TX!Z'TX#T'TXv'TX~P'MmO^9xO_9xO`9xOa9xO'U9vO~O!j:VO~P!.cOPoOQ!QOZeO^9xO_9xO`9xOa9xOd9{O!U#bO!W#cO!X;RO!Z!YO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO[#sXo#sXw#sX}#sX!l#sX!q#sX!t#sX#Q#sX#R#sX#p#sX'h#sX'r#sX's#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sX~P%;dO#S$uO~P!.cO}'lXP'TX!S'TX!e'TX!O'TXy'TX!P'TXX'TX!Z'TX#T'TXv'TX~P'MmOo#qX#Q#qX#R#qX#p#qX's#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qX~P!.cOo#zX#Q#zX#R#zX#p#zX's#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zX~P!.cOPoOQ!QOZeO^9xO_9xO`9xOa9xOd9{O!U#bO!W#cO!X;RO!Z!YO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO[#sao#saw#sa}#sa!l#sa!q#sa!t#sa#Q#sa#R#sa#p#sa'h#sa'r#sa's#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#sa~P%;dOo:aO#Q:aO#R:^Ow#sa~P!BqOw$Ua~P#9jOQ'YXd'YX}iX~OQlXdlX}jX~O^:zO_:zO`:zOa:zO'U:fO~OQ'YXd'YX}hX~Ow#qa~P#9jOw#za~P#9jO!S&_Oo#za#Q#za#R#za#p#za's#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#za~P!.cO#S*dO~P!.cOw#ci~P#9jO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!q#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'y#ei'z#ei'{#ei'|#ei'}#ei~O'h#ei(P#ei~P(/aO'h#gO(P#gO~P(/aO[#}O}#zO'h#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'{#ei'|#ei'}#ei~O!q#ei~P(1]O!q#jO~P(1]O[#}O}#zO!q#jO'h#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei'|#ei'}#ei~O's#ei~P(3UO's#lO~P(3UO[#}O}#zO!q#jO#R:^O'h#gO's#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#Q#ei#p#ei'r#ei'|#ei~O'}#ei~P(4}O'}#mO~P(4}Oo:aO#Q:aO#R:^Ow#ni~P$1lOo:aO#Q:aO#R:^Ow#si~P$3mOQ'YXd'YX}'lX~Ow#zi~P#9jOw$Ui~P#9jOd:UO~Ow#ca~P#9jOd:|O~OU'x_'v'Q'P'_s!{'_'U'[~",
    goto: "$L^(xPPPPPPP(yPP)QPP)`PPPP)l-rP0r5oP7a7a9U7a?VDoEQPEWHaPPPPPPKqP! b! pPPPPP!!hP!%QP!%QPP!'QP!)TP!)Y!*P!*w!*w!*w!)Y!+nP!)Y!.c!.fPP!.lP!)Y!)Y!)Y!)YP!)Y!)YP!)Y!)Y!/[!/[!/y!0hP!0hKaKaKaPPPP!0hPP!%QP!0v!0y!1P!2Q!2^!4^!4^!6[!8^!2^!2^!:Y!;w!=h!?T!@n!BV!Cl!D}!2^!2^P!2^P!2^!2^!F^!2^P!G}!2^!2^P!I}!2^P!2^!8^!8^!2^!8^!2^!LU!N^!Na!8^!2^!Nd!Ng!Ng!Ng!Nk!%QP!%QP!%QP! b! bP!Nu! b! bP# R#!g! bP! bP#!v##{#$T#$s#$w#$}#$}#%VP#']#']#'c#(X#(e! bP! bP#(u#)U! bP! bPP#)b#)p#)|#*f#)v! b! bP! b! b! bP#*l#*l#*r#*x#*l#*l! b! bP#+V#+`#+j#+j#-b#/U#/b#/b#/e#/e5o5o5o5o5o5o5o5oP5o#/h#/n#0Y#2e#2k#2z#6x#7O#7U#7h#7r#9c#9m#9|#:S#:Y#:d#:n#:t#;R#;X#;_#;i#;w#<R#>a#>m#>z#?Q#?Y#?a#?k#?qPPPPPPP#?w#CTP#GS#Kn#Mi$ h$'UP$'XPPP$*`$*i$*{$0V$2e$2n$4gP!)Y$5a$8u$;l$?W$?a$?f$?iPPP$?l$BcP$BsPPPPPPPPPP$CXP$Eg$Ej$Em$Es$Ev$Ey$E|$FP$FV$Ha$Hd$Hg$Hj$Hm$Hp$Hs$Hv$Hy$H|$IP$KV$KY$K]#*l$Ki$Ko$Kr$Ku$Ky$K}$LQ$LT$LW$LZQ!tPT'V!s'Wi!SOlm!P!T$T$W$y%b)T*e/fQ'h#QQ,l'kQ1d,kR7q5X(SSOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%X%_%b&U&Y&[&b&u&z&|'P'a'k'm'n'|(V(X(a(c(d(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m+y,k,o,r,y-Q-S-f-l-s.|/]/a/c/f0d0f0l0|1O1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m:nS(y$v-nQ*o&eQ*s&hQ-j(xQ-x)YW0Y+P0X4]7ZR4[0Z&{!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'k'|(V(X(a(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,r,y-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m#r]Ofgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9of#[b#Q$y'k(a)R)T*Y,k-s5X!h$bo!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t$b%k!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n!W;Q!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR;T%n$_%u!Q!n$O$u%o%p%q&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n$e%l!Q!n$O$u%n%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n'hZOY[fgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r%_%b%i%j&U&Y&[&b&u'a'|(V(X(c(d(e(i(n(o(q({)h)o)p*e*h*j*k+Y+m,r,y-Q-S-f-l.h.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:g:h:l:m:n:{:|;P$^%l!Q!n$O$u%n%o%p%q%y%{&P&p&r(p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nQ&j!hQ&k!iQ&l!jQ&m!kQ&s!oQ)Z%QQ)[%RQ)]%SQ)^%TQ)a%WQ+_&oS,Q']1YQ.V)_S/q*t4VR4p0r+}TOY[bfgilmop!O!P!Q!T!Y!Z![!_!`!c!n!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$O$T$W$`$a$e$g$h$q$r$u$y%X%_%b%i%j%n%o%p%q%y%{&P&U&Y&[&b&o&p&r&u&z&|'P']'a'k'm'n'|(V(X(a(c(d(e(i(n(o(p(q({)R)T)h)o)p)r)w)x)}*O*Q*U*Y*Z*]*d*e*h*j*k*m*v*w+T+U+Y+g+m+n+y+|,k,o,r,y-Q-S-f-h-l-s-u.T._.h.o.s.w.x.|/Y/Z/]/a/c/f/z/|0_0d0f0l0q0v0|0}1O1X1Y1i1s1z1}2b2i2k2n2t2w3W3`3b3g3i3l3w3}4O4T4W4Y4a4e4g4j4v4x5O5X5a5e5i5l5y5{6W6_6b6f6u6{6}7X7c7h7l7t7y8S8_8`8n8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:g:h:l:m:n:{:|;PQ'[!xQ'g#PQ)k%gU)q%m*S*VR.e)jQ,S']R5R1Y#t%s!Q!n$O$u%p%q&P&p&r(p)w)x)}*Q*U*Z*]*d*m*v+U+g+n+|-h-u.T._.s.w.x/Y/Z/z/|0_0q0v0}1X1z2b2i2k2n2w3W3w3}4O4W4g4v5e5i5{6W6_6u6{6}7h7y8nQ)w%oQ+^&oQ,T']l,_'b'c'd,Y,e,f/l/m1`3p3s5V5W7pS.p)r2tQ.}*OQ/P*RQ/p*tS0P*w4TQ0`+T[0n+Y.i0f4j6O7cQ2w.oS4f0d2sQ4o0rQ5S1YQ6Y3SQ7P4RQ7T4VQ7^4aR9a8o&pVOfgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u']'|(V(X(a(e(i(n(o(q({)h*e*h*j*k+Y+m,j,k,r,y-S-f-l.|/]/a/c/f0d0f0l0|1Y1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mU&g!g%P%[m,_'b'c'd,Y,e,f/l/m1`3p3s5V5W7p$nsOfgilm!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y'|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:R:S:V:W:X:Y:Z:[:]:^:_:`:a:lS$tp:PS&O!W#bS&Q!X#cQ&`!bQ*^&RQ*`&VS*c&[:mQ*g&^Q,S']Q-i(vQ/h*iQ0o+ZS2g.W0pQ3^/^Q3_/_Q3h/gQ3j/jQ5R1YU5g2S2h4nU7v5h5j5wQ8d6iS8|7w7xS9f8}9OR9p9gi{Ob!O!P!T$y%_%b)R)T)h-shxOb!O!P!T$y%_%b)R)T)h-sW/u*u/s3y6vQ/|*vW0Z+P0X4]7ZQ3}/zQ6}4OR8n6{!h$do!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tQ&d!dQ&f!fQ&n!mW&x!q%X&|1OQ'S!rQ)W$}Q)X%OQ)`%VU)c%Y'T'UQ*r&hS+r&z'PS-X(j1tQ-t)VQ-w)YS.`)d)eS0w+b/rQ1R+yQ1V+zS1w-^-_Q2l.aQ3u/oQ5b1yR5m2W${sOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m$zsOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR3^/^V&T!Y!`*h!i$lo!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t!k$^o!c!p$e$g$h$q$r&U&b&u(a(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t!i$co!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t&e^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'|(V(X(e(i(n(o(q({)h*e*h*j*k+Y+m,r,y-S-f-l.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR(k$fQ-Z(jR5_1tQ(R#|S(z$v-nS-Y(j1tQ-k(xW/t*u/s3y6vS1x-^-_Q3x/uR5c1yQ'e#Oh,b'b'c'd,Y,e,f/l/m1`3p3s5WQ,m'lQ,p'oQ.t)tR8f6kQ'f#Oh,b'b'c'd,Y,e,f/l/m1`3p3s5WQ,n'lQ,p'oQ.t)tR8f6ki,b'b'c'd,Y,e,f/l/m1`3p3s5WR*f&]X/b*e/c/f3g!}aOb!O!P!T#z$v$y%_%b'|(x)R)T)h)r*e*u*v+P+Y,r-n-s.i/a/c/f/s/z0X0f1i2t3g3y4O4]4j6O6f6v6{7Z7cQ3a/`Q6d3cQ8a6eR9^8b${rOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m#nfOfglmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o!T9|!Y!_!`*h*k/]3i9|9}:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:l:m#rfOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o!X9|!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m$srOfglmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:l:m#U#oh#d$P$Q$V$s%^&W&X'p's't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9i}:W&S&]/j3]6i:c:d:j:k:o:q:r:s:t:u:v:w:x:y:};O;S#W#ph#d$P$Q$V$s%^&W&X'p'q's't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9i!P:X&S&]/j3]6i:c:d:j:k:o:p:q:r:s:t:u:v:w:x:y:};O;S#S#qh#d$P$Q$V$s%^&W&X'p't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9i{:Y&S&]/j3]6i:c:d:j:k:o:r:s:t:u:v:w:x:y:};O;S#Q#rh#d$P$Q$V$s%^&W&X'p'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iy:Z&S&]/j3]6i:c:d:j:k:o:s:t:u:v:w:x:y:};O;S#O#sh#d$P$Q$V$s%^&W&X'p'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iw:[&S&]/j3]6i:c:d:j:k:o:t:u:v:w:x:y:};O;S!|#th#d$P$Q$V$s%^&W&X'p'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iu:]&S&]/j3]6i:c:d:j:k:o:u:v:w:x:y:};O;S!x#vh#d$P$Q$V$s%^&W&X'p'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iq:_&S&]/j3]6i:c:d:j:k:o:w:x:y:};O;S!v#wh#d$P$Q$V$s%^&W&X'p'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9io:`&S&]/j3]6i:c:d:j:k:o:x:y:};O;S$]#{h#`#d$P$Q$V$s%^&S&W&X&]'p'q'r's't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m/j0y1j1m2O3Q3]4y5[5f6c6i6j7W7j7m7z8Q8q8x9S9c9i:c:d:j:k:o:p:q:r:s:t:u:v:w:x:y:};O;S${jOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m$v!aOfgilmp!O!P!T!Y!Z!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ&Y![Q&Z!]R:l:S#rpOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9oQ&[!^!W:P!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR:m;RR$moR-e(qR$wqT(|$v-nQ/e*eS3e/c/fR6h3gQ3o/lQ3r/mQ6n3pR6q3sQ$zwQ)U${Q*p&fQ+e&qQ+h&sQ-v)XW.Y)a+i+j+kS/W*[+fW2c.V.Z.[.]U3X/X/[0xU5t2d2e2fS6]3Y3[S8O5u5vS8X6[6^Q9Q8PS9U8Y8ZR9j9V^|O!O!P!T%_%b)hX)Q$y)R)T-sQ&r!nQ*]&PQ*{&jQ+O&kQ+S&lQ+V&mQ+[&nQ+k&sQ-|)ZQ.P)[Q.S)]Q.U)^Q.X)`Q.])aQ2T-tQ2f.VR4W0UU+`&o*t4VR4q0rQ+X&mQ+j&sS.[)a+k^0u+^+_/p/q4o4p7TS2e.V.]S4S0Q0RR5v2fS0Q*w4TQ0`+TR7^4aU+c&o*t4VR4r0rQ*y&jQ*}&kQ+R&lQ+f&qQ+i&sS-z)Z*{S.O)[+OS.R)]+SU.Z)a+j+kQ/X*[Q0W*zQ0p+ZQ2Y-{Q2Z-|Q2^.PQ2`.SU2d.V.[.]Q2h.WS3[/[0xS5h2S4nQ5o2[S5u2e2fQ6^3YS7x5j5wQ8P5vQ8Y6[Q8}7wQ9V8ZR9g9OQ0S*wR7R4TQ*x&jQ*|&kU-y)Z*y*{U-})[*}+OS2X-z-|S2].O.PQ4Z0YQ5n2ZQ5p2^R7Y4[Q/v*uQ3v/sQ6w3yR8k6vQ*z&jS-{)Z*{Q2[-|Q4Z0YR7Y4[Q+Q&lU.Q)]+R+SS2_.R.SR5q2`Q0[+PQ4X0XQ7[4]R8s7ZQ+Z&nS.W)`+[S2S-t.XR5j2TQ0h+YQ4h0fQ7e4jR8t7cQ.l)rQ0h+YQ2q.iQ4h0fQ6R2tQ7e4jQ8U6OR8t7cQ0h+YR4h0fX'O!q%X&|1OX&{!q%X&|1OW'O!q%X&|1OS+t&z'PR1T+y_|O!O!P!T%_%b)hQ%a!PS)g%_%bR.c)h$^%u!Q!n$O$u%o%p%q&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nQ*T%yR*W%{$c%n!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nW)s%m%x*S*VQ.d)iR2|.uR.l)rR6R2tQ'W!sR+}'WQ!TOQ$TlQ$WmQ%b!P[%|!T$T$W%b)T/fQ)T$yR/f*e$b%i!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n[)m%i)o.h:g:{;PQ)o%jQ.h)pQ:g%nQ:{:hR;P:|Q!vUR'Y!vS!OO!TU%]!O%_)hQ%_!PR)h%b#rYOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9oh!yY!|#U$`'a'm(c,o-Q9z:T:nQ!|[f#Ub#Q$y'k(a)R)T*Y,k-s5X!h$`o!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tQ'a!}Q'm#ZQ(c$aQ,o'nQ-Q(d!W9z!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ:T9{R:n:UQ-T(fR1q-TQ1u-ZR5`1uQ,Y'bQ,e'cQ,f'dW1^,Y,e,f5WR5W1`Q/c*eS3d/c3gR3g/ffbO!O!P!T$y%_%b)R)T)h-sp#Wb'|(x.i/a/s/z0X0f1i6O6f6v6{7Z7cQ'|#zS(x$v-nQ.i)rW/a*e/c/f3gQ/s*uQ/z*vQ0X+PQ0f+YQ1i,rQ6O2tQ6v3yQ6{4OQ7Z4]R7c4jQ,s'}Q1h,qT1k,s1hS(W$Q(ZQ(]$VU,w(W(],|R,|(_Q(r$mR-g(rQ-o(}R2Q-oQ3p/lQ3s/mT6o3p3sQ)R$yS-q)R-sR-s)TQ4b0`R7_4b`0s+]+^+_+`+c/p/q7TR4s0sQ8p7PR9b8pQ4U0SR7S4UQ3z/vQ6s3vT6x3z6sQ4P/{Q6y3|U7O4P6y8lR8l6zQ4^0[Q7V4XT7]4^7VhzOb!O!P!T$y%_%b)R)T)h-sQ$|xW%Zz$|%f)u$b%f!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nR)u%nS4k0h0mS7b4h4iT7g4k7bW&z!q%X&|1OS+q&z+yR+y'PQ1P+vR4|1PU1Z,R,S,TR5T1ZS3T/P7TR6Z3TQ2u.lQ5}2qT6S2u5}Q.y)yR3P.yQ5Y1dR7r5Y^_O!O!P!T%_%b)hY#Xb$y)R)T-s$l#_fgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['|(V(X({*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!h$io!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tW'i#Q'k,k5XQ-O(aR/U*Y&z!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'k'|(V(X(a(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,r,y-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m[!{Y[#U#Z9z9{W&{!q%X&|1O['`!|!}'m'n:T:US(b$`$aS+s&z'PU,W'a,o:nS-P(c(dQ1S+yR1o-QS%t!Q&oQ&q!nQ(U$OQ(v$uS)v%o.oQ)y%pQ)|%qS*[&P&rQ+d&pQ,R']Q-c(pQ.k)rU.v)w)x2wS.})}*OQ/O*QQ/S*UQ/V*ZQ/[*]Q/_*dQ/k*mQ/{*vS0R*w4TQ0`+TQ0b+UQ0x+gQ0z+nQ1W+|Q1|-hQ2U-uQ2a.TQ2j._Q2{.sQ2}.wQ3O.xQ3Y/YQ3Z/ZS3|/z/|Q4`0_Q4n0qQ4u0vQ4z0}Q5P1XQ5Q1YQ5d1zQ5s2bQ5w2iQ5z2kQ5|2nQ6Q2tQ6[3WQ6t3wQ6z3}Q6|4OQ7U4WQ7^4aQ7a4gQ7i4vQ7u5eQ7w5iQ8T5{Q8W6WQ8Z6_Q8j6uS8m6{6}Q8v7hQ9O7yR9`8n$^%m!Q!n$O$u%o%p%q&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nQ)i%nQ*S%yR*V%{$y%h!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](p)o)p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.h.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n:g:h:{:|;P'tWOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'k'm'n'|(V(X(a(c(d(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,o,r,y-Q-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m:n$x%g!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](p)o)p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.h.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n:g:h:{:|;P_&y!q%X&z&|'P+y1OR,U']$zrOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!j$]o!c!p$e$g$h$q$r&U&b&u(a(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tQ,S']Q1c,jQ1d,kQ5R1YR7q5X_}O!O!P!T%_%b)h^|O!O!P!T%_%b)hQ#YbX)Q$y)R)T-sbhO!O!T3`6b8_8`9]9oS#`f9|Q#dgQ$PiQ$QlQ$VmQ$spW%^!P%_%b)hU&S!Y!`*hQ&W!ZQ&X![Q&]!_Q'p#eQ'q#oS'r#p:XQ's#qQ't#rQ'u#sQ'v#tQ'w#uQ'x#vQ'y#wQ'z#xQ'{#yQ'}#zQ(T#}Q(Z$TQ(_$WQ*a&YQ*b&[Q,q'|Q,v(VQ,x(XQ-m({Q/j*kQ0y+mQ1j,rQ1m,yQ2O-lQ3Q.|Q3]/]Q4y0|Q5[1iQ5f1}Q6c3bQ6i3iQ6j3lQ7W4YQ7j4xQ7m5OQ7z5lQ8Q5yQ8q7XQ8x7lQ9S8SQ9c8rQ9i9TQ:c:OQ:d:PQ:j:RQ:k:SQ:o:VQ:p:WQ:q:YQ:r:ZQ:s:[Q:t:]Q:u:^Q:v:_Q:w:`Q:x:aQ:y:bQ:}:lQ;O:mR;S9}^tO!O!P!T%_%b)h$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['|(V(X({*h*k+m,r,y-l.|/]0|1i1}3b3i3l4Y4x5O5l5y7X7l8S8r9T9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ6a3`Q8^6bQ9Y8_Q9[8`Q9n9]R9t9oQ&V!YQ&^!`R/g*hQ$joQ&a!cQ&t!pU(f$e$g(iS(m$h0dQ(t$qQ(u$rQ*_&UQ*l&bQ+o&uQ-R(eS-a(n4eQ-b(oQ-d(qW/`*e/c/f3gQ/i*jW0e+Y0f4j7cQ1p-SQ1{-fQ3c/aQ4m0lQ5^1sQ7s5aQ8b6fR8{7t!h$_o!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tR-O(a'uXOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'k'm'n'|(V(X(a(c(d(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,o,r,y-Q-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m:n$zqOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!i$fo!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t&d^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'|(V(X(e(i(n(o(q({)h*e*h*j*k+Y+m,r,y-S-f-l.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m[!zY[$`$a9z9{['_!|!}(c(d:T:UW)n%i%j:g:hU,V'a-Q:nW.g)o)p:{:|T2p.h;PQ(h$eQ(l$gR-V(iV(g$e$g(iR-](jR-[(j$znOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!i$ko!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t`,c'b'c'd,Y,e,f1`5WX3n/l/m3p3sh,b'b'c'd,Y,e,f/l/m1`3p3s5WQ7o5VR8z7p^uO!O!P!T%_%b)h$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['|(V(X({*h*k+m,r,y-l.|/]0|1i1}3b3i3l4Y4x5O5l5y7X7l8S8r9T9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ6`3`Q8]6bQ9X8_Q9Z8`Q9m9]R9s9oR(P#zR(O#zQ$SlR([$TR$ooR$noR)P$vR)O$vQ(}$vR2P-nhwOb!O!P!T$y%_%b)R)T)h-s$l!lz!Q!n$O$u$|%f%n%o%p%q%y%{&P&o&p&r'](p)r)u)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nR${xR0a+TR0V*wR0T*wR7Q4RR/x*uR/w*uR0O*vR/}*vR0^+PR0]+P%XyObxz!O!P!Q!T!n$O$u$y$|%_%b%f%n%o%p%q%y%{&P&o&p&r'](p)R)T)h)r)u)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-s-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nR0j+YR0i+YQ'R!qQ)b%XQ+v&|R4{1OX'Q!q%X&|1OR+x&|R+w&|T/R*R4VT/Q*R4VR.n)rR.m)rR)z%pR1f,kR1e,k",
    nodeNames: "\u26A0 | < > RawString Float LineComment BlockComment SourceFile ] InnerAttribute ! [ MetaItem self Metavariable super crate Identifier ScopedIdentifier :: QualifiedScope AbstractType impl SelfType MetaType TypeIdentifier ScopedTypeIdentifier ScopeIdentifier TypeArgList TypeBinding = Lifetime String Escape Char Boolean Integer } { Block ; ConstItem Vis pub ( in ) const BoundIdentifier : UnsafeBlock unsafe AsyncBlock async move IfExpression if LetDeclaration let LiteralPattern ArithOp MetaPattern SelfPattern ScopedIdentifier TuplePattern ScopedTypeIdentifier , StructPattern FieldPatternList FieldPattern ref mut FieldIdentifier .. RefPattern SlicePattern CapturedPattern ReferencePattern & MutPattern RangePattern ... OrPattern MacroPattern ParenthesizedTokens BracketedTokens BracedTokens TokenBinding Identifier TokenRepetition ArithOp BitOp LogicOp UpdateOp CompareOp -> => ArithOp _ else MatchExpression match MatchBlock MatchArm Attribute Guard UnaryExpression ArithOp DerefOp LogicOp ReferenceExpression TryExpression BinaryExpression ArithOp ArithOp BitOp BitOp BitOp BitOp LogicOp LogicOp AssignmentExpression TypeCastExpression as ReturnExpression return RangeExpression CallExpression ArgList AwaitExpression await FieldExpression GenericFunction BreakExpression break LoopLabel ContinueExpression continue IndexExpression ArrayExpression TupleExpression MacroInvocation UnitExpression ClosureExpression ParamList Parameter Parameter ParenthesizedExpression StructExpression FieldInitializerList ShorthandFieldInitializer FieldInitializer BaseFieldInitializer MatchArm WhileExpression while LoopExpression loop ForExpression for MacroInvocation MacroDefinition macro_rules MacroRule EmptyStatement ModItem mod DeclarationList AttributeItem ForeignModItem extern StructItem struct TypeParamList ConstrainedTypeParameter TraitBounds HigherRankedTraitBound RemovedTraitBound OptionalTypeParameter ConstParameter WhereClause where LifetimeClause TypeBoundClause FieldDeclarationList FieldDeclaration OrderedFieldDeclarationList UnionItem union EnumItem enum EnumVariantList EnumVariant TypeItem type FunctionItem default fn ParamList Parameter SelfParameter VariadicParameter VariadicParameter ImplItem TraitItem trait AssociatedType LetDeclaration UseDeclaration use ScopedIdentifier UseAsClause ScopedIdentifier UseList ScopedUseList UseWildcard ExternCrateDeclaration StaticItem static ExpressionStatement ExpressionStatement GenericType FunctionType ForLifetimes ParamList VariadicParameter Parameter VariadicParameter Parameter ReferenceType PointerType TupleType UnitType ArrayType MacroInvocation EmptyType DynamicType dyn BoundedType",
    maxTerm: 361,
    nodeProps: [
      [NodeProp2.group, -42, 4, 5, 14, 15, 16, 17, 18, 19, 33, 35, 36, 37, 40, 51, 53, 56, 101, 107, 111, 112, 113, 122, 123, 125, 127, 128, 130, 132, 133, 134, 137, 139, 140, 141, 142, 143, 144, 148, 149, 155, 157, 159, "Expression", -16, 22, 24, 25, 26, 27, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 239, "Type", -20, 42, 161, 162, 165, 166, 169, 170, 172, 188, 190, 194, 196, 204, 205, 207, 208, 209, 217, 218, 220, "Statement", -17, 49, 60, 62, 63, 64, 65, 68, 74, 75, 76, 77, 78, 80, 81, 83, 84, 99, "Pattern"],
      [NodeProp2.openedBy, 9, "[", 38, "{", 47, "("],
      [NodeProp2.closedBy, 12, "]", 39, "}", 45, ")"]
    ],
    skippedNodes: [0, 6, 7, 240],
    repeatNodeCount: 33,
    tokenData: "#?|_R!VOX$hXY1_YZ2ZZ]$h]^1_^p$hpq1_qr2srs4qst5Ztu6Vuv9lvw;jwx=nxy!!ayz!#]z{!$X{|!&R|}!'T}!O!(P!O!P!*Q!P!Q!-|!Q!R!6X!R![!7|![!]!Jw!]!^!Lu!^!_!Mq!_!`# x!`!a##y!a!b#&Q!b!c#&|!c!}#'x!}#O#)o#O#P#*k#P#Q#1b#Q#R#2^#R#S#'x#S#T$h#T#U#'x#U#V#3`#V#f#'x#f#g#6s#g#o#'x#o#p#<Q#p#q#<|#q#r#?Q#r${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hU$oZ'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU%iT'`Q'PSOz%xz{&^{!P%x!P!Q'S!Q~%xS%}T'PSOz%xz{&^{!P%x!P!Q'S!Q~%xS&aTOz&pz{&^{!P&p!P!Q({!Q~&pS&sTOz%xz{&^{!P%x!P!Q'S!Q~%xS'VSOz&p{!P&p!P!Q'c!Q~&pS'fSOz'r{!P'r!P!Q'c!Q~'rS'uTOz(Uz{(l{!P(U!P!Q'c!Q~(US(]T'QS'PSOz(Uz{(l{!P(U!P!Q'c!Q~(US(oSOz'rz{(l{!P'r!Q~'rS)QO'QSU)VZ'`QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)xU)}Z'`QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU*uZ'`QOY)xYZ+hZr)xrs&psz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)xU+mT'`QOz%xz{&^{!P%x!P!Q'S!Q~%xQ,RT'`QOY+|YZ,bZr+|s#O+|#P~+|Q,gO'`QU,lZ'`QOY-_YZ0cZr-_rs'rsz-_z{+|{!P-_!P!Q,g!Q#O-_#O#P'r#P~-_U-dZ'`QOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU.`Z'`Q'QS'PSOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU/[T'`Q'QS'PSOz(Uz{(l{!P(U!P!Q'c!Q~(UU/pZ'`QOY-_YZ0cZr-_rs'rsz-_z{/k{!P-_!P!Q+|!Q#O-_#O#P'r#P~-_U0hT'`QOz(Uz{(l{!P(U!P!Q'c!Q~(UU1OT'`Q'QSOY+|YZ,bZr+|s#O+|#P~+|_1hZ'`Q&}X'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_2dT'`Q&}X'PSOz%xz{&^{!P%x!P!Q'S!Q~%x_2|]ZX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`#O$h#O#P%x#P~$h_4OZ#RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_4zT'^Q'PS'_XOz%xz{&^{!P%x!P!Q'S!Q~%x_5dZ'RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_6`g'`Q'vW'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_8Qh'`Q_X'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![7w![!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_9u](TP'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_:wZ#QX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_;s_!qX'`Q'PSOY$hYZ%bZr$hrs%xsv$hvw<rwz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_<{Z'}X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_=ui'`Q'PSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q!c?d!c!}Et!}#O?d#O#PId#P#R?d#R#SEt#S#T?d#T#oEt#o${?d${$|Et$|4w?d4w5bEt5b5i?d5i6SEt6S~?d_?k]'`Q'PSOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_@mZ'`Q'PSsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_AgV'`Q'PSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x]BTT'PSsXOz%xz{&^{!P%x!P!Q'S!Q~%x]BiV'PSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x_CT]'`QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)x_DTZ'`QsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_D{]'`QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)x_E}j'`Q'PS'[XOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h_Gxh'`Q'PS'[XOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h]IiX'PSOzBdz{JU{!PBd!P!QKS!Q#iBd#i#jKi#j#lBd#l#mMX#m~Bd]JXVOw&pwxJnxz&pz{&^{!P&p!P!Q({!Q~&p]JsTsXOz%xz{&^{!P%x!P!Q'S!Q~%x]KVUOw&pwxJnxz&p{!P&p!P!Q'c!Q~&p]Kn['PSOz%xz{&^{!P%x!P!Q'S!Q![Ld![!c%x!c!iLd!i#T%x#T#ZLd#Z#o%x#o#pNq#p~%x]LiY'PSOz%xz{&^{!P%x!P!Q'S!Q![MX![!c%x!c!iMX!i#T%x#T#ZMX#Z~%x]M^Y'PSOz%xz{&^{!P%x!P!Q'S!Q![M|![!c%x!c!iM|!i#T%x#T#ZM|#Z~%x]NRY'PSOz%xz{&^{!P%x!P!Q'S!Q![Bd![!c%x!c!iBd!i#T%x#T#ZBd#Z~%x]NvY'PSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z~%x]! k['PSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z#q%x#q#rBd#r~%x_!!jZ}X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!#fZ!PX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!$`](QX'`QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!%`Z#QX'`QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!&[](PX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_!'^Z!eX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!(Y^'hX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`!a!)U!a#O$h#O#P%x#P~$h_!)_Z#SX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!*Z[(OX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!+P!P!Q*p!Q#O$h#O#P%x#P~$h_!+Y^!lX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!,U!P!Q*p!Q!_$h!_!`!-Q!`#O$h#O#P%x#P~$h_!,_Z!tX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV!-ZZ'rP'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!.T]'`Q'xXOY)xYZ+hZr)xrs&psz)xz{!.|{!P)x!P!Q!/d!Q!_)x!_!`!%X!`#O)x#O#P&p#P~)x_!/TT'O]'`QOY+|YZ,bZr+|s#O+|#P~+|_!/kZ'`QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!5k{!P!0^!P!Q!/d!Q#O!0^#O#P!3`#P~!0^_!0eZ'`QUXOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W_!1cZ'`QUX'QS'PSOY!1WYZ/RZr!1Wrs!2Usz!1Wz{!4q{!P!1W!P!Q!/d!Q#O!1W#O#P!2U#P~!1W]!2_VUX'QS'PSOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!2yVUXOY!3`YZ'rZz!3`z{!2t{!P!3`!P!Q!4f!Q~!3`]!3eVUXOY!2UYZ(UZz!2Uz{!2t{!P!2U!P!Q!3z!Q~!2U]!4PVUXOY!3`YZ'rZz!3`z{!4f{!P!3`!P!Q!3z!Q~!3`X!4kQUXOY!4fZ~!4f_!4xZ'`QUXOY!0^YZ0cZr!0^rs!3`sz!0^z{!4q{!P!0^!P!Q!5k!Q#O!0^#O#P!3`#P~!0^Z!5rV'`QUXOY!5kYZ,bZr!5krs!4fs#O!5k#O#P!4f#P~!5k_!6bhuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#U$h#U#V!By#V#]$h#]#^!9_#^#c$h#c#d!Ee#d#i$h#i#j!9_#j#l$h#l#m!Gy#m~$h_!8VbuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!7|![#O$h#O#P%x#P#R$h#R#S!7|#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!9fe'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R$h!R!S!:w!S!T$h!T!U!=y!U!W$h!W!X!>y!X!Y$h!Y!Z!<}!Z#O$h#O#P%x#P#g$h#g#h!?y#h~$h_!;O_'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!;}!T!W$h!W!X!<}!X#O$h#O#P%x#P~$h_!<U]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y$h!Y!Z!<}!Z#O$h#O#P%x#P~$h_!=WZuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!>Q]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!<}!T#O$h#O#P%x#P~$h_!?Q]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!U$h!U!V!<}!V#O$h#O#P%x#P~$h_!@Q]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#]$h#]#^!@y#^~$h_!AQ]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#n$h#n#o!Ay#o~$h_!BQ]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#X$h#X#Y!<}#Y~$h_!CQ_'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S~$h_!DYcuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!DP!R!S!DP!S#O$h#O#P%x#P#R$h#R#S!DP#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!El^'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S~$h_!FqbuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!Fh!Y#O$h#O#P%x#P#R$h#R#S!Fh#S#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!HQb'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z~$h_!IcfuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!IY![!c$h!c!i!IY!i#O$h#O#P%x#P#R$h#R#S!IY#S#T$h#T#Z!IY#Z#]$h#]#^!9_#^#i$h#i#j!9_#j~$h_!KQ]!SX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![$h![!]!Ky!]#O$h#O#P%x#P~$h_!LSZdX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!MOZyX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!Mz^#RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!^$h!^!_!Nv!_!`3u!`#O$h#O#P%x#P~$h_# P]'yX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#!R^oX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#!}!a#O$h#O#P%x#P~$h_##WZ#TX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#$S^#RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#%O!a#O$h#O#P%x#P~$h_#%X]'zX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#&ZZ(RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV#'VZ'qP'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#(Th'`Q'PS!{W'UPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h_#)xZ[X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU#*pX'PSOz#+]z{#+s{!P#+]!P!Q#,X!Q#i#+]#i#j#,j#j#l#+]#l#m#.Y#m~#+]U#+dTrQ'PSOz%xz{&^{!P%x!P!Q'S!Q~%xU#+xTrQOz&pz{&^{!P&p!P!Q({!Q~&pU#,^SrQOz&p{!P&p!P!Q'c!Q~&pU#,o['PSOz%xz{&^{!P%x!P!Q'S!Q![#-e![!c%x!c!i#-e!i#T%x#T#Z#-e#Z#o%x#o#p#/r#p~%xU#-jY'PSOz%xz{&^{!P%x!P!Q'S!Q![#.Y![!c%x!c!i#.Y!i#T%x#T#Z#.Y#Z~%xU#._Y'PSOz%xz{&^{!P%x!P!Q'S!Q![#.}![!c%x!c!i#.}!i#T%x#T#Z#.}#Z~%xU#/SY'PSOz%xz{&^{!P%x!P!Q'S!Q![#+]![!c%x!c!i#+]!i#T%x#T#Z#+]#Z~%xU#/wY'PSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z~%xU#0l['PSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z#q%x#q#r#+]#r~%x_#1kZXX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#2g]'{X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#3kj'`Q'PS!{W'UPOY$hYZ%bZr$hrs#5]sw$hwx#5sxz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$h]#5dT'PS'_XOz%xz{&^{!P%x!P!Q'S!Q~%x_#5z]'`Q'PSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q#O?d#O#PId#P~?d_#7Oi'`Q'PS!{W'UPOY$hYZ%bZr$hrs%xst#8mtz$hz{)Q{!P$h!P!Q*p!Q![#'x![!c$h!c!}#'x!}#O$h#O#P%x#P#R$h#R#S#'x#S#T$h#T#o#'x#o${$h${$|#'x$|4w$h4w5b#'x5b5i$h5i6S#'x6S~$hV#8tg'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$hV#:fh'`Q'PS'UPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#:]![!c$h!c!}#:]!}#O$h#O#P%x#P#R$h#R#S#:]#S#T$h#T#o#:]#o${$h${$|#:]$|4w$h4w5b#:]5b5i$h5i6S#:]6S~$h_#<ZZwX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#=V_'sX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P#p$h#p#q#>U#q~$h_#>_Z'|X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#?ZZvX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h",
    tokenizers: [closureParam, tpDelim, literalTokens, 0, 1, 2, 3],
    topRules: { "SourceFile": [0, 8] },
    specialized: [{ term: 282, get: (value) => spec_identifier[value] || -1 }],
    tokenPrec: 15890
  });
  var rustLanguage = /* @__PURE__ */ LRLanguage.define({
    parser: /* @__PURE__ */ parser.configure({
      props: [
        /* @__PURE__ */ indentNodeProp.add({
          IfExpression: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
          "String BlockComment": () => -1,
          "Statement MatchArm": /* @__PURE__ */ continuedIndent()
        }),
        /* @__PURE__ */ foldNodeProp.add((type) => {
          if (/(Block|edTokens|List)$/.test(type.name))
            return foldInside;
          if (type.name == "BlockComment")
            return (tree) => ({ from: tree.from + 2, to: tree.to - 2 });
          return void 0;
        }),
        /* @__PURE__ */ styleTags({
          "const macro_rules mod struct union enum type fn impl trait let use crate static": tags.definitionKeyword,
          "pub unsafe async mut extern default move": tags.modifier,
          "for if else loop while match continue break return await": tags.controlKeyword,
          "as in ref": tags.operatorKeyword,
          "where _ crate super dyn": tags.keyword,
          "self": tags.self,
          String: tags.string,
          RawString: /* @__PURE__ */ tags.special(tags.string),
          Boolean: tags.bool,
          Identifier: tags.variableName,
          "CallExpression/Identifier": /* @__PURE__ */ tags.function(tags.variableName),
          BoundIdentifier: /* @__PURE__ */ tags.definition(tags.variableName),
          LoopLabel: tags.labelName,
          FieldIdentifier: tags.propertyName,
          "CallExpression/FieldExpression/FieldIdentifier": /* @__PURE__ */ tags.function(tags.propertyName),
          Lifetime: /* @__PURE__ */ tags.special(tags.variableName),
          ScopeIdentifier: tags.namespace,
          TypeIdentifier: tags.typeName,
          "MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier": tags.macroName,
          "MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier": tags.macroName,
          '"!"': tags.macroName,
          UpdateOp: tags.updateOperator,
          LineComment: tags.lineComment,
          BlockComment: tags.blockComment,
          Integer: tags.integer,
          Float: tags.float,
          ArithOp: tags.arithmeticOperator,
          LogicOp: tags.logicOperator,
          BitOp: tags.bitwiseOperator,
          CompareOp: tags.compareOperator,
          "=": tags.definitionOperator,
          ".. ... => ->": tags.punctuation,
          "( )": tags.paren,
          "[ ]": tags.squareBracket,
          "{ }": tags.brace,
          ".": tags.derefOperator,
          "&": tags.operator,
          ", ; ::": tags.separator
        })
      ]
    }),
    languageData: {
      commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
      indentOnInput: /^\s*(?:\{|\})$/
    }
  });
  function rust() {
    return new LanguageSupport(rustLanguage);
  }
  var slicing_paper_default = "@inproceedings{horwitz1988interprocedural,\n  title={Interprocedural slicing using dependence graphs},\n  author={Horwitz, Susan and Reps, Thomas and Binkley, David},\n  booktitle={Proceedings of the ACM SIGPLAN 1988 conference on Programming Language design and Implementation},\n  pages={35--46},\n  year={1988}\n}\n\n@article{ferrante1987program,\n  title={The program dependence graph and its use in optimization},\n  author={Ferrante, Jeanne and Ottenstein, Karl J and Warren, Joe D},\n  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},\n  volume={9},\n  number={3},\n  pages={319--349},\n  year={1987},\n  publisher={ACM New York, NY, USA}\n}\n\n@article{cooper2001simple,\n  title={A simple, fast dominance algorithm},\n  author={Cooper, Keith D and Harvey, Timothy J and Kennedy, Ken},\n  journal={Software Practice & Experience},\n  volume={4},\n  number={1-10},\n  pages={1--8},\n  year={2001}\n}\n\n@article{weiser1984program,\n  title={Program slicing},\n  author={Weiser, Mark},\n  journal={IEEE Transactions on software engineering},\n  number={4},\n  pages={352--357},\n  year={1984},\n  publisher={IEEE}\n}\n\n@article{weiser1982programmers,\n  title={Programmers use slices when debugging},\n  author={Weiser, Mark},\n  journal={Communications of the ACM},\n  volume={25},\n  number={7},\n  pages={446--452},\n  year={1982},\n  publisher={ACM New York, NY, USA}\n}\n\n@article{xu2005brief,\n  title={A brief survey of program slicing},\n  author={Xu, Baowen and Qian, Ju and Zhang, Xiaofang and Wu, Zhongqiang and Chen, Lin},\n  journal={ACM SIGSOFT Software Engineering Notes},\n  volume={30},\n  number={2},\n  pages={1--36},\n  year={2005},\n  publisher={ACM New York, NY, USA}\n}\n\n@article{silva2012vocabulary,\n  title={A vocabulary of program slicing-based techniques},\n  author={Silva, Josep},\n  journal={ACM computing surveys (CSUR)},\n  volume={44},\n  number={3},\n  pages={1--41},\n  year={2012},\n  publisher={ACM New York, NY, USA}\n}\n\n@inproceedings{parnin2011automated,\n  title={Are automated debugging techniques actually helping programmers?},\n  author={Parnin, Chris and Orso, Alessandro},\n  booktitle={Proceedings of the 2011 international symposium on software testing and analysis},\n  pages={199--209},\n  year={2011}\n}\n\n@inproceedings{cuoq2012frama,\n  title={Frama-c},\n  author={Cuoq, Pascal and Kirchner, Florent and Kosmatov, Nikolai and Prevosto, Virgile and Signoles, Julien and Yakobowski, Boris},\n  booktitle={International conference on software engineering and formal methods},\n  pages={233--247},\n  year={2012},\n  organization={Springer}\n}\n\n@inproceedings{balakrishnan2005codesurfer,\n  title={Codesurfer/x86\u2014a platform for analyzing x86 executables},\n  author={Balakrishnan, Gogul and Gruian, Radu and Reps, Thomas and Teitelbaum, Tim},\n  booktitle={International Conference on Compiler Construction},\n  pages={250--254},\n  year={2005},\n  organization={Springer}\n}\n\n@inproceedings{zhao2018parallel,\n  title={Parallel sparse flow-sensitive points-to analysis},\n  author={Zhao, Jisheng and Burke, Michael G and Sarkar, Vivek},\n  booktitle={Proceedings of the 27th International Conference on Compiler Construction},\n  pages={59--70},\n  year={2018}\n}\n\n@inproceedings{might2010resolving,\n  title={Resolving and exploiting the k-CFA paradox: illuminating functional vs. object-oriented program analysis},\n  author={Might, Matthew and Smaragdakis, Yannis and Van Horn, David},\n  booktitle={Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation},\n  pages={305--315},\n  year={2010}\n}\n\n@inproceedings{clarke1998ownership,\n  title={Ownership types for flexible alias protection},\n  author={Clarke, David G and Potter, John M and Noble, James},\n  booktitle={Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},\n  pages={48--64},\n  year={1998}\n}\n\n@inproceedings{grossman2002region,\n  title={Region-based memory management in Cyclone},\n  author={Grossman, Dan and Morrisett, Greg and Jim, Trevor and Hicks, Michael and Wang, Yanling and Cheney, James},\n  booktitle={Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation},\n  pages={282--293},\n  year={2002}\n}\n\n@inproceedings{agrawal2001evaluating,\n  title={Evaluating explicitly context-sensitive program slicing},\n  author={Agrawal, Gagan and Guo, Liang},\n  booktitle={Proceedings of the 2001 ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools and engineering},\n  pages={6--12},\n  year={2001}\n}\n\n@article{girard1987linear,\n  title={Linear logic},\n  author={Girard, Jean-Yves},\n  journal={Theoretical computer science},\n  volume={50},\n  number={1},\n  pages={1--101},\n  year={1987},\n  publisher={Elsevier}\n}\n\n@article{weiss2019oxide,\n  title={Oxide: The essence of rust},\n  author={Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Matsakis, Nicholas D and Ahmed, Amal},\n  journal={arXiv preprint arXiv:1903.00982},\n  year={2019}\n}\n\n@inproceedings{rountev1999data,\n  title={Data-flow analysis of program fragments},\n  author={Rountev, Atanas and Ryder, Barbara G and Landi, William},\n  booktitle={Software Engineering\u2014ESEC/FSE\u201999},\n  pages={235--252},\n  year={1999},\n  organization={Springer}\n}\n\n@inproceedings{cousot2002modular,\n  title={Modular static program analysis},\n  author={Cousot, Patrick and Cousot, Radhia},\n  booktitle={International Conference on Compiler Construction},\n  pages={159--179},\n  year={2002},\n  organization={Springer}\n}\n\n@inproceedings{gulwani2007computing,\n  title={Computing procedure summaries for interprocedural analysis},\n  author={Gulwani, Sumit and Tiwari, Ashish},\n  booktitle={European Symposium on Programming},\n  pages={253--267},\n  year={2007},\n  organization={Springer}\n}\n\n@inproceedings{yorsh2008generating,\n  title={Generating precise and concise procedure summaries},\n  author={Yorsh, Greta and Yahav, Eran and Chandra, Satish},\n  booktitle={Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},\n  pages={221--234},\n  year={2008}\n}\n\n@book{sharir1978two,\n  title={Two approaches to interprocedural data flow analysis},\n  author={Sharir, Micha and Pnueli, Amir and others},\n  year={1978},\n  publisher={New York University. Courant Institute of Mathematical Sciences}\n}\n\n@inproceedings{tang2015summary,\n  title={Summary-based context-sensitive data-dependence analysis in presence of callbacks},\n  author={Tang, Hao and Wang, Xiaoyin and Zhang, Lingming and Xie, Bing and Zhang, Lu and Mei, Hong},\n  booktitle={Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},\n  pages={83--95},\n  year={2015}\n}\n\n@inproceedings{madhavan2012modular,\n  title={Modular heap analysis for higher-order programs},\n  author={Madhavan, Ravichandhran and Ramalingam, Ganesan and Vaswani, Kapil},\n  booktitle={International Static Analysis Symposium},\n  pages={370--387},\n  year={2012},\n  organization={Springer}\n}\n \n@inproceedings{wadler1989theorems,\n  title={Theorems for free!},\n  author={Wadler, Philip},\n  booktitle={Proceedings of the fourth international conference on Functional programming languages and computer architecture},\n  pages={347--359},\n  year={1989}\n}\n\n@article{tofte1997region,\n  title={Region-based memory management},\n  author={Tofte, Mads and Talpin, Jean-Pierre},\n  journal={Information and computation},\n  volume={132},\n  number={2},\n  pages={109--176},\n  year={1997},\n  publisher={Elsevier}\n}\n\n@misc{nllrfc,\n    author={Niko Matsakis},\n    title={Non-lexical lifetimes},\n    year={2017},\n    url={https://rust-lang.github.io/rfcs/2094-nll.html}\n}\n\n@misc{polonius,\n  author={Niko Matsakis},\n  title={An alias-based formulation of the borrow checker},\n  year={2018},\n  url={http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker}\n}\n\n@article{jung2017rustbelt,\n  title={RustBelt: Securing the foundations of the Rust programming language},\n  author={Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},\n  journal={Proceedings of the ACM on Programming Languages},\n  volume={2},\n  number={POPL},\n  pages={1--34},\n  year={2017},\n  publisher={ACM New York, NY, USA}\n}\n\n@book{appel1997modern,\n  title={Modern Compiler Implementation in ML},\n  author={Appel, Andrew W},\n  year={1997},\n  publisher={Cambridge University Press}\n}\n\n@misc{mirguide,\n    title={The MIR (Mid-level IR) - Guide to Rustc Development},\n    year={2021},\n    url={https://rustc-dev-guide.rust-lang.org/mir/index.html},\n}\n\n@inproceedings{cytron1989efficient,\n  title={An efficient method of computing static single assignment form},\n  author={Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K and Wegman, Mark N and Zadeck, F Kenneth},\n  booktitle={Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},\n  pages={25--35},\n  year={1989}\n}\n\n@misc{cloc,\n    title={cloc: Count Lines of Code},\n    author={Al Danial},\n    year={2021},\n    url={https://github.com/AlDanial/cloc}\n}\n\n@mastersthesis{llvmslicer,\n author={Marek Chalupa},\n title = {Slicing of LLVM bitcode},\n school = {Masaryk University},\n year = {2016},\n} \n\n@inproceedings{jayaraman2005kaveri,\n  title={Kaveri: Delivering the indus java program slicer to eclipse},\n  author={Jayaraman, Ganeshan and Ranganath, Venkatesh Prasad and Hatcliff, John},\n  booktitle={International Conference on Fundamental Approaches to Software Engineering},\n  pages={269--272},\n  year={2005},\n  organization={Springer}\n}\n\n@inproceedings{abadi1999core,\n  title={A core calculus of dependency},\n  author={Abadi, Martin and Banerjee, Anindya and Heintze, Nevin and Riecke, Jon G},\n  booktitle={Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},\n  pages={147--160},\n  year={1999}\n}\n\n@phdthesis{andersen1994program,\n  title={Program analysis and specialization for the C programming language},\n  author={Andersen, Lars Ole},\n  year={1994},\n  school={Citeseer}\n}\n\n@inproceedings{steensgaard1996points,\n  title={Points-to analysis in almost linear time},\n  author={Steensgaard, Bjarne},\n  booktitle={Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},\n  pages={32--41},\n  year={1996}\n}\n\n@article{pottier2003information,\n  title={Information flow inference for ML},\n  author={Pottier, Francois and Simonet, Vincent},\n  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},\n  volume={25},\n  number={1},\n  pages={117--158},\n  year={2003},\n  publisher={ACM New York, NY, USA}\n}\n\n@inproceedings{campbell2018cognitive,\n  title={Cognitive complexity: An overview and evaluation},\n  author={Campbell, G Ann},\n  booktitle={Proceedings of the 2018 international conference on technical debt},\n  pages={57--58},\n  year={2018}\n}\n\n@article{smaragdakis2015pointer,\n  title={Pointer analysis},\n  author={Smaragdakis, Yannis and Balatsouras, George},\n  journal={Foundations and Trends in Programming Languages},\n  volume={2},\n  number={1},\n  pages={1--69},\n  year={2015},\n  publisher={Now Publishers Inc. Hanover, MA, USA}\n}\n\n@article{astrauskas2019leveraging,\n  title={Leveraging Rust types for modular specification and verification},\n  author={Astrauskas, Vytautas and M\xFCller, Peter and Poli, Federico and Summers, Alexander J},\n  journal={Proceedings of the ACM on Programming Languages},\n  volume={3},\n  number={OOPSLA},\n  pages={1--30},\n  year={2019},\n  publisher={ACM New York, NY, USA}\n}\n\n@article{jung2020stacked,\n  title={Stacked borrows: an aliasing model for Rust},\n  author={Jung, Ralf and Dang, Hoang-Hai and Kang, Jeehoon and Dreyer, Derek},\n  journal={Proceedings of the ACM on Programming Languages},\n  volume={4},\n  number={POPL},\n  pages={1--32},\n  year={2020},\n  publisher={ACM New York, NY, USA}\n}\n\n@article{astrauskas2020programmers,\n  title={How do programmers use unsafe rust?},\n  author={Astrauskas, Vytautas and Matheja, Christoph and Poli, Federico and M\xFCller, Peter and Summers, Alexander J},\n  journal={Proceedings of the ACM on Programming Languages},\n  volume={4},\n  number={OOPSLA},\n  pages={1--27},\n  year={2020},\n  publisher={ACM New York, NY, USA}\n}\n\n@article{dillig2011precise,\n  title={Precise and compact modular procedure summaries for heap manipulating programs},\n  author={Dillig, Isil and Dillig, Thomas and Aiken, Alex and Sagiv, Mooly},\n  journal={ACM SIGPLAN Notices},\n  volume={46},\n  number={6},\n  pages={567--577},\n  year={2011},\n  publisher={ACM New York, NY, USA}\n}";
  var import_axios = __toModule2(require_axios2());
  var SLICER_ENDPOINT = "https://slicer.willcrichton.net";
  var SliceListing = ({ code, prelude }) => /* @__PURE__ */ import_react10.default.createElement(WT, null, () => {
    let logger = kt(Jl);
    let loader = (0, import_react10.useContext)(ch);
    let [editor, set_editor] = (0, import_react10.useState)(null);
    let get_slice = async (range) => {
      if (!editor) {
        return;
      }
      editor.dispatch({
        effects: jc.of(null)
      });
      let program = [prelude || ""].concat(editor.state.doc.toJSON()).join("\n");
      program = `fn main() { ${program} }`;
      let start2 = EA(editor, range[0]);
      let end = EA(editor, range[1]);
      if (start2.line != end.line) {
        throw "Start line different from end line";
      }
      let request = { program, line: start2.line, start: start2.col, end: end.col };
      loader.set_loaded(false);
      let response = await import_axios.default.post(SLICER_ENDPOINT, request);
      loader.set_loaded(true);
      if (response.data.error) {
        logger.log(() => /* @__PURE__ */ import_react10.default.createElement("pre", {
          className: "textcolor-error",
          style: { whiteSpace: "pre-wrap", margin: 0 }
        }, response.data.error), 15e3);
        return;
      }
      let ranges = response.data.ranges;
      let highlights = ranges.filter((range2) => range2.filename.includes("main.rs")).filter((range2) => !(range2.start_line == request.line && range2.start_col == request.start || range2.start_line == 0)).map((range2) => {
        let from = TA(editor, {
          line: range2.start_line,
          col: range2.start_col
        });
        let to = TA(editor, {
          line: range2.end_line,
          col: range2.end_col
        });
        return Hc.of({ from, to, color: "peach" });
      });
      highlights.push(Hc.of({
        from: range[0],
        to: range[1],
        color: "forest-green"
      }));
      editor.dispatch({
        effects: highlights,
        selection: { anchor: editor.state.selection.main.from }
      });
    };
    return /* @__PURE__ */ import_react10.default.createElement("div", null, /* @__PURE__ */ import_react10.default.createElement(MA, {
      editable: true,
      code,
      extensions: [
        EditorView.updateListener.of((update) => {
          if (update.docChanged) {
            editor.dispatch({ effects: jc.of(null) });
          }
        })
      ],
      onLoad: (e) => {
        editor = e;
        set_editor(e);
      },
      delimiters: {
        delimiters: [["@", "@"]],
        onParse: ([range]) => {
          get_slice(range);
        }
      }
    }), /* @__PURE__ */ import_react10.default.createElement("button", {
      onClick: () => {
        let selection = editor.state.selection;
        let range = selection.main;
        if (!range.empty) {
          get_slice([range.from, range.to]);
        } else {
          logger.log(() => "You have to select a variable to slice on.");
        }
      }
    }, "Slice"));
  });
  var num_principles = 0;
  var Principle = ({ type, text }) => {
    let [num] = (0, import_react10.useState)(() => {
      num_principles += 1;
      return num_principles;
    });
    let Label = () => /* @__PURE__ */ import_react10.default.createElement(import_react10.default.Fragment, null, "Principle ", num);
    let Text2 = () => /* @__PURE__ */ import_react10.default.createElement(import_react10.default.Fragment, null, text);
    return /* @__PURE__ */ import_react10.default.createElement(G0, {
      name: `prin:${type}`,
      Label,
      Tooltip: Text2,
      block: true
    }, /* @__PURE__ */ import_react10.default.createElement("p", {
      style: { margin: "1rem" }
    }, /* @__PURE__ */ import_react10.default.createElement("strong", null, "Principle ", num), " (Slicing principle for ", type, "). ", /* @__PURE__ */ import_react10.default.createElement("em", null, /* @__PURE__ */ import_react10.default.createElement(Text2, null))));
  };
  var import_lodash = __toModule2(require_lodash());
  var r2 = String.raw;
  var get_relative_midpoint = (container, el, top2) => {
    let cr2 = container.getBoundingClientRect();
    let er = el.getBoundingClientRect();
    let x = er.x - cr2.x;
    let y = er.y - cr2.y;
    let mx = x + er.width / 2;
    let my = top2 ? y : y + er.height;
    return { x: mx, y: my };
  };
  var SyntaxDiagram = () => {
    let container_ref = (0, import_react11.useRef)(null);
    let label_texts = [
      r2`Variable $\vr$`,
      r2`Sized Type $\tys$`,
      r2`Expression $\expr$`,
      r2`Place $\plc$`,
      r2`Place Expr $\pexp$`,
      r2`Ownership Qual. $\ownq$`,
      r2`Provenance $\prov$`
    ];
    let labels = label_texts.map((text, i) => {
      let ref = (0, import_react11.useRef)(null);
      let pos = i < 4 ? "top" : "bottom";
      let label = /* @__PURE__ */ import_react11.default.createElement("span", {
        ref,
        key: i,
        className: "diagram-label"
      }, /* @__PURE__ */ import_react11.default.createElement(yA, null, r2`\text{${text}}`));
      return { label, ref, pos };
    });
    let overlay = Uo(null, 1e3, () => {
      let container = container_ref.current;
      let elems = container.querySelectorAll("[data-index]");
      let elems_arr = import_lodash.default.sortBy(Array.from(elems), (elem) => {
        let index = parseInt(elem.dataset.index);
        return index;
      });
      let arrows = Ul(elems_arr, labels).map(([dst, label], i) => {
        let src = label.ref.current;
        let spt = get_relative_midpoint(container, src, label.pos == "bottom");
        let dpt = get_relative_midpoint(container, dst, label.pos == "top");
        let path = `M${spt.x},${spt.y} L${dpt.x},${dpt.y}`;
        return /* @__PURE__ */ import_react11.default.createElement("path", {
          key: i,
          d: path,
          style: { stroke: "#ccc", strokeWidth: "1.25px" }
        });
      });
      return /* @__PURE__ */ import_react11.default.createElement("svg", {
        width: "700",
        height: "300",
        style: { position: "absolute", left: 0, top: 0 }
      }, /* @__PURE__ */ import_react11.default.createElement("defs", null, /* @__PURE__ */ import_react11.default.createElement("marker", {
        id: "arrow",
        markerWidth: "13",
        markerHeight: "13",
        orient: "auto",
        refX: "2",
        refY: "6"
      }, /* @__PURE__ */ import_react11.default.createElement("path", {
        d: "M2,2 L2,11 L10,6 L2,2",
        style: { fill: "#ccc" }
      }))), arrows);
    });
    return /* @__PURE__ */ import_react11.default.createElement("div", {
      id: "syntax-diagram",
      ref: container_ref,
      style: { textAlign: "center", position: "relative", marginBottom: "1rem" }
    }, /* @__PURE__ */ import_react11.default.createElement("style", null, `
    .diagram-label { padding: 2px 4px; margin: 5px 10px; }
    .diagram-hl {
      border: 1px solid #ccc;
      border-radius: 2px;
    }
    .gutter.top {
      margin-bottom: 80px;
    }
    .gutter.bottom {
      margin-top: 30px;
    }
    `), overlay, /* @__PURE__ */ import_react11.default.createElement("div", {
      className: "gutter top"
    }, labels.filter(({ pos }) => pos == "top").map(({ label }) => label)), /* @__PURE__ */ import_react11.default.createElement(Aa, {
      style: { height: "5rem", marginTop: "3rem" }
    }, `
    \\newcommand{\\lbl}[2]{\\htmlClass{diagram-hl}{\\htmlData{index=#1}{#2}}}
    \\begin{aligned}
    &\\exprlet
      {\\lbl{0}{a}}{\\lbl{1}{\\tystup{\\uty, \\uty}}}
      {\\lbl{2}{\\exprtup{\\exprconst{\\constnum{0}}, \\exprconst{\\constnum{1}}}}}{
    \\\\ \\exprprov{\\r_1, \\r_2}{
      \\\\ ~~ \\exprlet
        {b}{\\tysref{\\r_2}{\\lbl{5}{\\uniq}}{\\uty}}
        {\\exprref{\\lbl{6}{\\r_1}}{\\uniq}{\\lbl{3}{a.0}}}{
      \\\\ ~~ \\exprpexpasgn{\\lbl{4}{\\pexpderef{b}}}{a.1} \\\\
      }}
    }
    \\end{aligned}`), /* @__PURE__ */ import_react11.default.createElement("div", {
      className: "gutter bottom"
    }, labels.filter(({ pos }) => pos == "bottom").map(({ label }) => label)));
  };
  var $T = (tex) => (props) => /* @__PURE__ */ import_react11.default.createElement(yA, {
    ...props
  }, r2`\text{${tex}}`);
  var AssignStaticRule = () => /* @__PURE__ */ import_react11.default.createElement(lT, {
    id: "assign-static-rule",
    Top: ({ reg }) => /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, /* @__PURE__ */ import_react11.default.createElement(sT, null, /* @__PURE__ */ import_react11.default.createElement(oT, null, /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\expr$ has sized type $\tys$, making $\stackenv_1$`),
      Inside: $T(r2`$\tc{\fenv}{\tyenv}{\stackenv}{\expr}{\tys}{\stackenv'}$`)
    })), /* @__PURE__ */ import_react11.default.createElement(oT, null, /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\plc$ has maybe-dead type $\tysx$ in $\stackenv_1$`),
      Inside: $T(r2`$\stackenv_1(\plc) = \tysx$`)
    }))), /* @__PURE__ */ import_react11.default.createElement(sT, null, /* @__PURE__ */ import_react11.default.createElement(oT, null, "(", /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\plc$ is dead`),
      Inside: $T(r2`$\tysx = \tyd$`)
    }), /* @__PURE__ */ import_react11.default.createElement(yA, {
      style: { margin: "0 0.5rem" }
    }, r2`\vee`), /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(`$\\plc$ is $\\uniq$-safe`),
      Inside: $T(`$\\ownsafe{\\tyenv}{\\stackenv_1}{\\uniq}{\\plc}{\\{\\loanform{\\uniq}{\\plc}\\}}$`)
    }), ")"), /* @__PURE__ */ import_react11.default.createElement(oT, null, /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\tys$ is a subtype of $\tysx$, making $\stackenv'$`),
      Inside: $T(r2`$\subtype{\tyenv}{\stackenv_1}{\tys}{\tysx}{\stackenv'}$`)
    })))),
    Bot: ({ reg }) => /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\exprplcasgn{\plc}{\expr}$ has type $\tysbase{\tybunit}$ and adds $\plc : \tys$ to $\stackenv'$`),
      Inside: $T(r2`
        $\tc{\fenv}{\tyenv}{\stackenv}
          {\exprplcasgn{\plc}{\expr}}
          {\tysbase{\tybunit}}
          {\stackenv'[\plc \mapsto \tys] \triangleright \plc}$
        `)
    })
  });
  var AssignDynamicRule = () => /* @__PURE__ */ import_react11.default.createElement(lT, {
    Top: ({ reg }) => /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\pexp$ points to $\plc$ in $\stack$ with root $\vr$ and context $\valuectx$`),
      Inside: $T(r2`$\pointsto{\stack}{\pexp}{\pctx{\plc}{\vr}}{\valuectx}$`)
    }),
    Bot: ({ reg }) => /* @__PURE__ */ import_react11.default.createElement(aT, {
      registerToggle: reg,
      Outside: $T(r2`$\exprpexpasgn{\pexp}{v}$ sets $\plc$ to $v$ in $\stack$ by setting $x$ to $\valueplug{\valuectx}{v}$`),
      Inside: $T(r2`$\stepsto{\fenv}{\stack}{\exprpexpasgn{\pexp}{v}}{\stack[\vr \mapsto \valueplug{\valuectx}{v}]}{\exprconst{\constunit}}$`)
    })
  });
  var r3 = String.raw;
  var Oxide = new gf([
    ["Variable", "vr", "x", []],
    ["Function", "fname", "f", []],
    ["Number", "num", "n", []],
    ["Path", "path", "q", [
      [r3`empty`, 0, r3`\varepsilon`, []],
      [r3`elem`, 2, r3`{#1}.{#2}`, [r3`\num`, r3`\path`]]
    ]],
    ["Place", "plc", r3`\pi`, [
      [r3`form`, 2, r3`{#1}.{#2}`, [r3`\vr`, r3`\path`]]
    ]],
    ["Place Expression", "pexp", `p`, [
      [`var`, 1, r3`#1`, [r3`\vr`]],
      [`elem`, 2, r3`{#1}.{#2}`, [r3`\pexp`, r3`\num`]],
      [`deref`, 1, r3`\ast {#1}`, [r3`\pexp`]]
    ]],
    ["Constant", "const", "c", [
      [`unit`, 0, "()", []],
      [`num`, 1, "#1", [r3`\num`]],
      [`true`, 0, r3`\msf{true}`, []],
      [`false`, 0, r3`\msf{false}`, []]
    ]],
    ["Concrete Provenance", "concrprov", "r", []],
    ["Abstract Provenance", "abstrprov", r3`\varrho`, []],
    ["Provenance", "prov", r3`\rho`, [
      ["concr", 1, "#1", [r3`\concrprov`]],
      ["abstr", 1, "#1", [r3`\abstrprov`]]
    ]],
    ["Ownership Qualifier", "ownq", r3`\omega`, [
      ["shrd", 0, r3`\msf{shrd}`, []],
      ["uniq", 0, r3`\msf{uniq}`, []]
    ]],
    ["Base Type", "tyb", r3`\tau^\textsc{B}`, [
      ["unit", 0, r3`\msf{unit}`, []],
      ["num", 0, r3`\msf{u32}`, []],
      ["bool", 0, r3`\msf{bool}`, []]
    ]],
    ["Sized Type", "tys", r3`\tau^\textsc{SI}`, [
      ["base", 1, "{#1}", [r3`\tyb`]],
      ["ref", 3, r3`\&{#1}~{#2}~{#3}`, [r3`\prov`, r3`\ownq`, r3`\tau^\textsc{XI}`]],
      ["tup", 1, r3`({#1})`, [r3`\tys{}_1, \ldots, \tys{}_n`]]
    ]],
    ["Expression", "expr", "e", [
      ["const", 1, "{#1}", [r3`\const`]],
      ["pexp", 1, "{#1}", [r3`\pexp`]],
      ["ref", 3, r3`\&{#1}~{#2}~{#3}`, [r3`\concrprov`, r3`\ownq`, r3`\pexp`]],
      [
        "ite",
        3,
        r3`\msf{if}~{#1}~\{\,{#2}\,\}~\msf{else}~\{\,{#3}\,\}`,
        [r3`\expr_1`, r3`\expr_2`, r3`\expr_3`]
      ],
      [
        "let",
        4,
        r3`\msf{let}~{#1} : {#2} = {#3}; ~ {#4}`,
        [r3`\expr_1`, r3`\tys`, r3`\expr_2`, r3`\expr_3`]
      ],
      ["plcasgn", 2, r3`{#1} \mathrel{:=} {#2}`, [r3`\plc`, r3`\expr`]],
      ["pexpasgn", 2, r3`{#1} \mathrel{:=} {#2}`, [r3`\pexp`, r3`\expr`]],
      ["seq", 2, r3`{#1};~{#2}`, [r3`\expr_1`, r3`\expr_2`]],
      [
        "call",
        5,
        r3`{#1}\left\langle{#2}, {#3}, {#4}\right\rangle\left({#5}\right)`,
        [r3`\fname`, r3`\overline{\Phi}`, r3`\overline{\rho}`, r3`\overline{\tau}`, r3`\plc`]
      ],
      ["tup", 1, "({#1})", [r3`\expr_1, \ldots, \expr_n`]],
      ["prov", 2, r3`\msf{letprov}\langle{#1}\rangle\,\{{#2}\}`, [r3`\concrprov`, r3`\expr`]]
    ]],
    ["Global Entries", "fdef", r3`\varepsilon`, [
      [
        "form",
        9,
        r3`\msf{fn}~{#1}\left\langle {#2}, {#3}, {#4}, \right\rangle\left({#5} : {#6}\right) \rightarrow {#7} ~ \msf{where} ~ {#8} ~ \{\,{#9}\,\}`,
        [
          r3`\fname`,
          r3`\overline{\psi}`,
          r3`\overline{\abstrprov}`,
          r3`\overline{\alpha}`,
          r3`\vr`,
          r3`\tys_a`,
          r3`\tys_r`,
          r3`\overline{\abstrprov_1 : \abstrprov_2}`,
          r3`\expr`
        ]
      ]
    ]],
    ["Global Environment", "fenv", r3`\Sigma`, [
      ["empty", 0, r3`\bullet`, []],
      ["with", 2, r3`{#1}, {#2}`, [r3`\fenv`, r3`\fdef`]]
    ]]
  ]);
  var OxideExtra = new gf([
    ["Dead Types", "tyd", r3`\tau^\textsc{SD}`, [
      ["s", 1, r3`{#1}^\dagger`, [r3`\tys`]],
      ["tup", 1, r3`({#1})`, [r3`\tyd_1, \ldots, \tyd_n`]]
    ]],
    ["Maybe Unsized Type", "tyx", r3`\tau^\textsc{XI}`, [
      ["s", 1, "{#1}", [r3`\tys`]],
      ["a", 1, "[{#1}]", [r3`\tys`]]
    ]],
    ["Maybe Dead Types", "tysx", r3`\tau^\textsc{SX}`, [
      ["s", 1, "{#1}", [r3`\tys`]],
      ["d", 1, "{#1}", [r3`\tyd`]],
      ["tup", 1, "({#1})", [r3`\tysx_1, \ldots, \tysx_n`]]
    ]],
    ["Type", "ty", r3`\tau`, [
      ["tyx", 1, "{#1}", [r3`\tyx`]],
      ["tysx", 1, "{#1}", [r3`\tysx`]]
    ]],
    ["Loan", "loan", r3`\ell`, [
      [`form`, 2, r3`\,^{#1}{#2}`, [r3`\ownq`, r3`\pexp`]]
    ]],
    ["Frame Var", "frmvar", r3`\varphi`, []],
    ["Frame Typing", "ft", r3`\mathcal{F}`, [
      ["empty", 0, r3`\bullet`, []],
      ["wty", 3, "{#1}, {#2} : {#3}", [r3`\ft`, r3`\vr`, r3`\tyx`]],
      [
        "wlf",
        3,
        r3`{#1}, {#2} \mapsto {#3}`,
        [r3`\ft`, r3`\concrprov`, r3`\setof{\loan}`]
      ]
    ]],
    ["Stack Typing", "stackenv", r3`\Gamma`, [
      ["empty", 0, r3`\bullet`, []],
      ["wfr", 2, r3`{#1} \mathrel{\natural} {#2}`, [r3`\stackenv`, r3`\ft`]]
    ]],
    ["Kind", "kind", r3`\kappa`, [
      ["base", 0, r3`\bigstar`, []],
      ["prv", 0, r3`\msf{PRV}`, []],
      ["frm", 0, r3`\msf{FRM}`, []]
    ]],
    ["Type Var", "tyvar", r3`\alpha`, []],
    ["Type Environment", "tyenv", r3`\Delta`, [
      ["empty", 0, r3`\bullet`, []],
      ["wtvar", 2, r3`{#1}, {#2} : \kindbase`, [r3`\tyenv`, r3`\tyvar`]],
      ["wprv", 2, r3`{#1}, {#2} : \kindprv`, [r3`\tyenv`, r3`\abstrprov`]],
      ["wfrm", 2, r3`{#1}, {#2} : \kindfrm`, [r3`\tyenv`, r3`\frmvar`]],
      ["wconstr", 3, r3`{#1}, {#2} \mathrel{:>} {#3}`, [r3`\tyenv`, r3`\abstrprov`, r3`\abstrprov'`]]
    ]]
  ]);
  function MDXContent(props = {}) {
    const _components = Object.assign({
      p: "p",
      em: "em",
      ul: "ul",
      li: "li",
      ol: "ol",
      code: "code"
    }, useMDXComponents(), props.components), { ListingConfigure, Title, Authors, Affiliation, Institution, Author, Name, Abstract, $$: $$2, Section, SectionTitle, Ref, FootnoteDef, $: $2, Wrap, Row, Listing: Listing2, Center, Figure, Subfigure, Expandable, Caption, Definition: Definition2, Smallcaps, ToggleButton, Correspondence, Link, Theorem, References, wrapper: MDXLayout } = _components;
    const _content = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [(0, import_jsx_runtime.jsx)(ListingConfigure, {
        language: rust()
      }), "\n", (0, import_jsx_runtime.jsx)(Title, {
        children: "Modular Program Slicing Through Ownership"
      }), "\n", (0, import_jsx_runtime.jsx)(Authors, {
        children: (() => {
          let stanford = (0, import_jsx_runtime.jsx)(Affiliation, {
            children: (0, import_jsx_runtime.jsx)(Institution, {
              value: "Stanford University"
            })
          });
          let cispa = (0, import_jsx_runtime.jsx)(Affiliation, {
            children: (0, import_jsx_runtime.jsx)(Institution, {
              value: "CISPA Helmholtz Center for Information Security"
            })
          });
          return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
            children: [(0, import_jsx_runtime.jsxs)(Author, {
              children: [(0, import_jsx_runtime.jsx)(Name, {
                value: "Will Crichton"
              }), stanford]
            }), (0, import_jsx_runtime.jsxs)(Author, {
              children: [(0, import_jsx_runtime.jsx)(Name, {
                value: "Marco Patrignani"
              }), cispa]
            }), (0, import_jsx_runtime.jsxs)(Author, {
              children: [(0, import_jsx_runtime.jsx)(Name, {
                value: "Maneesh Agrawala"
              }), stanford]
            }), (0, import_jsx_runtime.jsxs)(Author, {
              children: [(0, import_jsx_runtime.jsx)(Name, {
                value: "Pat Hanrahan"
              }), stanford]
            })]
          });
        })()
      }), "\n", (0, import_jsx_runtime.jsx)(Abstract, {
        children: (0, import_jsx_runtime.jsx)(_components.p, {
          children: "Program slicing, or identifying the subset of a program relevant to a value, relies on understanding the dataflow of a program. In languages with mutable pointers and functions like C or Java, tracking dataflow has historically required whole-program analysis, which can be be slow and challenging to integrate in practice. Advances in type systems have shown how to modularly track dataflow through the concept of ownership. We demonstrate that ownership can modularize program slicing by using types to compute a provably sound and reasonably precise approximation of mutation. We present an algorithm for slicing Oxide, a formalized ownership-based language, and prove the algorithm's soundness as a form of noninterference. Then we describe an implementation of the algorithm for the Rust programming language, and show empirically that modular slices are the same as whole-program slices in 95.4% of slices drawn from large Rust codebases."
        })
      }), "\n", (0, import_jsx_runtime.jsx)($$2, {
        children: "\\newcommand{\\cmddef}[2]{\\htmlData{def=#1}{#2}}\n\\newcommand{\\textsc}[1]{\\text{\\tiny #1}}\n\\newcommand{\\msf}[1]{\\mathsf{#1}}\n\\newcommand{\\tc}[6]{{#1}; {#2}; {#3} \\vdash {#4} : {#5} \\Rightarrow {#6}}\n\\newcommand{\\ownsafe}[5]{{#1}; {#2} \\vdash_{#3} {#4} \\Rightarrow {#5}}\n\\newcommand{\\subtype}[5]{{#1}; {#2} \\vdash {#3} \\mathrel{\\footnotesize \\lesssim} {#4} \\Rightarrow {#5}}\n\\newcommand{\\stepsto}[5]{{#1} \\vdash ({#2};~{#3}) \\rightarrow ({#4};~{#5})}\n\\newcommand{\\evalsto}[5]{{#1} \\vdash ({#2};~{#3}) \\overset{\\footnotesize\\ast}{\\rightarrow} ({#4};~{#5})}\n\\newcommand{\\stack}[0]{\\sigma}\n\\newcommand{\\pctx}[2]{{#1}^{\\tiny\\square}[{#2}]}\n\\newcommand{\\valuectx}[0]{\\mathcal{V}}\n\\newcommand{\\valueplug}[2]{{#1}[{#2}]}\n\\newcommand{\\pointsto}[4]{{#1} \\vdash {#2} \\Downarrow {#3} \\times {#4}}\n\\newcommand{\\notdisjoint}[2]{{#1} \\sqcap {#2}}\n\\newcommand{\\disjoint}[2]{{#1} \\mathrel{\\#} {#2}}\n\\newcommand{\\refs}[2]{{#1}\\text{-}\\mathsf{refs}({#2})}\n\\newcommand{\\ownqleq}[2]{{#1} \\lesssim {#2}}\n\\newcommand{\\stackeq}[3]{{#1} \\mathrel{\\overset{#3}{\\sim}} {#2}}\n\\newcommand{\\allplaces}[2]{\\msf{all}\\text{-}\\msf{places}({#1}, {#2})}\n\\newcommand{\\setof}[1]{\\{\\overline{#1}\\}}\n\\newcommand{\\stepped}[1]{\\vec{#1}}\n\\newcommand{\\link}[2]{\\htmlClass{link type-#1}{#2}}\n\\newcommand{\\eqdef}{~\\mathrel{\\overset{\\msf{def}}{=}}~}"
      }), "\n", (0, import_jsx_runtime.jsx)(Oxide.Commands, {}), "\n", (0, import_jsx_runtime.jsx)(OxideExtra.Commands, {}), "\n", (0, import_jsx_runtime.jsx)($$2, {
        children: "\\newcommand{\\uty}{\\tybnum}\n\\newcommand{\\eref}[3]{\\tysref{#2}{#1}{#3}}\n\\newcommand{\\uniq}{\\ownquniq}\n\\newcommand{\\shrd}{\\ownqshrd}\n\\renewcommand{\\r}{\\concrprov}\n\\newcommand{\\loanset}{\\setof{\\loan}}\n\\newcommand{\\sty}{\\msf{String}}\n\\newcommand{\\mut}{\\msf{mut}}\n\\newcommand{\\any}{\\msf{any}}\n\\newcommand{\\arrg}{\\msf{arg}}\n\\newcommand{\\reff}{\\msf{ref}}"
      }), "\n", (0, import_jsx_runtime.jsxs)(Section, {
        name: "sec:intro",
        children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
          children: "Introduction"
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["Program slicing is the task of identifying the subset of a program relevant to computing a value of interest. The concept of slicing was introduced 40 years ago when ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "weiser1982programmers",
            full: "true"
          }), " demonstrated that programmers mentally construct slices while debugging. Since then, hundreds of papers have been published on implementing automated program slice, as surveyed by ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "xu2005brief",
            full: "true"
          }), " and ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "silva2012vocabulary",
            full: "true"
          }), '. Despite these efforts, a review of slicers found "slicing-based debugging techniques are rarely used in practice" ', (0, import_jsx_runtime.jsx)(Ref, {
            name: "parnin2011automated"
          }), (0, import_jsx_runtime.jsx)(Ref, {
            name: "footnote:1"
          }), "."]
        }), (0, import_jsx_runtime.jsx)(FootnoteDef, {
          name: "1",
          children: (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["The only open-source, functioning slicers the authors could find are Frama-C ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "cuoq2012frama"
            }), " and dg ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "llvmslicer"
            }), ". Slicing tools for Java like Kaveri ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "jayaraman2005kaveri"
            }), " no longer work. The most industrial-strength slicing tool, CodeSurfer ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "balakrishnan2005codesurfer"
            }), " was GrammaTech's proprietary technology and appears to no longer exist."]
          })
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["A major challenge for slicing is addressing the underlying program analysis problems. At a high level, slicing is about dataflow \u2014 if ", (0, import_jsx_runtime.jsx)($2, {
            children: "x"
          }), " is relevant, then any means by which data flows into ", (0, import_jsx_runtime.jsx)($2, {
            children: "x"
          }), " are also relevant. In today's programming languages, analyzing dataflow is difficult because of the interaction of two features: functions and pointers. For example, imagine slicing a value in a function ", (0, import_jsx_runtime.jsx)($2, {
            children: "f"
          }), " which calls a function ", (0, import_jsx_runtime.jsx)($2, {
            children: "g"
          }), ". In a language without side-effects, then the only relevance ", (0, import_jsx_runtime.jsx)($2, {
            children: "g"
          }), " could possibly have in ", (0, import_jsx_runtime.jsx)($2, {
            children: "f"
          }), " is its return value. But in a language that allows effects such as mutation on pointers, ", (0, import_jsx_runtime.jsx)($2, {
            children: "g"
          }), " could modify data used within ", (0, import_jsx_runtime.jsx)($2, {
            children: "f"
          }), ", requiring a pointer analysis. Moreover, if ", (0, import_jsx_runtime.jsx)($2, {
            children: "f"
          }), " is a higher-order function parameterized on ", (0, import_jsx_runtime.jsx)($2, {
            children: "g"
          }), ", then the slice must consider all the possible functions that ", (0, import_jsx_runtime.jsx)($2, {
            children: "g"
          }), " could be, i.e. control-flow analysis."]
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["The standard solution for analyzing programs with pointers and functions is ", (0, import_jsx_runtime.jsx)(_components.em, {
            children: "whole-program analysis"
          }), ". That is, for a given function of interest, analyze the definitions of all of the function's callers and callees in the current codebase. However, whole-program analysis suffers from a few logistical and conceptual issues:"]
        }), (0, import_jsx_runtime.jsxs)(_components.ul, {
          children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: [(0, import_jsx_runtime.jsx)(_components.em, {
              children: "Analysis time scales with the size of the whole program:"
            }), " the time complexity of whole-program analysis scales either polynomially or exponentially with the number of call sites in the program, depending on context-sensitivity ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "might2010resolving"
            }), ". In practice, this means more complex codebases can take substantially longer to analyze. For\ninstance, the recent PSEGPT pointer analysis tool ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "zhao2018parallel"
            }), " takes 1 second on a codebase of 282,000 lines of code and 3 minutes on a codebase of 2.2 million lines of code."]
          }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: [(0, import_jsx_runtime.jsx)(_components.em, {
              children: "Analysis requires access to source code for the whole program:"
            }), " an assumption of analyzing a whole program is that a whole program is actually accessible. However, many programs use libraries that are shipped as pre-compiled objects with no source code, either for reasons of efficiency or intellectual property."]
          }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: [(0, import_jsx_runtime.jsx)(_components.em, {
              children: "Analysis results are anti-modular:"
            }), " when analyzing a particular function, relying on calling contexts to analyze the function's inputs means that any results are not universal. Calling-context-sensitive analysis determine whether two pointers alias ", (0, import_jsx_runtime.jsx)(_components.em, {
              children: "in the context of the broader codebase"
            }), ", so alias analysis results can change due to modifications in code far away from the current module."]
          }), "\n"]
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["These issues are not new \u2014 ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "rountev1999data",
            full: "true"
          }), " and ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "cousot2002modular",
            full: "true"
          }), " observed the same two decades ago when arguing for modular static analysis. The key insight arising from their research is that static analysis can be modularized by computing ", (0, import_jsx_runtime.jsx)(_components.em, {
            children: "symbolic procedure summaries"
          }), ". For instance, ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "yorsh2008generating",
            full: "true"
          }), " show how to automatically summarize which inputs and outputs are possibly null for a given Java function. The analysis is modular because a function's summary can be computed only given the summaries, and not definitions, of callees in the function. In such prior work, the language of symbolic procedure summaries has been defined in a separate formal system from the programming language being analyzed, such as the micro-transformer framework of ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "yorsh2008generating",
            full: "true"
          }), "."]
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["Our work begins with the observation: ", (0, import_jsx_runtime.jsx)(_components.em, {
            children: "function type signatures are symbolic procedure summaries"
          }), ". The more expressive a language's type system, the more behavior that can be summarized by a type. Nearly all work on program slicing, dataflow analysis, and procedure summaries has operated on C, Java, or equivalents. These languages have impoverished type systems, and so any interesting static analysis requires a standalone abstract interpreter. However, if a language's type system were expressive enough to encode information about dataflow, then a function's type signature could be used to reason about the aliasing and side effects needed for slicing. Moreover, a function's type signature is required information for a compiler to export when\nbuilding a library. Using the type system for dataflow analysis therefore obviates the logistical challenge of integrating an external analysis tool into a complex build system."]
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["Today, the primary technique for managing dataflow with types is ", (0, import_jsx_runtime.jsx)(_components.em, {
            children: "ownership"
          }), ". Ownership is a concept that has emerged from several intersecting lines of research on linear logic ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "girard1987linear"
          }), ", class-based alias management ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "clarke1998ownership"
          }), ", and region-based memory management ", (0, import_jsx_runtime.jsx)(Ref, {
            name: "grossman2002region"
          }), ". Generally, ownership refers to a system where values are owned by an entity, which can temporarily or permanently transfer ownership to other entities. The type system then statically tracks the flow of ownership between entities. Ownership-based type systems enforce the invariant that values are not simultaneously aliased and mutated, either for the purposes of avoiding memory errors, data races, or abstraction violations."]
        }), (0, import_jsx_runtime.jsx)(_components.p, {
          children: "Our thesis is that ownership can modularize program slicing by using types to compute a provably sound and reasonably precise approximation of the necessary dataflow information. We build this thesis in five parts:"
        }), (0, import_jsx_runtime.jsxs)(_components.ol, {
          children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: ["We provide an intuition for the relationship between ownership and slicing by describing how ownership works in Rust, the only industrial-grade ownership-based programming language today (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:background"
            }), ")."]
          }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: ["We formalize an algorithm for modular static slicing as an extension to the type system of Oxide ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "weiss2019oxide"
            }), ", a formal model of Rust's static and dynamic semantics (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:model"
            }), " and ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:algorithm"
            }), ")."]
          }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: ["We prove the soundness of this algorithm as a form of noninterference, building on the connection between slicing and information flow established by ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "abadi1999core",
              full: "true"
            }), " (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:soundness"
            }), " and ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:appendix"
            }), ")."]
          }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: ["We describe an implementation of the slicing algorithm for Rust, translating the core insights of the algorithm to work on a lower-level control-flow graph (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:implementation"
            }), ")"]
          }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
            children: ["We evaluate the precision of the modular Rust slicer against a whole-program slicer on a dataset of 10 codebases with a total of 280k LOC. We find that modular slices are the same size as whole-program slices 95.4% of the time, and are on average 7.6% larger in the remaining 4.6% of cases (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:evaluation"
            }), ")."]
          }), "\n"]
        })]
      }), "\n", (0, import_jsx_runtime.jsxs)(Section, {
        name: "sec:background",
        children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
          children: "Principles"
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["A backwards static slice is the subset of a program that could influence a particular value (backwards) under any possible execution (static). A slice is defined with respect to a slicing criterion, which is a variable at a particular point in a program. In this section, we provide an intuition for how slices interact with different features of the Rust programming language, namely: places (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:places"
          }), "), references (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:pointers"
          }), "), function calls (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:funcalls"
          }), "), and interior mutability (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:intmut"
          }), ")."]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:places",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Places"
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "right",
            children: (0, import_jsx_runtime.jsx)(SliceListing, {
              code: `let mut x = 1;
let y = 2;
let z = 3;
x = y;
println!("{}", @x@);`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["A place is a reference to a concrete piece of data in memory, like a variable ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), " or path into a data structure ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x.field"
            }), ". Slices on places are defined by bindings, mutation, and control flow."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["For instance, the Rust snippet on the right shows the slice in orange of a place in green. The assignment ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x = y"
            }), " means ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y"
            }), " is relevant for the slice, so the statement ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "let y = 2"
            }), " is relevant as well. Because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "z"
            }), " is not used in the computation of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), ", then ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "let z = 3"
            }), ". is not relevant. Additionally, because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x = y"
            }), " overwrites the previous value of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), ", then the original assignment ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x = 1"
            }), " is not relevant either."]
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "left",
            children: (0, import_jsx_runtime.jsx)(SliceListing, {
              code: `let mut x = 1;
let mut y = 2;
if y > 0 { x = 3; }
else     { y = 4; }
println!("{}", @x@);`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["If a mutation is conditioned on a predicate (as in line 3 in the snippet on the left) then the predicate is relevant to the mutated place. In this example, because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x = 3"
            }), " is only executed if ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y > 0"
            }), ", then the value of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y"
            }), " (at the time-of-check) is relevant to the value of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), "."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Slices on composite data structures are defined by whether a mutation conflicts with a particular path into the data structure. For example, consider slicing on a tuple as in the three snippets below (note that ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.n"
            }), " gets the ", (0, import_jsx_runtime.jsx)($2, {
              children: "n"
            }), "-th field of the tuple ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t"
            }), "):"]
          }), (0, import_jsx_runtime.jsxs)(Row, {
            children: [(0, import_jsx_runtime.jsx)(SliceListing, {
              code: `let mut t = (0, 1, 2);
t = (3, 4, 5);
t.0 = 6;
t.1 = 7;
println!("{:?}", @t@);`
            }), (0, import_jsx_runtime.jsx)(SliceListing, {
              code: `let mut t = (0, 1, 2);
t = (3, 4, 5);
t.0 = 6;
t.1 = 7;
println!("{}", @t.0@);`
            }), (0, import_jsx_runtime.jsx)(SliceListing, {
              code: `let mut t = (0, 1, 2);
t = (3, 4, 5);
t.0 = 6;
t.1 = 7;
println!("{}", @t.2@);`
            })]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["In this program, when slicing on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t"
            }), ", changing the value of a field of a structure changes the value of the whole structure, so ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.1 = 7"
            }), " is part of the slice on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t"
            }), ". However, when slicing on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.0"
            }), ", the path ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.0"
            }), " is disjoint from the path ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.1"
            }), ", so ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.1 = 7"
            }), " is not part of the slice on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.0"
            }), ". Similarly, when slicing on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.2"
            }), ", the only relevant assignment is ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t = (3, 4, 5)"
            }), ". More generally, a place conflicts with another place if either's path is a prefix of the other's. For instance, ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.0"
            }), " conflicts with both ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t"
            }), " (parent) and ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.0.1"
            }), " (child) but not ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.1"
            }), " (sibling). This leads to the first slicing principle:"]
          }), (0, import_jsx_runtime.jsx)(Principle, {
            type: "places",
            text: "A mutation to a place is a mutation to all conflicting places."
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["This principle provides an intuition for making an algorithm that constructs slices. For instance, take the last example above on the left. On line 4, when ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.1"
            }), " is mutated, that mutation is registered as part of the slice on every conflicting place, specifically ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t"
            }), " and ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "t.1"
            }), "."]
          })]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:pointers",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "References"
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "Pointers are the first major challenge for slicing. A mutation to a dereferenced pointer\nis a mutation to any place that is possibly pointed-to, so such places must be known to\nthe slicer. For example:"
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "right",
            children: (0, import_jsx_runtime.jsx)(SliceListing, {
              code: `let mut x = 1;
let y = &mut x;
*y = 2;
let z = &x;
println!("{}", @*z@);`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Rust has two distinct types of pointers, which are called ", (0, import_jsx_runtime.jsx)("q", {
              children: "references"
            }), " to distinguish them from ", (0, import_jsx_runtime.jsx)("q", {
              children: "raw pointers"
            }), " with C-like behavior (discussed in ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:intmut"
            }), "). For a given type ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "T"
            }), ", there are immutable references of type ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&T"
            }), ", and\nmutable references of type ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&mut T"
            }), " which correspond respectively to the expressions\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&x"
            }), " and ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&mut x"
            }), ". Because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y"
            }), " points to ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), ", then the mutation\nthrough ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y"
            }), " is relevant to the read of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*z"
            }), ". We refer to the left-hand side of\nassignment statements like ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*y"
            }), " as ", (0, import_jsx_runtime.jsx)("q", {
              children: "place expressions"
            }), ", since they could include\ndereferences."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["The task of determining what a reference can point-to is called ", (0, import_jsx_runtime.jsx)(_components.em, {
              children: "pointer analysis"
            }), "\n. While many methods exist for pointer analysis ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "smaragdakis2015pointer"
            }), ", our\nfirst key insight is that Rust's ownership types implicitly perform a kind of modular\npointer analysis that we can leverage for slicing. To understand why, we first need to\ndescribe two ingredients: the goal, i.e. what ownership is trying to accomplish, and the\nmechanism, i.e. how ownership-checking is implemented in the type system."]
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "The core goal of ownership is eliminating simultaneous aliasing and mutation. In Rust,\nachieving this goal enables the use of references without garbage collection while\nretaining memory safety. For instance, these three classes of errors are all caught at\ncompile-time:"
          }), (0, import_jsx_runtime.jsxs)(Row, {
            children: [(0, import_jsx_runtime.jsx)(Listing2, {
              code: `// Dangling reference
let p = {
  let x = 1; &x
};
let y = *p;`
            }), (0, import_jsx_runtime.jsx)(Listing2, {
              code: `// Use-after-free
let d = tempdir();
let d2 = &d;
d.close();
let p = d2.path();`
            }), (0, import_jsx_runtime.jsx)(Listing2, {
              code: `// Iterator invalidation
let mut v = vec![1,2];
for x in v.iter() {
  v.push(*x);
}`
            })]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["From left-to-right: the dangling references is caught because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), " is deallocated at\nthe end of scope on line 4, which is a mutation, conflicting with the alias ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&x"
            }), ". The\nuse-after-free is caught because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "d.close()"
            }), " requires ownership of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "d"
            }), ", which\nprevents an alias ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "d2"
            }), " from being live. The iterator invalidation case is subtler:\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), " is a pointer to data within ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "v"
            }), ". However, ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "v.push(*x)"
            }), " could resize\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "v"
            }), " which would copy/deallocate all vector elements to a new heap location,\ninvalidating all pointers to ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "v"
            }), ". Hence ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "v.push(*x)"
            }), " is a simultaneous mutation\nand alias of the vector."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Catching these errors requires understanding which places are pointed by which references.\nFor instance, knowing that ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), " points to an element of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "v"
            }), " and not just any\narbitrary ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "i32"
            }), ". The key mechanism behind these ownership checks is\n", (0, import_jsx_runtime.jsx)(_components.em, {
              children: "lifetimes"
            }), "."]
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "left",
            children: (0, import_jsx_runtime.jsx)(Listing2, {
              code: `let mut x: i32 = 1;
let y: &'1 i32 = &'0 mut x;
*y = 2;
let z: &'3 i32 = &'2 x;
println!("{}", *z);`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Each reference expression and type has a corresponding lifetime, written explicitly in the\nsyntax ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'n"
            }), " on the left, where ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "n"
            }), ' is an arbitrary and unique number. The name\n"lifetime" implies a model of lifetimes as the live range of the reference. Prior work on\nregion-based memory management like ', (0, import_jsx_runtime.jsx)(Ref, {
              name: "tofte1997region",
              full: "true"
            }), " and ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "grossman2002region",
              full: "true"
            }), " use this model."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["However, recent work from ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "polonius",
              full: "true"
            }), " and ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "weiss2019oxide",
              full: "true"
            }), ' have\ndevised an alternative model of lifetimes as "provenances" or "origins" that more directly\ncorrespond to a pointer analysis. In essence, a lifetime is the set of places that a\nreference could point-to. For the above example, that would be ', (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'n = x "
            }), " for all\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "n"
            }), ", because each reference points to ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "x"
            }), ". As a more interesting example,\nconsider the code on the left."]
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "left",
            children: (0, import_jsx_runtime.jsx)(Listing2, {
              code: `let mut x = 1;
let mut y = 2;
let z: &'2 mut i32 = if true {
  &'0 mut x
} else {
  &'1 mut y
};
let w: &'4 mut i32 = &'3 mut *z;
*w = 1;`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["There, lifetimes for borrow expressions are assigned to the place being borrowed, so\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'0 = x "
            }), " and ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'1 = y "
            }), ". Because ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "z"
            }), " could be assigned to either reference,\nthen ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'2 = '0 \u222A '1 = {x, y}"
            }), ". An expression of the form ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "& *p"
            }), ' is called a\n"reborrow", as the underlying address is being passed from one reference to another. To\nregister that a reference is reborrowed, the reborrowed place is also added to the\nlifetime, so ', (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'3 = '4 = {x, y, *z}"
            }), ". More generally:"]
          }), (0, import_jsx_runtime.jsx)(Principle, {
            type: "references",
            text: "The lifetime of a reference contains all potential aliases of what the reference points-to."
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["In the context of slicing, then to determine which places could be modified by a\nparticular assignment, one only needs to look up the aliases in the lifetime of\nreferences. For instance, ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*w = 1"
            }), " would be part of a slice on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*z"
            }), ", because\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*z"
            }), " is in the lifetime ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'4"
            }), " of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "w"
            }), "."]
          })]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:funcalls",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Function calls"
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["The other major challenge for slicing is function calls. For instance, consider slicing a\ncall to an arbitrary function ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), " with various kinds of inputs:2"]
          }), (0, import_jsx_runtime.jsx)(FootnoteDef, {
            name: "2",
            children: (0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["Why is ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "String::from"
              }), " needed? The literal ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: '"Hello world"'
              }), " has type ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&'static str"
              }), ", meaning an immutable reference to the binary's string pool which lives forever. The function ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "String::from"
              }), " converts the immutable reference into a value of type ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "String"
              }), ", which stores its contents on the heap and allows the string to be mutated."]
            })
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "left",
            children: (0, import_jsx_runtime.jsx)(Listing2, {
              code: `let x = String::from("x");
let y = String::from("y");
let mut z = String::from("z");
let w = f(x, &y, &mut z);
println!("{} {} {}", y, z, w);`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["The standard approach to slicing ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), " would be to inspect the definition of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), ",\nand recursively slice it by translating the slicing criteria from caller to callee (e.g.\nsee ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "weiser1982programmers",
              full: "true"
            }), " for an example). However, our goal is to avoid\nusing the definition of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), " (i.e. a whole-program analysis) for the reasons described\nin ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:intro"
            }), "."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["To modularly slice through function calls, we need to approximate the effects of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), "\nin a manner that is sound, but also as precise as possible. Put another way, what\nmutations could possibly occur as a result of calling ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), "? Consider the three cases\nthat arise in the code above."]
          }), (0, import_jsx_runtime.jsxs)(_components.ul, {
            children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: ["Passing a value ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "x"
              }), " of type ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "String"
              }), " (or generally of type ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "T"
              }), ") moves the value into ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "f"
              }), ".\nTherefore it is an ownership error to refer to ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "x"
              }), " after calling ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "f"
              }), " and we do not need to\nconsider slices on ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "x"
              }), " after ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "f"
              }), "."]
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: ["Passing a value ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "y"
              }), " of type ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&String"
              }), " (or ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&T"
              }), ") passes an immutable reference. Immutable\nreferences cannot be mutated, therefore ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "y"
              }), " cannot change in ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "f"
              }), "3."]
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: ["Passing a value ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "z"
              }), " of type ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&mut String"
              }), " (or ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&mut T"
              }), ") passes a mutable reference, which could\npossibly be mutated. This case is therefore the only observable of effect ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "f"
              }), " apart from its\nreturn value."]
            }), "\n"]
          }), (0, import_jsx_runtime.jsx)(FootnoteDef, {
            name: "3",
            children: (0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["A notable detail to the safety of immutable references is that immutability is transitive. For instance, if ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "b = &mut a"
              }), " and ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "c = &b"
              }), ", then ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "a"
              }), " is guaranteed not to be mutated through ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "c"
              }), ". This stands in contrast to other languages with pointers like C and C++ where the ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "const"
              }), " keyword only protects values from mutation at the top-level, and not into the interior fields."]
            })
          }), (0, import_jsx_runtime.jsxs)("p", {
            id: "multi-snippets",
            children: ["Without inspecting ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), ", we cannot know how a mutable reference is modified, so we\nhave to conservatively assume that every argument was used as input to a mutation.\nTherefore the modular slice of each variable looks as in the snippets below:"]
          }), (0, import_jsx_runtime.jsxs)(Row, {
            children: [(0, import_jsx_runtime.jsx)(SliceListing, {
              prelude: "let f = |x: String, y: &String, z: &mut String| -> usize { 0 };",
              code: `let x = String::from("x");
let y = String::from("y");
let mut z = String::from("z");
let w = f(x, &y, &mut z);
println!("{}", @y@);`
            }), (0, import_jsx_runtime.jsx)(SliceListing, {
              prelude: "let f = |x: String, y: &String, z: &mut String| -> usize { 0 };",
              code: `let x = String::from("x");
let y = String::from("y");
let mut z = String::from("z");
let w = f(x, &y, &mut z);
println!("{}", @z@);`
            }), (0, import_jsx_runtime.jsx)(SliceListing, {
              prelude: "let f = |x: String, y: &String, z: &mut String| -> usize { 0 };",
              code: `let x = String::from("x");
let y = String::from("y");
let mut z = String::from("z");
let w = f(x, &y, &mut z);
println!("{}", @w@);`
            })]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Note that like ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "z"
            }), " (middle), the return value ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "w"
            }), " (right) is also assumed to be\ninfluenced by every input to ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), ". Implicit in these slices are additional assumptions\nabout the limitations of ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), ". For example, in C, a function could manufacture a\npointer to the stack frame above it and mutate the values, meaning ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "f"
            }), " could mutate\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y"
            }), " (even if ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "y"
            }), " was not an input!). Similarly, functions could potentially read\narbitrary data (e.g. global variables) that would influence mutations apart from just the\narguments."]
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "However, allowing such pointer manipulation would easily break ownership safety, since\nfundamentally it permits unchecked aliasing. Hence, our principle:"
          }), (0, import_jsx_runtime.jsx)(Principle, {
            type: "function calls",
            text: "When calling a function, (a) only mutable references in the arguments can be mutated, and (b) the mutations and return value are only influenced by the arguments."
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "This principle is essentially a worst-case approximation to the function's effects. It is\nthe core of how we can modularly slice programs, because a function's definition does not\nhave to be inspected to analyze what it can mutate."
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["A caveat to this principle is global variables: (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "prin:function calls"
            }), "-a) is not true with mutable globals, and (", (0, import_jsx_runtime.jsx)(Ref, {
              name: "prin:function calls"
            }), "-b) is not true with read-only globals. Mutable globals are disallowed by the rules of ownership, as\nthey are implicitly aliased and hence disallowed from being mutable. However, read-only globals are ownership-safe\n(and hence permitted in Rust). For simplicity we do not consider read-only globals in this work."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Another notable detail is the interaction of function calls and lifetimes. Pointer\nanalysis, like slicing, has historically been done via whole-program analysis for maximum\nprecision. However, Rust can analyze lifetimes (and subsequently what references point-to)\nmodularly just by looking at the type signature of a called function using\n", (0, import_jsx_runtime.jsx)(_components.em, {
              children: "lifetime parameters"
            }), " . Consider the function ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "Vec::get_mut"
            }), " that returns a\nmutable reference to an element of a vector. For instance, ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "vec![5, 6].get_mut(0)"
            }), "\nreturns a mutable reference to the value 5. This function has the type signature:"]
          }), (0, import_jsx_runtime.jsx)(Center, {
            style: {
              margin: "1rem 0"
            },
            children: (0, import_jsx_runtime.jsx)(_components.p, {
              children: (0, import_jsx_runtime.jsx)(_components.code, {
                children: "Vec::get_mut   :   forall 'a, T . (&'a mut Vec<T>, usize) -> &'a mut T"
              })
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Because this type signature is parametric in the lifetime ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "'a"
            }), ", it can express the\nconstraint that the output reference ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&'a mut T"
            }), " must have the same lifetime as the\ninput reference ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&'a mut Vec<T>"
            }), ". Therefore the returned pointer is known to\npoint to the same data as the input pointer, but without inspecting the definition of\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "get_mut"
            }), "."]
          })]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:intmut",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Interior mutability"
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ['The previous sections describe a slicing strategy for the subset of Rust known as "safe\nRust", that is programs which strictly adhere to the rules of ownership. Importantly, Rust\nalso has the ', (0, import_jsx_runtime.jsx)(_components.code, {
              children: "unsafe"
            }), " feature that gives users access to raw pointers, or pointers\nwith similar unchecked behavior to C. Most commonly, ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "unsafe"
            }), " code is used to\nimplement APIs that satisfy ownership, but not in a manner that is deducible by the type\nsystem. For example, shared mutable state between threads:"]
          }), (0, import_jsx_runtime.jsx)(Wrap, {
            align: "left",
            children: (0, import_jsx_runtime.jsx)(Listing2, {
              code: `let value = Arc::new(Mutex::new(0));
let value_ref = value.clone();
thread::spawn(move || {
*value_ref.lock().unwrap() += 1;
}).join().unwrap();
assert!(*value.lock().unwrap() == 1);`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["In this snippet, two threads have ownership over two values of type ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "Arc<Mutex<i32>>"
            }), " which internally point to the same number. Both threads can call\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "Mutex::lock"
            }), " which takes an immutable reference to an ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&Mutex<i32>"
            }), " and returns a mutable reference ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "&mut i32"
            }), " to the data inside.4 This nominally violates ownership, as the data is aliased (shared by two threads) and mutable (both can mutate)."]
          }), (0, import_jsx_runtime.jsx)(FootnoteDef, {
            name: "4",
            children: (0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["Technically the returned type is a ", " but the distinction isn't relevant here."]
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["The mutex is ownership-safe only because its implementation ensures that both threads\ncannot ", (0, import_jsx_runtime.jsx)(_components.em, {
              children: "simultaneously"
            }), " access the underlying value in accordance with the system\nmutex's semantics. For our purposes, the aliasing between ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "value"
            }), " and\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "value_ref"
            }), " is not possible to observe using the type system alone. For example, in\nour algorithm, slicing on ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "value"
            }), " would ", (0, import_jsx_runtime.jsx)(_components.em, {
              children: "not"
            }), " include mutations to\n", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "value_ref"
            }), ". This is because the data inside the mutex has type ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*mut i32"
            }), " (a\nraw pointer), and without a lifetime attached, our algorithm has no way to determine\nwhether ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "value"
            }), " and ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "value_ref"
            }), " are aliases just by inspecting their types."]
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "More broadly, modular slicing is only sound for safe Rust. The point of this work is to\nsay: when a program can be statically determined to satisfy the rules of ownership, then\nmodular slicing is sound. The principles above help clarify the specific assumptions made\npossible by ownership, which are otherwise impossible to make in languages like C or Java."
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: [(0, import_jsx_runtime.jsx)(Ref, {
              name: "astrauskas2020programmers",
              full: "true"
            }), " found that 76.4% of published Rust projects contain no unsafe\ncode, suggesting that safe Rust is more common than not. However, their study does not account for safe\nRust built on internally-unsafe abstractions like ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "Mutex"
            }), ", so it is difficult to estimate the true likelihood\nof soundness in practice. We discuss the issue of slicing with unsafe code further in\n", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:whole-vs-mod"
            }), "."]
          })]
        })]
      }), "\n", (0, import_jsx_runtime.jsxs)(Section, {
        name: "sec:model",
        children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
          children: "Formal Model"
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["To build an algorithm from these principles, we first need a formal model to describe and\nreason about the underlying language. Rather than devise our own, we build on the work of\n", (0, import_jsx_runtime.jsx)(Ref, {
            name: "weiss2019oxide",
            full: "true"
          }), " : Oxide is a model of (safe) Rust's surface language with a\nformal static and dynamic semantics, along with a proof of syntactic type soundness.\nImportantly, Oxide uses a provenance model of lifetimes which we leverage for our slicing\nalgorithm."]
        }), (0, import_jsx_runtime.jsxs)(_components.p, {
          children: ["We will incrementally introduce the aspects of Oxide's syntax and semantics as necessary to understand our principles and algorithm. We describe Oxide's syntax (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:syn"
          }), "), static semantics (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:statsem"
          }), ") and dynamic semantics (", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:dynsem"
          }), "), and then apply these concepts to formalize the slicing principles of the previous section\n(", (0, import_jsx_runtime.jsx)(Ref, {
            name: "sec:formal_principles"
          }), ")."]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:syn",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Syntax"
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: [(0, import_jsx_runtime.jsx)(Ref, {
              name: "fig:oxide_syntax"
            }), " shows a subset of Oxide's syntax along with a labeled\nexample. An Oxide program consists of a set of functions ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\fenv"
            }), ' (the "global\nenvironment"), where each function body is an expression ', (0, import_jsx_runtime.jsx)($2, {
              children: "\\expr"
            }), "."]
          }), (0, import_jsx_runtime.jsxs)(Figure, {
            name: "fig:oxide_syntax",
            children: [(0, import_jsx_runtime.jsxs)(Subfigure, {
              name: "fig:oxide_syntax_bnf",
              children: [(0, import_jsx_runtime.jsx)(Oxide.Bnf, {
                layout: {
                  columns: 2,
                  cutoff: 9
                }
              }), (0, import_jsx_runtime.jsx)(Expandable, {
                prompt: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
                  children: "Rest of the grammar..."
                }),
                children: (0, import_jsx_runtime.jsx)(OxideExtra.Bnf, {})
              }), (0, import_jsx_runtime.jsxs)(Caption, {
                children: ["Subset of Oxide syntax, reproduced from ", (0, import_jsx_runtime.jsx)(Ref, {
                  name: "weiss2019oxide",
                  full: "true"
                }), ". The only difference in this subset is that closures are eliminated and functions are simplified to take one argument."]
              })]
            }), (0, import_jsx_runtime.jsxs)(Subfigure, {
              name: "fig:oxide_syntax_example",
              children: [(0, import_jsx_runtime.jsx)(SyntaxDiagram, {}), (0, import_jsx_runtime.jsx)(Caption, {
                children: "Syntactic forms and corresponding metavariables labeled in context of an example"
              })]
            }), (0, import_jsx_runtime.jsx)(Caption, {
              children: "Formal elements of Oxide and their explanation (excerpts)."
            })]
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "The syntax is largely the same as Rust's with a few exceptions:"
          }), (0, import_jsx_runtime.jsxs)(_components.ul, {
            children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: ['Lifetimes are called "provenances", and they are both explicit in expressions and types throughout the program, and initially bound via ', (0, import_jsx_runtime.jsx)($2, {
                children: "\\msf{letprov}"
              }), " expressions or as function parameters."]
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: ["Rather than having immutable references ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&'a \u03C4"
              }), " and mutable references ", (0, import_jsx_runtime.jsx)(_components.code, {
                children: "&'a mut \u03C4"
              }), ', Oxide calls them "shared" references ', (0, import_jsx_runtime.jsx)($2, {
                children: "\\tysref{\\ownqshrd}{\\prov}{\\ty}"
              }), ' and "unique" references ', (0, import_jsx_runtime.jsx)($2, {
                children: "\\tysref{\\ownquniq}{\\prov}{\\ty}"
              })]
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: ['Provenances are divided into "concrete" (', (0, import_jsx_runtime.jsx)($2, {
                children: "\\concrprov"
              }), ') and "abstract" (', (0, import_jsx_runtime.jsx)($2, {
                children: "\\abstrprov"
              }), "). Concrete provenances are used by borrow expressions, and abstract provenances are function parameters used for inputs with reference type."]
            }), "\n"]
          })]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:statsem",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Static semantics"
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: [(0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:tc",
              children: ["Expressions are typechecked via the judgment ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\tc{\\fenv}{\\tyenv}{\\stackenv}{\\expr}{\\ty}{\\stackenv'}"
              }), ', read as: "', (0, import_jsx_runtime.jsx)($2, {
                children: "\\expr"
              }), " has type ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\ty"
              }), " under contexts ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\fenv, \\tyenv, \\stackenv"
              }), " producing new context ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\stackenv'"
              }), '."']
            }), " ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\tyenv"
            }), " contains function-level type and provenance variables. ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stackenv"
            }), " maps variables to types and provenances to pointed-to place expressions with ownership qualifiers. For instance, when type checking ", (0, import_jsx_runtime.jsx)(_components.code, {
              children: "*b := a.1"
            }), " in ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "fig:oxide_syntax_example"
            }), " , the inputs would be ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\tyenv = \\tyenvempty"
            }), " (empty) and ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stackenv = \\{a \\mapsto (\\uty, \\uty),~ b \\mapsto \\eref{\\uniq}{\\r_2}{\\uty},~ r_1 \\mapsto \\{\\loanform{\\uniq}{a.0}\\},~ \\r_2 \\mapsto \\{\\loanform{\\uniq}{a.0}\\}\\}"
            }), "."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Typechecking relies on a number of auxiliary judgments, such as subtyping\n(", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:subtype",
              Tooltip: () => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
                children: [(0, import_jsx_runtime.jsx)($2, {
                  children: r`\subtype{\tyenv}{\stackenv}{\tau_1}{\tau_2}{\stackenv'}`
                }), " means ", (0, import_jsx_runtime.jsx)($2, {
                  children: r`\tau_1`
                }), " is a subtype of ", (0, import_jsx_runtime.jsx)($2, {
                  children: r`\tau_2`
                })]
              }),
              children: ["\n", (0, import_jsx_runtime.jsx)($2, {
                children: "\\subtype{\\tyenv}{\\stackenv}{\\tau_1}{\\tau_2}{\\stackenv'}"
              }), "\n"]
            }), ")\nand ownership-safety\n(", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:ownsafe",
              children: ["\n", (0, import_jsx_runtime.jsx)($2, {
                children: "\\ownsafe{\\tyenv}{\\stackenv}{\\ownq}{\\pexp}{\\loanset}"
              }), ', read as "', (0, import_jsx_runtime.jsx)($2, {
                children: "\\pexp"
              }), " has ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\ownq\\text{-loans}"
              }), " ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\loanset"
              }), " in the contexts ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\Delta, \\Gamma"
              }), '"\n']
            }), ").\nAs an example, consider ", (0, import_jsx_runtime.jsx)(Smallcaps, {
              children: "T-Assign"
            }), " for the assignment expression ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\exprplcasgn{\\plc}{\\expr}"
            }), ":"]
          }), (0, import_jsx_runtime.jsx)(Center, {
            children: (0, import_jsx_runtime.jsx)(AssignStaticRule, {})
          }), (0, import_jsx_runtime.jsx)("p", {
            id: "static-rule",
            className: "noindent",
            style: {
              color: "#444"
            },
            children: (0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["[Note: Each section of the rule has a natural language explanation, shown by default. Click on the ", (0, import_jsx_runtime.jsx)("span", {
                style: {
                  marginLeft: "-0.5rem"
                },
                children: (0, import_jsx_runtime.jsx)(ToggleButton, {
                  big: true,
                  on: false,
                  onClick: () => {
                  }
                })
              }), " button to see corresponding mathematical formula. You can also click on the right-most button to toggle all sections at once.]"]
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["A valid assignment must be type-safe and ownership-safe. To be type-safe, the type of the expression ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\tys"
            }), " must be a subtype of the place's type ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stackenv_1(\\plc)"
            }), ". To be ownership-safe, the type must either be deaddead, or ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc"
            }), " must have unique ownership over itself, i.e. there should be no live references to ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc"
            }), ". If so, then the type of ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc"
            }), " is updated to ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\tys"
            }), "."]
          }), (0, import_jsx_runtime.jsxs)(FootnoteDef, {
            name: "dead",
            children: [(0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["Oxide uses the metavariables ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\tyd"
              }), ' to mean "dead types" and ', (0, import_jsx_runtime.jsx)($2, {
                children: "\\tysx"
              }), ' to mean "possibly dead types". A place becomes dead when it is moved, e.g. see ', (0, import_jsx_runtime.jsx)(Smallcaps, {
                children: "T-Move"
              }), " in ", (0, import_jsx_runtime.jsx)(Ref, {
                name: "weiss2019oxide"
              }), ". ", (0, import_jsx_runtime.jsx)(Smallcaps, {
                children: "T-Assign"
              }), " allows a dead place to be revived. For instance, consider the program:"]
            }), "\n", (0, import_jsx_runtime.jsx)($2, {
              children: '\\exprlet{\\vr}{\\sty}{\\text{\\textquotedblleft}a"}{\\exprseq{\\msf{print}(\\vr)}{\\exprplcasgn{\\vr}{\\text{\\textquotedblleft}b"}}}'
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["When ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\msf{print}(\\vr)"
              }), " moves ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\vr"
              }), ", its type is updated to ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\tyds{\\sty}"
              }), " in ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\stackenv"
              }), ". Then the ", (0, import_jsx_runtime.jsx)(Smallcaps, {
                children: "T-Assign"
              }), " rule permits ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\vr"
              }), ' to be assigned again to "revive" that place, setting its type back to ', (0, import_jsx_runtime.jsx)($2, {
                children: "\\sty"
              }), "."]
            })]
          })]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:dynsem",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Dynamic semantics"
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Expressions are executed via a small-step operational semantics, and the program state is a pair of a stack and an expression.\n", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:stepsto",
              children: ["A single step is represented by the judgment ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\stepsto{\\fenv}{\\stack}{\\expr}{\\stepped{\\stack}}{\\expr'}"
              }), "."]
            }), "\n", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:stack",
              children: ["A stack ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\stack"
              }), " is a list of stack frames ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\varsigma ::= \\setof{\\vr \\mapsto v}"
              }), " that map variables to values."]
            }), "\nFor example, consider ", (0, import_jsx_runtime.jsx)(Smallcaps, {
              children: "E-Assign"
            }), " ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "weiss2019oxide"
            }), " that covers ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\exprplcasgn{\\plc}{\\expr}"
            }), " and ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\exprpexpasgn{\\pexp}{\\expr}"
            }), " expressions:fix"]
          }), (0, import_jsx_runtime.jsx)(FootnoteDef, {
            name: "fix",
            children: (0, import_jsx_runtime.jsxs)(_components.p, {
              children: ["This ", (0, import_jsx_runtime.jsx)(Smallcaps, {
                children: "E-Assign"
              }), " rule is not the exact same rule that appears in ", (0, import_jsx_runtime.jsx)(Ref, {
                name: "weiss2019oxide"
              }), ", as the published version is incorrect. In correspondence with the authors, we determined that the rule presented here has the intended semantics. Additionally, we do not use the referent ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\mathcal{R}"
              }), " construct of Oxide since we do not consider arrays in this paper, so we use ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\plc"
              }), " anywhere ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\mathcal{R}"
              }), " would otherwise appear."]
            })
          }), (0, import_jsx_runtime.jsx)(Center, {
            children: (0, import_jsx_runtime.jsx)(AssignDynamicRule, {})
          }), (0, import_jsx_runtime.jsx)(_components.p, {
            children: "This rule introduces several new shorthands and administrative forms:"
          }), (0, import_jsx_runtime.jsxs)(_components.ul, {
            children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: [(0, import_jsx_runtime.jsxs)(Definition2, {
                name: "tex:pctx",
                children: ["The syntax ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\pctx{\\plc}{\\vr}"
                }), " means the decomposition of a place ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\plc"
                }), " into a root variable ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\vr"
                }), " and context ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\plc^\\square"
                }), "."]
              }), " For example, if ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\plc = a.0"
              }), " then ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\plc^\\square = \\square.0"
              }), " and ", (0, import_jsx_runtime.jsx)($2, {
                children: "x = a"
              }), " ."]
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: [(0, import_jsx_runtime.jsxs)(Definition2, {
                name: "tex:valuectx",
                children: ["A value context ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\valuectx"
                }), " is a form to handle mutation of compound objects."]
              }), " For instance, if ", (0, import_jsx_runtime.jsx)($2, {
                children: "a = (0, 1)"
              }), " , when evaluating ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\exprplcasgn{a.0}{2}"
              }), " , then ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\valuectx = (\\square, 1)"
              }), ". ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\valuectx"
              }), " copies all the old values, leaving a hole for the one value to be updated. Then the syntax ", (0, import_jsx_runtime.jsxs)(Definition2, {
                name: "tex:valueplug",
                children: [(0, import_jsx_runtime.jsx)($2, {
                  children: "\\valueplug{\\valuectx}{v}"
                }), " means plugging ", (0, import_jsx_runtime.jsx)($2, {
                  children: "v"
                }), " into the hole."]
              }), " Hence, mutating a place is represented as ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\stack[x \\mapsto \\valueplug{\\valuectx}{v}]"
              }), "."]
            }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
              children: [(0, import_jsx_runtime.jsxs)(Definition2, {
                name: "tex:pointsto",
                children: ["The judgment ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\pointsto{\\stack}{\\pexp}{\\pctx{\\plc}{\\vr}}{\\valuectx}"
                }), " evaluates a place expression ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\pexp"
                }), " under the current stack ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\stack"
                }), " into a place ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\plc"
                }), " and value context ", (0, import_jsx_runtime.jsx)($2, {
                  children: "\\valuectx"
                }), "."]
              }), " For instance, if ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\pexp"
              }), " is a dereference of a reference, then this judgment resolves ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\pexp"
              }), " to the concrete memory location ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\plc"
              }), " it points-to under ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\stack"
              }), "."]
            }), "\n"]
          })]
        }), (0, import_jsx_runtime.jsxs)(Section, {
          name: "sec:formal_principles",
          children: [(0, import_jsx_runtime.jsx)(SectionTitle, {
            children: "Formalized principles"
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Now, we have enough of the language formalized to give a precise statement of each slicing principle from ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:background"
            }), ". Each principle will be presented with the corresponding theorem, using underlining in color to highlight correspondences."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["In the principles and corresponding algorithm/proofs, there are many concepts which we  distinguish by notational convention. We denote objects by their metavariable, e.g. ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp"
            }), " or ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack"
            }), ", and add a sans-serif subscript for distinct roles where needed, e.g. ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\mut"
            }), " for a mutated place and ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\any"
            }), " for an arbitrary place. We generally use a superscript ", (0, import_jsx_runtime.jsx)($2, {
              children: "i"
            }), " for an object that varies between two executions of a program, like ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack^i"
            }), " or ", (0, import_jsx_runtime.jsx)($2, {
              children: "v^i"
            }), " . And we use right arrows to indicate changes to an object after stepping (instead of primes, to avoid polluting the superscript), e.g. ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack^i"
            }), " versus ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stepped{\\stack}^i"
            }), "."]
          }), (0, import_jsx_runtime.jsx)("hr", {}), (0, import_jsx_runtime.jsx)(Correspondence, {
            id: "correspondence-principle-1",
            children: (0, import_jsx_runtime.jsxs)(Row, {
              children: [(0, import_jsx_runtime.jsxs)("div", {
                style: {
                  width: "300px",
                  marginRight: "3rem"
                },
                children: [(0, import_jsx_runtime.jsx)(Smallcaps, {
                  children: (0, import_jsx_runtime.jsx)(Ref, {
                    name: "prin:places"
                  })
                }), (0, import_jsx_runtime.jsx)("div", {
                  style: {
                    fontStyle: "italic"
                  },
                  children: (0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["A ", (0, import_jsx_runtime.jsx)(Link, {
                      name: "1",
                      children: "mutation"
                    }), " to a ", (0, import_jsx_runtime.jsx)(Link, {
                      name: "2",
                      children: "place"
                    }), " is a ", (0, import_jsx_runtime.jsx)(Link, {
                      name: "3",
                      children: "mutation"
                    }), " to ", (0, import_jsx_runtime.jsx)(Link, {
                      name: "4",
                      children: "all conflicting places."
                    })]
                  })
                })]
              }), (0, import_jsx_runtime.jsx)("div", {
                style: {
                  width: "max-content"
                },
                children: (0, import_jsx_runtime.jsxs)(Theorem, {
                  name: "thm:slice-places",
                  children: [(0, import_jsx_runtime.jsx)(_components.p, {
                    children: "Let:"
                  }), (0, import_jsx_runtime.jsxs)(_components.ul, {
                    children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{2}{\\plc_\\mut = \\pctx{\\plc_\\mut}{\\vr}}, \\stack"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\pointsto{\\stack}{\\plc_\\mut}{\\_}{\\valuectx}"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: ["\n", (0, import_jsx_runtime.jsx)($2, {
                        children: "v, \\link{1}{\\stepped{\\stack} =\\stack[\\vr \\mapsto \\valueplug{\\valuectx}{v}]}"
                      }), "\n"]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: ["\n", (0, import_jsx_runtime.jsxs)(Link, {
                        name: "4",
                        children: [(0, import_jsx_runtime.jsx)($2, {
                          children: "\\plc_\\any"
                        }), " be any place"]
                      }), "\n"]
                    }), "\n"]
                  }), (0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["Then ", (0, import_jsx_runtime.jsx)($2, {
                      children: "\\link{3}{\\stack(\\plc_\\any) \\neq \\stepped{\\stack}(\\plc_\\any)} \\implies \\link{4}{\\notdisjoint{\\plc_\\any}{\\plc_\\mut}}"
                    }), "."]
                  })]
                })
              })]
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["As described in ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:dynsem"
            }), ", a mutation to a place is represented by updating a variable ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\vr"
            }), " in a stack ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack"
            }), " by plugging a value ", (0, import_jsx_runtime.jsx)($2, {
              children: "v"
            }), " into a value context ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\valuectx"
            }), ". To denote a conflict, we reuse the notation from Oxide that ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\disjoint{\\plc_1}{\\plc_2}"
            }), ' means "', (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_1"
            }), " and ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_2"
            }), ' do not conflict", or more formally:']
          }), (0, import_jsx_runtime.jsx)(Definition2, {
            name: "tex:disjoint",
            children: (0, import_jsx_runtime.jsx)($$2, {
              children: "\\disjoint{x_1.q_1}{x_2.q_2} \\eqdef x_1 \\neq x_2 \\vee\n((q_1 \\text{ is not a prefix of } q_2) \\wedge (q_2 \\text{ is not a prefix of } q_1))"
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Conversely, we use the shorthand ", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:notdisjoint",
              children: ["\n", (0, import_jsx_runtime.jsx)($2, {
                children: "\\notdisjoint{\\pi_1}{\\pi_2} \\eqdef \\neg(\\disjoint{\\pi_1}{\\pi_2})"
              }), "\n"]
            }), ". So if a place ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\any"
            }), " is changed when ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\mut"
            }), " is mutated, then it must be that ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\notdisjoint{\\plc_\\any}{\\plc_\\mut}"
            }), "."]
          }), (0, import_jsx_runtime.jsx)("hr", {}), (0, import_jsx_runtime.jsx)(Correspondence, {
            children: (0, import_jsx_runtime.jsxs)(Row, {
              children: [(0, import_jsx_runtime.jsxs)("div", {
                style: {
                  width: "400px",
                  marginRight: "3rem"
                },
                children: [(0, import_jsx_runtime.jsx)(Smallcaps, {
                  children: (0, import_jsx_runtime.jsx)(Ref, {
                    name: "prin:references"
                  })
                }), (0, import_jsx_runtime.jsx)("br", {}), "\n", (0, import_jsx_runtime.jsxs)("em", {
                  children: ["The ", (0, import_jsx_runtime.jsx)(Link, {
                    name: "1",
                    children: "lifetime"
                  }), " of a ", (0, import_jsx_runtime.jsx)(Link, {
                    name: "2",
                    children: "reference"
                  }), " contains all potential ", (0, import_jsx_runtime.jsx)(Link, {
                    name: "3",
                    children: "aliases"
                  }), " of what the reference ", (0, import_jsx_runtime.jsx)(Link, {
                    name: "4",
                    children: "points-to."
                  })]
                })]
              }), (0, import_jsx_runtime.jsx)("div", {
                style: {
                  width: "max-content",
                  textAlign: "left"
                },
                children: (0, import_jsx_runtime.jsxs)(Theorem, {
                  name: "thm:slice-refs",
                  children: [(0, import_jsx_runtime.jsx)(_components.p, {
                    children: "Let:"
                  }), (0, import_jsx_runtime.jsxs)(_components.ul, {
                    children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\stack"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\fenv \\vdash \\stack : \\stackenv"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{2}{\\pexp_\\mut}"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{1}{\\ownsafe{\\tyenvempty}{\\stackenv}{\\uniq}{\\pexp_\\mut}{\\loanset}}"
                      }), " and ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\pointsto{\\stack}{\\pexp_\\mut}{\\link{4}{\\plc_\\mut}}{\\_}"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{3}{\\pexp_\\any}"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\pointsto{\\stack}{\\pexp_\\any}{\\plc_\\any}{\\_}"
                      })]
                    }), "\n"]
                  }), (0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["Then ", (0, import_jsx_runtime.jsx)($2, {
                      children: "\\notdisjoint{\\plc_\\any}{\\plc_\\mut} \\implies \\link{3}{\\exists \\loanform{\\uniq}{\\pexp_\\msf{loan}}} ~ . ~ \\notdisjoint{\\pexp_\\any}{\\pexp_\\msf{loan}}"
                    }), "."]
                  })]
                })
              })]
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Rather than referring to a lifetime directly, we instead use Oxide's ownership safety judgment described in ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "sec:statsem"
            }), " to get the corresponding loan set for a mutated place expression ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\mut"
            }), ". If ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\mut"
            }), " includes a dereference, then the loan set should include potential aliases."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["A notable detail is that we do not compare the loan sets of ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\mut"
            }), " and ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\any"
            }), " to see if they contain conflicting places, but rather compare ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\any"
            }), " just against the loan set of ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\mut"
            }), ". This works because the loan set contains not just the set of places ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc"
            }), " that ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\mut"
            }), " could point-to, but also the set of other references to the places ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\pexp_\\mut"
            }), " points-to (via reborrows)."]
          }), (0, import_jsx_runtime.jsx)("hr", {}), (0, import_jsx_runtime.jsx)(Correspondence, {
            children: (0, import_jsx_runtime.jsxs)(Row, {
              children: [(0, import_jsx_runtime.jsxs)("div", {
                style: {
                  width: "340px",
                  marginRight: "2.5rem",
                  textAlign: "left"
                },
                children: [(0, import_jsx_runtime.jsx)(Smallcaps, {
                  children: (0, import_jsx_runtime.jsx)(Ref, {
                    name: "prin:function calls"
                  })
                }), (0, import_jsx_runtime.jsx)("br", {}), (0, import_jsx_runtime.jsxs)("div", {
                  style: {
                    fontStyle: "italic"
                  },
                  children: [(0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["When ", (0, import_jsx_runtime.jsx)(Link, {
                      name: "1",
                      children: "calling a function:"
                    })]
                  }), (0, import_jsx_runtime.jsx)("ol", {
                    className: "parenkey",
                    children: (0, import_jsx_runtime.jsxs)("li", {
                      children: ["only ", (0, import_jsx_runtime.jsx)(Link, {
                        name: "2",
                        children: "mutable references in the arguments"
                      }), " ", (0, import_jsx_runtime.jsx)(Link, {
                        name: "3",
                        children: "can be mutated"
                      }), ", and..."]
                    })
                  })]
                })]
              }), (0, import_jsx_runtime.jsx)("div", {
                style: {
                  width: "max-content",
                  textAlign: "left"
                },
                children: (0, import_jsx_runtime.jsxs)(Theorem, {
                  name: "thm:proc_mutrefs",
                  children: [(0, import_jsx_runtime.jsx)(_components.p, {
                    children: "Let:"
                  }), (0, import_jsx_runtime.jsxs)(_components.ul, {
                    children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\stackenv, \\plc_\\arrg, \\stack"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\stackenv(\\plc_\\arrg) = \\tys"
                      }), " and ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\fenv \\vdash \\stack : \\stackenv"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\fname"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{1}{\\evalsto{\\fenv}{\\stack}{\\fname(\\plc_\\arrg)}{\\stepped{\\stack}}{\\_}}"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: ["\n", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\stepped{\\stack}' = \\stepped{\\stack}[\\link{2}{\\forall \\pexp_\\reff \\in \\refs{\\uniq}{\\plc_\\arrg, \\tys}} ~ . ~ \\link{3}{\\pexp_\\reff \\mapsto \\stack(\\pexp_\\reff)}]"
                      }), "\n"]
                    }), "\n"]
                  }), (0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["Then ", (0, import_jsx_runtime.jsx)($2, {
                      children: "\\stack = \\stepped{\\stack}'"
                    }), "."]
                  })]
                })
              })]
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["First, ", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:refs",
              children: ['we define "mutable references in the arguments" as ', (0, import_jsx_runtime.jsx)($2, {
                children: "\\refs{\\ownq}{\\pexp, \\tys}"
              }), " that returns the ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\ownq"
              }), "-safe place expressions of references inside of ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\pexp"
              }), " of type ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\tys"
              })]
            }), ". For instance, if ", (0, import_jsx_runtime.jsx)($2, {
              children: "x = 0"
            }), " and ", (0, import_jsx_runtime.jsx)($2, {
              children: "y = (0, \\tysref{\\uniq}{\\concrprov}{x})"
            }), " then ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\refs{\\uniq}{y, (\\uty, \\tysref{\\uniq}{\\concrprov}{\\uty})} = \\{\\pexpderef{y.1}\\}"
            }), " . The full definition is:"]
          }), (0, import_jsx_runtime.jsx)($$2, {
            children: "\\begin{align*}\n\\refs{\\ownq}{\\pexp, \\tyb} &=\n\\varnothing\n\\hspace{32pt}\n\\refs{\\ownq}{\\pexp, \\tystup{\\tys_1, \\ldots, \\tys_n}} =\n\\bigcup_i \\refs{\\ownq}{\\pexp.i, \\tys_i}\n\\\\\n\\refs{\\ownq}{p, \\tysref{\\ownq'}{\\prov}{\\tyx}} &= \\begin{cases}\n\\{\\pexpderef{\\pexp}\\} \\cup \\refs{\\ownq}{\\pexpderef{p}, \\tyx} & \\text{if $\\ownqleq{\\ownq'}{\\ownq}$} \\\\\n\\varnothing & \\text{otherwise}\n\\end{cases}\n\\end{align*}"
          }), (0, import_jsx_runtime.jsxs)("p", {
            className: "noindent",
            children: ["Here, ", (0, import_jsx_runtime.jsxs)(Definition2, {
              name: "tex:ownqleq",
              children: ["the relation ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\ownqleq{\\ownq'}{\\ownq}"
              }), " is defined as ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\uniq \\not\\lesssim \\shrd"
              }), " and otherwise ", (0, import_jsx_runtime.jsx)($2, {
                children: "\\ownqleq{\\ownq'}{\\ownq}"
              }), "."]
            })]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Then we define ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "thm:proc_mutrefs"
            }), " in the theme of a transaction: if all the changes to unique references in ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\arrg"
            }), " are rolled back, then the new stack is the same as the one before the function call. This means implicitly that no other values could have been mutated."]
          }), (0, import_jsx_runtime.jsx)("hr", {}), (0, import_jsx_runtime.jsx)(Correspondence, {
            children: (0, import_jsx_runtime.jsxs)(Row, {
              children: [(0, import_jsx_runtime.jsxs)("div", {
                style: {
                  width: "330px",
                  marginRight: "2rem",
                  textAlign: "left"
                },
                children: [(0, import_jsx_runtime.jsx)(Smallcaps, {
                  children: (0, import_jsx_runtime.jsx)(Ref, {
                    name: "prin:function calls"
                  })
                }), (0, import_jsx_runtime.jsx)("br", {}), (0, import_jsx_runtime.jsxs)("div", {
                  style: {
                    fontStyle: "italic"
                  },
                  children: [(0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["When ", (0, import_jsx_runtime.jsx)(Link, {
                      name: "1",
                      children: "calling a function:"
                    })]
                  }), (0, import_jsx_runtime.jsx)("ol", {
                    className: "parenkey",
                    start: 2,
                    children: (0, import_jsx_runtime.jsxs)("li", {
                      children: ["...the ", (0, import_jsx_runtime.jsx)(Link, {
                        name: "2",
                        children: "mutations"
                      }), " and ", (0, import_jsx_runtime.jsx)(Link, {
                        name: "3",
                        children: "return value"
                      }), " are only ", (0, import_jsx_runtime.jsx)(Link, {
                        name: "4",
                        children: "influenced by the arguments."
                      })]
                    })
                  })]
                })]
              }), (0, import_jsx_runtime.jsx)("div", {
                style: {
                  width: "max-content",
                  textAlign: "left"
                },
                children: (0, import_jsx_runtime.jsxs)(Theorem, {
                  name: "thm:proc_eqarg",
                  children: [(0, import_jsx_runtime.jsx)(_components.p, {
                    children: "Let:"
                  }), (0, import_jsx_runtime.jsxs)(_components.ul, {
                    children: ["\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\stackenv, \\plc_\\arrg, \\stack^i"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\stackenv(\\plc_\\arrg) = \\tys"
                      }), " and ", (0, import_jsx_runtime.jsx)($2, {
                        children: "i \\in \\{1, 2\\}, \\fenv \\vdash \\stack^i : \\stackenv"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: [(0, import_jsx_runtime.jsx)($2, {
                        children: "\\fname"
                      }), " where ", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{1}{\\evalsto{\\fenv}{\\stack}{\\fname(\\plc_\\arrg)}{\\stepped{\\stack}}{v^i}}"
                      })]
                    }), "\n", (0, import_jsx_runtime.jsxs)(_components.li, {
                      children: ["\n", (0, import_jsx_runtime.jsx)($2, {
                        children: "\\link{4}{P = \\allplaces{\\plc_\\arrg}{\\tys}}"
                      }), "\n"]
                    }), "\n"]
                  }), (0, import_jsx_runtime.jsxs)(_components.p, {
                    children: ["Then ", (0, import_jsx_runtime.jsx)($2, {
                      children: "\\link{4}{\\stackeq{\\stack^1}{\\stack^2}{P}} \\implies \\link{2}{\\stackeq{\\stepped{\\stack}^1}{\\stepped{\\stack}^2}{P}} \\wedge \\link{3}{v^1 = v^2}"
                    })]
                  })]
                })
              })]
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["The idea behind ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "thm:proc_eqarg"
            }), ' is that "influence" is translated into a form of noninterference: if the input to a function is the same under any two stacks ', (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack^1"
            }), " and ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack^2"
            }), ", then the mutations to that input must be the same. The rest of the stack is allowed to vary, but because the function ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\fname"
            }), " cannot read it, that variation cannot influence the final value."]
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ['To formalize "the input being the same", we introduce another auxiliary function for transitive equality. For instance, if we only required that ', (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack^1(\\plc_\\arrg) = \\stack^2(\\plc_\\arrg)"
            }), " where ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\arrg = \\msf{ptr}~x"
            }), ", then if ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\stack^1(x) \\neq \\stack^2(x)"
            }), " the theorem would not be true. Hence, transitive equality is defined as equality including all pointed places. We define this concept through two pieces: a function for generating the set of places (denoted by ", (0, import_jsx_runtime.jsx)($2, {
              children: "P"
            }), "), and a relation defining the equivalence of stacks for a set of places."]
          }), (0, import_jsx_runtime.jsx)($$2, {
            children: "\\begin{align*}\n\\cmddef{allplaces}{\\allplaces{\\pexp}{\\tys}} &\\eqdef \\{\\pexp\\} \\cup \\refs{\\shrd}{\\pexp, \\tys} \\\\\n\\cmddef{stackeq}{\\stackeq{\\stack^1}{\\stack^2}{P}} &\\eqdef \\forall \\pexp \\in P ~ . ~ \\stack^1(\\pexp) = \\stack^2(\\pexp)\n\\end{align*}"
          }), (0, import_jsx_runtime.jsx)(Definition2, {
            name: "tex:allplaces",
            Tooltip: () => (0, import_jsx_runtime.jsx)($2, {
              children: r`\allplaces{\pexp}{\tys} \eqdef \{\pexp\} \cup \refs{\shrd}{\pexp, \tys}`
            })
          }), (0, import_jsx_runtime.jsx)(Definition2, {
            name: "tex:stackeq",
            Tooltip: () => (0, import_jsx_runtime.jsx)($2, {
              children: r`\stackeq{\stack^1}{\stack^2}{P} \eqdef \forall \pexp \in P ~ . ~ \stack^1(\pexp) = \stack^2(\pexp)`
            })
          }), (0, import_jsx_runtime.jsxs)(_components.p, {
            children: ["Therefore ", (0, import_jsx_runtime.jsx)(Ref, {
              name: "thm:proc_eqarg"
            }), " states that if ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\arrg"
            }), " is transitively equal under two otherwise arbitrary stacks, then ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\plc_\\arrg"
            }), " is still transitively equal after evaluating ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\fname(\\plc_\\arrg)"
            }), " , and the output of ", (0, import_jsx_runtime.jsx)($2, {
              children: "\\fname(\\plc_\\arrg)"
            }), " is also equal."]
          }), (0, import_jsx_runtime.jsx)(References, {
            bibtex: slicing_paper_default
          })]
        })]
      })]
    });
    return MDXLayout ? (0, import_jsx_runtime.jsx)(MDXLayout, Object.assign({}, props, {
      children: _content
    })) : _content;
  }
  var slicing_paper_default2 = MDXContent;

  // hatra-paper.bib
  var hatra_paper_default = "@article{cavallo2019higher,\n  title={Higher inductive types in cubical computational type theory},\n  author={Cavallo, Evan and Harper, Robert},\n  journal={Proceedings of the ACM on Programming Languages},\n  volume={3},\n  number={POPL},\n  pages={1--27},\n  year={2019},\n  publisher={ACM New York, NY, USA}\n}\n\n@inproceedings{head2021augmenting,\n  title={Augmenting scientific papers with just-in-time, position-sensitive definitions of terms and symbols},\n  author={Head, Andrew and Lo, Kyle and Kang, Dongyeop and Fok, Raymond and Skjonsberg, Sam and Weld, Daniel S and Hearst, Marti A},\n  booktitle={Proceedings of the 2021 CHI Conference on Human Factors in Computing Systems},\n  pages={1--18},\n  year={2021}\n}\n\n@misc{placcessible,\n  title={Making PL Ideas Accessible: An Open-Source, Open-Access, Interactive Journal},\n  author={Greenberg, Michael},\n  year={2021},\n  note={https://blog.sigplan.org/2021/04/13/making-pl-ideas-accessible-an-open-source-open-access-interactive-journal/}  \n}\n\n@misc{victor2005magic,\n  title={Magic Ink: Information software and the graphical interface},\n  author={Victor, Bret},\n  note={http://worrydream.com/MagicInk},\n  year={2006}\n}\n\n@article{team2021distill,\n  author = {Team, Editorial},\n  title = {Distill Hiatus},\n  journal = {Distill},\n  year = {2021},\n  note = {https://distill.pub/2021/distill-hiatus},\n  doi = {10.23915/distill.00031}\n}";

  // tsx-viewer.tsx
  var import_react12 = __toModule(require_react());
  var import_react_codemirror = __toModule(require_Codemirror());
  var import_jsx = __toModule(require_jsx());
  var TsxViewer = ({
    code,
    width,
    height
  }) => {
    let ref = (0, import_react12.useRef)(null);
    (0, import_react12.useEffect)(() => {
      let cm = ref.current.getCodeMirror();
      let rect = cm.getWrapperElement().querySelector(".CodeMirror-sizer").getBoundingClientRect();
      cm.setSize(width || rect.width, height || rect.height);
    }, []);
    return /* @__PURE__ */ import_react12.default.createElement(import_react12.default.Fragment, null, /* @__PURE__ */ import_react12.default.createElement("style", null, `
    .CodeMirror { font-size: 16px; font-family: Inconsolata; }
    .CodeMirror-gutters { background: none; border: none; padding-right: 5px; }
    .CodeMirror-linenumber { font-size: 12px; position: relative; top: 2px; }
    `), /* @__PURE__ */ import_react12.default.createElement(import_react_codemirror.default, {
      value: code,
      ref,
      options: {
        mode: { name: "jsx", base: { name: "javascript", typescript: true } },
        lineNumbers: true,
        readOnly: true
      }
    }));
  };

  // hatra-paper.mdx
  var r4 = String.raw;
  var AEx = ({ children, ...props }) => {
    const _components = Object.assign({
      a: "a"
    }, useMDXComponents());
    return (0, import_jsx_runtime2.jsx)(_components.a, Object.assign({
      target: "_blank"
    }, props, {
      children
    }));
  };
  var CenterSep = ({ children }) => {
    const _components = Object.assign({
      div: "div"
    }, useMDXComponents()), { Center } = _components;
    return (0, import_jsx_runtime2.jsx)(_components.div, {
      style: {
        margin: "1rem 0"
      },
      children: (0, import_jsx_runtime2.jsx)(Center, {
        children
      })
    });
  };
  var bt2 = "`";
  function MDXContent2(props = {}) {
    const _components = Object.assign({
      p: "p",
      em: "em",
      ol: "ol",
      li: "li",
      code: "code",
      ul: "ul"
    }, useMDXComponents(), props.components), { Title, Authors, Author, Name, Affiliation, Institution, Abstract, $$, Section, SectionTitle, Center, IR, $, Smallcaps, Ref, PremiseRow, Premise, Commentary, Document, Comment, Togglebox, References, wrapper: MDXLayout } = _components;
    const _content = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)(Title, {
        children: "A New Medium for Communicating Research on Programming Languages"
      }), "\n", (0, import_jsx_runtime2.jsx)(Authors, {
        children: (0, import_jsx_runtime2.jsxs)(Author, {
          children: [(0, import_jsx_runtime2.jsx)(Name, {
            value: "Will Crichton"
          }), (0, import_jsx_runtime2.jsx)(Affiliation, {
            children: (0, import_jsx_runtime2.jsx)(Institution, {
              value: "Stanford University"
            })
          })]
        })
      }), "\n", (0, import_jsx_runtime2.jsx)(Abstract, {
        children: (0, import_jsx_runtime2.jsx)(_components.p, {
          children: "Papers about programming languages involve complex notations, systems, and proofs. Static PDFs offer little support in understanding such concepts. I describe Nota, a framework for academic papers that uses the browser's interactive capabilities to support comprehension in context. Nota uses hover effects, tooltips, expandable sections, toggleable explanations, and other interactions to help readers understand a language's syntax and semantics. I demonstrate the use of Nota by rewriting a PL paper using its primitives, and also by writing this paper in Nota."
        })
      }), "\n", (0, import_jsx_runtime2.jsx)($$, {
        children: "\\newcommand{\\k}{\\mathcal{K}}\n\\newcommand{\\m}{\\footnotesize\\text{M}}\n\\newcommand{\\nl}{\\hspace{2em}}"
      }), "\n", (0, import_jsx_runtime2.jsxs)(Section, {
        children: [(0, import_jsx_runtime2.jsx)(SectionTitle, {
          children: "Introduction"
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Programming languages research is conveyed through the medium of ", (0, import_jsx_runtime2.jsx)(_components.em, {
            children: "academic papers."
          }), " These papers use a combination of natural language and mathematical notation to communicate ideas about languages, algorithms, and proofs. For example, an explanation of a typing rule for the simply-typed lambda calculus might look like this:"]
        }), (0, import_jsx_runtime2.jsxs)("div", {
          style: {
            border: "1px solid #ccc",
            borderRadius: "4px",
            padding: "1rem",
            margin: "1rem 2rem"
          },
          children: [(0, import_jsx_runtime2.jsx)(_components.p, {
            children: "To type-check a function, we need to check that the body is well-typed given its argument. This is formally written as:"
          }), (0, import_jsx_runtime2.jsx)(Center, {
            children: (0, import_jsx_runtime2.jsx)(IR, {
              Top: (0, import_jsx_runtime2.jsx)($, {
                children: r4`\Gamma, x : \tau_x \vdash e : \tau_e`
              }),
              Bot: (0, import_jsx_runtime2.jsx)($, {
                children: r4`\Gamma \vdash \lambda x : \tau_x \, . \, e ~ : ~ \tau_x \rightarrow \tau_e`
              }),
              Right: (0, import_jsx_runtime2.jsx)(Smallcaps, {
                children: "(T-Lambda)"
              })
            })
          }), (0, import_jsx_runtime2.jsxs)(_components.p, {
            children: ["Here, the syntax ", (0, import_jsx_runtime2.jsx)("q", {
              children: (0, import_jsx_runtime2.jsx)($, {
                children: "\\Gamma, x : \\tau_x"
              })
            }), " means ", (0, import_jsx_runtime2.jsxs)("q", {
              children: ["add ", (0, import_jsx_runtime2.jsx)($, {
                children: "x : \\tau_x"
              }), " to the type environment ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\Gamma"
              }), "."]
            }), " Therefore we recursively check that ", (0, import_jsx_runtime2.jsx)($, {
              children: "e"
            }), " is well-typed assuming ", (0, import_jsx_runtime2.jsx)($, {
              children: "x : \\tau_x"
            }), ". If so, then the type of the function is ", (0, import_jsx_runtime2.jsx)($, {
              children: "\\tau_x \\rightarrow \\tau_e"
            }), " because it takes a value of type ", (0, import_jsx_runtime2.jsx)($, {
              children: "\\tau_x"
            }), " as input and returns a value of type ", (0, import_jsx_runtime2.jsx)($, {
              children: "\\tau_e"
            }), " as output."]
          })]
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["The principal question underlying this work is: ", (0, import_jsx_runtime2.jsx)(_components.em, {
            children: "how much effort does it take to understand a PL paper?"
          }), " In the example above, a key challenge is understanding the notation and the concepts they represent. For a formal system as small as the simply-typed lambda calculus, such an explanation only needs to reference a few symbols. The ", (0, import_jsx_runtime2.jsx)(Smallcaps, {
            children: "T-Lambda"
          }), " rule uses 11 distinct symbols (", (0, import_jsx_runtime2.jsx)($, {
            children: "x"
          }), ", ", (0, import_jsx_runtime2.jsx)($, {
            children: "e"
          }), ", ", (0, import_jsx_runtime2.jsx)($, {
            children: "\\tau"
          }), ",  ", (0, import_jsx_runtime2.jsx)($, {
            children: "\\lambda"
          }), ",  ", (0, import_jsx_runtime2.jsx)($, {
            children: "."
          }), ",  ", (0, import_jsx_runtime2.jsx)($, {
            children: "\\rightarrow"
          }), ",  ", (0, import_jsx_runtime2.jsx)($, {
            children: "\\Gamma"
          }), ", ", (0, import_jsx_runtime2.jsx)($, {
            children: "\\vdash"
          }), ", ", (0, import_jsx_runtime2.jsx)($, {
            children: "\\text{\\textemdash}"
          }), ")  to reference 8 distinct concepts (variables, expressions, types, functions, function types, typing contexts, typing judgments, and inference rules)."]
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["However, PL has come a long way since the lambda calculus. Consider this rule reproduced from ", (0, import_jsx_runtime2.jsx)(Ref, {
            name: "cavallo2019higher",
            full: "true"
          }), ", a recent POPL paper about cubical type theory:"]
        }), (0, import_jsx_runtime2.jsx)("div", {
          style: {
            border: "1px solid #ccc",
            borderRadius: "4px",
            margin: "1rem 2rem",
            textAlign: "center"
          },
          children: (0, import_jsx_runtime2.jsx)(IR, {
            Top: (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
              children: [(0, import_jsx_runtime2.jsxs)(PremiseRow, {
                children: [(0, import_jsx_runtime2.jsx)(Premise, {
                  children: (0, import_jsx_runtime2.jsx)($, {
                    children: r4`\Delta \triangleright \mathcal{E} : \k \rightharpoonup \delta.h.D\,[\Psi]`
                  })
                }), (0, import_jsx_runtime2.jsx)(Premise, {
                  children: (0, import_jsx_runtime2.jsx)($, {
                    children: r4`\k[\ell] = (\Gamma;~ \gamma.\overline{I};~ \gamma.\Theta;~ \overline{x}.\overrightharpoon{\xi_k \hookrightarrow \gamma.\Theta.\m_k})`
                  })
                })]
              }), (0, import_jsx_runtime2.jsxs)(PremiseRow, {
                children: [(0, import_jsx_runtime2.jsx)(Premise, {
                  children: (0, import_jsx_runtime2.jsx)($, {
                    children: r4`\text{ht}_\k(\ell) = |\mathcal{E}|`
                  })
                }), (0, import_jsx_runtime2.jsx)(Premise, {
                  children: (0, import_jsx_runtime2.jsx)($, {
                    children: r4`H_\ell := (\gamma : \Gamma, \eta : \lBrace \Theta \rBrace(\text{ind}_\Delta(\k; \overline{I})), \rho : \lBrace \Theta \rBrace_d(\delta.h.D;~\eta)) `
                  })
                })]
              }), (0, import_jsx_runtime2.jsx)(PremiseRow, {
                children: (0, import_jsx_runtime2.jsx)(Premise, {
                  children: (0, import_jsx_runtime2.jsx)($, {
                    children: r4`H_\ell \gg R \in D[\text{intro}_{k,\ell}^{\overline{x}}(\gamma; \eta)/h]\,[\Psi,\overline{x}]`
                  })
                })
              }), (0, import_jsx_runtime2.jsx)(PremiseRow, {
                children: (0, import_jsx_runtime2.jsx)(Premise, {
                  children: (0, import_jsx_runtime2.jsx)($, {
                    children: r4`(\forall k) H_\ell \gg R \doteq {\Large ⦇} \Theta.\m_k {\Large ⦈}^{\k,\mathcal{E}}_{\delta.h.D}\normalsize(\eta; \rho) \in D[\text{intro}^{\overline{x}}_{\k,\ell}(\delta; \eta)/h]\,[\Psi, \overline{x}\mid \xi_k]`
                  })
                })
              })]
            }),
            Bot: (0, import_jsx_runtime2.jsx)($, {
              children: r4`\Delta \triangleright [\mathcal{E}, \ell : \overline{x}.\gamma.n.\rho.R] : \k \rightharpoonup \delta.h.D\,[\Psi]`
            })
          })
        }), (0, import_jsx_runtime2.jsxs)("p", {
          className: "noindent",
          children: ["This rule uses about 40 distinct symbols to communicate a significant number of concepts. Some symbols, such as ", (0, import_jsx_runtime2.jsx)("q", {
            children: (0, import_jsx_runtime2.jsx)($, {
              children: "\\forall"
            })
          }), ", are expected background for the reader. But most are defined solely within the context of the paper. Remembering and applying these paper-specific symbols is a known challenge in reading scientific papers ", (0, import_jsx_runtime2.jsx)(Ref, {
            name: "head2021augmenting"
          }), ". And comprehension challenges go beyond individual symbols. A person reading a complex expression may want to know, how do I mentally parse this string? Where is the nearby text that explains this particular part of the rule? What kind of related work defines rules similar to this one?"]
        }), (0, import_jsx_runtime2.jsx)(_components.p, {
          children: "The difficulty of these tasks is compounded by the two technologies underlying the modern academic paper: PDF and LaTeX. PDFs are designed to be static documents, and so the only forms of interaction they usually offer are internal hyperlinks and text search, along with structuring mechanisms like a table of contents. LaTeX, a system designed in the 1980s, uses an archaic programming language where the only abstraction mechanism is a macro. Combined, these factors make certain visualizations and interactions nigh impossible to implement."
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["On the SIGPLAN blog, ", (0, import_jsx_runtime2.jsx)(Ref, {
            name: "placcessible",
            full: "true"
          }), " argued for a new PL journal motivated by these challenges: to make PL research more accessible. Greenberg cited ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://distill.pub/",
            children: "Distill"
          }), " as a primary inspiration for similar efforts in machine learning research. However, only three months after Greenberg's post, the Distill editors announced a potentially indefinite hiatus ", (0, import_jsx_runtime2.jsx)(Ref, {
            name: "team2021distill"
          }), ". A key reason was:"]
        }), (0, import_jsx_runtime2.jsx)("blockquote", {
          children: (0, import_jsx_runtime2.jsx)("q", {
            children: "We believed that many valuable scientific contributions\u2009\u2014\u2009such as explanations, interactive articles, and visualizations\u2009\u2014\u2009were held back by not being seen as \u201Creal scientific publications.\u201D Our theory was that if a journal were to publish such artifacts, it would allow authors to benefit from the traditional academic incentive system and enable more of this kind of work. After four years, we no longer believe this theory of impact. [...] Instead, we believe the primary bottleneck is the amount of effort it takes to produce these articles and the unusual combination of scientific and design expertise required."
          })
        }), (0, import_jsx_runtime2.jsx)("p", {
          className: "noindent",
          children: "In this way, Distill presents both an inspiration and a cautionary tale. We know papers can be improved to help readers better understand their concepts. But we cannot train every researcher to be an expert in graphic design or frontend web development. Part of the success of LaTeX is that so many CS researchers are able to use it to create papers without significant training (and despite its many flaws)."
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Hence, my goal is to create a system for writing PL papers that (a) provides features for more effective reading, and (b) requires no special design knowledge to use. To that end, I designed Nota (as in ", (0, import_jsx_runtime2.jsx)(_components.em, {
            children: "nota bene"
          }), "), a web framework for writing academic papers. The core principle of Nota is ", (0, import_jsx_runtime2.jsx)(_components.em, {
            children: "bridging the gap between definition and use."
          }), " Specifically:"]
        }), (0, import_jsx_runtime2.jsxs)(_components.ol, {
          children: ["\n", (0, import_jsx_runtime2.jsx)(_components.li, {
            children: "A reader should always be able to access the definition of a symbol."
          }), "\n", (0, import_jsx_runtime2.jsx)(_components.li, {
            children: "Jumping around is bad \u2014 definitions should be visible in context."
          }), "\n", (0, import_jsx_runtime2.jsx)(_components.li, {
            children: "A static display is preferable to an interactive one, all else being equal."
          }), "\n"]
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["I applied these principles to design novel interfaces for ", (0, import_jsx_runtime2.jsx)("a", {
            href: "#def-fig-oxide_syntax_bnf",
            children: "grammars"
          }), ", ", (0, import_jsx_runtime2.jsx)("a", {
            href: "#assign-static-rule",
            children: "inference rules"
          }), ", and ", (0, import_jsx_runtime2.jsx)("a", {
            href: "#correspondence-principle-1",
            children: "theorems"
          }), ". To showcase these interfaces, I have reimplemented a portion of one of my papers using Nota. The design choices here are assuredly not all optimal \u2014 Nota is very much a prototype, not a final system. But I hope this demo at least conveys a sense of what is possible."]
        }), (0, import_jsx_runtime2.jsx)("div", {
          style: {
            marginTop: "1rem",
            textAlign: "center",
            fontVariant: "small-caps"
          },
          children: (0, import_jsx_runtime2.jsx)(_components.p, {
            children: "This demo has only been tested in Chrome \u2014 use other browsers at your own peril!"
          })
        })]
      }), "\n", (0, import_jsx_runtime2.jsxs)(Section, {
        name: "sec:demo",
        children: [(0, import_jsx_runtime2.jsx)(SectionTitle, {
          children: "Demo"
        }), (0, import_jsx_runtime2.jsxs)(Commentary, {
          Document: (props2) => (0, import_jsx_runtime2.jsx)(Document, Object.assign({}, props2, {
            children: (0, import_jsx_runtime2.jsx)(slicing_paper_default2, {})
          })),
          comment_width: 350,
          children: [(0, import_jsx_runtime2.jsxs)(Comment, {
            selector: "h1",
            children: [(0, import_jsx_runtime2.jsxs)(_components.p, {
              children: ["The left column contains a draft of an unpublished paper about ", (0, import_jsx_runtime2.jsx)(AEx, {
                href: "https://en.wikipedia.org/wiki/Program_slicing",
                children: "program slicing"
              }), ". The white bubbles in the right column contain commentary about the usage of Nota. You can compare against the original LaTeX/PDF version ", (0, import_jsx_runtime2.jsx)(AEx, {
                href: "slicing_paper.pdf",
                children: "here"
              }), ". If you want to just skim the uses of Nota features, you don't have to read all the text -- just skip to the next white discussion bubble."]
            }), (0, import_jsx_runtime2.jsx)(_components.p, {
              children: "The general style (fonts, spacing, etc.) was designed to mimic the ACM Primary template as closely as possible. This demonstrates that the core visual style of a LaTeX-generated paper can still be represented in the browser."
            })]
          }), (0, import_jsx_runtime2.jsxs)(Comment, {
            selector: "#def-sec-intro section:first-child h2 ~ p",
            children: [(0, import_jsx_runtime2.jsxs)("p", {
              children: ["Try clicking on one of the purple citations. One click brings up a tooltip with the corresponding citation. (Click anywhere on the page to close it.) Then try double-clicking on a citation. You can use the browser's ", (0, import_jsx_runtime2.jsx)("q", {
                children: "back"
              }), " function to jump back to where you were. Also note that the object you jump to is briefly highlighted in yellow to draw your attention after jumping."]
            }), "\n", (0, import_jsx_runtime2.jsx)("p", {
              children: "Some foundational concepts in Nota are definitions and references. For example, a bibliography defines sources, which can be referenced inline as a citation. A footnote defines asides, which can be referenced as a number. Try clicking on the footnote at the end of the first paragraph. Notice that the same tooltip mechanism can be used as with the citation."
            })]
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#def-sec-intro ol",
            children: (0, import_jsx_runtime2.jsx)(_components.p, {
              children: "Unimplemented references are replaced with placeholders, rather than preventing the document from compiling."
            })
          }), (0, import_jsx_runtime2.jsxs)(Comment, {
            selector: "#def-sec-places h3 ~ p",
            children: [(0, import_jsx_runtime2.jsxs)("p", {
              children: ["Examples don't have to be static in the browser! Try editing this code example to say ", (0, import_jsx_runtime2.jsx)("code", {
                children: "x = z;"
              }), " on line 4. Then select ", (0, import_jsx_runtime2.jsx)("code", {
                children: "x"
              }), " on line 5 and click ", (0, import_jsx_runtime2.jsx)("q", {
                children: "Slice"
              }), ". "]
            }), "\n", (0, import_jsx_runtime2.jsx)("p", {
              children: "Interactive examples allow readers to engage with the material by forming and testing hypotheses, or checking edge cases of an algorithm."
            })]
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#multi-snippets",
            children: (0, import_jsx_runtime2.jsx)(_components.p, {
              children: "Note that the browser allows for flexible layouts. If a figure needs to extend beyond page boundaries, then no problem \u2014 a monitor is wide enough."
            })
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#def-sec-model",
            children: (0, import_jsx_runtime2.jsx)(_components.p, {
              children: "This section demonstrates the core features of Nota. Here, the paper needs to describe a large language, Oxide, imported from another paper (Weiss et al.). This language contains a large syntax and a semantics with a number of judgments. The goal of Nota is to simplify the definition, referencing, and explaining of formal systems like Oxide."
            })
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#def-sec-syn",
            children: (0, import_jsx_runtime2.jsxs)(_components.p, {
              children: ["This grammar defines dozens of syntax kinds, metavariables, and syntactic forms. Using Nota, every instance is linked to its definition. For example, try hovering over the form ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\&\\rho\\,\\omega\\,\\tau^{\\tiny\\text{XI}}"
              }), " under Sized Type. Click on each metavariable, then click on the ampersand. As before, you can double click to jump to the definition. The stack of tooltips indicate nested references, e.g. ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\omega"
              }), " within the broader reference form."]
            })
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#syntax-diagram",
            children: (0, import_jsx_runtime2.jsx)(_components.p, {
              children: "This diagram doesn't have to be drawn in Illustrator! It uses HTML for the layout and boxes, and SVG to draw the lines. That means the underlying structure is still preserved, so the syntax elements are inspectable (as opposed to a static image)."
            })
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#def-sec-statsem",
            children: (0, import_jsx_runtime2.jsxs)(_components.p, {
              children: ["When describing a large formal system, some elements are less important than others. For instance, the context ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\Delta"
              }), " is necessary for the typing judgment, but isn't relevant to most of the paper. Rather than having a giant syntax figure or punting ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\Delta"
              }), " to the appendix, we can introduce ", (0, import_jsx_runtime2.jsx)("em", {
                children: "expandable elements."
              }), " Try double-clicking the ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\Delta"
              }), ". It will jump to the ", (0, import_jsx_runtime2.jsx)("q", {
                children: "extra"
              }), " grammar hidden by the ", (0, import_jsx_runtime2.jsx)("q", {
                children: "Show grammar"
              }), " button."]
            })
          }), (0, import_jsx_runtime2.jsx)(Comment, {
            selector: "#static-rule",
            children: (0, import_jsx_runtime2.jsxs)(_components.p, {
              children: ["A common pattern in PL papers is to present a formal rule full of symbols, then accompany that rule with a separate paragraph explaining it. The rule on the left shows a possible enhancement of this pattern: co-locating natural language explanations with the corresponding symbolic expressions. Try clicking the ", (0, import_jsx_runtime2.jsx)($, {
                children: "\\Sigma"
              }), " buttons."]
            })
          }), (0, import_jsx_runtime2.jsxs)(Comment, {
            selector: "#correspondence-principle-1",
            children: [(0, import_jsx_runtime2.jsxs)(_components.p, {
              children: ["Part of Nota's inspiration was my attempts to visually encode correspondences between objects (see page 10 of the ", (0, import_jsx_runtime2.jsx)(AEx, {
                href: "slicing_paper.pdf#page=10",
                children: "PDF"
              }), "). LaTeX's brittle abstractions made it frustratingly hard to do something as simple as ", (0, import_jsx_runtime2.jsx)("q", {
                children: "draw a colored underline beneath a piece of math."
              })]
            }), (0, import_jsx_runtime2.jsx)(_components.p, {
              children: "By contrast, implementing this feature was trivial in HTML/CSS/Javascript. And we could extend the idea with interactions like drawing attention to corresponding objects on hover."
            })]
          })]
        })]
      }), "\n", (0, import_jsx_runtime2.jsxs)(Section, {
        children: [(0, import_jsx_runtime2.jsx)(SectionTitle, {
          children: "Implementation"
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Nota is a browser technology, so it is implemented using a combination of HTML, CSS, and Javascript. The core is the ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://reactjs.org/",
            children: "React"
          }), " Javascript library. React allows HTML to be freely intermixed with Javascript, and enables the creation of new tags with associated interactions. For example, the following code shows the Nota implementation of ", (0, import_jsx_runtime2.jsx)("a", {
            href: "#def-sec-statsem",
            children: "Section 3.2"
          }), " from above:"]
        }), (0, import_jsx_runtime2.jsx)(CenterSep, {
          children: (0, import_jsx_runtime2.jsx)(TsxViewer, {
            code: r4`<SubSection title="Static semantics" name="sec:statsem">
<p>
  <Definition name="tex:tc">
    Expressions are typechecked via the judgment
    <$>{r${bt2}\tc{\fenv}{\tyenv}{\stackenv}{\expr}{\ty}{\stackenv'}${bt2}}</$>,
    read as: "<$>\expr</$> has type <$>\ty</$> under contexts
    <$>{\fenv, \tyenv, \stackenv}</$> producing new context <$>\stackenv'</$>."
  </Definition>
  <$>\tyenv</$> contains function-level type and provenance variables.
  <$>\stackenv</$> maps variables to types and provenances to pointed-to
  place expressions with ownership qualifiers. For instance, when type checking
  <code>*b := a.1</code> in <Ref name="fig:oxide_syntax_example" />, the inputs would be
  <$>\tyenv = \tyenvempty</$> (empty) and
  <$>{r${bt2}\stackenv = \{
    a \mapsto (\uty, \uty), ~
    b \mapsto \eref{\uniq}{\r_2}{\uty}, ~
    \r_1 \mapsto \{\loanform{\uniq}{a.0}\}, ~
    \r_2 \mapsto \{\loanform{\uniq}{a.0}\}\}
  ${bt2}}</$>.
</p>
{/* ... */}`
          })
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Some tags like ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<p>"
          }), " and ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<code>"
          }), " are default tags built into the browser. The rest are components provided by Nota. For instance, ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<SubSection>"
          }), " and ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<$>"
          }), " directly correspond to the ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "\\subsection"
          }), " and ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "$"
          }), " operators of LaTeX. The ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<Definition>"
          }), " and ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<Ref>"
          }), " components are enhanced versions of ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "\\label"
          }), " and ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "\\ref"
          }), ". A definition has a name and a tooltip, by default the contents of the definition. Then a reference to the definition will bring up the tooltip on click, and jump to the definition on double-click."]
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["The ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<$>"
          }), " component is implemented using ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://katex.org/",
            children: "KaTeX"
          }), ", a TeX implementation for the browser. By default, KaTeX is a black-box that generates HTML to render directly into the page. To support definitions and references, we use KaTeX's ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://katex.org/docs/supported.html#html",
            children: "HTML extensions"
          }), " to tag elements with data. For example, the ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "\\stackenv"
          }), " macro is defined as:"]
        }), (0, import_jsx_runtime2.jsx)(CenterSep, {
          children: (0, import_jsx_runtime2.jsx)("pre", {
            children: r4`\newcommand{\stackenv}{\htmlData{cmd=stackenv}{\Gamma}}`
          })
        }), (0, import_jsx_runtime2.jsxs)("p", {
          className: "noindent",
          children: ["With this macro, the generated HTML for a ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "\\stackenv"
          }), " invocation looks like ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: '<span data-cmd="stackenv">...</span>'
          }), ". Nota post-processes KaTeX's output to replace tagged nodes with the corresponding definitions and references, enabling the interactions shown in the previous section."]
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Most users of Nota would write the declarative markup shown above. Library writers would create React components that can be plugged into a Nota document. For instance, the ", (0, import_jsx_runtime2.jsx)("a", {
            href: "#assign-static-rule",
            children: "toggle-based inference rule"
          }), " is based on a ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<Togglebox>"
          }), " abstraction. A basic togglebox looks like this:"]
        }), (0, import_jsx_runtime2.jsx)(CenterSep, {
          children: (0, import_jsx_runtime2.jsx)(Togglebox, {
            Inside: (props2) => (0, import_jsx_runtime2.jsx)($, Object.assign({}, props2, {
              children: r4`\text{$\LaTeX$ on the inside!}`
            })),
            Outside: (props2) => (0, import_jsx_runtime2.jsx)($, Object.assign({}, props2, {
              children: r4`\text{Text out the outside...}`
            }))
          })
        }), (0, import_jsx_runtime2.jsxs)("p", {
          className: "noindent",
          children: ["Below is a simplified implementation of ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "<Togglebox>"
          }), " using React and Typescript. It uses ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://reactjs.org/docs/components-and-props.html",
            children: "function components"
          }), " and ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://reactjs.org/docs/hooks-overview.html",
            children: "hooks"
          }), " to implement the two key aspects of the togglebox: sizing the box to fit both elements, and toggling the box when clicking the toggle button."]
        }), (0, import_jsx_runtime2.jsx)(CenterSep, {
          children: (0, import_jsx_runtime2.jsx)(TsxViewer, {
            code: r4`export let Togglebox: React.FC<ToggleboxProps> = ({ Inside, Outside }) => {
  let outside_ref = useRef<HTMLDivElement>(null);
  let inside_ref = useRef<HTMLDivElement>(null);
  let [show_inside, set_show_inside] = useState(false);

  // Set the box's dimensions to the maximum size of both input elements
  let style = useStateOnInterval({}, 1000, () => {
    if (outside_ref.current || !inside_ref.current) { return {}; }
    let get_dims = (ref: React.RefObject<HTMLDivElement>) =>
      ref.current!.getBoundingClientRect();
    let outside_dims = get_dims(outside_ref);
    let inside_dims = get_dims(inside_ref);
    return {
      width: Math.max(outside_dims.width, inside_dims.width),
      height: Math.max(outside_dims.height, inside_dims.height),
    };
  });

  let inner_style = (show: boolean): any =>
    !show ? {
      visibility: "hidden",
      position: "absolute",
    } : {};

  return <div className="togglebox-parent">
    <div className="togglebox" style={style}>
      <div ref={outside_ref} style={inner_style(!show_inside)}>
        <Outside />
      </div>
      <div ref={inside_ref} style={inner_style(show_inside)}>
        <Inside />
      </div>
    </div>
    <ToggleButton on={show_inside} onClick={() => set_show_inside(!show_inside)} />
  </div>;
}`
          })
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["One advantage of using Javascript vs. TeX is the ability to define abstractions at a higher level than macros. For example, the BNF grammar above is automatically generated by a ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "Language"
          }), " class that takes a grammar specification as input, and generates both the grammar and the TeX macros. The Oxide language is defined like this:"]
        }), (0, import_jsx_runtime2.jsx)(CenterSep, {
          children: (0, import_jsx_runtime2.jsx)(TsxViewer, {
            code: r4`export let Oxide = new Language([
  ["Variable", "vr", "x", []],
  ["Function", "fname", "f", []],
  ["Number", "num", "n", []],
  ["Path", "path", "q", [
    [r${bt2}empty${bt2}, 0, r${bt2}\varepsilon${bt2}, []],
    [r${bt2}elem${bt2}, 2, r${bt2}{#1}.{#2}${bt2}, [r${bt2}\num${bt2}, r${bt2}\path${bt2}]]]],
  ["Place", "plc", r${bt2}\pi${bt2}, [
    [r${bt2}form${bt2}, 2, r${bt2}{#1}.{#2}${bt2}, [r${bt2}\vr${bt2}, r${bt2}\path${bt2}]]]],
  ["Place Expression", "pexp", "p", [
    [${bt2}var${bt2}, 1, r${bt2}#1${bt2}, [r${bt2}\vr${bt2}]],
    [${bt2}elem${bt2}, 2, r${bt2}{#1}.{#2}${bt2}, [r${bt2}\pexp${bt2}, r${bt2}\num${bt2}]],
    [${bt2}deref${bt2}, 1, r${bt2}\ast {#1}${bt2}, [r${bt2}\pexp${bt2}]]]],
  ...
  ]);`
          })
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Then the ", (0, import_jsx_runtime2.jsx)(_components.code, {
            children: "Oxide"
          }), " object has two methods to generate the TeX macros and BNF, like so:"]
        }), (0, import_jsx_runtime2.jsx)(CenterSep, {
          children: (0, import_jsx_runtime2.jsx)(TsxViewer, {
            code: r4`<Oxide.Commands />
<Oxide.BNF layout={{columns: 2}} />`
          })
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["In my experience writing Nota features, it is far easier to define new components in Javascript than in TeX. Abstraction boundaries are less fragile, and orthogonal features are more likely to work together. The full source code for Nota and this paper are available on Github at ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://github.com/willcrichton/nota",
            children: "willcrichton/nota"
          }), "."]
        })]
      }), "\n", (0, import_jsx_runtime2.jsxs)(Section, {
        children: [(0, import_jsx_runtime2.jsx)(SectionTitle, {
          children: "Discussion"
        }), (0, import_jsx_runtime2.jsx)(_components.p, {
          children: "What will be the academic paper of the future? My goal with Nota is to show what's already possible today. I believe adopting Nota, or a system like it, could help make PL papers more readable to both novices and experts alike. It does not require any special design skills from authors, mostly just additional metadata around pieces of the document to enable rich references."
        }), (0, import_jsx_runtime2.jsx)(_components.p, {
          children: "Of course, Nota is one of many possible visions for the future. Alternatives include:"
        }), (0, import_jsx_runtime2.jsxs)(_components.ul, {
          children: ["\n", (0, import_jsx_runtime2.jsxs)(_components.li, {
            children: [(0, import_jsx_runtime2.jsx)(_components.em, {
              children: "Notebooks:"
            }), " mixed text/code media like ", (0, import_jsx_runtime2.jsx)(AEx, {
              href: "https://jupyter.org/",
              children: "Jupyter"
            }), ", ", (0, import_jsx_runtime2.jsx)(AEx, {
              href: "https://observablehq.com/",
              children: "Observable"
            }), ", and ", (0, import_jsx_runtime2.jsx)(AEx, {
              href: "https://rmarkdown.rstudio.com/",
              children: "R Markdown"
            }), " have grown in popularity especially in the non-computer sciences. The goal of a notebook is to put the explanation of an object as close as possible to the code that generated it. In fields like psychology, this usually means analyzing datasets and generating graphs. Perhaps the future for PL is literate Agda/Lean/Coq programs."]
          }), "\n", (0, import_jsx_runtime2.jsxs)(_components.li, {
            children: ["*Enhanced PDFs: creating a new browser-based medium will inevitably require reinventing a number of wheels that already exist for LaTeX/PDFs: IDEs (like ", (0, import_jsx_runtime2.jsx)(AEx, {
              href: "https://www.overleaf.com/",
              children: "Overleaf"
            }), "), documentation, accessibility features, and so on. A far simpler approach would be to make LaTeX and PDFs as powerful as possible, like ", (0, import_jsx_runtime2.jsx)(Ref, {
              name: "head2021augmenting",
              full: "true"
            }), " recently explored."]
          }), "\n", (0, import_jsx_runtime2.jsxs)(_components.li, {
            children: [(0, import_jsx_runtime2.jsx)(_components.em, {
              children: "Beyond papers:"
            }), " the academic paper is a concept extending back hundreds of years. It persists with the momentum of history, millions of adherents, and the myriad incentive structures of academia. Perhaps systems like Nota merely prolong the lifespan of this outdated practice, and academic contributions should be reimagined outside the frame of ", (0, import_jsx_runtime2.jsx)("q", {
              children: "a new kind of paper."
            })]
          }), "\n"]
        }), (0, import_jsx_runtime2.jsxs)(_components.p, {
          children: ["Nota itself also has drawbacks for academic communication. The web ecosystem changes rapidly, meaning what works today may not work tomorrow. While some ", (0, import_jsx_runtime2.jsx)(AEx, {
            href: "https://www.spacejam.com/1996/",
            children: "venerable websites"
          }), " survive the test of time, would a Nota paper still work properly in 100 or 1,000 years? Such longevity is arguably much more likely for a PDF than a website. Moreover, important infrastructure for Nota like KaTeX would need feature-parity with existing TeX engines like pdfTeX to match the wide range of notation needed for PL research."]
        }), (0, import_jsx_runtime2.jsx)(_components.p, {
          children: "Regardless, I hope that this paper draws attention to the pressing issue of how we communicate in PL research. As the field progresses, the conceptual infrastructure of new ideas grows ever larger. Interactive mediums like Nota can provide cognitive support for understanding ideas in context. And support doesn't have to stop at the individual level \u2014 a public platform could support crowd-sourced annotations on each paragraph of a research paper. In classic PL fashion, we could maybe design a medium so great that everyone else adopts it... in 30 years."
        }), (0, import_jsx_runtime2.jsx)(References, {
          bibtex: hatra_paper_default
        })]
      })]
    });
    return MDXLayout ? (0, import_jsx_runtime2.jsx)(MDXLayout, Object.assign({}, props, {
      children: _content
    })) : _content;
  }
  var hatra_paper_default2 = MDXContent2;

  // ../../packages/nota-cli/lib/page.tsx
  import_react_dom2.default.render(/* @__PURE__ */ import_react14.default.createElement(MDXProvider, {
    components: nota_exports
  }, /* @__PURE__ */ import_react14.default.createElement(HA, null, /* @__PURE__ */ import_react14.default.createElement(hatra_paper_default2, null))), document.getElementById("page-container"));
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=index.js.map
